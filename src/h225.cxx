//
// h225.cxx
//
// Code automatically generated by asnparse.
//

#ifdef __GNUC__
#pragma implementation "h225.hpp"
#endif

#include "ss.hpp"
#include "allocatable.hpp"
#include <stdexcept>
#include <iomanip>
#include <limits>
#include <cstring>
#include "asn.hpp"

#include "h225.hpp"


#include "h235_t.cxx"


using namespace H225;

//
// StimulusControl
//

StimulusControl :: StimulusControl ( Asn :: istream & is ) : Asn :: Sequence ( is, 3, true, 0 ), m_nonStandard ( 0 ), m_isText ( 0 ), m_h248Message ( 0 ) {
	try {
		if ( hasOptionalField ( e_nonStandard ) )
			m_nonStandard = new NonStandardParameter ( is );
		if ( hasOptionalField ( e_isText ) )
			m_isText = new Asn :: Null ( is );
		if ( hasOptionalField ( e_h248Message ) )
			m_h248Message = new Asn :: OctetString ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_nonStandard;
		delete m_isText;
		delete m_h248Message;
		throw;
	}
}

StimulusControl :: StimulusControl ( ) : Asn :: Sequence ( 3, true, 0 ), m_nonStandard ( 0 ), m_isText ( 0 ), m_h248Message ( 0 ) { }

StimulusControl & StimulusControl :: operator= ( const StimulusControl & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_nonStandard, s.m_nonStandard );
	assignCopy ( m_isText, s.m_isText );
	assignCopy ( m_h248Message, s.m_h248Message );
	return * this;
}

StimulusControl :: StimulusControl ( const StimulusControl & s ) : Asn :: Sequence ( s ), m_nonStandard ( 0 ), m_isText ( 0 ), m_h248Message ( 0 ) {
	try {
		if ( s.m_nonStandard )
			m_nonStandard = new NonStandardParameter ( * s.m_nonStandard );
		if ( s.m_isText )
			m_isText = new Asn :: Null ( * s.m_isText );
		if ( s.m_h248Message )
			m_h248Message = new Asn :: OctetString ( * s.m_h248Message );
	} catch ( ... ) {
		delete m_nonStandard;
		delete m_isText;
		delete m_h248Message;
		throw;
	}
}


void StimulusControl :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandard:
			assignNew ( m_nonStandard, new NonStandardParameter );
			break;
		case e_isText:
			assignNew ( m_isText, new Asn :: Null );
			break;
		case e_h248Message:
			assignNew ( m_h248Message, new Asn :: OctetString );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void StimulusControl :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandard:
			delete m_nonStandard;
			m_nonStandard = 0;
			break;
		case e_isText:
			delete m_isText;
			m_isText = 0;
			break;
		case e_h248Message:
			delete m_h248Message;
			m_h248Message = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void StimulusControl :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_nonStandard ) )
		m_nonStandard -> NonStandardParameter :: encode ( os );
	if ( hasOptionalField ( e_isText ) )
		m_isText -> Asn :: Null :: encode ( os );
	if ( hasOptionalField ( e_h248Message ) )
		m_h248Message -> Asn :: OctetString :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

StimulusControl :: ~StimulusControl ( ) {
	delete m_nonStandard;
	delete m_isText;
	delete m_h248Message;
}

void StimulusControl :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_nonStandard ) ) {
		os << std :: setw ( indent + 14 ) << "nonStandard = " << std :: setprecision ( indent );
		m_nonStandard -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_isText ) ) {
		os << std :: setw ( indent + 9 ) << "isText = " << std :: setprecision ( indent );
		m_isText -> Asn :: Null :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_h248Message ) ) {
		os << std :: setw ( indent + 14 ) << "h248Message = " << std :: setprecision ( indent );
		m_h248Message -> Asn :: OctetString :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

StimulusControl * StimulusControl :: clone ( ) const {
	return new StimulusControl ( * this );
}

//
// ScnConnectionType
//

ScnConnectionType :: ScnConnectionType ( Asn :: istream & is ) : Asn :: Choice ( is, 7, true ) {
	switch ( tag ) {
		case e_unknown:
		case e_bChannel:
		case e_hybrid2x64:
		case e_hybrid384:
		case e_hybrid1536:
		case e_hybrid1920:
		case e_multirate:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

ScnConnectionType :: ScnConnectionType ( ) : Asn :: Choice ( 7, true ) { }

void ScnConnectionType :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_unknown:
		case e_bChannel:
		case e_hybrid2x64:
		case e_hybrid384:
		case e_hybrid1536:
		case e_hybrid1920:
		case e_multirate:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & ScnConnectionType :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_unknown, "unknown" },
		{ e_bChannel, "bChannel" },
		{ e_hybrid2x64, "hybrid2x64" },
		{ e_hybrid384, "hybrid384" },
		{ e_hybrid1536, "hybrid1536" },
		{ e_hybrid1920, "hybrid1920" },
		{ e_multirate, "multirate" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

ScnConnectionType * ScnConnectionType :: clone ( ) const {
	return new ScnConnectionType ( * this );
}

//
// ScnConnectionAggregation
//

ScnConnectionAggregation :: ScnConnectionAggregation ( Asn :: istream & is ) : Asn :: Choice ( is, 6, true ) {
	switch ( tag ) {
		case e_auto:
		case e_none:
		case e_h221:
		case e_bonded_mode1:
		case e_bonded_mode2:
		case e_bonded_mode3:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

ScnConnectionAggregation :: ScnConnectionAggregation ( ) : Asn :: Choice ( 6, true ) { }

void ScnConnectionAggregation :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_auto:
		case e_none:
		case e_h221:
		case e_bonded_mode1:
		case e_bonded_mode2:
		case e_bonded_mode3:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & ScnConnectionAggregation :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_auto, "auto" },
		{ e_none, "none" },
		{ e_h221, "h221" },
		{ e_bonded_mode1, "bonded_mode1" },
		{ e_bonded_mode2, "bonded_mode2" },
		{ e_bonded_mode3, "bonded_mode3" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

ScnConnectionAggregation * ScnConnectionAggregation :: clone ( ) const {
	return new ScnConnectionAggregation ( * this );
}

//
// PresentationIndicator
//

PresentationIndicator :: PresentationIndicator ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_presentationAllowed:
		case e_presentationRestricted:
		case e_addressNotAvailable:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

PresentationIndicator :: PresentationIndicator ( ) : Asn :: Choice ( 3, true ) { }

void PresentationIndicator :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_presentationAllowed:
		case e_presentationRestricted:
		case e_addressNotAvailable:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & PresentationIndicator :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_presentationAllowed, "presentationAllowed" },
		{ e_presentationRestricted, "presentationRestricted" },
		{ e_addressNotAvailable, "addressNotAvailable" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

PresentationIndicator * PresentationIndicator :: clone ( ) const {
	return new PresentationIndicator ( * this );
}

//
// ScreeningIndicator
//

ScreeningIndicator :: ScreeningIndicator ( Asn :: istream & is ) : Asn :: Enumeration ( is, 3, true ) { }

ScreeningIndicator :: ScreeningIndicator ( ) : Asn :: Enumeration ( e_userProvidedNotScreened, 3, true ) { }

const Asn :: NamesMapType & ScreeningIndicator :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_userProvidedNotScreened, "userProvidedNotScreened" },
		{ e_userProvidedVerifiedAndPassed, "userProvidedVerifiedAndPassed" },
		{ e_userProvidedVerifiedAndFailed, "userProvidedVerifiedAndFailed" },
		{ e_networkProvided, "networkProvided" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

ScreeningIndicator * ScreeningIndicator :: clone ( ) const {
	return new ScreeningIndicator ( * this );
}

//
// ConferenceList
//

ConferenceList :: ConferenceList ( Asn :: istream & is ) : Asn :: Sequence ( is, 3, true, 0 ), m_conferenceID ( 0 ), m_conferenceAlias ( 0 ), m_nonStandardData ( 0 ) {
	try {
		if ( hasOptionalField ( e_conferenceID ) )
			m_conferenceID = new ConferenceIdentifier ( is );
		if ( hasOptionalField ( e_conferenceAlias ) )
			m_conferenceAlias = new AliasAddress ( is );
		if ( hasOptionalField ( e_nonStandardData ) )
			m_nonStandardData = new NonStandardParameter ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_conferenceID;
		delete m_conferenceAlias;
		delete m_nonStandardData;
		throw;
	}
}

ConferenceList :: ConferenceList ( ) : Asn :: Sequence ( 3, true, 0 ), m_conferenceID ( 0 ), m_conferenceAlias ( 0 ), m_nonStandardData ( 0 ) { }

ConferenceList & ConferenceList :: operator= ( const ConferenceList & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_conferenceID, s.m_conferenceID );
	assignCopy ( m_conferenceAlias, s.m_conferenceAlias );
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	return * this;
}

ConferenceList :: ConferenceList ( const ConferenceList & s ) : Asn :: Sequence ( s ), m_conferenceID ( 0 ), m_conferenceAlias ( 0 ), m_nonStandardData ( 0 ) {
	try {
		if ( s.m_conferenceID )
			m_conferenceID = new ConferenceIdentifier ( * s.m_conferenceID );
		if ( s.m_conferenceAlias )
			m_conferenceAlias = new AliasAddress ( * s.m_conferenceAlias );
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
	} catch ( ... ) {
		delete m_conferenceID;
		delete m_conferenceAlias;
		delete m_nonStandardData;
		throw;
	}
}


void ConferenceList :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_conferenceID:
			assignNew ( m_conferenceID, new ConferenceIdentifier );
			break;
		case e_conferenceAlias:
			assignNew ( m_conferenceAlias, new AliasAddress );
			break;
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void ConferenceList :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_conferenceID:
			delete m_conferenceID;
			m_conferenceID = 0;
			break;
		case e_conferenceAlias:
			delete m_conferenceAlias;
			m_conferenceAlias = 0;
			break;
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void ConferenceList :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_conferenceID ) )
		m_conferenceID -> ConferenceIdentifier :: encode ( os );
	if ( hasOptionalField ( e_conferenceAlias ) )
		m_conferenceAlias -> AliasAddress :: encode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

ConferenceList :: ~ConferenceList ( ) {
	delete m_conferenceID;
	delete m_conferenceAlias;
	delete m_nonStandardData;
}

void ConferenceList :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_conferenceID ) ) {
		os << std :: setw ( indent + 15 ) << "conferenceID = " << std :: setprecision ( indent );
		m_conferenceID -> ConferenceIdentifier :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_conferenceAlias ) ) {
		os << std :: setw ( indent + 18 ) << "conferenceAlias = " << std :: setprecision ( indent );
		m_conferenceAlias -> AliasAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

ConferenceList * ConferenceList :: clone ( ) const {
	return new ConferenceList ( * this );
}

//
// FacilityReason
//

FacilityReason :: FacilityReason ( Asn :: istream & is ) : Asn :: Choice ( is, 4, true ) {
	switch ( tag ) {
		case e_routeCallToGatekeeper:
		case e_callForwarded:
		case e_routeCallToMC:
		case e_undefinedReason:
		case e_conferenceListChoice:
		case e_startH245:
		case e_noH245:
		case e_newTokens:
		case e_featureSetUpdate:
		case e_forwardedElements:
		case e_transportedInformation:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

FacilityReason :: FacilityReason ( ) : Asn :: Choice ( 4, true ) { }

void FacilityReason :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_routeCallToGatekeeper:
		case e_callForwarded:
		case e_routeCallToMC:
		case e_undefinedReason:
		case e_conferenceListChoice:
		case e_startH245:
		case e_noH245:
		case e_newTokens:
		case e_featureSetUpdate:
		case e_forwardedElements:
		case e_transportedInformation:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & FacilityReason :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_routeCallToGatekeeper, "routeCallToGatekeeper" },
		{ e_callForwarded, "callForwarded" },
		{ e_routeCallToMC, "routeCallToMC" },
		{ e_undefinedReason, "undefinedReason" },
		{ e_conferenceListChoice, "conferenceListChoice" },
		{ e_startH245, "startH245" },
		{ e_noH245, "noH245" },
		{ e_newTokens, "newTokens" },
		{ e_featureSetUpdate, "featureSetUpdate" },
		{ e_forwardedElements, "forwardedElements" },
		{ e_transportedInformation, "transportedInformation" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

FacilityReason * FacilityReason :: clone ( ) const {
	return new FacilityReason ( * this );
}

//
// EndpointType
//

EndpointType :: EndpointType ( Asn :: istream & is ) : Asn :: Sequence ( is, 6, true, 2 ), m_nonStandardData ( hasOptionalField ( e_nonStandardData ) ? pushTemporaryMember ( new NonStandardParameter ( is ) ) : 0 ), m_vendor ( hasOptionalField ( e_vendor ) ? pushTemporaryMember ( new VendorIdentifier ( is ) ) : 0 ), m_gatekeeper ( hasOptionalField ( e_gatekeeper ) ? pushTemporaryMember ( new GatekeeperInfo ( is ) ) : 0 ), m_gateway ( hasOptionalField ( e_gateway ) ? pushTemporaryMember ( new GatewayInfo ( is ) ) : 0 ), m_mcu ( hasOptionalField ( e_mcu ) ? pushTemporaryMember ( new McuInfo ( is ) ) : 0 ), m_terminal ( hasOptionalField ( e_terminal ) ? pushTemporaryMember ( new TerminalInfo ( is ) ) : 0 ), m_mc ( is ), m_undefinedNode ( is ), m_set ( 0 ), m_supportedTunnelledProtocols ( 0 ) {
	clearTemporaryMembers ( );
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_set ) )
				m_set = new EndpointType_set ( is );
			if ( hasKnownExtensionToDecode ( is, e_supportedTunnelledProtocols ) )
				m_supportedTunnelledProtocols = new ArrayOf_TunnelledProtocol ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_vendor;
		delete m_gatekeeper;
		delete m_gateway;
		delete m_mcu;
		delete m_terminal;
		delete m_set;
		delete m_supportedTunnelledProtocols;
		throw;
	}
}

EndpointType :: EndpointType ( ) : Asn :: Sequence ( 6, true, 2 ), m_nonStandardData ( 0 ), m_vendor ( 0 ), m_gatekeeper ( 0 ), m_gateway ( 0 ), m_mcu ( 0 ), m_terminal ( 0 ), m_set ( 0 ), m_supportedTunnelledProtocols ( 0 ) { }

EndpointType & EndpointType :: operator= ( const EndpointType & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	assignCopy ( m_vendor, s.m_vendor );
	assignCopy ( m_gatekeeper, s.m_gatekeeper );
	assignCopy ( m_gateway, s.m_gateway );
	assignCopy ( m_mcu, s.m_mcu );
	assignCopy ( m_terminal, s.m_terminal );
	m_mc = s.m_mc;
	m_undefinedNode = s.m_undefinedNode;
	assignCopy ( m_set, s.m_set );
	assignCopy ( m_supportedTunnelledProtocols, s.m_supportedTunnelledProtocols );
	return * this;
}

EndpointType :: EndpointType ( const EndpointType & s ) : Asn :: Sequence ( s ), m_nonStandardData ( 0 ), m_vendor ( 0 ), m_gatekeeper ( 0 ), m_gateway ( 0 ), m_mcu ( 0 ), m_terminal ( 0 ), m_mc ( s.m_mc ), m_undefinedNode ( s.m_undefinedNode ), m_set ( 0 ), m_supportedTunnelledProtocols ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_vendor )
			m_vendor = new VendorIdentifier ( * s.m_vendor );
		if ( s.m_gatekeeper )
			m_gatekeeper = new GatekeeperInfo ( * s.m_gatekeeper );
		if ( s.m_gateway )
			m_gateway = new GatewayInfo ( * s.m_gateway );
		if ( s.m_mcu )
			m_mcu = new McuInfo ( * s.m_mcu );
		if ( s.m_terminal )
			m_terminal = new TerminalInfo ( * s.m_terminal );
		if ( s.m_set )
			m_set = new EndpointType_set ( * s.m_set );
		if ( s.m_supportedTunnelledProtocols )
			m_supportedTunnelledProtocols = new ArrayOf_TunnelledProtocol ( * s.m_supportedTunnelledProtocols );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_vendor;
		delete m_gatekeeper;
		delete m_gateway;
		delete m_mcu;
		delete m_terminal;
		delete m_set;
		delete m_supportedTunnelledProtocols;
		throw;
	}
}


void EndpointType :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_vendor:
			assignNew ( m_vendor, new VendorIdentifier );
			break;
		case e_gatekeeper:
			assignNew ( m_gatekeeper, new GatekeeperInfo );
			break;
		case e_gateway:
			assignNew ( m_gateway, new GatewayInfo );
			break;
		case e_mcu:
			assignNew ( m_mcu, new McuInfo );
			break;
		case e_terminal:
			assignNew ( m_terminal, new TerminalInfo );
			break;
		case e_set:
			assignNew ( m_set, new EndpointType_set );
			break;
		case e_supportedTunnelledProtocols:
			assignNew ( m_supportedTunnelledProtocols, new ArrayOf_TunnelledProtocol );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void EndpointType :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_vendor:
			delete m_vendor;
			m_vendor = 0;
			break;
		case e_gatekeeper:
			delete m_gatekeeper;
			m_gatekeeper = 0;
			break;
		case e_gateway:
			delete m_gateway;
			m_gateway = 0;
			break;
		case e_mcu:
			delete m_mcu;
			m_mcu = 0;
			break;
		case e_terminal:
			delete m_terminal;
			m_terminal = 0;
			break;
		case e_set:
			delete m_set;
			m_set = 0;
			break;
		case e_supportedTunnelledProtocols:
			delete m_supportedTunnelledProtocols;
			m_supportedTunnelledProtocols = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void EndpointType :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( hasOptionalField ( e_vendor ) )
		m_vendor -> VendorIdentifier :: encode ( os );
	if ( hasOptionalField ( e_gatekeeper ) )
		m_gatekeeper -> GatekeeperInfo :: encode ( os );
	if ( hasOptionalField ( e_gateway ) )
		m_gateway -> GatewayInfo :: encode ( os );
	if ( hasOptionalField ( e_mcu ) )
		m_mcu -> McuInfo :: encode ( os );
	if ( hasOptionalField ( e_terminal ) )
		m_terminal -> TerminalInfo :: encode ( os );
	m_mc.encode ( os );
	m_undefinedNode.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_set, m_set );
		knownExtensionEncode ( os, e_supportedTunnelledProtocols, m_supportedTunnelledProtocols );
		unknownExtensionsEncode ( os );
	}
}

EndpointType :: ~EndpointType ( ) {
	delete m_nonStandardData;
	delete m_vendor;
	delete m_gatekeeper;
	delete m_gateway;
	delete m_mcu;
	delete m_terminal;
	delete m_set;
	delete m_supportedTunnelledProtocols;
}

void EndpointType :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_vendor ) ) {
		os << std :: setw ( indent + 9 ) << "vendor = " << std :: setprecision ( indent );
		m_vendor -> VendorIdentifier :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_gatekeeper ) ) {
		os << std :: setw ( indent + 13 ) << "gatekeeper = " << std :: setprecision ( indent );
		m_gatekeeper -> GatekeeperInfo :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_gateway ) ) {
		os << std :: setw ( indent + 10 ) << "gateway = " << std :: setprecision ( indent );
		m_gateway -> GatewayInfo :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_mcu ) ) {
		os << std :: setw ( indent + 6 ) << "mcu = " << std :: setprecision ( indent );
		m_mcu -> McuInfo :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_terminal ) ) {
		os << std :: setw ( indent + 11 ) << "terminal = " << std :: setprecision ( indent );
		m_terminal -> TerminalInfo :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 5 ) << "mc = " << std :: setprecision ( indent ) << m_mc << '\n';
	os << std :: setw ( indent + 16 ) << "undefinedNode = " << std :: setprecision ( indent ) << m_undefinedNode << '\n';
	if ( hasOptionalField ( e_set ) ) {
		os << std :: setw ( indent + 6 ) << "set = " << std :: setprecision ( indent );
		m_set -> EndpointType_set :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_supportedTunnelledProtocols ) ) {
		os << std :: setw ( indent + 30 ) << "supportedTunnelledProtocols = " << std :: setprecision ( indent );
		m_supportedTunnelledProtocols -> ArrayOf_TunnelledProtocol :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

EndpointType * EndpointType :: clone ( ) const {
	return new EndpointType ( * this );
}

//
// GatewayInfo
//

GatewayInfo :: GatewayInfo ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 0 ), m_protocol ( 0 ), m_nonStandardData ( 0 ) {
	try {
		if ( hasOptionalField ( e_protocol ) )
			m_protocol = new ArrayOf_SupportedProtocols ( is );
		if ( hasOptionalField ( e_nonStandardData ) )
			m_nonStandardData = new NonStandardParameter ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_protocol;
		delete m_nonStandardData;
		throw;
	}
}

GatewayInfo :: GatewayInfo ( ) : Asn :: Sequence ( 2, true, 0 ), m_protocol ( 0 ), m_nonStandardData ( 0 ) { }

GatewayInfo & GatewayInfo :: operator= ( const GatewayInfo & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_protocol, s.m_protocol );
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	return * this;
}

GatewayInfo :: GatewayInfo ( const GatewayInfo & s ) : Asn :: Sequence ( s ), m_protocol ( 0 ), m_nonStandardData ( 0 ) {
	try {
		if ( s.m_protocol )
			m_protocol = new ArrayOf_SupportedProtocols ( * s.m_protocol );
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
	} catch ( ... ) {
		delete m_protocol;
		delete m_nonStandardData;
		throw;
	}
}


void GatewayInfo :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_protocol:
			assignNew ( m_protocol, new ArrayOf_SupportedProtocols );
			break;
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void GatewayInfo :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_protocol:
			delete m_protocol;
			m_protocol = 0;
			break;
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void GatewayInfo :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_protocol ) )
		m_protocol -> ArrayOf_SupportedProtocols :: encode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

GatewayInfo :: ~GatewayInfo ( ) {
	delete m_protocol;
	delete m_nonStandardData;
}

void GatewayInfo :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_protocol ) ) {
		os << std :: setw ( indent + 11 ) << "protocol = " << std :: setprecision ( indent );
		m_protocol -> ArrayOf_SupportedProtocols :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

GatewayInfo * GatewayInfo :: clone ( ) const {
	return new GatewayInfo ( * this );
}

//
// H310Caps
//

H310Caps :: H310Caps ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 2 ), m_nonStandardData ( 0 ), m_dataRatesSupported ( 0 ), m_supportedPrefixes ( 0 ) {
	try {
		if ( hasOptionalField ( e_nonStandardData ) )
			m_nonStandardData = new NonStandardParameter ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_dataRatesSupported ) )
				m_dataRatesSupported = new ArrayOf_DataRate ( is );
			if ( hasKnownExtensionToDecode ( is, e_supportedPrefixes ) )
				m_supportedPrefixes = new ArrayOf_SupportedPrefix ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_dataRatesSupported;
		delete m_supportedPrefixes;
		throw;
	}
}

H310Caps :: H310Caps ( ) : Asn :: Sequence ( 1, true, 2 ), m_nonStandardData ( 0 ), m_dataRatesSupported ( 0 ), m_supportedPrefixes ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_supportedPrefixes );
		m_supportedPrefixes = new ArrayOf_SupportedPrefix;
	} catch ( ... ) {
		delete m_supportedPrefixes;
		throw;
	}
}

H310Caps & H310Caps :: operator= ( const H310Caps & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	assignCopy ( m_dataRatesSupported, s.m_dataRatesSupported );
	assignCopy ( m_supportedPrefixes, s.m_supportedPrefixes );
	return * this;
}

H310Caps :: H310Caps ( const H310Caps & s ) : Asn :: Sequence ( s ), m_nonStandardData ( 0 ), m_dataRatesSupported ( 0 ), m_supportedPrefixes ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_dataRatesSupported )
			m_dataRatesSupported = new ArrayOf_DataRate ( * s.m_dataRatesSupported );
		if ( s.m_supportedPrefixes )
			m_supportedPrefixes = new ArrayOf_SupportedPrefix ( * s.m_supportedPrefixes );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_dataRatesSupported;
		delete m_supportedPrefixes;
		throw;
	}
}


void H310Caps :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_dataRatesSupported:
			assignNew ( m_dataRatesSupported, new ArrayOf_DataRate );
			break;
		case e_supportedPrefixes:
			assignNew ( m_supportedPrefixes, new ArrayOf_SupportedPrefix );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void H310Caps :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_dataRatesSupported:
			delete m_dataRatesSupported;
			m_dataRatesSupported = 0;
			break;
		case e_supportedPrefixes:
			delete m_supportedPrefixes;
			m_supportedPrefixes = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void H310Caps :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_dataRatesSupported, m_dataRatesSupported );
		knownExtensionEncode ( os, e_supportedPrefixes, m_supportedPrefixes );
		unknownExtensionsEncode ( os );
	}
}

H310Caps :: ~H310Caps ( ) {
	delete m_nonStandardData;
	delete m_dataRatesSupported;
	delete m_supportedPrefixes;
}

void H310Caps :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_dataRatesSupported ) ) {
		os << std :: setw ( indent + 21 ) << "dataRatesSupported = " << std :: setprecision ( indent );
		m_dataRatesSupported -> ArrayOf_DataRate :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_supportedPrefixes ) ) {
		os << std :: setw ( indent + 20 ) << "supportedPrefixes = " << std :: setprecision ( indent );
		m_supportedPrefixes -> ArrayOf_SupportedPrefix :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H310Caps * H310Caps :: clone ( ) const {
	return new H310Caps ( * this );
}

//
// H320Caps
//

H320Caps :: H320Caps ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 2 ), m_nonStandardData ( 0 ), m_dataRatesSupported ( 0 ), m_supportedPrefixes ( 0 ) {
	try {
		if ( hasOptionalField ( e_nonStandardData ) )
			m_nonStandardData = new NonStandardParameter ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_dataRatesSupported ) )
				m_dataRatesSupported = new ArrayOf_DataRate ( is );
			if ( hasKnownExtensionToDecode ( is, e_supportedPrefixes ) )
				m_supportedPrefixes = new ArrayOf_SupportedPrefix ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_dataRatesSupported;
		delete m_supportedPrefixes;
		throw;
	}
}

H320Caps :: H320Caps ( ) : Asn :: Sequence ( 1, true, 2 ), m_nonStandardData ( 0 ), m_dataRatesSupported ( 0 ), m_supportedPrefixes ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_supportedPrefixes );
		m_supportedPrefixes = new ArrayOf_SupportedPrefix;
	} catch ( ... ) {
		delete m_supportedPrefixes;
		throw;
	}
}

H320Caps & H320Caps :: operator= ( const H320Caps & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	assignCopy ( m_dataRatesSupported, s.m_dataRatesSupported );
	assignCopy ( m_supportedPrefixes, s.m_supportedPrefixes );
	return * this;
}

H320Caps :: H320Caps ( const H320Caps & s ) : Asn :: Sequence ( s ), m_nonStandardData ( 0 ), m_dataRatesSupported ( 0 ), m_supportedPrefixes ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_dataRatesSupported )
			m_dataRatesSupported = new ArrayOf_DataRate ( * s.m_dataRatesSupported );
		if ( s.m_supportedPrefixes )
			m_supportedPrefixes = new ArrayOf_SupportedPrefix ( * s.m_supportedPrefixes );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_dataRatesSupported;
		delete m_supportedPrefixes;
		throw;
	}
}


void H320Caps :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_dataRatesSupported:
			assignNew ( m_dataRatesSupported, new ArrayOf_DataRate );
			break;
		case e_supportedPrefixes:
			assignNew ( m_supportedPrefixes, new ArrayOf_SupportedPrefix );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void H320Caps :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_dataRatesSupported:
			delete m_dataRatesSupported;
			m_dataRatesSupported = 0;
			break;
		case e_supportedPrefixes:
			delete m_supportedPrefixes;
			m_supportedPrefixes = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void H320Caps :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_dataRatesSupported, m_dataRatesSupported );
		knownExtensionEncode ( os, e_supportedPrefixes, m_supportedPrefixes );
		unknownExtensionsEncode ( os );
	}
}

H320Caps :: ~H320Caps ( ) {
	delete m_nonStandardData;
	delete m_dataRatesSupported;
	delete m_supportedPrefixes;
}

void H320Caps :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_dataRatesSupported ) ) {
		os << std :: setw ( indent + 21 ) << "dataRatesSupported = " << std :: setprecision ( indent );
		m_dataRatesSupported -> ArrayOf_DataRate :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_supportedPrefixes ) ) {
		os << std :: setw ( indent + 20 ) << "supportedPrefixes = " << std :: setprecision ( indent );
		m_supportedPrefixes -> ArrayOf_SupportedPrefix :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H320Caps * H320Caps :: clone ( ) const {
	return new H320Caps ( * this );
}

//
// H321Caps
//

H321Caps :: H321Caps ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 2 ), m_nonStandardData ( 0 ), m_dataRatesSupported ( 0 ), m_supportedPrefixes ( 0 ) {
	try {
		if ( hasOptionalField ( e_nonStandardData ) )
			m_nonStandardData = new NonStandardParameter ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_dataRatesSupported ) )
				m_dataRatesSupported = new ArrayOf_DataRate ( is );
			if ( hasKnownExtensionToDecode ( is, e_supportedPrefixes ) )
				m_supportedPrefixes = new ArrayOf_SupportedPrefix ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_dataRatesSupported;
		delete m_supportedPrefixes;
		throw;
	}
}

H321Caps :: H321Caps ( ) : Asn :: Sequence ( 1, true, 2 ), m_nonStandardData ( 0 ), m_dataRatesSupported ( 0 ), m_supportedPrefixes ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_supportedPrefixes );
		m_supportedPrefixes = new ArrayOf_SupportedPrefix;
	} catch ( ... ) {
		delete m_supportedPrefixes;
		throw;
	}
}

H321Caps & H321Caps :: operator= ( const H321Caps & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	assignCopy ( m_dataRatesSupported, s.m_dataRatesSupported );
	assignCopy ( m_supportedPrefixes, s.m_supportedPrefixes );
	return * this;
}

H321Caps :: H321Caps ( const H321Caps & s ) : Asn :: Sequence ( s ), m_nonStandardData ( 0 ), m_dataRatesSupported ( 0 ), m_supportedPrefixes ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_dataRatesSupported )
			m_dataRatesSupported = new ArrayOf_DataRate ( * s.m_dataRatesSupported );
		if ( s.m_supportedPrefixes )
			m_supportedPrefixes = new ArrayOf_SupportedPrefix ( * s.m_supportedPrefixes );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_dataRatesSupported;
		delete m_supportedPrefixes;
		throw;
	}
}


void H321Caps :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_dataRatesSupported:
			assignNew ( m_dataRatesSupported, new ArrayOf_DataRate );
			break;
		case e_supportedPrefixes:
			assignNew ( m_supportedPrefixes, new ArrayOf_SupportedPrefix );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void H321Caps :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_dataRatesSupported:
			delete m_dataRatesSupported;
			m_dataRatesSupported = 0;
			break;
		case e_supportedPrefixes:
			delete m_supportedPrefixes;
			m_supportedPrefixes = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void H321Caps :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_dataRatesSupported, m_dataRatesSupported );
		knownExtensionEncode ( os, e_supportedPrefixes, m_supportedPrefixes );
		unknownExtensionsEncode ( os );
	}
}

H321Caps :: ~H321Caps ( ) {
	delete m_nonStandardData;
	delete m_dataRatesSupported;
	delete m_supportedPrefixes;
}

void H321Caps :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_dataRatesSupported ) ) {
		os << std :: setw ( indent + 21 ) << "dataRatesSupported = " << std :: setprecision ( indent );
		m_dataRatesSupported -> ArrayOf_DataRate :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_supportedPrefixes ) ) {
		os << std :: setw ( indent + 20 ) << "supportedPrefixes = " << std :: setprecision ( indent );
		m_supportedPrefixes -> ArrayOf_SupportedPrefix :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H321Caps * H321Caps :: clone ( ) const {
	return new H321Caps ( * this );
}

//
// H322Caps
//

H322Caps :: H322Caps ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 2 ), m_nonStandardData ( 0 ), m_dataRatesSupported ( 0 ), m_supportedPrefixes ( 0 ) {
	try {
		if ( hasOptionalField ( e_nonStandardData ) )
			m_nonStandardData = new NonStandardParameter ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_dataRatesSupported ) )
				m_dataRatesSupported = new ArrayOf_DataRate ( is );
			if ( hasKnownExtensionToDecode ( is, e_supportedPrefixes ) )
				m_supportedPrefixes = new ArrayOf_SupportedPrefix ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_dataRatesSupported;
		delete m_supportedPrefixes;
		throw;
	}
}

H322Caps :: H322Caps ( ) : Asn :: Sequence ( 1, true, 2 ), m_nonStandardData ( 0 ), m_dataRatesSupported ( 0 ), m_supportedPrefixes ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_supportedPrefixes );
		m_supportedPrefixes = new ArrayOf_SupportedPrefix;
	} catch ( ... ) {
		delete m_supportedPrefixes;
		throw;
	}
}

H322Caps & H322Caps :: operator= ( const H322Caps & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	assignCopy ( m_dataRatesSupported, s.m_dataRatesSupported );
	assignCopy ( m_supportedPrefixes, s.m_supportedPrefixes );
	return * this;
}

H322Caps :: H322Caps ( const H322Caps & s ) : Asn :: Sequence ( s ), m_nonStandardData ( 0 ), m_dataRatesSupported ( 0 ), m_supportedPrefixes ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_dataRatesSupported )
			m_dataRatesSupported = new ArrayOf_DataRate ( * s.m_dataRatesSupported );
		if ( s.m_supportedPrefixes )
			m_supportedPrefixes = new ArrayOf_SupportedPrefix ( * s.m_supportedPrefixes );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_dataRatesSupported;
		delete m_supportedPrefixes;
		throw;
	}
}


void H322Caps :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_dataRatesSupported:
			assignNew ( m_dataRatesSupported, new ArrayOf_DataRate );
			break;
		case e_supportedPrefixes:
			assignNew ( m_supportedPrefixes, new ArrayOf_SupportedPrefix );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void H322Caps :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_dataRatesSupported:
			delete m_dataRatesSupported;
			m_dataRatesSupported = 0;
			break;
		case e_supportedPrefixes:
			delete m_supportedPrefixes;
			m_supportedPrefixes = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void H322Caps :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_dataRatesSupported, m_dataRatesSupported );
		knownExtensionEncode ( os, e_supportedPrefixes, m_supportedPrefixes );
		unknownExtensionsEncode ( os );
	}
}

H322Caps :: ~H322Caps ( ) {
	delete m_nonStandardData;
	delete m_dataRatesSupported;
	delete m_supportedPrefixes;
}

void H322Caps :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_dataRatesSupported ) ) {
		os << std :: setw ( indent + 21 ) << "dataRatesSupported = " << std :: setprecision ( indent );
		m_dataRatesSupported -> ArrayOf_DataRate :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_supportedPrefixes ) ) {
		os << std :: setw ( indent + 20 ) << "supportedPrefixes = " << std :: setprecision ( indent );
		m_supportedPrefixes -> ArrayOf_SupportedPrefix :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H322Caps * H322Caps :: clone ( ) const {
	return new H322Caps ( * this );
}

//
// H323Caps
//

H323Caps :: H323Caps ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 2 ), m_nonStandardData ( 0 ), m_dataRatesSupported ( 0 ), m_supportedPrefixes ( 0 ) {
	try {
		if ( hasOptionalField ( e_nonStandardData ) )
			m_nonStandardData = new NonStandardParameter ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_dataRatesSupported ) )
				m_dataRatesSupported = new ArrayOf_DataRate ( is );
			if ( hasKnownExtensionToDecode ( is, e_supportedPrefixes ) )
				m_supportedPrefixes = new ArrayOf_SupportedPrefix ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_dataRatesSupported;
		delete m_supportedPrefixes;
		throw;
	}
}

H323Caps :: H323Caps ( ) : Asn :: Sequence ( 1, true, 2 ), m_nonStandardData ( 0 ), m_dataRatesSupported ( 0 ), m_supportedPrefixes ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_supportedPrefixes );
		m_supportedPrefixes = new ArrayOf_SupportedPrefix;
	} catch ( ... ) {
		delete m_supportedPrefixes;
		throw;
	}
}

H323Caps & H323Caps :: operator= ( const H323Caps & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	assignCopy ( m_dataRatesSupported, s.m_dataRatesSupported );
	assignCopy ( m_supportedPrefixes, s.m_supportedPrefixes );
	return * this;
}

H323Caps :: H323Caps ( const H323Caps & s ) : Asn :: Sequence ( s ), m_nonStandardData ( 0 ), m_dataRatesSupported ( 0 ), m_supportedPrefixes ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_dataRatesSupported )
			m_dataRatesSupported = new ArrayOf_DataRate ( * s.m_dataRatesSupported );
		if ( s.m_supportedPrefixes )
			m_supportedPrefixes = new ArrayOf_SupportedPrefix ( * s.m_supportedPrefixes );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_dataRatesSupported;
		delete m_supportedPrefixes;
		throw;
	}
}


void H323Caps :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_dataRatesSupported:
			assignNew ( m_dataRatesSupported, new ArrayOf_DataRate );
			break;
		case e_supportedPrefixes:
			assignNew ( m_supportedPrefixes, new ArrayOf_SupportedPrefix );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void H323Caps :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_dataRatesSupported:
			delete m_dataRatesSupported;
			m_dataRatesSupported = 0;
			break;
		case e_supportedPrefixes:
			delete m_supportedPrefixes;
			m_supportedPrefixes = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void H323Caps :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_dataRatesSupported, m_dataRatesSupported );
		knownExtensionEncode ( os, e_supportedPrefixes, m_supportedPrefixes );
		unknownExtensionsEncode ( os );
	}
}

H323Caps :: ~H323Caps ( ) {
	delete m_nonStandardData;
	delete m_dataRatesSupported;
	delete m_supportedPrefixes;
}

void H323Caps :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_dataRatesSupported ) ) {
		os << std :: setw ( indent + 21 ) << "dataRatesSupported = " << std :: setprecision ( indent );
		m_dataRatesSupported -> ArrayOf_DataRate :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_supportedPrefixes ) ) {
		os << std :: setw ( indent + 20 ) << "supportedPrefixes = " << std :: setprecision ( indent );
		m_supportedPrefixes -> ArrayOf_SupportedPrefix :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H323Caps * H323Caps :: clone ( ) const {
	return new H323Caps ( * this );
}

//
// H324Caps
//

H324Caps :: H324Caps ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 2 ), m_nonStandardData ( 0 ), m_dataRatesSupported ( 0 ), m_supportedPrefixes ( 0 ) {
	try {
		if ( hasOptionalField ( e_nonStandardData ) )
			m_nonStandardData = new NonStandardParameter ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_dataRatesSupported ) )
				m_dataRatesSupported = new ArrayOf_DataRate ( is );
			if ( hasKnownExtensionToDecode ( is, e_supportedPrefixes ) )
				m_supportedPrefixes = new ArrayOf_SupportedPrefix ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_dataRatesSupported;
		delete m_supportedPrefixes;
		throw;
	}
}

H324Caps :: H324Caps ( ) : Asn :: Sequence ( 1, true, 2 ), m_nonStandardData ( 0 ), m_dataRatesSupported ( 0 ), m_supportedPrefixes ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_supportedPrefixes );
		m_supportedPrefixes = new ArrayOf_SupportedPrefix;
	} catch ( ... ) {
		delete m_supportedPrefixes;
		throw;
	}
}

H324Caps & H324Caps :: operator= ( const H324Caps & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	assignCopy ( m_dataRatesSupported, s.m_dataRatesSupported );
	assignCopy ( m_supportedPrefixes, s.m_supportedPrefixes );
	return * this;
}

H324Caps :: H324Caps ( const H324Caps & s ) : Asn :: Sequence ( s ), m_nonStandardData ( 0 ), m_dataRatesSupported ( 0 ), m_supportedPrefixes ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_dataRatesSupported )
			m_dataRatesSupported = new ArrayOf_DataRate ( * s.m_dataRatesSupported );
		if ( s.m_supportedPrefixes )
			m_supportedPrefixes = new ArrayOf_SupportedPrefix ( * s.m_supportedPrefixes );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_dataRatesSupported;
		delete m_supportedPrefixes;
		throw;
	}
}


void H324Caps :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_dataRatesSupported:
			assignNew ( m_dataRatesSupported, new ArrayOf_DataRate );
			break;
		case e_supportedPrefixes:
			assignNew ( m_supportedPrefixes, new ArrayOf_SupportedPrefix );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void H324Caps :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_dataRatesSupported:
			delete m_dataRatesSupported;
			m_dataRatesSupported = 0;
			break;
		case e_supportedPrefixes:
			delete m_supportedPrefixes;
			m_supportedPrefixes = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void H324Caps :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_dataRatesSupported, m_dataRatesSupported );
		knownExtensionEncode ( os, e_supportedPrefixes, m_supportedPrefixes );
		unknownExtensionsEncode ( os );
	}
}

H324Caps :: ~H324Caps ( ) {
	delete m_nonStandardData;
	delete m_dataRatesSupported;
	delete m_supportedPrefixes;
}

void H324Caps :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_dataRatesSupported ) ) {
		os << std :: setw ( indent + 21 ) << "dataRatesSupported = " << std :: setprecision ( indent );
		m_dataRatesSupported -> ArrayOf_DataRate :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_supportedPrefixes ) ) {
		os << std :: setw ( indent + 20 ) << "supportedPrefixes = " << std :: setprecision ( indent );
		m_supportedPrefixes -> ArrayOf_SupportedPrefix :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H324Caps * H324Caps :: clone ( ) const {
	return new H324Caps ( * this );
}

//
// VoiceCaps
//

VoiceCaps :: VoiceCaps ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 2 ), m_nonStandardData ( 0 ), m_dataRatesSupported ( 0 ), m_supportedPrefixes ( 0 ) {
	try {
		if ( hasOptionalField ( e_nonStandardData ) )
			m_nonStandardData = new NonStandardParameter ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_dataRatesSupported ) )
				m_dataRatesSupported = new ArrayOf_DataRate ( is );
			if ( hasKnownExtensionToDecode ( is, e_supportedPrefixes ) )
				m_supportedPrefixes = new ArrayOf_SupportedPrefix ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_dataRatesSupported;
		delete m_supportedPrefixes;
		throw;
	}
}

VoiceCaps :: VoiceCaps ( ) : Asn :: Sequence ( 1, true, 2 ), m_nonStandardData ( 0 ), m_dataRatesSupported ( 0 ), m_supportedPrefixes ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_supportedPrefixes );
		m_supportedPrefixes = new ArrayOf_SupportedPrefix;
	} catch ( ... ) {
		delete m_supportedPrefixes;
		throw;
	}
}

VoiceCaps & VoiceCaps :: operator= ( const VoiceCaps & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	assignCopy ( m_dataRatesSupported, s.m_dataRatesSupported );
	assignCopy ( m_supportedPrefixes, s.m_supportedPrefixes );
	return * this;
}

VoiceCaps :: VoiceCaps ( const VoiceCaps & s ) : Asn :: Sequence ( s ), m_nonStandardData ( 0 ), m_dataRatesSupported ( 0 ), m_supportedPrefixes ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_dataRatesSupported )
			m_dataRatesSupported = new ArrayOf_DataRate ( * s.m_dataRatesSupported );
		if ( s.m_supportedPrefixes )
			m_supportedPrefixes = new ArrayOf_SupportedPrefix ( * s.m_supportedPrefixes );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_dataRatesSupported;
		delete m_supportedPrefixes;
		throw;
	}
}


void VoiceCaps :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_dataRatesSupported:
			assignNew ( m_dataRatesSupported, new ArrayOf_DataRate );
			break;
		case e_supportedPrefixes:
			assignNew ( m_supportedPrefixes, new ArrayOf_SupportedPrefix );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void VoiceCaps :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_dataRatesSupported:
			delete m_dataRatesSupported;
			m_dataRatesSupported = 0;
			break;
		case e_supportedPrefixes:
			delete m_supportedPrefixes;
			m_supportedPrefixes = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void VoiceCaps :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_dataRatesSupported, m_dataRatesSupported );
		knownExtensionEncode ( os, e_supportedPrefixes, m_supportedPrefixes );
		unknownExtensionsEncode ( os );
	}
}

VoiceCaps :: ~VoiceCaps ( ) {
	delete m_nonStandardData;
	delete m_dataRatesSupported;
	delete m_supportedPrefixes;
}

void VoiceCaps :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_dataRatesSupported ) ) {
		os << std :: setw ( indent + 21 ) << "dataRatesSupported = " << std :: setprecision ( indent );
		m_dataRatesSupported -> ArrayOf_DataRate :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_supportedPrefixes ) ) {
		os << std :: setw ( indent + 20 ) << "supportedPrefixes = " << std :: setprecision ( indent );
		m_supportedPrefixes -> ArrayOf_SupportedPrefix :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

VoiceCaps * VoiceCaps :: clone ( ) const {
	return new VoiceCaps ( * this );
}

//
// T120OnlyCaps
//

T120OnlyCaps :: T120OnlyCaps ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 2 ), m_nonStandardData ( 0 ), m_dataRatesSupported ( 0 ), m_supportedPrefixes ( 0 ) {
	try {
		if ( hasOptionalField ( e_nonStandardData ) )
			m_nonStandardData = new NonStandardParameter ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_dataRatesSupported ) )
				m_dataRatesSupported = new ArrayOf_DataRate ( is );
			if ( hasKnownExtensionToDecode ( is, e_supportedPrefixes ) )
				m_supportedPrefixes = new ArrayOf_SupportedPrefix ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_dataRatesSupported;
		delete m_supportedPrefixes;
		throw;
	}
}

T120OnlyCaps :: T120OnlyCaps ( ) : Asn :: Sequence ( 1, true, 2 ), m_nonStandardData ( 0 ), m_dataRatesSupported ( 0 ), m_supportedPrefixes ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_supportedPrefixes );
		m_supportedPrefixes = new ArrayOf_SupportedPrefix;
	} catch ( ... ) {
		delete m_supportedPrefixes;
		throw;
	}
}

T120OnlyCaps & T120OnlyCaps :: operator= ( const T120OnlyCaps & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	assignCopy ( m_dataRatesSupported, s.m_dataRatesSupported );
	assignCopy ( m_supportedPrefixes, s.m_supportedPrefixes );
	return * this;
}

T120OnlyCaps :: T120OnlyCaps ( const T120OnlyCaps & s ) : Asn :: Sequence ( s ), m_nonStandardData ( 0 ), m_dataRatesSupported ( 0 ), m_supportedPrefixes ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_dataRatesSupported )
			m_dataRatesSupported = new ArrayOf_DataRate ( * s.m_dataRatesSupported );
		if ( s.m_supportedPrefixes )
			m_supportedPrefixes = new ArrayOf_SupportedPrefix ( * s.m_supportedPrefixes );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_dataRatesSupported;
		delete m_supportedPrefixes;
		throw;
	}
}


void T120OnlyCaps :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_dataRatesSupported:
			assignNew ( m_dataRatesSupported, new ArrayOf_DataRate );
			break;
		case e_supportedPrefixes:
			assignNew ( m_supportedPrefixes, new ArrayOf_SupportedPrefix );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void T120OnlyCaps :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_dataRatesSupported:
			delete m_dataRatesSupported;
			m_dataRatesSupported = 0;
			break;
		case e_supportedPrefixes:
			delete m_supportedPrefixes;
			m_supportedPrefixes = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void T120OnlyCaps :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_dataRatesSupported, m_dataRatesSupported );
		knownExtensionEncode ( os, e_supportedPrefixes, m_supportedPrefixes );
		unknownExtensionsEncode ( os );
	}
}

T120OnlyCaps :: ~T120OnlyCaps ( ) {
	delete m_nonStandardData;
	delete m_dataRatesSupported;
	delete m_supportedPrefixes;
}

void T120OnlyCaps :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_dataRatesSupported ) ) {
		os << std :: setw ( indent + 21 ) << "dataRatesSupported = " << std :: setprecision ( indent );
		m_dataRatesSupported -> ArrayOf_DataRate :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_supportedPrefixes ) ) {
		os << std :: setw ( indent + 20 ) << "supportedPrefixes = " << std :: setprecision ( indent );
		m_supportedPrefixes -> ArrayOf_SupportedPrefix :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

T120OnlyCaps * T120OnlyCaps :: clone ( ) const {
	return new T120OnlyCaps ( * this );
}

//
// SIPCaps
//

SIPCaps :: SIPCaps ( Asn :: istream & is ) : Asn :: Sequence ( is, 3, true, 0 ), m_nonStandardData ( 0 ), m_dataRatesSupported ( 0 ), m_supportedPrefixes ( 0 ) {
	try {
		if ( hasOptionalField ( e_nonStandardData ) )
			m_nonStandardData = new NonStandardParameter ( is );
		if ( hasOptionalField ( e_dataRatesSupported ) )
			m_dataRatesSupported = new ArrayOf_DataRate ( is );
		if ( hasOptionalField ( e_supportedPrefixes ) )
			m_supportedPrefixes = new ArrayOf_SupportedPrefix ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_dataRatesSupported;
		delete m_supportedPrefixes;
		throw;
	}
}

SIPCaps :: SIPCaps ( ) : Asn :: Sequence ( 3, true, 0 ), m_nonStandardData ( 0 ), m_dataRatesSupported ( 0 ), m_supportedPrefixes ( 0 ) { }

SIPCaps & SIPCaps :: operator= ( const SIPCaps & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	assignCopy ( m_dataRatesSupported, s.m_dataRatesSupported );
	assignCopy ( m_supportedPrefixes, s.m_supportedPrefixes );
	return * this;
}

SIPCaps :: SIPCaps ( const SIPCaps & s ) : Asn :: Sequence ( s ), m_nonStandardData ( 0 ), m_dataRatesSupported ( 0 ), m_supportedPrefixes ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_dataRatesSupported )
			m_dataRatesSupported = new ArrayOf_DataRate ( * s.m_dataRatesSupported );
		if ( s.m_supportedPrefixes )
			m_supportedPrefixes = new ArrayOf_SupportedPrefix ( * s.m_supportedPrefixes );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_dataRatesSupported;
		delete m_supportedPrefixes;
		throw;
	}
}


void SIPCaps :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_dataRatesSupported:
			assignNew ( m_dataRatesSupported, new ArrayOf_DataRate );
			break;
		case e_supportedPrefixes:
			assignNew ( m_supportedPrefixes, new ArrayOf_SupportedPrefix );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void SIPCaps :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_dataRatesSupported:
			delete m_dataRatesSupported;
			m_dataRatesSupported = 0;
			break;
		case e_supportedPrefixes:
			delete m_supportedPrefixes;
			m_supportedPrefixes = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void SIPCaps :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( hasOptionalField ( e_dataRatesSupported ) )
		m_dataRatesSupported -> ArrayOf_DataRate :: encode ( os );
	if ( hasOptionalField ( e_supportedPrefixes ) )
		m_supportedPrefixes -> ArrayOf_SupportedPrefix :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

SIPCaps :: ~SIPCaps ( ) {
	delete m_nonStandardData;
	delete m_dataRatesSupported;
	delete m_supportedPrefixes;
}

void SIPCaps :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_dataRatesSupported ) ) {
		os << std :: setw ( indent + 21 ) << "dataRatesSupported = " << std :: setprecision ( indent );
		m_dataRatesSupported -> ArrayOf_DataRate :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_supportedPrefixes ) ) {
		os << std :: setw ( indent + 20 ) << "supportedPrefixes = " << std :: setprecision ( indent );
		m_supportedPrefixes -> ArrayOf_SupportedPrefix :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

SIPCaps * SIPCaps :: clone ( ) const {
	return new SIPCaps ( * this );
}

//
// McuInfo
//

McuInfo :: McuInfo ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 1 ), m_nonStandardData ( 0 ), m_protocol ( 0 ) {
	try {
		if ( hasOptionalField ( e_nonStandardData ) )
			m_nonStandardData = new NonStandardParameter ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_protocol ) )
				m_protocol = new ArrayOf_SupportedProtocols ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_protocol;
		throw;
	}
}

McuInfo :: McuInfo ( ) : Asn :: Sequence ( 1, true, 1 ), m_nonStandardData ( 0 ), m_protocol ( 0 ) { }

McuInfo & McuInfo :: operator= ( const McuInfo & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	assignCopy ( m_protocol, s.m_protocol );
	return * this;
}

McuInfo :: McuInfo ( const McuInfo & s ) : Asn :: Sequence ( s ), m_nonStandardData ( 0 ), m_protocol ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_protocol )
			m_protocol = new ArrayOf_SupportedProtocols ( * s.m_protocol );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_protocol;
		throw;
	}
}


void McuInfo :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_protocol:
			assignNew ( m_protocol, new ArrayOf_SupportedProtocols );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void McuInfo :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_protocol:
			delete m_protocol;
			m_protocol = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void McuInfo :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_protocol, m_protocol );
		unknownExtensionsEncode ( os );
	}
}

McuInfo :: ~McuInfo ( ) {
	delete m_nonStandardData;
	delete m_protocol;
}

void McuInfo :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_protocol ) ) {
		os << std :: setw ( indent + 11 ) << "protocol = " << std :: setprecision ( indent );
		m_protocol -> ArrayOf_SupportedProtocols :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

McuInfo * McuInfo :: clone ( ) const {
	return new McuInfo ( * this );
}

//
// TerminalInfo
//

TerminalInfo :: TerminalInfo ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_nonStandardData ( 0 ) {
	try {
		if ( hasOptionalField ( e_nonStandardData ) )
			m_nonStandardData = new NonStandardParameter ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_nonStandardData;
		throw;
	}
}

TerminalInfo :: TerminalInfo ( ) : Asn :: Sequence ( 1, true, 0 ), m_nonStandardData ( 0 ) { }

TerminalInfo & TerminalInfo :: operator= ( const TerminalInfo & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	return * this;
}

TerminalInfo :: TerminalInfo ( const TerminalInfo & s ) : Asn :: Sequence ( s ), m_nonStandardData ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
	} catch ( ... ) {
		delete m_nonStandardData;
		throw;
	}
}


void TerminalInfo :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void TerminalInfo :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void TerminalInfo :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

TerminalInfo :: ~TerminalInfo ( ) {
	delete m_nonStandardData;
}

void TerminalInfo :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

TerminalInfo * TerminalInfo :: clone ( ) const {
	return new TerminalInfo ( * this );
}

//
// GatekeeperInfo
//

GatekeeperInfo :: GatekeeperInfo ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_nonStandardData ( 0 ) {
	try {
		if ( hasOptionalField ( e_nonStandardData ) )
			m_nonStandardData = new NonStandardParameter ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_nonStandardData;
		throw;
	}
}

GatekeeperInfo :: GatekeeperInfo ( ) : Asn :: Sequence ( 1, true, 0 ), m_nonStandardData ( 0 ) { }

GatekeeperInfo & GatekeeperInfo :: operator= ( const GatekeeperInfo & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	return * this;
}

GatekeeperInfo :: GatekeeperInfo ( const GatekeeperInfo & s ) : Asn :: Sequence ( s ), m_nonStandardData ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
	} catch ( ... ) {
		delete m_nonStandardData;
		throw;
	}
}


void GatekeeperInfo :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void GatekeeperInfo :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void GatekeeperInfo :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

GatekeeperInfo :: ~GatekeeperInfo ( ) {
	delete m_nonStandardData;
}

void GatekeeperInfo :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

GatekeeperInfo * GatekeeperInfo :: clone ( ) const {
	return new GatekeeperInfo ( * this );
}

//
// NumberDigits
//

NumberDigits :: NumberDigits ( Asn :: istream & is ) : Asn :: IA5String ( is, Asn :: fixedConstraint, 1, 128, "#*,0123456789", sizeof ( "0123456789#*," ) > 17 ? 8 : 4 ) { }

NumberDigits :: NumberDigits ( const Asn :: string & v ) : Asn :: IA5String ( v, Asn :: fixedConstraint, 1, 128, "#*,0123456789", sizeof ( "0123456789#*," ) > 17 ? 8 : 4 ) { }

NumberDigits * NumberDigits :: clone ( ) const {
	return new NumberDigits ( * this );
}

//
// PublicTypeOfNumber
//

PublicTypeOfNumber :: PublicTypeOfNumber ( Asn :: istream & is ) : Asn :: Choice ( is, 6, true ) {
	switch ( tag ) {
		case e_unknown:
		case e_internationalNumber:
		case e_nationalNumber:
		case e_networkSpecificNumber:
		case e_subscriberNumber:
		case e_abbreviatedNumber:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

PublicTypeOfNumber :: PublicTypeOfNumber ( ) : Asn :: Choice ( 6, true ) { }

void PublicTypeOfNumber :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_unknown:
		case e_internationalNumber:
		case e_nationalNumber:
		case e_networkSpecificNumber:
		case e_subscriberNumber:
		case e_abbreviatedNumber:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & PublicTypeOfNumber :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_unknown, "unknown" },
		{ e_internationalNumber, "internationalNumber" },
		{ e_nationalNumber, "nationalNumber" },
		{ e_networkSpecificNumber, "networkSpecificNumber" },
		{ e_subscriberNumber, "subscriberNumber" },
		{ e_abbreviatedNumber, "abbreviatedNumber" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

PublicTypeOfNumber * PublicTypeOfNumber :: clone ( ) const {
	return new PublicTypeOfNumber ( * this );
}

//
// PrivateTypeOfNumber
//

PrivateTypeOfNumber :: PrivateTypeOfNumber ( Asn :: istream & is ) : Asn :: Choice ( is, 6, true ) {
	switch ( tag ) {
		case e_unknown:
		case e_level2RegionalNumber:
		case e_level1RegionalNumber:
		case e_pISNSpecificNumber:
		case e_localNumber:
		case e_abbreviatedNumber:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

PrivateTypeOfNumber :: PrivateTypeOfNumber ( ) : Asn :: Choice ( 6, true ) { }

void PrivateTypeOfNumber :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_unknown:
		case e_level2RegionalNumber:
		case e_level1RegionalNumber:
		case e_pISNSpecificNumber:
		case e_localNumber:
		case e_abbreviatedNumber:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & PrivateTypeOfNumber :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_unknown, "unknown" },
		{ e_level2RegionalNumber, "level2RegionalNumber" },
		{ e_level1RegionalNumber, "level1RegionalNumber" },
		{ e_pISNSpecificNumber, "pISNSpecificNumber" },
		{ e_localNumber, "localNumber" },
		{ e_abbreviatedNumber, "abbreviatedNumber" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

PrivateTypeOfNumber * PrivateTypeOfNumber :: clone ( ) const {
	return new PrivateTypeOfNumber ( * this );
}

//
// TBCD-STRING
//

TBCD_STRING :: TBCD_STRING ( Asn :: istream & is ) : Asn :: IA5String ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ), "#*0123456789abc", sizeof ( "0123456789#*abc" ) > 17 ? 8 : 4 ) { }

TBCD_STRING :: TBCD_STRING ( const Asn :: string & v ) : Asn :: IA5String ( v, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ), "#*0123456789abc", sizeof ( "0123456789#*abc" ) > 17 ? 8 : 4 ) { }

TBCD_STRING * TBCD_STRING :: clone ( ) const {
	return new TBCD_STRING ( * this );
}

//
// NatureOfAddress
//

NatureOfAddress :: NatureOfAddress ( Asn :: istream & is ) : Asn :: Choice ( is, 8, true ) {
	switch ( tag ) {
		case e_unknown:
		case e_subscriberNumber:
		case e_nationalNumber:
		case e_internationalNumber:
		case e_networkSpecificNumber:
		case e_routingNumberNationalFormat:
		case e_routingNumberNetworkSpecificFormat:
		case e_routingNumberWithCalledDirectoryNumber:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

NatureOfAddress :: NatureOfAddress ( ) : Asn :: Choice ( 8, true ) { }

void NatureOfAddress :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_unknown:
		case e_subscriberNumber:
		case e_nationalNumber:
		case e_internationalNumber:
		case e_networkSpecificNumber:
		case e_routingNumberNationalFormat:
		case e_routingNumberNetworkSpecificFormat:
		case e_routingNumberWithCalledDirectoryNumber:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & NatureOfAddress :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_unknown, "unknown" },
		{ e_subscriberNumber, "subscriberNumber" },
		{ e_nationalNumber, "nationalNumber" },
		{ e_internationalNumber, "internationalNumber" },
		{ e_networkSpecificNumber, "networkSpecificNumber" },
		{ e_routingNumberNationalFormat, "routingNumberNationalFormat" },
		{ e_routingNumberNetworkSpecificFormat, "routingNumberNetworkSpecificFormat" },
		{ e_routingNumberWithCalledDirectoryNumber, "routingNumberWithCalledDirectoryNumber" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

NatureOfAddress * NatureOfAddress :: clone ( ) const {
	return new NatureOfAddress ( * this );
}

//
// IsupDigits
//

IsupDigits :: IsupDigits ( Asn :: istream & is ) : Asn :: IA5String ( is, Asn :: fixedConstraint, 1, 128, "0123456789ABCDE", sizeof ( "0123456789ABCDE" ) > 17 ? 8 : 4 ) { }

IsupDigits :: IsupDigits ( const Asn :: string & v ) : Asn :: IA5String ( v, Asn :: fixedConstraint, 1, 128, "0123456789ABCDE", sizeof ( "0123456789ABCDE" ) > 17 ? 8 : 4 ) { }

IsupDigits * IsupDigits :: clone ( ) const {
	return new IsupDigits ( * this );
}

//
// Endpoint
//

Endpoint :: Endpoint ( Asn :: istream & is ) : Asn :: Sequence ( is, 10, true, 3 ), m_nonStandardData ( 0 ), m_aliasAddress ( 0 ), m_callSignalAddress ( 0 ), m_rasAddress ( 0 ), m_endpointType ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_priority ( 0 ), m_remoteExtensionAddress ( 0 ), m_destExtraCallInfo ( 0 ), m_alternateTransportAddresses ( 0 ), m_circuitInfo ( 0 ), m_featureSet ( 0 ) {
	try {
		if ( hasOptionalField ( e_nonStandardData ) )
			m_nonStandardData = new NonStandardParameter ( is );
		if ( hasOptionalField ( e_aliasAddress ) )
			m_aliasAddress = new ArrayOf_AliasAddress ( is );
		if ( hasOptionalField ( e_callSignalAddress ) )
			m_callSignalAddress = new ArrayOf_TransportAddress ( is );
		if ( hasOptionalField ( e_rasAddress ) )
			m_rasAddress = new ArrayOf_TransportAddress ( is );
		if ( hasOptionalField ( e_endpointType ) )
			m_endpointType = new EndpointType ( is );
		if ( hasOptionalField ( e_tokens ) )
			m_tokens = new ArrayOf_ClearToken ( is );
		if ( hasOptionalField ( e_cryptoTokens ) )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
		if ( hasOptionalField ( e_priority ) )
			m_priority = new Endpoint_priority ( is );
		if ( hasOptionalField ( e_remoteExtensionAddress ) )
			m_remoteExtensionAddress = new ArrayOf_AliasAddress ( is );
		if ( hasOptionalField ( e_destExtraCallInfo ) )
			m_destExtraCallInfo = new ArrayOf_AliasAddress ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_alternateTransportAddresses ) )
				m_alternateTransportAddresses = new AlternateTransportAddresses ( is );
			if ( hasKnownExtensionToDecode ( is, e_circuitInfo ) )
				m_circuitInfo = new CircuitInfo ( is );
			if ( hasKnownExtensionToDecode ( is, e_featureSet ) )
				m_featureSet = new FeatureSet ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_aliasAddress;
		delete m_callSignalAddress;
		delete m_rasAddress;
		delete m_endpointType;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_priority;
		delete m_remoteExtensionAddress;
		delete m_destExtraCallInfo;
		delete m_alternateTransportAddresses;
		delete m_circuitInfo;
		delete m_featureSet;
		throw;
	}
}

Endpoint :: Endpoint ( ) : Asn :: Sequence ( 10, true, 3 ), m_nonStandardData ( 0 ), m_aliasAddress ( 0 ), m_callSignalAddress ( 0 ), m_rasAddress ( 0 ), m_endpointType ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_priority ( 0 ), m_remoteExtensionAddress ( 0 ), m_destExtraCallInfo ( 0 ), m_alternateTransportAddresses ( 0 ), m_circuitInfo ( 0 ), m_featureSet ( 0 ) { }

Endpoint & Endpoint :: operator= ( const Endpoint & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	assignCopy ( m_aliasAddress, s.m_aliasAddress );
	assignCopy ( m_callSignalAddress, s.m_callSignalAddress );
	assignCopy ( m_rasAddress, s.m_rasAddress );
	assignCopy ( m_endpointType, s.m_endpointType );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_priority, s.m_priority );
	assignCopy ( m_remoteExtensionAddress, s.m_remoteExtensionAddress );
	assignCopy ( m_destExtraCallInfo, s.m_destExtraCallInfo );
	assignCopy ( m_alternateTransportAddresses, s.m_alternateTransportAddresses );
	assignCopy ( m_circuitInfo, s.m_circuitInfo );
	assignCopy ( m_featureSet, s.m_featureSet );
	return * this;
}

Endpoint :: Endpoint ( const Endpoint & s ) : Asn :: Sequence ( s ), m_nonStandardData ( 0 ), m_aliasAddress ( 0 ), m_callSignalAddress ( 0 ), m_rasAddress ( 0 ), m_endpointType ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_priority ( 0 ), m_remoteExtensionAddress ( 0 ), m_destExtraCallInfo ( 0 ), m_alternateTransportAddresses ( 0 ), m_circuitInfo ( 0 ), m_featureSet ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_aliasAddress )
			m_aliasAddress = new ArrayOf_AliasAddress ( * s.m_aliasAddress );
		if ( s.m_callSignalAddress )
			m_callSignalAddress = new ArrayOf_TransportAddress ( * s.m_callSignalAddress );
		if ( s.m_rasAddress )
			m_rasAddress = new ArrayOf_TransportAddress ( * s.m_rasAddress );
		if ( s.m_endpointType )
			m_endpointType = new EndpointType ( * s.m_endpointType );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_priority )
			m_priority = new Endpoint_priority ( * s.m_priority );
		if ( s.m_remoteExtensionAddress )
			m_remoteExtensionAddress = new ArrayOf_AliasAddress ( * s.m_remoteExtensionAddress );
		if ( s.m_destExtraCallInfo )
			m_destExtraCallInfo = new ArrayOf_AliasAddress ( * s.m_destExtraCallInfo );
		if ( s.m_alternateTransportAddresses )
			m_alternateTransportAddresses = new AlternateTransportAddresses ( * s.m_alternateTransportAddresses );
		if ( s.m_circuitInfo )
			m_circuitInfo = new CircuitInfo ( * s.m_circuitInfo );
		if ( s.m_featureSet )
			m_featureSet = new FeatureSet ( * s.m_featureSet );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_aliasAddress;
		delete m_callSignalAddress;
		delete m_rasAddress;
		delete m_endpointType;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_priority;
		delete m_remoteExtensionAddress;
		delete m_destExtraCallInfo;
		delete m_alternateTransportAddresses;
		delete m_circuitInfo;
		delete m_featureSet;
		throw;
	}
}


void Endpoint :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_aliasAddress:
			assignNew ( m_aliasAddress, new ArrayOf_AliasAddress );
			break;
		case e_callSignalAddress:
			assignNew ( m_callSignalAddress, new ArrayOf_TransportAddress );
			break;
		case e_rasAddress:
			assignNew ( m_rasAddress, new ArrayOf_TransportAddress );
			break;
		case e_endpointType:
			assignNew ( m_endpointType, new EndpointType );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_priority:
			assignNew ( m_priority, new Endpoint_priority );
			break;
		case e_remoteExtensionAddress:
			assignNew ( m_remoteExtensionAddress, new ArrayOf_AliasAddress );
			break;
		case e_destExtraCallInfo:
			assignNew ( m_destExtraCallInfo, new ArrayOf_AliasAddress );
			break;
		case e_alternateTransportAddresses:
			assignNew ( m_alternateTransportAddresses, new AlternateTransportAddresses );
			break;
		case e_circuitInfo:
			assignNew ( m_circuitInfo, new CircuitInfo );
			break;
		case e_featureSet:
			assignNew ( m_featureSet, new FeatureSet );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void Endpoint :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_aliasAddress:
			delete m_aliasAddress;
			m_aliasAddress = 0;
			break;
		case e_callSignalAddress:
			delete m_callSignalAddress;
			m_callSignalAddress = 0;
			break;
		case e_rasAddress:
			delete m_rasAddress;
			m_rasAddress = 0;
			break;
		case e_endpointType:
			delete m_endpointType;
			m_endpointType = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_priority:
			delete m_priority;
			m_priority = 0;
			break;
		case e_remoteExtensionAddress:
			delete m_remoteExtensionAddress;
			m_remoteExtensionAddress = 0;
			break;
		case e_destExtraCallInfo:
			delete m_destExtraCallInfo;
			m_destExtraCallInfo = 0;
			break;
		case e_alternateTransportAddresses:
			delete m_alternateTransportAddresses;
			m_alternateTransportAddresses = 0;
			break;
		case e_circuitInfo:
			delete m_circuitInfo;
			m_circuitInfo = 0;
			break;
		case e_featureSet:
			delete m_featureSet;
			m_featureSet = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void Endpoint :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( hasOptionalField ( e_aliasAddress ) )
		m_aliasAddress -> ArrayOf_AliasAddress :: encode ( os );
	if ( hasOptionalField ( e_callSignalAddress ) )
		m_callSignalAddress -> ArrayOf_TransportAddress :: encode ( os );
	if ( hasOptionalField ( e_rasAddress ) )
		m_rasAddress -> ArrayOf_TransportAddress :: encode ( os );
	if ( hasOptionalField ( e_endpointType ) )
		m_endpointType -> EndpointType :: encode ( os );
	if ( hasOptionalField ( e_tokens ) )
		m_tokens -> ArrayOf_ClearToken :: encode ( os );
	if ( hasOptionalField ( e_cryptoTokens ) )
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: encode ( os );
	if ( hasOptionalField ( e_priority ) )
		m_priority -> Endpoint_priority :: encode ( os );
	if ( hasOptionalField ( e_remoteExtensionAddress ) )
		m_remoteExtensionAddress -> ArrayOf_AliasAddress :: encode ( os );
	if ( hasOptionalField ( e_destExtraCallInfo ) )
		m_destExtraCallInfo -> ArrayOf_AliasAddress :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_alternateTransportAddresses, m_alternateTransportAddresses );
		knownExtensionEncode ( os, e_circuitInfo, m_circuitInfo );
		knownExtensionEncode ( os, e_featureSet, m_featureSet );
		unknownExtensionsEncode ( os );
	}
}

Endpoint :: ~Endpoint ( ) {
	delete m_nonStandardData;
	delete m_aliasAddress;
	delete m_callSignalAddress;
	delete m_rasAddress;
	delete m_endpointType;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_priority;
	delete m_remoteExtensionAddress;
	delete m_destExtraCallInfo;
	delete m_alternateTransportAddresses;
	delete m_circuitInfo;
	delete m_featureSet;
}

void Endpoint :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_aliasAddress ) ) {
		os << std :: setw ( indent + 15 ) << "aliasAddress = " << std :: setprecision ( indent );
		m_aliasAddress -> ArrayOf_AliasAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_callSignalAddress ) ) {
		os << std :: setw ( indent + 20 ) << "callSignalAddress = " << std :: setprecision ( indent );
		m_callSignalAddress -> ArrayOf_TransportAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_rasAddress ) ) {
		os << std :: setw ( indent + 13 ) << "rasAddress = " << std :: setprecision ( indent );
		m_rasAddress -> ArrayOf_TransportAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_endpointType ) ) {
		os << std :: setw ( indent + 15 ) << "endpointType = " << std :: setprecision ( indent );
		m_endpointType -> EndpointType :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_priority ) ) {
		os << std :: setw ( indent + 11 ) << "priority = " << std :: setprecision ( indent );
		m_priority -> Endpoint_priority :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_remoteExtensionAddress ) ) {
		os << std :: setw ( indent + 25 ) << "remoteExtensionAddress = " << std :: setprecision ( indent );
		m_remoteExtensionAddress -> ArrayOf_AliasAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_destExtraCallInfo ) ) {
		os << std :: setw ( indent + 20 ) << "destExtraCallInfo = " << std :: setprecision ( indent );
		m_destExtraCallInfo -> ArrayOf_AliasAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_alternateTransportAddresses ) ) {
		os << std :: setw ( indent + 30 ) << "alternateTransportAddresses = " << std :: setprecision ( indent );
		m_alternateTransportAddresses -> AlternateTransportAddresses :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_circuitInfo ) ) {
		os << std :: setw ( indent + 14 ) << "circuitInfo = " << std :: setprecision ( indent );
		m_circuitInfo -> CircuitInfo :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_featureSet ) ) {
		os << std :: setw ( indent + 13 ) << "featureSet = " << std :: setprecision ( indent );
		m_featureSet -> FeatureSet :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

Endpoint * Endpoint :: clone ( ) const {
	return new Endpoint ( * this );
}

//
// AlternateTransportAddresses
//

AlternateTransportAddresses :: AlternateTransportAddresses ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 1 ), m_annexE ( 0 ), m_sctp ( 0 ) {
	try {
		if ( hasOptionalField ( e_annexE ) )
			m_annexE = new ArrayOf_TransportAddress ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_sctp ) )
				m_sctp = new ArrayOf_TransportAddress ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_annexE;
		delete m_sctp;
		throw;
	}
}

AlternateTransportAddresses :: AlternateTransportAddresses ( ) : Asn :: Sequence ( 1, true, 1 ), m_annexE ( 0 ), m_sctp ( 0 ) { }

AlternateTransportAddresses & AlternateTransportAddresses :: operator= ( const AlternateTransportAddresses & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_annexE, s.m_annexE );
	assignCopy ( m_sctp, s.m_sctp );
	return * this;
}

AlternateTransportAddresses :: AlternateTransportAddresses ( const AlternateTransportAddresses & s ) : Asn :: Sequence ( s ), m_annexE ( 0 ), m_sctp ( 0 ) {
	try {
		if ( s.m_annexE )
			m_annexE = new ArrayOf_TransportAddress ( * s.m_annexE );
		if ( s.m_sctp )
			m_sctp = new ArrayOf_TransportAddress ( * s.m_sctp );
	} catch ( ... ) {
		delete m_annexE;
		delete m_sctp;
		throw;
	}
}


void AlternateTransportAddresses :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_annexE:
			assignNew ( m_annexE, new ArrayOf_TransportAddress );
			break;
		case e_sctp:
			assignNew ( m_sctp, new ArrayOf_TransportAddress );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void AlternateTransportAddresses :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_annexE:
			delete m_annexE;
			m_annexE = 0;
			break;
		case e_sctp:
			delete m_sctp;
			m_sctp = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void AlternateTransportAddresses :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_annexE ) )
		m_annexE -> ArrayOf_TransportAddress :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_sctp, m_sctp );
		unknownExtensionsEncode ( os );
	}
}

AlternateTransportAddresses :: ~AlternateTransportAddresses ( ) {
	delete m_annexE;
	delete m_sctp;
}

void AlternateTransportAddresses :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_annexE ) ) {
		os << std :: setw ( indent + 9 ) << "annexE = " << std :: setprecision ( indent );
		m_annexE -> ArrayOf_TransportAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_sctp ) ) {
		os << std :: setw ( indent + 7 ) << "sctp = " << std :: setprecision ( indent );
		m_sctp -> ArrayOf_TransportAddress :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

AlternateTransportAddresses * AlternateTransportAddresses :: clone ( ) const {
	return new AlternateTransportAddresses ( * this );
}

//
// UseSpecifiedTransport
//

UseSpecifiedTransport :: UseSpecifiedTransport ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_tcp:
		case e_annexE:
		case e_sctp:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

UseSpecifiedTransport :: UseSpecifiedTransport ( ) : Asn :: Choice ( 2, true ) { }

void UseSpecifiedTransport :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_tcp:
		case e_annexE:
		case e_sctp:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & UseSpecifiedTransport :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_tcp, "tcp" },
		{ e_annexE, "annexE" },
		{ e_sctp, "sctp" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

UseSpecifiedTransport * UseSpecifiedTransport :: clone ( ) const {
	return new UseSpecifiedTransport ( * this );
}

//
// SecurityErrors
//

SecurityErrors :: SecurityErrors ( Asn :: istream & is ) : Asn :: Choice ( is, 16, true ) {
	switch ( tag ) {
		case e_securityWrongSyncTime:
		case e_securityReplay:
		case e_securityWrongGeneralID:
		case e_securityWrongSendersID:
		case e_securityIntegrityFailed:
		case e_securityWrongOID:
		case e_securityDHmismatch:
		case e_securityCertificateExpired:
		case e_securityCertificateDateInvalid:
		case e_securityCertificateRevoked:
		case e_securityCertificateNotReadable:
		case e_securityCertificateSignatureInvalid:
		case e_securityCertificateMissing:
		case e_securityCertificateIncomplete:
		case e_securityUnsupportedCertificateAlgOID:
		case e_securityUnknownCA:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

SecurityErrors :: SecurityErrors ( ) : Asn :: Choice ( 16, true ) { }

void SecurityErrors :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_securityWrongSyncTime:
		case e_securityReplay:
		case e_securityWrongGeneralID:
		case e_securityWrongSendersID:
		case e_securityIntegrityFailed:
		case e_securityWrongOID:
		case e_securityDHmismatch:
		case e_securityCertificateExpired:
		case e_securityCertificateDateInvalid:
		case e_securityCertificateRevoked:
		case e_securityCertificateNotReadable:
		case e_securityCertificateSignatureInvalid:
		case e_securityCertificateMissing:
		case e_securityCertificateIncomplete:
		case e_securityUnsupportedCertificateAlgOID:
		case e_securityUnknownCA:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & SecurityErrors :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_securityWrongSyncTime, "securityWrongSyncTime" },
		{ e_securityReplay, "securityReplay" },
		{ e_securityWrongGeneralID, "securityWrongGeneralID" },
		{ e_securityWrongSendersID, "securityWrongSendersID" },
		{ e_securityIntegrityFailed, "securityIntegrityFailed" },
		{ e_securityWrongOID, "securityWrongOID" },
		{ e_securityDHmismatch, "securityDHmismatch" },
		{ e_securityCertificateExpired, "securityCertificateExpired" },
		{ e_securityCertificateDateInvalid, "securityCertificateDateInvalid" },
		{ e_securityCertificateRevoked, "securityCertificateRevoked" },
		{ e_securityCertificateNotReadable, "securityCertificateNotReadable" },
		{ e_securityCertificateSignatureInvalid, "securityCertificateSignatureInvalid" },
		{ e_securityCertificateMissing, "securityCertificateMissing" },
		{ e_securityCertificateIncomplete, "securityCertificateIncomplete" },
		{ e_securityUnsupportedCertificateAlgOID, "securityUnsupportedCertificateAlgOID" },
		{ e_securityUnknownCA, "securityUnknownCA" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

SecurityErrors * SecurityErrors :: clone ( ) const {
	return new SecurityErrors ( * this );
}

//
// SecurityErrors2
//

SecurityErrors2 :: SecurityErrors2 ( Asn :: istream & is ) : Asn :: Choice ( is, 6, true ) {
	switch ( tag ) {
		case e_securityWrongSyncTime:
		case e_securityReplay:
		case e_securityWrongGeneralID:
		case e_securityWrongSendersID:
		case e_securityIntegrityFailed:
		case e_securityWrongOID:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

SecurityErrors2 :: SecurityErrors2 ( ) : Asn :: Choice ( 6, true ) { }

void SecurityErrors2 :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_securityWrongSyncTime:
		case e_securityReplay:
		case e_securityWrongGeneralID:
		case e_securityWrongSendersID:
		case e_securityIntegrityFailed:
		case e_securityWrongOID:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & SecurityErrors2 :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_securityWrongSyncTime, "securityWrongSyncTime" },
		{ e_securityReplay, "securityReplay" },
		{ e_securityWrongGeneralID, "securityWrongGeneralID" },
		{ e_securityWrongSendersID, "securityWrongSendersID" },
		{ e_securityIntegrityFailed, "securityIntegrityFailed" },
		{ e_securityWrongOID, "securityWrongOID" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

SecurityErrors2 * SecurityErrors2 :: clone ( ) const {
	return new SecurityErrors2 ( * this );
}

//
// Q954Details
//

Q954Details :: Q954Details ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_conferenceCalling ( is ), m_threePartyService ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

Q954Details :: Q954Details ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void Q954Details :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_conferenceCalling.encode ( os );
	m_threePartyService.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void Q954Details :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 20 ) << "conferenceCalling = " << std :: setprecision ( indent ) << m_conferenceCalling << '\n';
	os << std :: setw ( indent + 20 ) << "threePartyService = " << std :: setprecision ( indent ) << m_threePartyService << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

Q954Details * Q954Details :: clone ( ) const {
	return new Q954Details ( * this );
}

//
// GloballyUniqueID
//

GloballyUniqueID :: GloballyUniqueID ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 16, 16 ) { }

GloballyUniqueID :: GloballyUniqueID ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 16, 16 ) { }

GloballyUniqueID * GloballyUniqueID :: clone ( ) const {
	return new GloballyUniqueID ( * this );
}

//
// ConferenceIdentifier
//

ConferenceIdentifier :: ConferenceIdentifier ( Asn :: istream & is ) : GloballyUniqueID ( is ) { }

ConferenceIdentifier :: ConferenceIdentifier ( ) : GloballyUniqueID ( ) { }

ConferenceIdentifier * ConferenceIdentifier :: clone ( ) const {
	return new ConferenceIdentifier ( * this );
}

//
// RequestSeqNum
//

RequestSeqNum :: RequestSeqNum ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 65535 ) { }

RequestSeqNum :: RequestSeqNum ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 65535 ) { }

RequestSeqNum * RequestSeqNum :: clone ( ) const {
	return new RequestSeqNum ( * this );
}

//
// GatekeeperIdentifier
//

GatekeeperIdentifier :: GatekeeperIdentifier ( Asn :: istream & is ) : Asn :: BMPString ( is, Asn :: fixedConstraint, 1, 128 ) { }

GatekeeperIdentifier :: GatekeeperIdentifier ( const Asn :: string & v ) : Asn :: BMPString ( v, Asn :: fixedConstraint, 1, 128 ) { }

GatekeeperIdentifier * GatekeeperIdentifier :: clone ( ) const {
	return new GatekeeperIdentifier ( * this );
}

//
// BandWidth
//

BandWidth :: BandWidth ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 4294967295U ) { }

BandWidth :: BandWidth ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 4294967295U ) { }

BandWidth * BandWidth :: clone ( ) const {
	return new BandWidth ( * this );
}

//
// CallReferenceValue
//

CallReferenceValue :: CallReferenceValue ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

CallReferenceValue :: CallReferenceValue ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

CallReferenceValue * CallReferenceValue :: clone ( ) const {
	return new CallReferenceValue ( * this );
}

//
// EndpointIdentifier
//

EndpointIdentifier :: EndpointIdentifier ( Asn :: istream & is ) : Asn :: BMPString ( is, Asn :: fixedConstraint, 1, 128 ) { }

EndpointIdentifier :: EndpointIdentifier ( const Asn :: string & v ) : Asn :: BMPString ( v, Asn :: fixedConstraint, 1, 128 ) { }

EndpointIdentifier * EndpointIdentifier :: clone ( ) const {
	return new EndpointIdentifier ( * this );
}

//
// ProtocolIdentifier
//

ProtocolIdentifier :: ProtocolIdentifier ( Asn :: istream & is ) : Asn :: ObjectId ( is ) { }

ProtocolIdentifier :: ProtocolIdentifier ( ) : Asn :: ObjectId ( "" ) {
}

ProtocolIdentifier * ProtocolIdentifier :: clone ( ) const {
	return new ProtocolIdentifier ( * this );
}

//
// TimeToLive
//

TimeToLive :: TimeToLive ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 4294967295U ) { }

TimeToLive :: TimeToLive ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 4294967295U ) { }

TimeToLive * TimeToLive :: clone ( ) const {
	return new TimeToLive ( * this );
}

//
// H248PackagesDescriptor
//

H248PackagesDescriptor :: H248PackagesDescriptor ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

H248PackagesDescriptor :: H248PackagesDescriptor ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

H248PackagesDescriptor * H248PackagesDescriptor :: clone ( ) const {
	return new H248PackagesDescriptor ( * this );
}

//
// H248SignalsDescriptor
//

H248SignalsDescriptor :: H248SignalsDescriptor ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

H248SignalsDescriptor :: H248SignalsDescriptor ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

H248SignalsDescriptor * H248SignalsDescriptor :: clone ( ) const {
	return new H248SignalsDescriptor ( * this );
}

//
// CallIdentifier
//

CallIdentifier :: CallIdentifier ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_guid ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

CallIdentifier :: CallIdentifier ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void CallIdentifier :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_guid.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void CallIdentifier :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 7 ) << "guid = " << std :: setprecision ( indent ) << m_guid << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

CallIdentifier * CallIdentifier :: clone ( ) const {
	return new CallIdentifier ( * this );
}

//
// ICV
//

ICV :: ICV ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, false, 0 ), m_algorithmOID ( is ), m_icv ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) {
}

ICV :: ICV ( ) : Asn :: Sequence ( 0, false, 0 ) { }

void ICV :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_algorithmOID.encode ( os );
	m_icv.encode ( os );
}

void ICV :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 15 ) << "algorithmOID = " << std :: setprecision ( indent ) << m_algorithmOID << '\n';
	os << std :: setw ( indent + 6 ) << "icv = " << std :: setprecision ( indent ) << m_icv << '\n';
	os << std :: setw ( indent - 1 ) << '}';
}

ICV * ICV :: clone ( ) const {
	return new ICV ( * this );
}

//
// FastStartToken
//

FastStartToken :: FastStartToken ( Asn :: istream & is ) : H235 :: ClearToken ( is ) { }

FastStartToken :: FastStartToken ( ) : H235 :: ClearToken ( ) {
	includeOptionalField ( e_generalID );
	includeOptionalField ( e_dhkey );
	includeOptionalField ( e_timeStamp );
}

FastStartToken * FastStartToken :: clone ( ) const {
	return new FastStartToken ( * this );
}

//
// EncodedFastStartToken
//

EncodedFastStartToken :: EncodedFastStartToken ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

EncodedFastStartToken :: EncodedFastStartToken ( ) : Asn :: OctetString ( "", Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

EncodedFastStartToken * EncodedFastStartToken :: clone ( ) const {
	return new EncodedFastStartToken ( * this );
}

//
// DataRate
//

DataRate :: DataRate ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 0 ), m_nonStandardData ( hasOptionalField ( e_nonStandardData ) ? pushTemporaryMember ( new NonStandardParameter ( is ) ) : 0 ), m_channelRate ( is ), m_channelMultiplier ( 0 ) {
	clearTemporaryMembers ( );
	try {
		if ( hasOptionalField ( e_channelMultiplier ) )
			m_channelMultiplier = new DataRate_channelMultiplier ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_channelMultiplier;
		throw;
	}
}

DataRate :: DataRate ( ) : Asn :: Sequence ( 2, true, 0 ), m_nonStandardData ( 0 ), m_channelMultiplier ( 0 ) { }

DataRate & DataRate :: operator= ( const DataRate & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	m_channelRate = s.m_channelRate;
	assignCopy ( m_channelMultiplier, s.m_channelMultiplier );
	return * this;
}

DataRate :: DataRate ( const DataRate & s ) : Asn :: Sequence ( s ), m_nonStandardData ( 0 ), m_channelRate ( s.m_channelRate ), m_channelMultiplier ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_channelMultiplier )
			m_channelMultiplier = new DataRate_channelMultiplier ( * s.m_channelMultiplier );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_channelMultiplier;
		throw;
	}
}


void DataRate :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_channelMultiplier:
			assignNew ( m_channelMultiplier, new DataRate_channelMultiplier );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void DataRate :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_channelMultiplier:
			delete m_channelMultiplier;
			m_channelMultiplier = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void DataRate :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	m_channelRate.encode ( os );
	if ( hasOptionalField ( e_channelMultiplier ) )
		m_channelMultiplier -> DataRate_channelMultiplier :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

DataRate :: ~DataRate ( ) {
	delete m_nonStandardData;
	delete m_channelMultiplier;
}

void DataRate :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 14 ) << "channelRate = " << std :: setprecision ( indent ) << m_channelRate << '\n';
	if ( hasOptionalField ( e_channelMultiplier ) ) {
		os << std :: setw ( indent + 20 ) << "channelMultiplier = " << std :: setprecision ( indent );
		m_channelMultiplier -> DataRate_channelMultiplier :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

DataRate * DataRate :: clone ( ) const {
	return new DataRate ( * this );
}

//
// CallLinkage
//

CallLinkage :: CallLinkage ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 0 ), m_globalCallId ( 0 ), m_threadId ( 0 ) {
	try {
		if ( hasOptionalField ( e_globalCallId ) )
			m_globalCallId = new GloballyUniqueID ( is );
		if ( hasOptionalField ( e_threadId ) )
			m_threadId = new GloballyUniqueID ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_globalCallId;
		delete m_threadId;
		throw;
	}
}

CallLinkage :: CallLinkage ( ) : Asn :: Sequence ( 2, true, 0 ), m_globalCallId ( 0 ), m_threadId ( 0 ) { }

CallLinkage & CallLinkage :: operator= ( const CallLinkage & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_globalCallId, s.m_globalCallId );
	assignCopy ( m_threadId, s.m_threadId );
	return * this;
}

CallLinkage :: CallLinkage ( const CallLinkage & s ) : Asn :: Sequence ( s ), m_globalCallId ( 0 ), m_threadId ( 0 ) {
	try {
		if ( s.m_globalCallId )
			m_globalCallId = new GloballyUniqueID ( * s.m_globalCallId );
		if ( s.m_threadId )
			m_threadId = new GloballyUniqueID ( * s.m_threadId );
	} catch ( ... ) {
		delete m_globalCallId;
		delete m_threadId;
		throw;
	}
}


void CallLinkage :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_globalCallId:
			assignNew ( m_globalCallId, new GloballyUniqueID );
			break;
		case e_threadId:
			assignNew ( m_threadId, new GloballyUniqueID );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void CallLinkage :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_globalCallId:
			delete m_globalCallId;
			m_globalCallId = 0;
			break;
		case e_threadId:
			delete m_threadId;
			m_threadId = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void CallLinkage :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_globalCallId ) )
		m_globalCallId -> GloballyUniqueID :: encode ( os );
	if ( hasOptionalField ( e_threadId ) )
		m_threadId -> GloballyUniqueID :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

CallLinkage :: ~CallLinkage ( ) {
	delete m_globalCallId;
	delete m_threadId;
}

void CallLinkage :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_globalCallId ) ) {
		os << std :: setw ( indent + 15 ) << "globalCallId = " << std :: setprecision ( indent );
		m_globalCallId -> GloballyUniqueID :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_threadId ) ) {
		os << std :: setw ( indent + 11 ) << "threadId = " << std :: setprecision ( indent );
		m_threadId -> GloballyUniqueID :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

CallLinkage * CallLinkage :: clone ( ) const {
	return new CallLinkage ( * this );
}

//
// CapacityReportingCapability
//

CapacityReportingCapability :: CapacityReportingCapability ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_canReportCallCapacity ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

CapacityReportingCapability :: CapacityReportingCapability ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void CapacityReportingCapability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_canReportCallCapacity.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void CapacityReportingCapability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 24 ) << "canReportCallCapacity = " << std :: setprecision ( indent ) << m_canReportCallCapacity << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

CapacityReportingCapability * CapacityReportingCapability :: clone ( ) const {
	return new CapacityReportingCapability ( * this );
}

//
// CallCapacity
//

CallCapacity :: CallCapacity ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 0 ), m_maximumCallCapacity ( 0 ), m_currentCallCapacity ( 0 ) {
	try {
		if ( hasOptionalField ( e_maximumCallCapacity ) )
			m_maximumCallCapacity = new CallCapacityInfo ( is );
		if ( hasOptionalField ( e_currentCallCapacity ) )
			m_currentCallCapacity = new CallCapacityInfo ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_maximumCallCapacity;
		delete m_currentCallCapacity;
		throw;
	}
}

CallCapacity :: CallCapacity ( ) : Asn :: Sequence ( 2, true, 0 ), m_maximumCallCapacity ( 0 ), m_currentCallCapacity ( 0 ) { }

CallCapacity & CallCapacity :: operator= ( const CallCapacity & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_maximumCallCapacity, s.m_maximumCallCapacity );
	assignCopy ( m_currentCallCapacity, s.m_currentCallCapacity );
	return * this;
}

CallCapacity :: CallCapacity ( const CallCapacity & s ) : Asn :: Sequence ( s ), m_maximumCallCapacity ( 0 ), m_currentCallCapacity ( 0 ) {
	try {
		if ( s.m_maximumCallCapacity )
			m_maximumCallCapacity = new CallCapacityInfo ( * s.m_maximumCallCapacity );
		if ( s.m_currentCallCapacity )
			m_currentCallCapacity = new CallCapacityInfo ( * s.m_currentCallCapacity );
	} catch ( ... ) {
		delete m_maximumCallCapacity;
		delete m_currentCallCapacity;
		throw;
	}
}


void CallCapacity :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_maximumCallCapacity:
			assignNew ( m_maximumCallCapacity, new CallCapacityInfo );
			break;
		case e_currentCallCapacity:
			assignNew ( m_currentCallCapacity, new CallCapacityInfo );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void CallCapacity :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_maximumCallCapacity:
			delete m_maximumCallCapacity;
			m_maximumCallCapacity = 0;
			break;
		case e_currentCallCapacity:
			delete m_currentCallCapacity;
			m_currentCallCapacity = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void CallCapacity :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_maximumCallCapacity ) )
		m_maximumCallCapacity -> CallCapacityInfo :: encode ( os );
	if ( hasOptionalField ( e_currentCallCapacity ) )
		m_currentCallCapacity -> CallCapacityInfo :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

CallCapacity :: ~CallCapacity ( ) {
	delete m_maximumCallCapacity;
	delete m_currentCallCapacity;
}

void CallCapacity :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_maximumCallCapacity ) ) {
		os << std :: setw ( indent + 22 ) << "maximumCallCapacity = " << std :: setprecision ( indent );
		m_maximumCallCapacity -> CallCapacityInfo :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_currentCallCapacity ) ) {
		os << std :: setw ( indent + 22 ) << "currentCallCapacity = " << std :: setprecision ( indent );
		m_currentCallCapacity -> CallCapacityInfo :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

CallCapacity * CallCapacity :: clone ( ) const {
	return new CallCapacity ( * this );
}

//
// CallCapacityInfo
//

CallCapacityInfo :: CallCapacityInfo ( Asn :: istream & is ) : Asn :: Sequence ( is, 11, true, 1 ), m_voiceGwCallsAvailable ( 0 ), m_h310GwCallsAvailable ( 0 ), m_h320GwCallsAvailable ( 0 ), m_h321GwCallsAvailable ( 0 ), m_h322GwCallsAvailable ( 0 ), m_h323GwCallsAvailable ( 0 ), m_h324GwCallsAvailable ( 0 ), m_t120OnlyGwCallsAvailable ( 0 ), m_t38FaxAnnexbOnlyGwCallsAvailable ( 0 ), m_terminalCallsAvailable ( 0 ), m_mcuCallsAvailable ( 0 ), m_sipGwCallsAvailable ( 0 ) {
	try {
		if ( hasOptionalField ( e_voiceGwCallsAvailable ) )
			m_voiceGwCallsAvailable = new ArrayOf_CallsAvailable ( is );
		if ( hasOptionalField ( e_h310GwCallsAvailable ) )
			m_h310GwCallsAvailable = new ArrayOf_CallsAvailable ( is );
		if ( hasOptionalField ( e_h320GwCallsAvailable ) )
			m_h320GwCallsAvailable = new ArrayOf_CallsAvailable ( is );
		if ( hasOptionalField ( e_h321GwCallsAvailable ) )
			m_h321GwCallsAvailable = new ArrayOf_CallsAvailable ( is );
		if ( hasOptionalField ( e_h322GwCallsAvailable ) )
			m_h322GwCallsAvailable = new ArrayOf_CallsAvailable ( is );
		if ( hasOptionalField ( e_h323GwCallsAvailable ) )
			m_h323GwCallsAvailable = new ArrayOf_CallsAvailable ( is );
		if ( hasOptionalField ( e_h324GwCallsAvailable ) )
			m_h324GwCallsAvailable = new ArrayOf_CallsAvailable ( is );
		if ( hasOptionalField ( e_t120OnlyGwCallsAvailable ) )
			m_t120OnlyGwCallsAvailable = new ArrayOf_CallsAvailable ( is );
		if ( hasOptionalField ( e_t38FaxAnnexbOnlyGwCallsAvailable ) )
			m_t38FaxAnnexbOnlyGwCallsAvailable = new ArrayOf_CallsAvailable ( is );
		if ( hasOptionalField ( e_terminalCallsAvailable ) )
			m_terminalCallsAvailable = new ArrayOf_CallsAvailable ( is );
		if ( hasOptionalField ( e_mcuCallsAvailable ) )
			m_mcuCallsAvailable = new ArrayOf_CallsAvailable ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_sipGwCallsAvailable ) )
				m_sipGwCallsAvailable = new ArrayOf_CallsAvailable ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_voiceGwCallsAvailable;
		delete m_h310GwCallsAvailable;
		delete m_h320GwCallsAvailable;
		delete m_h321GwCallsAvailable;
		delete m_h322GwCallsAvailable;
		delete m_h323GwCallsAvailable;
		delete m_h324GwCallsAvailable;
		delete m_t120OnlyGwCallsAvailable;
		delete m_t38FaxAnnexbOnlyGwCallsAvailable;
		delete m_terminalCallsAvailable;
		delete m_mcuCallsAvailable;
		delete m_sipGwCallsAvailable;
		throw;
	}
}

CallCapacityInfo :: CallCapacityInfo ( ) : Asn :: Sequence ( 11, true, 1 ), m_voiceGwCallsAvailable ( 0 ), m_h310GwCallsAvailable ( 0 ), m_h320GwCallsAvailable ( 0 ), m_h321GwCallsAvailable ( 0 ), m_h322GwCallsAvailable ( 0 ), m_h323GwCallsAvailable ( 0 ), m_h324GwCallsAvailable ( 0 ), m_t120OnlyGwCallsAvailable ( 0 ), m_t38FaxAnnexbOnlyGwCallsAvailable ( 0 ), m_terminalCallsAvailable ( 0 ), m_mcuCallsAvailable ( 0 ), m_sipGwCallsAvailable ( 0 ) { }

CallCapacityInfo & CallCapacityInfo :: operator= ( const CallCapacityInfo & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_voiceGwCallsAvailable, s.m_voiceGwCallsAvailable );
	assignCopy ( m_h310GwCallsAvailable, s.m_h310GwCallsAvailable );
	assignCopy ( m_h320GwCallsAvailable, s.m_h320GwCallsAvailable );
	assignCopy ( m_h321GwCallsAvailable, s.m_h321GwCallsAvailable );
	assignCopy ( m_h322GwCallsAvailable, s.m_h322GwCallsAvailable );
	assignCopy ( m_h323GwCallsAvailable, s.m_h323GwCallsAvailable );
	assignCopy ( m_h324GwCallsAvailable, s.m_h324GwCallsAvailable );
	assignCopy ( m_t120OnlyGwCallsAvailable, s.m_t120OnlyGwCallsAvailable );
	assignCopy ( m_t38FaxAnnexbOnlyGwCallsAvailable, s.m_t38FaxAnnexbOnlyGwCallsAvailable );
	assignCopy ( m_terminalCallsAvailable, s.m_terminalCallsAvailable );
	assignCopy ( m_mcuCallsAvailable, s.m_mcuCallsAvailable );
	assignCopy ( m_sipGwCallsAvailable, s.m_sipGwCallsAvailable );
	return * this;
}

CallCapacityInfo :: CallCapacityInfo ( const CallCapacityInfo & s ) : Asn :: Sequence ( s ), m_voiceGwCallsAvailable ( 0 ), m_h310GwCallsAvailable ( 0 ), m_h320GwCallsAvailable ( 0 ), m_h321GwCallsAvailable ( 0 ), m_h322GwCallsAvailable ( 0 ), m_h323GwCallsAvailable ( 0 ), m_h324GwCallsAvailable ( 0 ), m_t120OnlyGwCallsAvailable ( 0 ), m_t38FaxAnnexbOnlyGwCallsAvailable ( 0 ), m_terminalCallsAvailable ( 0 ), m_mcuCallsAvailable ( 0 ), m_sipGwCallsAvailable ( 0 ) {
	try {
		if ( s.m_voiceGwCallsAvailable )
			m_voiceGwCallsAvailable = new ArrayOf_CallsAvailable ( * s.m_voiceGwCallsAvailable );
		if ( s.m_h310GwCallsAvailable )
			m_h310GwCallsAvailable = new ArrayOf_CallsAvailable ( * s.m_h310GwCallsAvailable );
		if ( s.m_h320GwCallsAvailable )
			m_h320GwCallsAvailable = new ArrayOf_CallsAvailable ( * s.m_h320GwCallsAvailable );
		if ( s.m_h321GwCallsAvailable )
			m_h321GwCallsAvailable = new ArrayOf_CallsAvailable ( * s.m_h321GwCallsAvailable );
		if ( s.m_h322GwCallsAvailable )
			m_h322GwCallsAvailable = new ArrayOf_CallsAvailable ( * s.m_h322GwCallsAvailable );
		if ( s.m_h323GwCallsAvailable )
			m_h323GwCallsAvailable = new ArrayOf_CallsAvailable ( * s.m_h323GwCallsAvailable );
		if ( s.m_h324GwCallsAvailable )
			m_h324GwCallsAvailable = new ArrayOf_CallsAvailable ( * s.m_h324GwCallsAvailable );
		if ( s.m_t120OnlyGwCallsAvailable )
			m_t120OnlyGwCallsAvailable = new ArrayOf_CallsAvailable ( * s.m_t120OnlyGwCallsAvailable );
		if ( s.m_t38FaxAnnexbOnlyGwCallsAvailable )
			m_t38FaxAnnexbOnlyGwCallsAvailable = new ArrayOf_CallsAvailable ( * s.m_t38FaxAnnexbOnlyGwCallsAvailable );
		if ( s.m_terminalCallsAvailable )
			m_terminalCallsAvailable = new ArrayOf_CallsAvailable ( * s.m_terminalCallsAvailable );
		if ( s.m_mcuCallsAvailable )
			m_mcuCallsAvailable = new ArrayOf_CallsAvailable ( * s.m_mcuCallsAvailable );
		if ( s.m_sipGwCallsAvailable )
			m_sipGwCallsAvailable = new ArrayOf_CallsAvailable ( * s.m_sipGwCallsAvailable );
	} catch ( ... ) {
		delete m_voiceGwCallsAvailable;
		delete m_h310GwCallsAvailable;
		delete m_h320GwCallsAvailable;
		delete m_h321GwCallsAvailable;
		delete m_h322GwCallsAvailable;
		delete m_h323GwCallsAvailable;
		delete m_h324GwCallsAvailable;
		delete m_t120OnlyGwCallsAvailable;
		delete m_t38FaxAnnexbOnlyGwCallsAvailable;
		delete m_terminalCallsAvailable;
		delete m_mcuCallsAvailable;
		delete m_sipGwCallsAvailable;
		throw;
	}
}


void CallCapacityInfo :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_voiceGwCallsAvailable:
			assignNew ( m_voiceGwCallsAvailable, new ArrayOf_CallsAvailable );
			break;
		case e_h310GwCallsAvailable:
			assignNew ( m_h310GwCallsAvailable, new ArrayOf_CallsAvailable );
			break;
		case e_h320GwCallsAvailable:
			assignNew ( m_h320GwCallsAvailable, new ArrayOf_CallsAvailable );
			break;
		case e_h321GwCallsAvailable:
			assignNew ( m_h321GwCallsAvailable, new ArrayOf_CallsAvailable );
			break;
		case e_h322GwCallsAvailable:
			assignNew ( m_h322GwCallsAvailable, new ArrayOf_CallsAvailable );
			break;
		case e_h323GwCallsAvailable:
			assignNew ( m_h323GwCallsAvailable, new ArrayOf_CallsAvailable );
			break;
		case e_h324GwCallsAvailable:
			assignNew ( m_h324GwCallsAvailable, new ArrayOf_CallsAvailable );
			break;
		case e_t120OnlyGwCallsAvailable:
			assignNew ( m_t120OnlyGwCallsAvailable, new ArrayOf_CallsAvailable );
			break;
		case e_t38FaxAnnexbOnlyGwCallsAvailable:
			assignNew ( m_t38FaxAnnexbOnlyGwCallsAvailable, new ArrayOf_CallsAvailable );
			break;
		case e_terminalCallsAvailable:
			assignNew ( m_terminalCallsAvailable, new ArrayOf_CallsAvailable );
			break;
		case e_mcuCallsAvailable:
			assignNew ( m_mcuCallsAvailable, new ArrayOf_CallsAvailable );
			break;
		case e_sipGwCallsAvailable:
			assignNew ( m_sipGwCallsAvailable, new ArrayOf_CallsAvailable );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void CallCapacityInfo :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_voiceGwCallsAvailable:
			delete m_voiceGwCallsAvailable;
			m_voiceGwCallsAvailable = 0;
			break;
		case e_h310GwCallsAvailable:
			delete m_h310GwCallsAvailable;
			m_h310GwCallsAvailable = 0;
			break;
		case e_h320GwCallsAvailable:
			delete m_h320GwCallsAvailable;
			m_h320GwCallsAvailable = 0;
			break;
		case e_h321GwCallsAvailable:
			delete m_h321GwCallsAvailable;
			m_h321GwCallsAvailable = 0;
			break;
		case e_h322GwCallsAvailable:
			delete m_h322GwCallsAvailable;
			m_h322GwCallsAvailable = 0;
			break;
		case e_h323GwCallsAvailable:
			delete m_h323GwCallsAvailable;
			m_h323GwCallsAvailable = 0;
			break;
		case e_h324GwCallsAvailable:
			delete m_h324GwCallsAvailable;
			m_h324GwCallsAvailable = 0;
			break;
		case e_t120OnlyGwCallsAvailable:
			delete m_t120OnlyGwCallsAvailable;
			m_t120OnlyGwCallsAvailable = 0;
			break;
		case e_t38FaxAnnexbOnlyGwCallsAvailable:
			delete m_t38FaxAnnexbOnlyGwCallsAvailable;
			m_t38FaxAnnexbOnlyGwCallsAvailable = 0;
			break;
		case e_terminalCallsAvailable:
			delete m_terminalCallsAvailable;
			m_terminalCallsAvailable = 0;
			break;
		case e_mcuCallsAvailable:
			delete m_mcuCallsAvailable;
			m_mcuCallsAvailable = 0;
			break;
		case e_sipGwCallsAvailable:
			delete m_sipGwCallsAvailable;
			m_sipGwCallsAvailable = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void CallCapacityInfo :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_voiceGwCallsAvailable ) )
		m_voiceGwCallsAvailable -> ArrayOf_CallsAvailable :: encode ( os );
	if ( hasOptionalField ( e_h310GwCallsAvailable ) )
		m_h310GwCallsAvailable -> ArrayOf_CallsAvailable :: encode ( os );
	if ( hasOptionalField ( e_h320GwCallsAvailable ) )
		m_h320GwCallsAvailable -> ArrayOf_CallsAvailable :: encode ( os );
	if ( hasOptionalField ( e_h321GwCallsAvailable ) )
		m_h321GwCallsAvailable -> ArrayOf_CallsAvailable :: encode ( os );
	if ( hasOptionalField ( e_h322GwCallsAvailable ) )
		m_h322GwCallsAvailable -> ArrayOf_CallsAvailable :: encode ( os );
	if ( hasOptionalField ( e_h323GwCallsAvailable ) )
		m_h323GwCallsAvailable -> ArrayOf_CallsAvailable :: encode ( os );
	if ( hasOptionalField ( e_h324GwCallsAvailable ) )
		m_h324GwCallsAvailable -> ArrayOf_CallsAvailable :: encode ( os );
	if ( hasOptionalField ( e_t120OnlyGwCallsAvailable ) )
		m_t120OnlyGwCallsAvailable -> ArrayOf_CallsAvailable :: encode ( os );
	if ( hasOptionalField ( e_t38FaxAnnexbOnlyGwCallsAvailable ) )
		m_t38FaxAnnexbOnlyGwCallsAvailable -> ArrayOf_CallsAvailable :: encode ( os );
	if ( hasOptionalField ( e_terminalCallsAvailable ) )
		m_terminalCallsAvailable -> ArrayOf_CallsAvailable :: encode ( os );
	if ( hasOptionalField ( e_mcuCallsAvailable ) )
		m_mcuCallsAvailable -> ArrayOf_CallsAvailable :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_sipGwCallsAvailable, m_sipGwCallsAvailable );
		unknownExtensionsEncode ( os );
	}
}

CallCapacityInfo :: ~CallCapacityInfo ( ) {
	delete m_voiceGwCallsAvailable;
	delete m_h310GwCallsAvailable;
	delete m_h320GwCallsAvailable;
	delete m_h321GwCallsAvailable;
	delete m_h322GwCallsAvailable;
	delete m_h323GwCallsAvailable;
	delete m_h324GwCallsAvailable;
	delete m_t120OnlyGwCallsAvailable;
	delete m_t38FaxAnnexbOnlyGwCallsAvailable;
	delete m_terminalCallsAvailable;
	delete m_mcuCallsAvailable;
	delete m_sipGwCallsAvailable;
}

void CallCapacityInfo :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_voiceGwCallsAvailable ) ) {
		os << std :: setw ( indent + 24 ) << "voiceGwCallsAvailable = " << std :: setprecision ( indent );
		m_voiceGwCallsAvailable -> ArrayOf_CallsAvailable :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_h310GwCallsAvailable ) ) {
		os << std :: setw ( indent + 23 ) << "h310GwCallsAvailable = " << std :: setprecision ( indent );
		m_h310GwCallsAvailable -> ArrayOf_CallsAvailable :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_h320GwCallsAvailable ) ) {
		os << std :: setw ( indent + 23 ) << "h320GwCallsAvailable = " << std :: setprecision ( indent );
		m_h320GwCallsAvailable -> ArrayOf_CallsAvailable :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_h321GwCallsAvailable ) ) {
		os << std :: setw ( indent + 23 ) << "h321GwCallsAvailable = " << std :: setprecision ( indent );
		m_h321GwCallsAvailable -> ArrayOf_CallsAvailable :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_h322GwCallsAvailable ) ) {
		os << std :: setw ( indent + 23 ) << "h322GwCallsAvailable = " << std :: setprecision ( indent );
		m_h322GwCallsAvailable -> ArrayOf_CallsAvailable :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_h323GwCallsAvailable ) ) {
		os << std :: setw ( indent + 23 ) << "h323GwCallsAvailable = " << std :: setprecision ( indent );
		m_h323GwCallsAvailable -> ArrayOf_CallsAvailable :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_h324GwCallsAvailable ) ) {
		os << std :: setw ( indent + 23 ) << "h324GwCallsAvailable = " << std :: setprecision ( indent );
		m_h324GwCallsAvailable -> ArrayOf_CallsAvailable :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_t120OnlyGwCallsAvailable ) ) {
		os << std :: setw ( indent + 27 ) << "t120OnlyGwCallsAvailable = " << std :: setprecision ( indent );
		m_t120OnlyGwCallsAvailable -> ArrayOf_CallsAvailable :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_t38FaxAnnexbOnlyGwCallsAvailable ) ) {
		os << std :: setw ( indent + 35 ) << "t38FaxAnnexbOnlyGwCallsAvailable = " << std :: setprecision ( indent );
		m_t38FaxAnnexbOnlyGwCallsAvailable -> ArrayOf_CallsAvailable :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_terminalCallsAvailable ) ) {
		os << std :: setw ( indent + 25 ) << "terminalCallsAvailable = " << std :: setprecision ( indent );
		m_terminalCallsAvailable -> ArrayOf_CallsAvailable :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_mcuCallsAvailable ) ) {
		os << std :: setw ( indent + 20 ) << "mcuCallsAvailable = " << std :: setprecision ( indent );
		m_mcuCallsAvailable -> ArrayOf_CallsAvailable :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_sipGwCallsAvailable ) ) {
		os << std :: setw ( indent + 22 ) << "sipGwCallsAvailable = " << std :: setprecision ( indent );
		m_sipGwCallsAvailable -> ArrayOf_CallsAvailable :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

CallCapacityInfo * CallCapacityInfo :: clone ( ) const {
	return new CallCapacityInfo ( * this );
}

//
// CircuitInfo
//

CircuitInfo :: CircuitInfo ( Asn :: istream & is ) : Asn :: Sequence ( is, 3, true, 0 ), m_sourceCircuitID ( 0 ), m_destinationCircuitID ( 0 ), m_genericData ( 0 ) {
	try {
		if ( hasOptionalField ( e_sourceCircuitID ) )
			m_sourceCircuitID = new CircuitIdentifier ( is );
		if ( hasOptionalField ( e_destinationCircuitID ) )
			m_destinationCircuitID = new CircuitIdentifier ( is );
		if ( hasOptionalField ( e_genericData ) )
			m_genericData = new ArrayOf_GenericData ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_sourceCircuitID;
		delete m_destinationCircuitID;
		delete m_genericData;
		throw;
	}
}

CircuitInfo :: CircuitInfo ( ) : Asn :: Sequence ( 3, true, 0 ), m_sourceCircuitID ( 0 ), m_destinationCircuitID ( 0 ), m_genericData ( 0 ) { }

CircuitInfo & CircuitInfo :: operator= ( const CircuitInfo & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_sourceCircuitID, s.m_sourceCircuitID );
	assignCopy ( m_destinationCircuitID, s.m_destinationCircuitID );
	assignCopy ( m_genericData, s.m_genericData );
	return * this;
}

CircuitInfo :: CircuitInfo ( const CircuitInfo & s ) : Asn :: Sequence ( s ), m_sourceCircuitID ( 0 ), m_destinationCircuitID ( 0 ), m_genericData ( 0 ) {
	try {
		if ( s.m_sourceCircuitID )
			m_sourceCircuitID = new CircuitIdentifier ( * s.m_sourceCircuitID );
		if ( s.m_destinationCircuitID )
			m_destinationCircuitID = new CircuitIdentifier ( * s.m_destinationCircuitID );
		if ( s.m_genericData )
			m_genericData = new ArrayOf_GenericData ( * s.m_genericData );
	} catch ( ... ) {
		delete m_sourceCircuitID;
		delete m_destinationCircuitID;
		delete m_genericData;
		throw;
	}
}


void CircuitInfo :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_sourceCircuitID:
			assignNew ( m_sourceCircuitID, new CircuitIdentifier );
			break;
		case e_destinationCircuitID:
			assignNew ( m_destinationCircuitID, new CircuitIdentifier );
			break;
		case e_genericData:
			assignNew ( m_genericData, new ArrayOf_GenericData );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void CircuitInfo :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_sourceCircuitID:
			delete m_sourceCircuitID;
			m_sourceCircuitID = 0;
			break;
		case e_destinationCircuitID:
			delete m_destinationCircuitID;
			m_destinationCircuitID = 0;
			break;
		case e_genericData:
			delete m_genericData;
			m_genericData = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void CircuitInfo :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_sourceCircuitID ) )
		m_sourceCircuitID -> CircuitIdentifier :: encode ( os );
	if ( hasOptionalField ( e_destinationCircuitID ) )
		m_destinationCircuitID -> CircuitIdentifier :: encode ( os );
	if ( hasOptionalField ( e_genericData ) )
		m_genericData -> ArrayOf_GenericData :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

CircuitInfo :: ~CircuitInfo ( ) {
	delete m_sourceCircuitID;
	delete m_destinationCircuitID;
	delete m_genericData;
}

void CircuitInfo :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_sourceCircuitID ) ) {
		os << std :: setw ( indent + 18 ) << "sourceCircuitID = " << std :: setprecision ( indent );
		m_sourceCircuitID -> CircuitIdentifier :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_destinationCircuitID ) ) {
		os << std :: setw ( indent + 23 ) << "destinationCircuitID = " << std :: setprecision ( indent );
		m_destinationCircuitID -> CircuitIdentifier :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_genericData ) ) {
		os << std :: setw ( indent + 14 ) << "genericData = " << std :: setprecision ( indent );
		m_genericData -> ArrayOf_GenericData :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

CircuitInfo * CircuitInfo :: clone ( ) const {
	return new CircuitInfo ( * this );
}

//
// CircuitIdentifier
//

CircuitIdentifier :: CircuitIdentifier ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 1 ), m_cic ( 0 ), m_group ( 0 ), m_carrier ( 0 ) {
	try {
		if ( hasOptionalField ( e_cic ) )
			m_cic = new CicInfo ( is );
		if ( hasOptionalField ( e_group ) )
			m_group = new GroupID ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_carrier ) )
				m_carrier = new CarrierInfo ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_cic;
		delete m_group;
		delete m_carrier;
		throw;
	}
}

CircuitIdentifier :: CircuitIdentifier ( ) : Asn :: Sequence ( 2, true, 1 ), m_cic ( 0 ), m_group ( 0 ), m_carrier ( 0 ) { }

CircuitIdentifier & CircuitIdentifier :: operator= ( const CircuitIdentifier & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_cic, s.m_cic );
	assignCopy ( m_group, s.m_group );
	assignCopy ( m_carrier, s.m_carrier );
	return * this;
}

CircuitIdentifier :: CircuitIdentifier ( const CircuitIdentifier & s ) : Asn :: Sequence ( s ), m_cic ( 0 ), m_group ( 0 ), m_carrier ( 0 ) {
	try {
		if ( s.m_cic )
			m_cic = new CicInfo ( * s.m_cic );
		if ( s.m_group )
			m_group = new GroupID ( * s.m_group );
		if ( s.m_carrier )
			m_carrier = new CarrierInfo ( * s.m_carrier );
	} catch ( ... ) {
		delete m_cic;
		delete m_group;
		delete m_carrier;
		throw;
	}
}


void CircuitIdentifier :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_cic:
			assignNew ( m_cic, new CicInfo );
			break;
		case e_group:
			assignNew ( m_group, new GroupID );
			break;
		case e_carrier:
			assignNew ( m_carrier, new CarrierInfo );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void CircuitIdentifier :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_cic:
			delete m_cic;
			m_cic = 0;
			break;
		case e_group:
			delete m_group;
			m_group = 0;
			break;
		case e_carrier:
			delete m_carrier;
			m_carrier = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void CircuitIdentifier :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_cic ) )
		m_cic -> CicInfo :: encode ( os );
	if ( hasOptionalField ( e_group ) )
		m_group -> GroupID :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_carrier, m_carrier );
		unknownExtensionsEncode ( os );
	}
}

CircuitIdentifier :: ~CircuitIdentifier ( ) {
	delete m_cic;
	delete m_group;
	delete m_carrier;
}

void CircuitIdentifier :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_cic ) ) {
		os << std :: setw ( indent + 6 ) << "cic = " << std :: setprecision ( indent );
		m_cic -> CicInfo :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_group ) ) {
		os << std :: setw ( indent + 8 ) << "group = " << std :: setprecision ( indent );
		m_group -> GroupID :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_carrier ) ) {
		os << std :: setw ( indent + 10 ) << "carrier = " << std :: setprecision ( indent );
		m_carrier -> CarrierInfo :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

CircuitIdentifier * CircuitIdentifier :: clone ( ) const {
	return new CircuitIdentifier ( * this );
}

//
// CarrierInfo
//

CarrierInfo :: CarrierInfo ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 0 ), m_carrierIdentificationCode ( 0 ), m_carrierName ( 0 ) {
	try {
		if ( hasOptionalField ( e_carrierIdentificationCode ) )
			m_carrierIdentificationCode = new CarrierInfo_carrierIdentificationCode ( is );
		if ( hasOptionalField ( e_carrierName ) )
			m_carrierName = new CarrierInfo_carrierName ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_carrierIdentificationCode;
		delete m_carrierName;
		throw;
	}
}

CarrierInfo :: CarrierInfo ( ) : Asn :: Sequence ( 2, true, 0 ), m_carrierIdentificationCode ( 0 ), m_carrierName ( 0 ) { }

CarrierInfo & CarrierInfo :: operator= ( const CarrierInfo & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_carrierIdentificationCode, s.m_carrierIdentificationCode );
	assignCopy ( m_carrierName, s.m_carrierName );
	return * this;
}

CarrierInfo :: CarrierInfo ( const CarrierInfo & s ) : Asn :: Sequence ( s ), m_carrierIdentificationCode ( 0 ), m_carrierName ( 0 ) {
	try {
		if ( s.m_carrierIdentificationCode )
			m_carrierIdentificationCode = new CarrierInfo_carrierIdentificationCode ( * s.m_carrierIdentificationCode );
		if ( s.m_carrierName )
			m_carrierName = new CarrierInfo_carrierName ( * s.m_carrierName );
	} catch ( ... ) {
		delete m_carrierIdentificationCode;
		delete m_carrierName;
		throw;
	}
}


void CarrierInfo :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_carrierIdentificationCode:
			assignNew ( m_carrierIdentificationCode, new CarrierInfo_carrierIdentificationCode );
			break;
		case e_carrierName:
			assignNew ( m_carrierName, new CarrierInfo_carrierName );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void CarrierInfo :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_carrierIdentificationCode:
			delete m_carrierIdentificationCode;
			m_carrierIdentificationCode = 0;
			break;
		case e_carrierName:
			delete m_carrierName;
			m_carrierName = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void CarrierInfo :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_carrierIdentificationCode ) )
		m_carrierIdentificationCode -> CarrierInfo_carrierIdentificationCode :: encode ( os );
	if ( hasOptionalField ( e_carrierName ) )
		m_carrierName -> CarrierInfo_carrierName :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

CarrierInfo :: ~CarrierInfo ( ) {
	delete m_carrierIdentificationCode;
	delete m_carrierName;
}

void CarrierInfo :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_carrierIdentificationCode ) ) {
		os << std :: setw ( indent + 28 ) << "carrierIdentificationCode = " << std :: setprecision ( indent );
		m_carrierIdentificationCode -> CarrierInfo_carrierIdentificationCode :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_carrierName ) ) {
		os << std :: setw ( indent + 14 ) << "carrierName = " << std :: setprecision ( indent );
		m_carrierName -> CarrierInfo_carrierName :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

CarrierInfo * CarrierInfo :: clone ( ) const {
	return new CarrierInfo ( * this );
}

//
// CallCreditCapability
//

CallCreditCapability :: CallCreditCapability ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 0 ), m_canDisplayAmountString ( 0 ), m_canEnforceDurationLimit ( 0 ) {
	try {
		if ( hasOptionalField ( e_canDisplayAmountString ) )
			m_canDisplayAmountString = new Asn :: Boolean ( is );
		if ( hasOptionalField ( e_canEnforceDurationLimit ) )
			m_canEnforceDurationLimit = new Asn :: Boolean ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_canDisplayAmountString;
		delete m_canEnforceDurationLimit;
		throw;
	}
}

CallCreditCapability :: CallCreditCapability ( ) : Asn :: Sequence ( 2, true, 0 ), m_canDisplayAmountString ( 0 ), m_canEnforceDurationLimit ( 0 ) { }

CallCreditCapability & CallCreditCapability :: operator= ( const CallCreditCapability & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_canDisplayAmountString, s.m_canDisplayAmountString );
	assignCopy ( m_canEnforceDurationLimit, s.m_canEnforceDurationLimit );
	return * this;
}

CallCreditCapability :: CallCreditCapability ( const CallCreditCapability & s ) : Asn :: Sequence ( s ), m_canDisplayAmountString ( 0 ), m_canEnforceDurationLimit ( 0 ) {
	try {
		if ( s.m_canDisplayAmountString )
			m_canDisplayAmountString = new Asn :: Boolean ( * s.m_canDisplayAmountString );
		if ( s.m_canEnforceDurationLimit )
			m_canEnforceDurationLimit = new Asn :: Boolean ( * s.m_canEnforceDurationLimit );
	} catch ( ... ) {
		delete m_canDisplayAmountString;
		delete m_canEnforceDurationLimit;
		throw;
	}
}


void CallCreditCapability :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_canDisplayAmountString:
			assignNew ( m_canDisplayAmountString, new Asn :: Boolean );
			break;
		case e_canEnforceDurationLimit:
			assignNew ( m_canEnforceDurationLimit, new Asn :: Boolean );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void CallCreditCapability :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_canDisplayAmountString:
			delete m_canDisplayAmountString;
			m_canDisplayAmountString = 0;
			break;
		case e_canEnforceDurationLimit:
			delete m_canEnforceDurationLimit;
			m_canEnforceDurationLimit = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void CallCreditCapability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_canDisplayAmountString ) )
		m_canDisplayAmountString -> Asn :: Boolean :: encode ( os );
	if ( hasOptionalField ( e_canEnforceDurationLimit ) )
		m_canEnforceDurationLimit -> Asn :: Boolean :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

CallCreditCapability :: ~CallCreditCapability ( ) {
	delete m_canDisplayAmountString;
	delete m_canEnforceDurationLimit;
}

void CallCreditCapability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_canDisplayAmountString ) ) {
		os << std :: setw ( indent + 25 ) << "canDisplayAmountString = " << std :: setprecision ( indent );
		m_canDisplayAmountString -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_canEnforceDurationLimit ) ) {
		os << std :: setw ( indent + 26 ) << "canEnforceDurationLimit = " << std :: setprecision ( indent );
		m_canEnforceDurationLimit -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

CallCreditCapability * CallCreditCapability :: clone ( ) const {
	return new CallCreditCapability ( * this );
}

//
// CallCreditServiceControl
//

CallCreditServiceControl :: CallCreditServiceControl ( Asn :: istream & is ) : Asn :: Sequence ( is, 5, true, 0 ), m_amountString ( 0 ), m_billingMode ( 0 ), m_callDurationLimit ( 0 ), m_enforceCallDurationLimit ( 0 ), m_callStartingPoint ( 0 ) {
	try {
		if ( hasOptionalField ( e_amountString ) )
			m_amountString = new CallCreditServiceControl_amountString ( is );
		if ( hasOptionalField ( e_billingMode ) )
			m_billingMode = new CallCreditServiceControl_billingMode ( is );
		if ( hasOptionalField ( e_callDurationLimit ) )
			m_callDurationLimit = new CallCreditServiceControl_callDurationLimit ( is );
		if ( hasOptionalField ( e_enforceCallDurationLimit ) )
			m_enforceCallDurationLimit = new Asn :: Boolean ( is );
		if ( hasOptionalField ( e_callStartingPoint ) )
			m_callStartingPoint = new CallCreditServiceControl_callStartingPoint ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_amountString;
		delete m_billingMode;
		delete m_callDurationLimit;
		delete m_enforceCallDurationLimit;
		delete m_callStartingPoint;
		throw;
	}
}

CallCreditServiceControl :: CallCreditServiceControl ( ) : Asn :: Sequence ( 5, true, 0 ), m_amountString ( 0 ), m_billingMode ( 0 ), m_callDurationLimit ( 0 ), m_enforceCallDurationLimit ( 0 ), m_callStartingPoint ( 0 ) { }

CallCreditServiceControl & CallCreditServiceControl :: operator= ( const CallCreditServiceControl & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_amountString, s.m_amountString );
	assignCopy ( m_billingMode, s.m_billingMode );
	assignCopy ( m_callDurationLimit, s.m_callDurationLimit );
	assignCopy ( m_enforceCallDurationLimit, s.m_enforceCallDurationLimit );
	assignCopy ( m_callStartingPoint, s.m_callStartingPoint );
	return * this;
}

CallCreditServiceControl :: CallCreditServiceControl ( const CallCreditServiceControl & s ) : Asn :: Sequence ( s ), m_amountString ( 0 ), m_billingMode ( 0 ), m_callDurationLimit ( 0 ), m_enforceCallDurationLimit ( 0 ), m_callStartingPoint ( 0 ) {
	try {
		if ( s.m_amountString )
			m_amountString = new CallCreditServiceControl_amountString ( * s.m_amountString );
		if ( s.m_billingMode )
			m_billingMode = new CallCreditServiceControl_billingMode ( * s.m_billingMode );
		if ( s.m_callDurationLimit )
			m_callDurationLimit = new CallCreditServiceControl_callDurationLimit ( * s.m_callDurationLimit );
		if ( s.m_enforceCallDurationLimit )
			m_enforceCallDurationLimit = new Asn :: Boolean ( * s.m_enforceCallDurationLimit );
		if ( s.m_callStartingPoint )
			m_callStartingPoint = new CallCreditServiceControl_callStartingPoint ( * s.m_callStartingPoint );
	} catch ( ... ) {
		delete m_amountString;
		delete m_billingMode;
		delete m_callDurationLimit;
		delete m_enforceCallDurationLimit;
		delete m_callStartingPoint;
		throw;
	}
}


void CallCreditServiceControl :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_amountString:
			assignNew ( m_amountString, new CallCreditServiceControl_amountString );
			break;
		case e_billingMode:
			assignNew ( m_billingMode, new CallCreditServiceControl_billingMode );
			break;
		case e_callDurationLimit:
			assignNew ( m_callDurationLimit, new CallCreditServiceControl_callDurationLimit );
			break;
		case e_enforceCallDurationLimit:
			assignNew ( m_enforceCallDurationLimit, new Asn :: Boolean );
			break;
		case e_callStartingPoint:
			assignNew ( m_callStartingPoint, new CallCreditServiceControl_callStartingPoint );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void CallCreditServiceControl :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_amountString:
			delete m_amountString;
			m_amountString = 0;
			break;
		case e_billingMode:
			delete m_billingMode;
			m_billingMode = 0;
			break;
		case e_callDurationLimit:
			delete m_callDurationLimit;
			m_callDurationLimit = 0;
			break;
		case e_enforceCallDurationLimit:
			delete m_enforceCallDurationLimit;
			m_enforceCallDurationLimit = 0;
			break;
		case e_callStartingPoint:
			delete m_callStartingPoint;
			m_callStartingPoint = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void CallCreditServiceControl :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_amountString ) )
		m_amountString -> CallCreditServiceControl_amountString :: encode ( os );
	if ( hasOptionalField ( e_billingMode ) )
		m_billingMode -> CallCreditServiceControl_billingMode :: encode ( os );
	if ( hasOptionalField ( e_callDurationLimit ) )
		m_callDurationLimit -> CallCreditServiceControl_callDurationLimit :: encode ( os );
	if ( hasOptionalField ( e_enforceCallDurationLimit ) )
		m_enforceCallDurationLimit -> Asn :: Boolean :: encode ( os );
	if ( hasOptionalField ( e_callStartingPoint ) )
		m_callStartingPoint -> CallCreditServiceControl_callStartingPoint :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

CallCreditServiceControl :: ~CallCreditServiceControl ( ) {
	delete m_amountString;
	delete m_billingMode;
	delete m_callDurationLimit;
	delete m_enforceCallDurationLimit;
	delete m_callStartingPoint;
}

void CallCreditServiceControl :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_amountString ) ) {
		os << std :: setw ( indent + 15 ) << "amountString = " << std :: setprecision ( indent );
		m_amountString -> CallCreditServiceControl_amountString :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_billingMode ) ) {
		os << std :: setw ( indent + 14 ) << "billingMode = " << std :: setprecision ( indent );
		m_billingMode -> CallCreditServiceControl_billingMode :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_callDurationLimit ) ) {
		os << std :: setw ( indent + 20 ) << "callDurationLimit = " << std :: setprecision ( indent );
		m_callDurationLimit -> CallCreditServiceControl_callDurationLimit :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_enforceCallDurationLimit ) ) {
		os << std :: setw ( indent + 27 ) << "enforceCallDurationLimit = " << std :: setprecision ( indent );
		m_enforceCallDurationLimit -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_callStartingPoint ) ) {
		os << std :: setw ( indent + 20 ) << "callStartingPoint = " << std :: setprecision ( indent );
		m_callStartingPoint -> CallCreditServiceControl_callStartingPoint :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

CallCreditServiceControl * CallCreditServiceControl :: clone ( ) const {
	return new CallCreditServiceControl ( * this );
}

//
// FeatureSet
//

FeatureSet :: FeatureSet ( Asn :: istream & is ) : Asn :: Sequence ( is, 3, true, 0 ), m_replacementFeatureSet ( is ), m_neededFeatures ( 0 ), m_desiredFeatures ( 0 ), m_supportedFeatures ( 0 ) {
	try {
		if ( hasOptionalField ( e_neededFeatures ) )
			m_neededFeatures = new ArrayOf_FeatureDescriptor ( is );
		if ( hasOptionalField ( e_desiredFeatures ) )
			m_desiredFeatures = new ArrayOf_FeatureDescriptor ( is );
		if ( hasOptionalField ( e_supportedFeatures ) )
			m_supportedFeatures = new ArrayOf_FeatureDescriptor ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_neededFeatures;
		delete m_desiredFeatures;
		delete m_supportedFeatures;
		throw;
	}
}

FeatureSet :: FeatureSet ( ) : Asn :: Sequence ( 3, true, 0 ), m_neededFeatures ( 0 ), m_desiredFeatures ( 0 ), m_supportedFeatures ( 0 ) { }

FeatureSet & FeatureSet :: operator= ( const FeatureSet & s ) {
	Asn :: Sequence :: operator= ( s );
	m_replacementFeatureSet = s.m_replacementFeatureSet;
	assignCopy ( m_neededFeatures, s.m_neededFeatures );
	assignCopy ( m_desiredFeatures, s.m_desiredFeatures );
	assignCopy ( m_supportedFeatures, s.m_supportedFeatures );
	return * this;
}

FeatureSet :: FeatureSet ( const FeatureSet & s ) : Asn :: Sequence ( s ), m_replacementFeatureSet ( s.m_replacementFeatureSet ), m_neededFeatures ( 0 ), m_desiredFeatures ( 0 ), m_supportedFeatures ( 0 ) {
	try {
		if ( s.m_neededFeatures )
			m_neededFeatures = new ArrayOf_FeatureDescriptor ( * s.m_neededFeatures );
		if ( s.m_desiredFeatures )
			m_desiredFeatures = new ArrayOf_FeatureDescriptor ( * s.m_desiredFeatures );
		if ( s.m_supportedFeatures )
			m_supportedFeatures = new ArrayOf_FeatureDescriptor ( * s.m_supportedFeatures );
	} catch ( ... ) {
		delete m_neededFeatures;
		delete m_desiredFeatures;
		delete m_supportedFeatures;
		throw;
	}
}


void FeatureSet :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_neededFeatures:
			assignNew ( m_neededFeatures, new ArrayOf_FeatureDescriptor );
			break;
		case e_desiredFeatures:
			assignNew ( m_desiredFeatures, new ArrayOf_FeatureDescriptor );
			break;
		case e_supportedFeatures:
			assignNew ( m_supportedFeatures, new ArrayOf_FeatureDescriptor );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void FeatureSet :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_neededFeatures:
			delete m_neededFeatures;
			m_neededFeatures = 0;
			break;
		case e_desiredFeatures:
			delete m_desiredFeatures;
			m_desiredFeatures = 0;
			break;
		case e_supportedFeatures:
			delete m_supportedFeatures;
			m_supportedFeatures = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void FeatureSet :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_replacementFeatureSet.encode ( os );
	if ( hasOptionalField ( e_neededFeatures ) )
		m_neededFeatures -> ArrayOf_FeatureDescriptor :: encode ( os );
	if ( hasOptionalField ( e_desiredFeatures ) )
		m_desiredFeatures -> ArrayOf_FeatureDescriptor :: encode ( os );
	if ( hasOptionalField ( e_supportedFeatures ) )
		m_supportedFeatures -> ArrayOf_FeatureDescriptor :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

FeatureSet :: ~FeatureSet ( ) {
	delete m_neededFeatures;
	delete m_desiredFeatures;
	delete m_supportedFeatures;
}

void FeatureSet :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 24 ) << "replacementFeatureSet = " << std :: setprecision ( indent ) << m_replacementFeatureSet << '\n';
	if ( hasOptionalField ( e_neededFeatures ) ) {
		os << std :: setw ( indent + 17 ) << "neededFeatures = " << std :: setprecision ( indent );
		m_neededFeatures -> ArrayOf_FeatureDescriptor :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_desiredFeatures ) ) {
		os << std :: setw ( indent + 18 ) << "desiredFeatures = " << std :: setprecision ( indent );
		m_desiredFeatures -> ArrayOf_FeatureDescriptor :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_supportedFeatures ) ) {
		os << std :: setw ( indent + 20 ) << "supportedFeatures = " << std :: setprecision ( indent );
		m_supportedFeatures -> ArrayOf_FeatureDescriptor :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

FeatureSet * FeatureSet :: clone ( ) const {
	return new FeatureSet ( * this );
}

//
// TransportChannelInfo
//

TransportChannelInfo :: TransportChannelInfo ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 0 ), m_sendAddress ( 0 ), m_recvAddress ( 0 ) {
	try {
		if ( hasOptionalField ( e_sendAddress ) )
			m_sendAddress = new TransportAddress ( is );
		if ( hasOptionalField ( e_recvAddress ) )
			m_recvAddress = new TransportAddress ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_sendAddress;
		delete m_recvAddress;
		throw;
	}
}

TransportChannelInfo :: TransportChannelInfo ( ) : Asn :: Sequence ( 2, true, 0 ), m_sendAddress ( 0 ), m_recvAddress ( 0 ) { }

TransportChannelInfo & TransportChannelInfo :: operator= ( const TransportChannelInfo & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_sendAddress, s.m_sendAddress );
	assignCopy ( m_recvAddress, s.m_recvAddress );
	return * this;
}

TransportChannelInfo :: TransportChannelInfo ( const TransportChannelInfo & s ) : Asn :: Sequence ( s ), m_sendAddress ( 0 ), m_recvAddress ( 0 ) {
	try {
		if ( s.m_sendAddress )
			m_sendAddress = new TransportAddress ( * s.m_sendAddress );
		if ( s.m_recvAddress )
			m_recvAddress = new TransportAddress ( * s.m_recvAddress );
	} catch ( ... ) {
		delete m_sendAddress;
		delete m_recvAddress;
		throw;
	}
}


void TransportChannelInfo :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_sendAddress:
			assignNew ( m_sendAddress, new TransportAddress );
			break;
		case e_recvAddress:
			assignNew ( m_recvAddress, new TransportAddress );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void TransportChannelInfo :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_sendAddress:
			delete m_sendAddress;
			m_sendAddress = 0;
			break;
		case e_recvAddress:
			delete m_recvAddress;
			m_recvAddress = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void TransportChannelInfo :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_sendAddress ) )
		m_sendAddress -> TransportAddress :: encode ( os );
	if ( hasOptionalField ( e_recvAddress ) )
		m_recvAddress -> TransportAddress :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

TransportChannelInfo :: ~TransportChannelInfo ( ) {
	delete m_sendAddress;
	delete m_recvAddress;
}

void TransportChannelInfo :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_sendAddress ) ) {
		os << std :: setw ( indent + 14 ) << "sendAddress = " << std :: setprecision ( indent );
		m_sendAddress -> TransportAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_recvAddress ) ) {
		os << std :: setw ( indent + 14 ) << "recvAddress = " << std :: setprecision ( indent );
		m_recvAddress -> TransportAddress :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

TransportChannelInfo * TransportChannelInfo :: clone ( ) const {
	return new TransportChannelInfo ( * this );
}

//
// RehomingModel
//

RehomingModel :: RehomingModel ( Asn :: istream & is ) : Asn :: Choice ( is, 2, false ) {
	switch ( tag ) {
		case e_gatekeeperBased:
		case e_endpointBased:
			choice = new Asn :: Null ( is );
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
}

RehomingModel :: RehomingModel ( ) : Asn :: Choice ( 2, false ) { }

void RehomingModel :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_gatekeeperBased:
		case e_endpointBased:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & RehomingModel :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_gatekeeperBased, "gatekeeperBased" },
		{ e_endpointBased, "endpointBased" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

RehomingModel * RehomingModel :: clone ( ) const {
	return new RehomingModel ( * this );
}

//
// GatekeeperRejectReason
//

GatekeeperRejectReason :: GatekeeperRejectReason ( Asn :: istream & is ) : Asn :: Choice ( is, 4, true ) {
	switch ( tag ) {
		case e_resourceUnavailable:
		case e_terminalExcluded:
		case e_invalidRevision:
		case e_undefinedReason:
		case e_securityDenial:
		case e_genericDataReason:
		case e_neededFeatureNotSupported:
			choice = new Asn :: Null ( is );
			break;
		case e_securityError:
			choice = new SecurityErrors ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

GatekeeperRejectReason :: GatekeeperRejectReason ( ) : Asn :: Choice ( 4, true ) { }

void GatekeeperRejectReason :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_resourceUnavailable:
		case e_terminalExcluded:
		case e_invalidRevision:
		case e_undefinedReason:
		case e_securityDenial:
		case e_genericDataReason:
		case e_neededFeatureNotSupported:
			o = new Asn :: Null;
			break;
		case e_securityError:
			o = new SecurityErrors;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & GatekeeperRejectReason :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_resourceUnavailable, "resourceUnavailable" },
		{ e_terminalExcluded, "terminalExcluded" },
		{ e_invalidRevision, "invalidRevision" },
		{ e_undefinedReason, "undefinedReason" },
		{ e_securityDenial, "securityDenial" },
		{ e_genericDataReason, "genericDataReason" },
		{ e_neededFeatureNotSupported, "neededFeatureNotSupported" },
		{ e_securityError, "securityError" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

GatekeeperRejectReason * GatekeeperRejectReason :: clone ( ) const {
	return new GatekeeperRejectReason ( * this );
}

//
// UnregRequestReason
//

UnregRequestReason :: UnregRequestReason ( Asn :: istream & is ) : Asn :: Choice ( is, 4, true ) {
	switch ( tag ) {
		case e_reregistrationRequired:
		case e_ttlExpired:
		case e_securityDenial:
		case e_undefinedReason:
		case e_maintenance:
		case e_registerWithAssignedGK:
			choice = new Asn :: Null ( is );
			break;
		case e_securityError:
			choice = new SecurityErrors2 ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

UnregRequestReason :: UnregRequestReason ( ) : Asn :: Choice ( 4, true ) { }

void UnregRequestReason :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_reregistrationRequired:
		case e_ttlExpired:
		case e_securityDenial:
		case e_undefinedReason:
		case e_maintenance:
		case e_registerWithAssignedGK:
			o = new Asn :: Null;
			break;
		case e_securityError:
			o = new SecurityErrors2;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & UnregRequestReason :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_reregistrationRequired, "reregistrationRequired" },
		{ e_ttlExpired, "ttlExpired" },
		{ e_securityDenial, "securityDenial" },
		{ e_undefinedReason, "undefinedReason" },
		{ e_maintenance, "maintenance" },
		{ e_securityError, "securityError" },
		{ e_registerWithAssignedGK, "registerWithAssignedGK" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

UnregRequestReason * UnregRequestReason :: clone ( ) const {
	return new UnregRequestReason ( * this );
}

//
// UnregistrationConfirm
//

UnregistrationConfirm :: UnregistrationConfirm ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 5 ), m_requestSeqNum ( is ), m_nonStandardData ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_genericData ( 0 ), m_assignedGatekeeper ( 0 ) {
	try {
		if ( hasOptionalField ( e_nonStandardData ) )
			m_nonStandardData = new NonStandardParameter ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_tokens ) )
				m_tokens = new ArrayOf_ClearToken ( is );
			if ( hasKnownExtensionToDecode ( is, e_cryptoTokens ) )
				m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
			if ( hasKnownExtensionToDecode ( is, e_integrityCheckValue ) )
				m_integrityCheckValue = new ICV ( is );
			if ( hasKnownExtensionToDecode ( is, e_genericData ) )
				m_genericData = new ArrayOf_GenericData ( is );
			if ( hasKnownExtensionToDecode ( is, e_assignedGatekeeper ) )
				m_assignedGatekeeper = new AlternateGK ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_genericData;
		delete m_assignedGatekeeper;
		throw;
	}
}

UnregistrationConfirm :: UnregistrationConfirm ( ) : Asn :: Sequence ( 1, true, 5 ), m_nonStandardData ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_genericData ( 0 ), m_assignedGatekeeper ( 0 ) { }

UnregistrationConfirm & UnregistrationConfirm :: operator= ( const UnregistrationConfirm & s ) {
	Asn :: Sequence :: operator= ( s );
	m_requestSeqNum = s.m_requestSeqNum;
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_integrityCheckValue, s.m_integrityCheckValue );
	assignCopy ( m_genericData, s.m_genericData );
	assignCopy ( m_assignedGatekeeper, s.m_assignedGatekeeper );
	return * this;
}

UnregistrationConfirm :: UnregistrationConfirm ( const UnregistrationConfirm & s ) : Asn :: Sequence ( s ), m_requestSeqNum ( s.m_requestSeqNum ), m_nonStandardData ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_genericData ( 0 ), m_assignedGatekeeper ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_integrityCheckValue )
			m_integrityCheckValue = new ICV ( * s.m_integrityCheckValue );
		if ( s.m_genericData )
			m_genericData = new ArrayOf_GenericData ( * s.m_genericData );
		if ( s.m_assignedGatekeeper )
			m_assignedGatekeeper = new AlternateGK ( * s.m_assignedGatekeeper );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_genericData;
		delete m_assignedGatekeeper;
		throw;
	}
}


void UnregistrationConfirm :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_integrityCheckValue:
			assignNew ( m_integrityCheckValue, new ICV );
			break;
		case e_genericData:
			assignNew ( m_genericData, new ArrayOf_GenericData );
			break;
		case e_assignedGatekeeper:
			assignNew ( m_assignedGatekeeper, new AlternateGK );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void UnregistrationConfirm :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_integrityCheckValue:
			delete m_integrityCheckValue;
			m_integrityCheckValue = 0;
			break;
		case e_genericData:
			delete m_genericData;
			m_genericData = 0;
			break;
		case e_assignedGatekeeper:
			delete m_assignedGatekeeper;
			m_assignedGatekeeper = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void UnregistrationConfirm :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_requestSeqNum.encode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_tokens, m_tokens );
		knownExtensionEncode ( os, e_cryptoTokens, m_cryptoTokens );
		knownExtensionEncode ( os, e_integrityCheckValue, m_integrityCheckValue );
		knownExtensionEncode ( os, e_genericData, m_genericData );
		knownExtensionEncode ( os, e_assignedGatekeeper, m_assignedGatekeeper );
		unknownExtensionsEncode ( os );
	}
}

UnregistrationConfirm :: ~UnregistrationConfirm ( ) {
	delete m_nonStandardData;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_integrityCheckValue;
	delete m_genericData;
	delete m_assignedGatekeeper;
}

void UnregistrationConfirm :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "requestSeqNum = " << std :: setprecision ( indent ) << m_requestSeqNum << '\n';
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_integrityCheckValue ) ) {
		os << std :: setw ( indent + 22 ) << "integrityCheckValue = " << std :: setprecision ( indent );
		m_integrityCheckValue -> ICV :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_genericData ) ) {
		os << std :: setw ( indent + 14 ) << "genericData = " << std :: setprecision ( indent );
		m_genericData -> ArrayOf_GenericData :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_assignedGatekeeper ) ) {
		os << std :: setw ( indent + 21 ) << "assignedGatekeeper = " << std :: setprecision ( indent );
		m_assignedGatekeeper -> AlternateGK :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

UnregistrationConfirm * UnregistrationConfirm :: clone ( ) const {
	return new UnregistrationConfirm ( * this );
}

//
// UnregRejectReason
//

UnregRejectReason :: UnregRejectReason ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_notCurrentlyRegistered:
		case e_callInProgress:
		case e_undefinedReason:
		case e_permissionDenied:
		case e_securityDenial:
			choice = new Asn :: Null ( is );
			break;
		case e_securityError:
			choice = new SecurityErrors2 ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

UnregRejectReason :: UnregRejectReason ( ) : Asn :: Choice ( 3, true ) { }

void UnregRejectReason :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_notCurrentlyRegistered:
		case e_callInProgress:
		case e_undefinedReason:
		case e_permissionDenied:
		case e_securityDenial:
			o = new Asn :: Null;
			break;
		case e_securityError:
			o = new SecurityErrors2;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & UnregRejectReason :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_notCurrentlyRegistered, "notCurrentlyRegistered" },
		{ e_callInProgress, "callInProgress" },
		{ e_undefinedReason, "undefinedReason" },
		{ e_permissionDenied, "permissionDenied" },
		{ e_securityDenial, "securityDenial" },
		{ e_securityError, "securityError" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

UnregRejectReason * UnregRejectReason :: clone ( ) const {
	return new UnregRejectReason ( * this );
}

//
// CallType
//

CallType :: CallType ( Asn :: istream & is ) : Asn :: Choice ( is, 4, true ) {
	switch ( tag ) {
		case e_pointToPoint:
		case e_oneToN:
		case e_nToOne:
		case e_nToN:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

CallType :: CallType ( ) : Asn :: Choice ( 4, true ) { }

void CallType :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_pointToPoint:
		case e_oneToN:
		case e_nToOne:
		case e_nToN:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & CallType :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_pointToPoint, "pointToPoint" },
		{ e_oneToN, "oneToN" },
		{ e_nToOne, "nToOne" },
		{ e_nToN, "nToN" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

CallType * CallType :: clone ( ) const {
	return new CallType ( * this );
}

//
// CallModel
//

CallModel :: CallModel ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_direct:
		case e_gatekeeperRouted:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

CallModel :: CallModel ( ) : Asn :: Choice ( 2, true ) { }

void CallModel :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_direct:
		case e_gatekeeperRouted:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & CallModel :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_direct, "direct" },
		{ e_gatekeeperRouted, "gatekeeperRouted" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

CallModel * CallModel :: clone ( ) const {
	return new CallModel ( * this );
}

//
// UUIEsRequested
//

UUIEsRequested :: UUIEsRequested ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 4 ), m_setup ( is ), m_callProceeding ( is ), m_connect ( is ), m_alerting ( is ), m_information ( is ), m_releaseComplete ( is ), m_facility ( is ), m_progress ( is ), m_empty ( is ), m_status ( 0 ), m_statusInquiry ( 0 ), m_setupAcknowledge ( 0 ), m_notify ( 0 ) {
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_status ) )
				m_status = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_statusInquiry ) )
				m_statusInquiry = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_setupAcknowledge ) )
				m_setupAcknowledge = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_notify ) )
				m_notify = new Asn :: Boolean ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_status;
		delete m_statusInquiry;
		delete m_setupAcknowledge;
		delete m_notify;
		throw;
	}
}

UUIEsRequested :: UUIEsRequested ( ) : Asn :: Sequence ( 0, true, 4 ), m_status ( 0 ), m_statusInquiry ( 0 ), m_setupAcknowledge ( 0 ), m_notify ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_status );
		m_status = new Asn :: Boolean;
		Asn :: Sequence :: includeOptionalField ( e_statusInquiry );
		m_statusInquiry = new Asn :: Boolean;
		Asn :: Sequence :: includeOptionalField ( e_setupAcknowledge );
		m_setupAcknowledge = new Asn :: Boolean;
		Asn :: Sequence :: includeOptionalField ( e_notify );
		m_notify = new Asn :: Boolean;
	} catch ( ... ) {
		delete m_status;
		delete m_statusInquiry;
		delete m_setupAcknowledge;
		delete m_notify;
		throw;
	}
}

UUIEsRequested & UUIEsRequested :: operator= ( const UUIEsRequested & s ) {
	Asn :: Sequence :: operator= ( s );
	m_setup = s.m_setup;
	m_callProceeding = s.m_callProceeding;
	m_connect = s.m_connect;
	m_alerting = s.m_alerting;
	m_information = s.m_information;
	m_releaseComplete = s.m_releaseComplete;
	m_facility = s.m_facility;
	m_progress = s.m_progress;
	m_empty = s.m_empty;
	assignCopy ( m_status, s.m_status );
	assignCopy ( m_statusInquiry, s.m_statusInquiry );
	assignCopy ( m_setupAcknowledge, s.m_setupAcknowledge );
	assignCopy ( m_notify, s.m_notify );
	return * this;
}

UUIEsRequested :: UUIEsRequested ( const UUIEsRequested & s ) : Asn :: Sequence ( s ), m_setup ( s.m_setup ), m_callProceeding ( s.m_callProceeding ), m_connect ( s.m_connect ), m_alerting ( s.m_alerting ), m_information ( s.m_information ), m_releaseComplete ( s.m_releaseComplete ), m_facility ( s.m_facility ), m_progress ( s.m_progress ), m_empty ( s.m_empty ), m_status ( 0 ), m_statusInquiry ( 0 ), m_setupAcknowledge ( 0 ), m_notify ( 0 ) {
	try {
		if ( s.m_status )
			m_status = new Asn :: Boolean ( * s.m_status );
		if ( s.m_statusInquiry )
			m_statusInquiry = new Asn :: Boolean ( * s.m_statusInquiry );
		if ( s.m_setupAcknowledge )
			m_setupAcknowledge = new Asn :: Boolean ( * s.m_setupAcknowledge );
		if ( s.m_notify )
			m_notify = new Asn :: Boolean ( * s.m_notify );
	} catch ( ... ) {
		delete m_status;
		delete m_statusInquiry;
		delete m_setupAcknowledge;
		delete m_notify;
		throw;
	}
}


void UUIEsRequested :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_status:
			assignNew ( m_status, new Asn :: Boolean );
			break;
		case e_statusInquiry:
			assignNew ( m_statusInquiry, new Asn :: Boolean );
			break;
		case e_setupAcknowledge:
			assignNew ( m_setupAcknowledge, new Asn :: Boolean );
			break;
		case e_notify:
			assignNew ( m_notify, new Asn :: Boolean );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void UUIEsRequested :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_status:
			delete m_status;
			m_status = 0;
			break;
		case e_statusInquiry:
			delete m_statusInquiry;
			m_statusInquiry = 0;
			break;
		case e_setupAcknowledge:
			delete m_setupAcknowledge;
			m_setupAcknowledge = 0;
			break;
		case e_notify:
			delete m_notify;
			m_notify = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void UUIEsRequested :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_setup.encode ( os );
	m_callProceeding.encode ( os );
	m_connect.encode ( os );
	m_alerting.encode ( os );
	m_information.encode ( os );
	m_releaseComplete.encode ( os );
	m_facility.encode ( os );
	m_progress.encode ( os );
	m_empty.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_status, m_status );
		knownExtensionEncode ( os, e_statusInquiry, m_statusInquiry );
		knownExtensionEncode ( os, e_setupAcknowledge, m_setupAcknowledge );
		knownExtensionEncode ( os, e_notify, m_notify );
		unknownExtensionsEncode ( os );
	}
}

UUIEsRequested :: ~UUIEsRequested ( ) {
	delete m_status;
	delete m_statusInquiry;
	delete m_setupAcknowledge;
	delete m_notify;
}

void UUIEsRequested :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 8 ) << "setup = " << std :: setprecision ( indent ) << m_setup << '\n';
	os << std :: setw ( indent + 17 ) << "callProceeding = " << std :: setprecision ( indent ) << m_callProceeding << '\n';
	os << std :: setw ( indent + 10 ) << "connect = " << std :: setprecision ( indent ) << m_connect << '\n';
	os << std :: setw ( indent + 11 ) << "alerting = " << std :: setprecision ( indent ) << m_alerting << '\n';
	os << std :: setw ( indent + 14 ) << "information = " << std :: setprecision ( indent ) << m_information << '\n';
	os << std :: setw ( indent + 18 ) << "releaseComplete = " << std :: setprecision ( indent ) << m_releaseComplete << '\n';
	os << std :: setw ( indent + 11 ) << "facility = " << std :: setprecision ( indent ) << m_facility << '\n';
	os << std :: setw ( indent + 11 ) << "progress = " << std :: setprecision ( indent ) << m_progress << '\n';
	os << std :: setw ( indent + 8 ) << "empty = " << std :: setprecision ( indent ) << m_empty << '\n';
	if ( hasOptionalField ( e_status ) ) {
		os << std :: setw ( indent + 9 ) << "status = " << std :: setprecision ( indent );
		m_status -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_statusInquiry ) ) {
		os << std :: setw ( indent + 16 ) << "statusInquiry = " << std :: setprecision ( indent );
		m_statusInquiry -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_setupAcknowledge ) ) {
		os << std :: setw ( indent + 19 ) << "setupAcknowledge = " << std :: setprecision ( indent );
		m_setupAcknowledge -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_notify ) ) {
		os << std :: setw ( indent + 9 ) << "notify = " << std :: setprecision ( indent );
		m_notify -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

UUIEsRequested * UUIEsRequested :: clone ( ) const {
	return new UUIEsRequested ( * this );
}

//
// BandwidthRequest
//

BandwidthRequest :: BandwidthRequest ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 12 ), m_requestSeqNum ( is ), m_endpointIdentifier ( is ), m_conferenceID ( is ), m_callReferenceValue ( is ), m_callType ( hasOptionalField ( e_callType ) ? pushTemporaryMember ( new CallType ( is ) ) : 0 ), m_bandWidth ( is ), m_nonStandardData ( 0 ), m_callIdentifier ( 0 ), m_gatekeeperIdentifier ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_answeredCall ( 0 ), m_callLinkage ( 0 ), m_capacity ( 0 ), m_usageInformation ( 0 ), m_bandwidthDetails ( 0 ), m_genericData ( 0 ), m_transportQOS ( 0 ) {
	clearTemporaryMembers ( );
	try {
		if ( hasOptionalField ( e_nonStandardData ) )
			m_nonStandardData = new NonStandardParameter ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_callIdentifier ) )
				m_callIdentifier = new CallIdentifier ( is );
			if ( hasKnownExtensionToDecode ( is, e_gatekeeperIdentifier ) )
				m_gatekeeperIdentifier = new GatekeeperIdentifier ( is );
			if ( hasKnownExtensionToDecode ( is, e_tokens ) )
				m_tokens = new ArrayOf_ClearToken ( is );
			if ( hasKnownExtensionToDecode ( is, e_cryptoTokens ) )
				m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
			if ( hasKnownExtensionToDecode ( is, e_integrityCheckValue ) )
				m_integrityCheckValue = new ICV ( is );
			if ( hasKnownExtensionToDecode ( is, e_answeredCall ) )
				m_answeredCall = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_callLinkage ) )
				m_callLinkage = new CallLinkage ( is );
			if ( hasKnownExtensionToDecode ( is, e_capacity ) )
				m_capacity = new CallCapacity ( is );
			if ( hasKnownExtensionToDecode ( is, e_usageInformation ) )
				m_usageInformation = new RasUsageInformation ( is );
			if ( hasKnownExtensionToDecode ( is, e_bandwidthDetails ) )
				m_bandwidthDetails = new ArrayOf_BandwidthDetails ( is );
			if ( hasKnownExtensionToDecode ( is, e_genericData ) )
				m_genericData = new ArrayOf_GenericData ( is );
			if ( hasKnownExtensionToDecode ( is, e_transportQOS ) )
				m_transportQOS = new TransportQOS ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_callType;
		delete m_nonStandardData;
		delete m_callIdentifier;
		delete m_gatekeeperIdentifier;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_answeredCall;
		delete m_callLinkage;
		delete m_capacity;
		delete m_usageInformation;
		delete m_bandwidthDetails;
		delete m_genericData;
		delete m_transportQOS;
		throw;
	}
}

BandwidthRequest :: BandwidthRequest ( ) : Asn :: Sequence ( 2, true, 12 ), m_callType ( 0 ), m_nonStandardData ( 0 ), m_callIdentifier ( 0 ), m_gatekeeperIdentifier ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_answeredCall ( 0 ), m_callLinkage ( 0 ), m_capacity ( 0 ), m_usageInformation ( 0 ), m_bandwidthDetails ( 0 ), m_genericData ( 0 ), m_transportQOS ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_callIdentifier );
		m_callIdentifier = new CallIdentifier;
		Asn :: Sequence :: includeOptionalField ( e_answeredCall );
		m_answeredCall = new Asn :: Boolean;
	} catch ( ... ) {
		delete m_callIdentifier;
		delete m_answeredCall;
		throw;
	}
}

BandwidthRequest & BandwidthRequest :: operator= ( const BandwidthRequest & s ) {
	Asn :: Sequence :: operator= ( s );
	m_requestSeqNum = s.m_requestSeqNum;
	m_endpointIdentifier = s.m_endpointIdentifier;
	m_conferenceID = s.m_conferenceID;
	m_callReferenceValue = s.m_callReferenceValue;
	assignCopy ( m_callType, s.m_callType );
	m_bandWidth = s.m_bandWidth;
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	assignCopy ( m_callIdentifier, s.m_callIdentifier );
	assignCopy ( m_gatekeeperIdentifier, s.m_gatekeeperIdentifier );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_integrityCheckValue, s.m_integrityCheckValue );
	assignCopy ( m_answeredCall, s.m_answeredCall );
	assignCopy ( m_callLinkage, s.m_callLinkage );
	assignCopy ( m_capacity, s.m_capacity );
	assignCopy ( m_usageInformation, s.m_usageInformation );
	assignCopy ( m_bandwidthDetails, s.m_bandwidthDetails );
	assignCopy ( m_genericData, s.m_genericData );
	assignCopy ( m_transportQOS, s.m_transportQOS );
	return * this;
}

BandwidthRequest :: BandwidthRequest ( const BandwidthRequest & s ) : Asn :: Sequence ( s ), m_requestSeqNum ( s.m_requestSeqNum ), m_endpointIdentifier ( s.m_endpointIdentifier ), m_conferenceID ( s.m_conferenceID ), m_callReferenceValue ( s.m_callReferenceValue ), m_callType ( 0 ), m_bandWidth ( s.m_bandWidth ), m_nonStandardData ( 0 ), m_callIdentifier ( 0 ), m_gatekeeperIdentifier ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_answeredCall ( 0 ), m_callLinkage ( 0 ), m_capacity ( 0 ), m_usageInformation ( 0 ), m_bandwidthDetails ( 0 ), m_genericData ( 0 ), m_transportQOS ( 0 ) {
	try {
		if ( s.m_callType )
			m_callType = new CallType ( * s.m_callType );
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_callIdentifier )
			m_callIdentifier = new CallIdentifier ( * s.m_callIdentifier );
		if ( s.m_gatekeeperIdentifier )
			m_gatekeeperIdentifier = new GatekeeperIdentifier ( * s.m_gatekeeperIdentifier );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_integrityCheckValue )
			m_integrityCheckValue = new ICV ( * s.m_integrityCheckValue );
		if ( s.m_answeredCall )
			m_answeredCall = new Asn :: Boolean ( * s.m_answeredCall );
		if ( s.m_callLinkage )
			m_callLinkage = new CallLinkage ( * s.m_callLinkage );
		if ( s.m_capacity )
			m_capacity = new CallCapacity ( * s.m_capacity );
		if ( s.m_usageInformation )
			m_usageInformation = new RasUsageInformation ( * s.m_usageInformation );
		if ( s.m_bandwidthDetails )
			m_bandwidthDetails = new ArrayOf_BandwidthDetails ( * s.m_bandwidthDetails );
		if ( s.m_genericData )
			m_genericData = new ArrayOf_GenericData ( * s.m_genericData );
		if ( s.m_transportQOS )
			m_transportQOS = new TransportQOS ( * s.m_transportQOS );
	} catch ( ... ) {
		delete m_callType;
		delete m_nonStandardData;
		delete m_callIdentifier;
		delete m_gatekeeperIdentifier;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_answeredCall;
		delete m_callLinkage;
		delete m_capacity;
		delete m_usageInformation;
		delete m_bandwidthDetails;
		delete m_genericData;
		delete m_transportQOS;
		throw;
	}
}


void BandwidthRequest :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_callType:
			assignNew ( m_callType, new CallType );
			break;
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_callIdentifier:
			assignNew ( m_callIdentifier, new CallIdentifier );
			break;
		case e_gatekeeperIdentifier:
			assignNew ( m_gatekeeperIdentifier, new GatekeeperIdentifier );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_integrityCheckValue:
			assignNew ( m_integrityCheckValue, new ICV );
			break;
		case e_answeredCall:
			assignNew ( m_answeredCall, new Asn :: Boolean );
			break;
		case e_callLinkage:
			assignNew ( m_callLinkage, new CallLinkage );
			break;
		case e_capacity:
			assignNew ( m_capacity, new CallCapacity );
			break;
		case e_usageInformation:
			assignNew ( m_usageInformation, new RasUsageInformation );
			break;
		case e_bandwidthDetails:
			assignNew ( m_bandwidthDetails, new ArrayOf_BandwidthDetails );
			break;
		case e_genericData:
			assignNew ( m_genericData, new ArrayOf_GenericData );
			break;
		case e_transportQOS:
			assignNew ( m_transportQOS, new TransportQOS );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void BandwidthRequest :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_callType:
			delete m_callType;
			m_callType = 0;
			break;
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_callIdentifier:
			delete m_callIdentifier;
			m_callIdentifier = 0;
			break;
		case e_gatekeeperIdentifier:
			delete m_gatekeeperIdentifier;
			m_gatekeeperIdentifier = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_integrityCheckValue:
			delete m_integrityCheckValue;
			m_integrityCheckValue = 0;
			break;
		case e_answeredCall:
			delete m_answeredCall;
			m_answeredCall = 0;
			break;
		case e_callLinkage:
			delete m_callLinkage;
			m_callLinkage = 0;
			break;
		case e_capacity:
			delete m_capacity;
			m_capacity = 0;
			break;
		case e_usageInformation:
			delete m_usageInformation;
			m_usageInformation = 0;
			break;
		case e_bandwidthDetails:
			delete m_bandwidthDetails;
			m_bandwidthDetails = 0;
			break;
		case e_genericData:
			delete m_genericData;
			m_genericData = 0;
			break;
		case e_transportQOS:
			delete m_transportQOS;
			m_transportQOS = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void BandwidthRequest :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_requestSeqNum.encode ( os );
	m_endpointIdentifier.encode ( os );
	m_conferenceID.encode ( os );
	m_callReferenceValue.encode ( os );
	if ( hasOptionalField ( e_callType ) )
		m_callType -> CallType :: encode ( os );
	m_bandWidth.encode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_callIdentifier, m_callIdentifier );
		knownExtensionEncode ( os, e_gatekeeperIdentifier, m_gatekeeperIdentifier );
		knownExtensionEncode ( os, e_tokens, m_tokens );
		knownExtensionEncode ( os, e_cryptoTokens, m_cryptoTokens );
		knownExtensionEncode ( os, e_integrityCheckValue, m_integrityCheckValue );
		knownExtensionEncode ( os, e_answeredCall, m_answeredCall );
		knownExtensionEncode ( os, e_callLinkage, m_callLinkage );
		knownExtensionEncode ( os, e_capacity, m_capacity );
		knownExtensionEncode ( os, e_usageInformation, m_usageInformation );
		knownExtensionEncode ( os, e_bandwidthDetails, m_bandwidthDetails );
		knownExtensionEncode ( os, e_genericData, m_genericData );
		knownExtensionEncode ( os, e_transportQOS, m_transportQOS );
		unknownExtensionsEncode ( os );
	}
}

BandwidthRequest :: ~BandwidthRequest ( ) {
	delete m_callType;
	delete m_nonStandardData;
	delete m_callIdentifier;
	delete m_gatekeeperIdentifier;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_integrityCheckValue;
	delete m_answeredCall;
	delete m_callLinkage;
	delete m_capacity;
	delete m_usageInformation;
	delete m_bandwidthDetails;
	delete m_genericData;
	delete m_transportQOS;
}

void BandwidthRequest :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "requestSeqNum = " << std :: setprecision ( indent ) << m_requestSeqNum << '\n';
	os << std :: setw ( indent + 21 ) << "endpointIdentifier = " << std :: setprecision ( indent ) << m_endpointIdentifier << '\n';
	os << std :: setw ( indent + 15 ) << "conferenceID = " << std :: setprecision ( indent ) << m_conferenceID << '\n';
	os << std :: setw ( indent + 21 ) << "callReferenceValue = " << std :: setprecision ( indent ) << m_callReferenceValue << '\n';
	if ( hasOptionalField ( e_callType ) ) {
		os << std :: setw ( indent + 11 ) << "callType = " << std :: setprecision ( indent );
		m_callType -> CallType :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 12 ) << "bandWidth = " << std :: setprecision ( indent ) << m_bandWidth << '\n';
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_callIdentifier ) ) {
		os << std :: setw ( indent + 17 ) << "callIdentifier = " << std :: setprecision ( indent );
		m_callIdentifier -> CallIdentifier :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_gatekeeperIdentifier ) ) {
		os << std :: setw ( indent + 23 ) << "gatekeeperIdentifier = " << std :: setprecision ( indent );
		m_gatekeeperIdentifier -> GatekeeperIdentifier :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_integrityCheckValue ) ) {
		os << std :: setw ( indent + 22 ) << "integrityCheckValue = " << std :: setprecision ( indent );
		m_integrityCheckValue -> ICV :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_answeredCall ) ) {
		os << std :: setw ( indent + 15 ) << "answeredCall = " << std :: setprecision ( indent );
		m_answeredCall -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_callLinkage ) ) {
		os << std :: setw ( indent + 14 ) << "callLinkage = " << std :: setprecision ( indent );
		m_callLinkage -> CallLinkage :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_capacity ) ) {
		os << std :: setw ( indent + 11 ) << "capacity = " << std :: setprecision ( indent );
		m_capacity -> CallCapacity :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_usageInformation ) ) {
		os << std :: setw ( indent + 19 ) << "usageInformation = " << std :: setprecision ( indent );
		m_usageInformation -> RasUsageInformation :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_bandwidthDetails ) ) {
		os << std :: setw ( indent + 19 ) << "bandwidthDetails = " << std :: setprecision ( indent );
		m_bandwidthDetails -> ArrayOf_BandwidthDetails :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_genericData ) ) {
		os << std :: setw ( indent + 14 ) << "genericData = " << std :: setprecision ( indent );
		m_genericData -> ArrayOf_GenericData :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_transportQOS ) ) {
		os << std :: setw ( indent + 15 ) << "transportQOS = " << std :: setprecision ( indent );
		m_transportQOS -> TransportQOS :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

BandwidthRequest * BandwidthRequest :: clone ( ) const {
	return new BandwidthRequest ( * this );
}

//
// BandwidthConfirm
//

BandwidthConfirm :: BandwidthConfirm ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 6 ), m_requestSeqNum ( is ), m_bandWidth ( is ), m_nonStandardData ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_capacity ( 0 ), m_genericData ( 0 ), m_transportQOS ( 0 ) {
	try {
		if ( hasOptionalField ( e_nonStandardData ) )
			m_nonStandardData = new NonStandardParameter ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_tokens ) )
				m_tokens = new ArrayOf_ClearToken ( is );
			if ( hasKnownExtensionToDecode ( is, e_cryptoTokens ) )
				m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
			if ( hasKnownExtensionToDecode ( is, e_integrityCheckValue ) )
				m_integrityCheckValue = new ICV ( is );
			if ( hasKnownExtensionToDecode ( is, e_capacity ) )
				m_capacity = new CallCapacity ( is );
			if ( hasKnownExtensionToDecode ( is, e_genericData ) )
				m_genericData = new ArrayOf_GenericData ( is );
			if ( hasKnownExtensionToDecode ( is, e_transportQOS ) )
				m_transportQOS = new TransportQOS ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_capacity;
		delete m_genericData;
		delete m_transportQOS;
		throw;
	}
}

BandwidthConfirm :: BandwidthConfirm ( ) : Asn :: Sequence ( 1, true, 6 ), m_nonStandardData ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_capacity ( 0 ), m_genericData ( 0 ), m_transportQOS ( 0 ) { }

BandwidthConfirm & BandwidthConfirm :: operator= ( const BandwidthConfirm & s ) {
	Asn :: Sequence :: operator= ( s );
	m_requestSeqNum = s.m_requestSeqNum;
	m_bandWidth = s.m_bandWidth;
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_integrityCheckValue, s.m_integrityCheckValue );
	assignCopy ( m_capacity, s.m_capacity );
	assignCopy ( m_genericData, s.m_genericData );
	assignCopy ( m_transportQOS, s.m_transportQOS );
	return * this;
}

BandwidthConfirm :: BandwidthConfirm ( const BandwidthConfirm & s ) : Asn :: Sequence ( s ), m_requestSeqNum ( s.m_requestSeqNum ), m_bandWidth ( s.m_bandWidth ), m_nonStandardData ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_capacity ( 0 ), m_genericData ( 0 ), m_transportQOS ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_integrityCheckValue )
			m_integrityCheckValue = new ICV ( * s.m_integrityCheckValue );
		if ( s.m_capacity )
			m_capacity = new CallCapacity ( * s.m_capacity );
		if ( s.m_genericData )
			m_genericData = new ArrayOf_GenericData ( * s.m_genericData );
		if ( s.m_transportQOS )
			m_transportQOS = new TransportQOS ( * s.m_transportQOS );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_capacity;
		delete m_genericData;
		delete m_transportQOS;
		throw;
	}
}


void BandwidthConfirm :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_integrityCheckValue:
			assignNew ( m_integrityCheckValue, new ICV );
			break;
		case e_capacity:
			assignNew ( m_capacity, new CallCapacity );
			break;
		case e_genericData:
			assignNew ( m_genericData, new ArrayOf_GenericData );
			break;
		case e_transportQOS:
			assignNew ( m_transportQOS, new TransportQOS );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void BandwidthConfirm :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_integrityCheckValue:
			delete m_integrityCheckValue;
			m_integrityCheckValue = 0;
			break;
		case e_capacity:
			delete m_capacity;
			m_capacity = 0;
			break;
		case e_genericData:
			delete m_genericData;
			m_genericData = 0;
			break;
		case e_transportQOS:
			delete m_transportQOS;
			m_transportQOS = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void BandwidthConfirm :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_requestSeqNum.encode ( os );
	m_bandWidth.encode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_tokens, m_tokens );
		knownExtensionEncode ( os, e_cryptoTokens, m_cryptoTokens );
		knownExtensionEncode ( os, e_integrityCheckValue, m_integrityCheckValue );
		knownExtensionEncode ( os, e_capacity, m_capacity );
		knownExtensionEncode ( os, e_genericData, m_genericData );
		knownExtensionEncode ( os, e_transportQOS, m_transportQOS );
		unknownExtensionsEncode ( os );
	}
}

BandwidthConfirm :: ~BandwidthConfirm ( ) {
	delete m_nonStandardData;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_integrityCheckValue;
	delete m_capacity;
	delete m_genericData;
	delete m_transportQOS;
}

void BandwidthConfirm :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "requestSeqNum = " << std :: setprecision ( indent ) << m_requestSeqNum << '\n';
	os << std :: setw ( indent + 12 ) << "bandWidth = " << std :: setprecision ( indent ) << m_bandWidth << '\n';
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_integrityCheckValue ) ) {
		os << std :: setw ( indent + 22 ) << "integrityCheckValue = " << std :: setprecision ( indent );
		m_integrityCheckValue -> ICV :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_capacity ) ) {
		os << std :: setw ( indent + 11 ) << "capacity = " << std :: setprecision ( indent );
		m_capacity -> CallCapacity :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_genericData ) ) {
		os << std :: setw ( indent + 14 ) << "genericData = " << std :: setprecision ( indent );
		m_genericData -> ArrayOf_GenericData :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_transportQOS ) ) {
		os << std :: setw ( indent + 15 ) << "transportQOS = " << std :: setprecision ( indent );
		m_transportQOS -> TransportQOS :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

BandwidthConfirm * BandwidthConfirm :: clone ( ) const {
	return new BandwidthConfirm ( * this );
}

//
// BandRejectReason
//

BandRejectReason :: BandRejectReason ( Asn :: istream & is ) : Asn :: Choice ( is, 6, true ) {
	switch ( tag ) {
		case e_notBound:
		case e_invalidConferenceID:
		case e_invalidPermission:
		case e_insufficientResources:
		case e_invalidRevision:
		case e_undefinedReason:
		case e_securityDenial:
			choice = new Asn :: Null ( is );
			break;
		case e_securityError:
			choice = new SecurityErrors2 ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

BandRejectReason :: BandRejectReason ( ) : Asn :: Choice ( 6, true ) { }

void BandRejectReason :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_notBound:
		case e_invalidConferenceID:
		case e_invalidPermission:
		case e_insufficientResources:
		case e_invalidRevision:
		case e_undefinedReason:
		case e_securityDenial:
			o = new Asn :: Null;
			break;
		case e_securityError:
			o = new SecurityErrors2;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & BandRejectReason :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_notBound, "notBound" },
		{ e_invalidConferenceID, "invalidConferenceID" },
		{ e_invalidPermission, "invalidPermission" },
		{ e_insufficientResources, "insufficientResources" },
		{ e_invalidRevision, "invalidRevision" },
		{ e_undefinedReason, "undefinedReason" },
		{ e_securityDenial, "securityDenial" },
		{ e_securityError, "securityError" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

BandRejectReason * BandRejectReason :: clone ( ) const {
	return new BandRejectReason ( * this );
}

//
// DisengageReason
//

DisengageReason :: DisengageReason ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_forcedDrop:
		case e_normalDrop:
		case e_undefinedReason:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

DisengageReason :: DisengageReason ( ) : Asn :: Choice ( 3, true ) { }

void DisengageReason :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_forcedDrop:
		case e_normalDrop:
		case e_undefinedReason:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & DisengageReason :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_forcedDrop, "forcedDrop" },
		{ e_normalDrop, "normalDrop" },
		{ e_undefinedReason, "undefinedReason" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

DisengageReason * DisengageReason :: clone ( ) const {
	return new DisengageReason ( * this );
}

//
// DisengageConfirm
//

DisengageConfirm :: DisengageConfirm ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 8 ), m_requestSeqNum ( is ), m_nonStandardData ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_capacity ( 0 ), m_circuitInfo ( 0 ), m_usageInformation ( 0 ), m_genericData ( 0 ), m_assignedGatekeeper ( 0 ) {
	try {
		if ( hasOptionalField ( e_nonStandardData ) )
			m_nonStandardData = new NonStandardParameter ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_tokens ) )
				m_tokens = new ArrayOf_ClearToken ( is );
			if ( hasKnownExtensionToDecode ( is, e_cryptoTokens ) )
				m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
			if ( hasKnownExtensionToDecode ( is, e_integrityCheckValue ) )
				m_integrityCheckValue = new ICV ( is );
			if ( hasKnownExtensionToDecode ( is, e_capacity ) )
				m_capacity = new CallCapacity ( is );
			if ( hasKnownExtensionToDecode ( is, e_circuitInfo ) )
				m_circuitInfo = new CircuitInfo ( is );
			if ( hasKnownExtensionToDecode ( is, e_usageInformation ) )
				m_usageInformation = new RasUsageInformation ( is );
			if ( hasKnownExtensionToDecode ( is, e_genericData ) )
				m_genericData = new ArrayOf_GenericData ( is );
			if ( hasKnownExtensionToDecode ( is, e_assignedGatekeeper ) )
				m_assignedGatekeeper = new AlternateGK ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_capacity;
		delete m_circuitInfo;
		delete m_usageInformation;
		delete m_genericData;
		delete m_assignedGatekeeper;
		throw;
	}
}

DisengageConfirm :: DisengageConfirm ( ) : Asn :: Sequence ( 1, true, 8 ), m_nonStandardData ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_capacity ( 0 ), m_circuitInfo ( 0 ), m_usageInformation ( 0 ), m_genericData ( 0 ), m_assignedGatekeeper ( 0 ) { }

DisengageConfirm & DisengageConfirm :: operator= ( const DisengageConfirm & s ) {
	Asn :: Sequence :: operator= ( s );
	m_requestSeqNum = s.m_requestSeqNum;
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_integrityCheckValue, s.m_integrityCheckValue );
	assignCopy ( m_capacity, s.m_capacity );
	assignCopy ( m_circuitInfo, s.m_circuitInfo );
	assignCopy ( m_usageInformation, s.m_usageInformation );
	assignCopy ( m_genericData, s.m_genericData );
	assignCopy ( m_assignedGatekeeper, s.m_assignedGatekeeper );
	return * this;
}

DisengageConfirm :: DisengageConfirm ( const DisengageConfirm & s ) : Asn :: Sequence ( s ), m_requestSeqNum ( s.m_requestSeqNum ), m_nonStandardData ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_capacity ( 0 ), m_circuitInfo ( 0 ), m_usageInformation ( 0 ), m_genericData ( 0 ), m_assignedGatekeeper ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_integrityCheckValue )
			m_integrityCheckValue = new ICV ( * s.m_integrityCheckValue );
		if ( s.m_capacity )
			m_capacity = new CallCapacity ( * s.m_capacity );
		if ( s.m_circuitInfo )
			m_circuitInfo = new CircuitInfo ( * s.m_circuitInfo );
		if ( s.m_usageInformation )
			m_usageInformation = new RasUsageInformation ( * s.m_usageInformation );
		if ( s.m_genericData )
			m_genericData = new ArrayOf_GenericData ( * s.m_genericData );
		if ( s.m_assignedGatekeeper )
			m_assignedGatekeeper = new AlternateGK ( * s.m_assignedGatekeeper );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_capacity;
		delete m_circuitInfo;
		delete m_usageInformation;
		delete m_genericData;
		delete m_assignedGatekeeper;
		throw;
	}
}


void DisengageConfirm :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_integrityCheckValue:
			assignNew ( m_integrityCheckValue, new ICV );
			break;
		case e_capacity:
			assignNew ( m_capacity, new CallCapacity );
			break;
		case e_circuitInfo:
			assignNew ( m_circuitInfo, new CircuitInfo );
			break;
		case e_usageInformation:
			assignNew ( m_usageInformation, new RasUsageInformation );
			break;
		case e_genericData:
			assignNew ( m_genericData, new ArrayOf_GenericData );
			break;
		case e_assignedGatekeeper:
			assignNew ( m_assignedGatekeeper, new AlternateGK );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void DisengageConfirm :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_integrityCheckValue:
			delete m_integrityCheckValue;
			m_integrityCheckValue = 0;
			break;
		case e_capacity:
			delete m_capacity;
			m_capacity = 0;
			break;
		case e_circuitInfo:
			delete m_circuitInfo;
			m_circuitInfo = 0;
			break;
		case e_usageInformation:
			delete m_usageInformation;
			m_usageInformation = 0;
			break;
		case e_genericData:
			delete m_genericData;
			m_genericData = 0;
			break;
		case e_assignedGatekeeper:
			delete m_assignedGatekeeper;
			m_assignedGatekeeper = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void DisengageConfirm :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_requestSeqNum.encode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_tokens, m_tokens );
		knownExtensionEncode ( os, e_cryptoTokens, m_cryptoTokens );
		knownExtensionEncode ( os, e_integrityCheckValue, m_integrityCheckValue );
		knownExtensionEncode ( os, e_capacity, m_capacity );
		knownExtensionEncode ( os, e_circuitInfo, m_circuitInfo );
		knownExtensionEncode ( os, e_usageInformation, m_usageInformation );
		knownExtensionEncode ( os, e_genericData, m_genericData );
		knownExtensionEncode ( os, e_assignedGatekeeper, m_assignedGatekeeper );
		unknownExtensionsEncode ( os );
	}
}

DisengageConfirm :: ~DisengageConfirm ( ) {
	delete m_nonStandardData;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_integrityCheckValue;
	delete m_capacity;
	delete m_circuitInfo;
	delete m_usageInformation;
	delete m_genericData;
	delete m_assignedGatekeeper;
}

void DisengageConfirm :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "requestSeqNum = " << std :: setprecision ( indent ) << m_requestSeqNum << '\n';
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_integrityCheckValue ) ) {
		os << std :: setw ( indent + 22 ) << "integrityCheckValue = " << std :: setprecision ( indent );
		m_integrityCheckValue -> ICV :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_capacity ) ) {
		os << std :: setw ( indent + 11 ) << "capacity = " << std :: setprecision ( indent );
		m_capacity -> CallCapacity :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_circuitInfo ) ) {
		os << std :: setw ( indent + 14 ) << "circuitInfo = " << std :: setprecision ( indent );
		m_circuitInfo -> CircuitInfo :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_usageInformation ) ) {
		os << std :: setw ( indent + 19 ) << "usageInformation = " << std :: setprecision ( indent );
		m_usageInformation -> RasUsageInformation :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_genericData ) ) {
		os << std :: setw ( indent + 14 ) << "genericData = " << std :: setprecision ( indent );
		m_genericData -> ArrayOf_GenericData :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_assignedGatekeeper ) ) {
		os << std :: setw ( indent + 21 ) << "assignedGatekeeper = " << std :: setprecision ( indent );
		m_assignedGatekeeper -> AlternateGK :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

DisengageConfirm * DisengageConfirm :: clone ( ) const {
	return new DisengageConfirm ( * this );
}

//
// DisengageRejectReason
//

DisengageRejectReason :: DisengageRejectReason ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_notRegistered:
		case e_requestToDropOther:
		case e_securityDenial:
			choice = new Asn :: Null ( is );
			break;
		case e_securityError:
			choice = new SecurityErrors2 ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

DisengageRejectReason :: DisengageRejectReason ( ) : Asn :: Choice ( 2, true ) { }

void DisengageRejectReason :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_notRegistered:
		case e_requestToDropOther:
		case e_securityDenial:
			o = new Asn :: Null;
			break;
		case e_securityError:
			o = new SecurityErrors2;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & DisengageRejectReason :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_notRegistered, "notRegistered" },
		{ e_requestToDropOther, "requestToDropOther" },
		{ e_securityDenial, "securityDenial" },
		{ e_securityError, "securityError" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

DisengageRejectReason * DisengageRejectReason :: clone ( ) const {
	return new DisengageRejectReason ( * this );
}

//
// InfoRequest
//

InfoRequest :: InfoRequest ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 12 ), m_requestSeqNum ( is ), m_callReferenceValue ( is ), m_nonStandardData ( 0 ), m_replyAddress ( 0 ), m_callIdentifier ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_uuiesRequested ( 0 ), m_callLinkage ( 0 ), m_usageInfoRequested ( 0 ), m_segmentedResponseSupported ( 0 ), m_nextSegmentRequested ( 0 ), m_capacityInfoRequested ( 0 ), m_genericData ( 0 ), m_assignedGatekeeper ( 0 ) {
	try {
		if ( hasOptionalField ( e_nonStandardData ) )
			m_nonStandardData = new NonStandardParameter ( is );
		if ( hasOptionalField ( e_replyAddress ) )
			m_replyAddress = new TransportAddress ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_callIdentifier ) )
				m_callIdentifier = new CallIdentifier ( is );
			if ( hasKnownExtensionToDecode ( is, e_tokens ) )
				m_tokens = new ArrayOf_ClearToken ( is );
			if ( hasKnownExtensionToDecode ( is, e_cryptoTokens ) )
				m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
			if ( hasKnownExtensionToDecode ( is, e_integrityCheckValue ) )
				m_integrityCheckValue = new ICV ( is );
			if ( hasKnownExtensionToDecode ( is, e_uuiesRequested ) )
				m_uuiesRequested = new UUIEsRequested ( is );
			if ( hasKnownExtensionToDecode ( is, e_callLinkage ) )
				m_callLinkage = new CallLinkage ( is );
			if ( hasKnownExtensionToDecode ( is, e_usageInfoRequested ) )
				m_usageInfoRequested = new RasUsageInfoTypes ( is );
			if ( hasKnownExtensionToDecode ( is, e_segmentedResponseSupported ) )
				m_segmentedResponseSupported = new Asn :: Null ( is );
			if ( hasKnownExtensionToDecode ( is, e_nextSegmentRequested ) )
				m_nextSegmentRequested = new InfoRequest_nextSegmentRequested ( is );
			if ( hasKnownExtensionToDecode ( is, e_capacityInfoRequested ) )
				m_capacityInfoRequested = new Asn :: Null ( is );
			if ( hasKnownExtensionToDecode ( is, e_genericData ) )
				m_genericData = new ArrayOf_GenericData ( is );
			if ( hasKnownExtensionToDecode ( is, e_assignedGatekeeper ) )
				m_assignedGatekeeper = new AlternateGK ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_replyAddress;
		delete m_callIdentifier;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_uuiesRequested;
		delete m_callLinkage;
		delete m_usageInfoRequested;
		delete m_segmentedResponseSupported;
		delete m_nextSegmentRequested;
		delete m_capacityInfoRequested;
		delete m_genericData;
		delete m_assignedGatekeeper;
		throw;
	}
}

InfoRequest :: InfoRequest ( ) : Asn :: Sequence ( 2, true, 12 ), m_nonStandardData ( 0 ), m_replyAddress ( 0 ), m_callIdentifier ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_uuiesRequested ( 0 ), m_callLinkage ( 0 ), m_usageInfoRequested ( 0 ), m_segmentedResponseSupported ( 0 ), m_nextSegmentRequested ( 0 ), m_capacityInfoRequested ( 0 ), m_genericData ( 0 ), m_assignedGatekeeper ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_callIdentifier );
		m_callIdentifier = new CallIdentifier;
	} catch ( ... ) {
		delete m_callIdentifier;
		throw;
	}
}

InfoRequest & InfoRequest :: operator= ( const InfoRequest & s ) {
	Asn :: Sequence :: operator= ( s );
	m_requestSeqNum = s.m_requestSeqNum;
	m_callReferenceValue = s.m_callReferenceValue;
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	assignCopy ( m_replyAddress, s.m_replyAddress );
	assignCopy ( m_callIdentifier, s.m_callIdentifier );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_integrityCheckValue, s.m_integrityCheckValue );
	assignCopy ( m_uuiesRequested, s.m_uuiesRequested );
	assignCopy ( m_callLinkage, s.m_callLinkage );
	assignCopy ( m_usageInfoRequested, s.m_usageInfoRequested );
	assignCopy ( m_segmentedResponseSupported, s.m_segmentedResponseSupported );
	assignCopy ( m_nextSegmentRequested, s.m_nextSegmentRequested );
	assignCopy ( m_capacityInfoRequested, s.m_capacityInfoRequested );
	assignCopy ( m_genericData, s.m_genericData );
	assignCopy ( m_assignedGatekeeper, s.m_assignedGatekeeper );
	return * this;
}

InfoRequest :: InfoRequest ( const InfoRequest & s ) : Asn :: Sequence ( s ), m_requestSeqNum ( s.m_requestSeqNum ), m_callReferenceValue ( s.m_callReferenceValue ), m_nonStandardData ( 0 ), m_replyAddress ( 0 ), m_callIdentifier ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_uuiesRequested ( 0 ), m_callLinkage ( 0 ), m_usageInfoRequested ( 0 ), m_segmentedResponseSupported ( 0 ), m_nextSegmentRequested ( 0 ), m_capacityInfoRequested ( 0 ), m_genericData ( 0 ), m_assignedGatekeeper ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_replyAddress )
			m_replyAddress = new TransportAddress ( * s.m_replyAddress );
		if ( s.m_callIdentifier )
			m_callIdentifier = new CallIdentifier ( * s.m_callIdentifier );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_integrityCheckValue )
			m_integrityCheckValue = new ICV ( * s.m_integrityCheckValue );
		if ( s.m_uuiesRequested )
			m_uuiesRequested = new UUIEsRequested ( * s.m_uuiesRequested );
		if ( s.m_callLinkage )
			m_callLinkage = new CallLinkage ( * s.m_callLinkage );
		if ( s.m_usageInfoRequested )
			m_usageInfoRequested = new RasUsageInfoTypes ( * s.m_usageInfoRequested );
		if ( s.m_segmentedResponseSupported )
			m_segmentedResponseSupported = new Asn :: Null ( * s.m_segmentedResponseSupported );
		if ( s.m_nextSegmentRequested )
			m_nextSegmentRequested = new InfoRequest_nextSegmentRequested ( * s.m_nextSegmentRequested );
		if ( s.m_capacityInfoRequested )
			m_capacityInfoRequested = new Asn :: Null ( * s.m_capacityInfoRequested );
		if ( s.m_genericData )
			m_genericData = new ArrayOf_GenericData ( * s.m_genericData );
		if ( s.m_assignedGatekeeper )
			m_assignedGatekeeper = new AlternateGK ( * s.m_assignedGatekeeper );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_replyAddress;
		delete m_callIdentifier;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_uuiesRequested;
		delete m_callLinkage;
		delete m_usageInfoRequested;
		delete m_segmentedResponseSupported;
		delete m_nextSegmentRequested;
		delete m_capacityInfoRequested;
		delete m_genericData;
		delete m_assignedGatekeeper;
		throw;
	}
}


void InfoRequest :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_replyAddress:
			assignNew ( m_replyAddress, new TransportAddress );
			break;
		case e_callIdentifier:
			assignNew ( m_callIdentifier, new CallIdentifier );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_integrityCheckValue:
			assignNew ( m_integrityCheckValue, new ICV );
			break;
		case e_uuiesRequested:
			assignNew ( m_uuiesRequested, new UUIEsRequested );
			break;
		case e_callLinkage:
			assignNew ( m_callLinkage, new CallLinkage );
			break;
		case e_usageInfoRequested:
			assignNew ( m_usageInfoRequested, new RasUsageInfoTypes );
			break;
		case e_segmentedResponseSupported:
			assignNew ( m_segmentedResponseSupported, new Asn :: Null );
			break;
		case e_nextSegmentRequested:
			assignNew ( m_nextSegmentRequested, new InfoRequest_nextSegmentRequested );
			break;
		case e_capacityInfoRequested:
			assignNew ( m_capacityInfoRequested, new Asn :: Null );
			break;
		case e_genericData:
			assignNew ( m_genericData, new ArrayOf_GenericData );
			break;
		case e_assignedGatekeeper:
			assignNew ( m_assignedGatekeeper, new AlternateGK );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void InfoRequest :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_replyAddress:
			delete m_replyAddress;
			m_replyAddress = 0;
			break;
		case e_callIdentifier:
			delete m_callIdentifier;
			m_callIdentifier = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_integrityCheckValue:
			delete m_integrityCheckValue;
			m_integrityCheckValue = 0;
			break;
		case e_uuiesRequested:
			delete m_uuiesRequested;
			m_uuiesRequested = 0;
			break;
		case e_callLinkage:
			delete m_callLinkage;
			m_callLinkage = 0;
			break;
		case e_usageInfoRequested:
			delete m_usageInfoRequested;
			m_usageInfoRequested = 0;
			break;
		case e_segmentedResponseSupported:
			delete m_segmentedResponseSupported;
			m_segmentedResponseSupported = 0;
			break;
		case e_nextSegmentRequested:
			delete m_nextSegmentRequested;
			m_nextSegmentRequested = 0;
			break;
		case e_capacityInfoRequested:
			delete m_capacityInfoRequested;
			m_capacityInfoRequested = 0;
			break;
		case e_genericData:
			delete m_genericData;
			m_genericData = 0;
			break;
		case e_assignedGatekeeper:
			delete m_assignedGatekeeper;
			m_assignedGatekeeper = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void InfoRequest :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_requestSeqNum.encode ( os );
	m_callReferenceValue.encode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( hasOptionalField ( e_replyAddress ) )
		m_replyAddress -> TransportAddress :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_callIdentifier, m_callIdentifier );
		knownExtensionEncode ( os, e_tokens, m_tokens );
		knownExtensionEncode ( os, e_cryptoTokens, m_cryptoTokens );
		knownExtensionEncode ( os, e_integrityCheckValue, m_integrityCheckValue );
		knownExtensionEncode ( os, e_uuiesRequested, m_uuiesRequested );
		knownExtensionEncode ( os, e_callLinkage, m_callLinkage );
		knownExtensionEncode ( os, e_usageInfoRequested, m_usageInfoRequested );
		knownExtensionEncode ( os, e_segmentedResponseSupported, m_segmentedResponseSupported );
		knownExtensionEncode ( os, e_nextSegmentRequested, m_nextSegmentRequested );
		knownExtensionEncode ( os, e_capacityInfoRequested, m_capacityInfoRequested );
		knownExtensionEncode ( os, e_genericData, m_genericData );
		knownExtensionEncode ( os, e_assignedGatekeeper, m_assignedGatekeeper );
		unknownExtensionsEncode ( os );
	}
}

InfoRequest :: ~InfoRequest ( ) {
	delete m_nonStandardData;
	delete m_replyAddress;
	delete m_callIdentifier;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_integrityCheckValue;
	delete m_uuiesRequested;
	delete m_callLinkage;
	delete m_usageInfoRequested;
	delete m_segmentedResponseSupported;
	delete m_nextSegmentRequested;
	delete m_capacityInfoRequested;
	delete m_genericData;
	delete m_assignedGatekeeper;
}

void InfoRequest :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "requestSeqNum = " << std :: setprecision ( indent ) << m_requestSeqNum << '\n';
	os << std :: setw ( indent + 21 ) << "callReferenceValue = " << std :: setprecision ( indent ) << m_callReferenceValue << '\n';
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_replyAddress ) ) {
		os << std :: setw ( indent + 15 ) << "replyAddress = " << std :: setprecision ( indent );
		m_replyAddress -> TransportAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_callIdentifier ) ) {
		os << std :: setw ( indent + 17 ) << "callIdentifier = " << std :: setprecision ( indent );
		m_callIdentifier -> CallIdentifier :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_integrityCheckValue ) ) {
		os << std :: setw ( indent + 22 ) << "integrityCheckValue = " << std :: setprecision ( indent );
		m_integrityCheckValue -> ICV :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_uuiesRequested ) ) {
		os << std :: setw ( indent + 17 ) << "uuiesRequested = " << std :: setprecision ( indent );
		m_uuiesRequested -> UUIEsRequested :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_callLinkage ) ) {
		os << std :: setw ( indent + 14 ) << "callLinkage = " << std :: setprecision ( indent );
		m_callLinkage -> CallLinkage :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_usageInfoRequested ) ) {
		os << std :: setw ( indent + 21 ) << "usageInfoRequested = " << std :: setprecision ( indent );
		m_usageInfoRequested -> RasUsageInfoTypes :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_segmentedResponseSupported ) ) {
		os << std :: setw ( indent + 29 ) << "segmentedResponseSupported = " << std :: setprecision ( indent );
		m_segmentedResponseSupported -> Asn :: Null :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_nextSegmentRequested ) ) {
		os << std :: setw ( indent + 23 ) << "nextSegmentRequested = " << std :: setprecision ( indent );
		m_nextSegmentRequested -> InfoRequest_nextSegmentRequested :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_capacityInfoRequested ) ) {
		os << std :: setw ( indent + 24 ) << "capacityInfoRequested = " << std :: setprecision ( indent );
		m_capacityInfoRequested -> Asn :: Null :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_genericData ) ) {
		os << std :: setw ( indent + 14 ) << "genericData = " << std :: setprecision ( indent );
		m_genericData -> ArrayOf_GenericData :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_assignedGatekeeper ) ) {
		os << std :: setw ( indent + 21 ) << "assignedGatekeeper = " << std :: setprecision ( indent );
		m_assignedGatekeeper -> AlternateGK :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

InfoRequest * InfoRequest :: clone ( ) const {
	return new InfoRequest ( * this );
}

//
// InfoRequestAck
//

InfoRequestAck :: InfoRequestAck ( Asn :: istream & is ) : Asn :: Sequence ( is, 4, true, 0 ), m_requestSeqNum ( is ), m_nonStandardData ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ) {
	try {
		if ( hasOptionalField ( e_nonStandardData ) )
			m_nonStandardData = new NonStandardParameter ( is );
		if ( hasOptionalField ( e_tokens ) )
			m_tokens = new ArrayOf_ClearToken ( is );
		if ( hasOptionalField ( e_cryptoTokens ) )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
		if ( hasOptionalField ( e_integrityCheckValue ) )
			m_integrityCheckValue = new ICV ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		throw;
	}
}

InfoRequestAck :: InfoRequestAck ( ) : Asn :: Sequence ( 4, true, 0 ), m_nonStandardData ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ) { }

InfoRequestAck & InfoRequestAck :: operator= ( const InfoRequestAck & s ) {
	Asn :: Sequence :: operator= ( s );
	m_requestSeqNum = s.m_requestSeqNum;
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_integrityCheckValue, s.m_integrityCheckValue );
	return * this;
}

InfoRequestAck :: InfoRequestAck ( const InfoRequestAck & s ) : Asn :: Sequence ( s ), m_requestSeqNum ( s.m_requestSeqNum ), m_nonStandardData ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_integrityCheckValue )
			m_integrityCheckValue = new ICV ( * s.m_integrityCheckValue );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		throw;
	}
}


void InfoRequestAck :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_integrityCheckValue:
			assignNew ( m_integrityCheckValue, new ICV );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void InfoRequestAck :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_integrityCheckValue:
			delete m_integrityCheckValue;
			m_integrityCheckValue = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void InfoRequestAck :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_requestSeqNum.encode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( hasOptionalField ( e_tokens ) )
		m_tokens -> ArrayOf_ClearToken :: encode ( os );
	if ( hasOptionalField ( e_cryptoTokens ) )
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: encode ( os );
	if ( hasOptionalField ( e_integrityCheckValue ) )
		m_integrityCheckValue -> ICV :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

InfoRequestAck :: ~InfoRequestAck ( ) {
	delete m_nonStandardData;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_integrityCheckValue;
}

void InfoRequestAck :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "requestSeqNum = " << std :: setprecision ( indent ) << m_requestSeqNum << '\n';
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_integrityCheckValue ) ) {
		os << std :: setw ( indent + 22 ) << "integrityCheckValue = " << std :: setprecision ( indent );
		m_integrityCheckValue -> ICV :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

InfoRequestAck * InfoRequestAck :: clone ( ) const {
	return new InfoRequestAck ( * this );
}

//
// InfoRequestNakReason
//

InfoRequestNakReason :: InfoRequestNakReason ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_notRegistered:
		case e_securityDenial:
		case e_undefinedReason:
			choice = new Asn :: Null ( is );
			break;
		case e_securityError:
			choice = new SecurityErrors2 ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

InfoRequestNakReason :: InfoRequestNakReason ( ) : Asn :: Choice ( 3, true ) { }

void InfoRequestNakReason :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_notRegistered:
		case e_securityDenial:
		case e_undefinedReason:
			o = new Asn :: Null;
			break;
		case e_securityError:
			o = new SecurityErrors2;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & InfoRequestNakReason :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_notRegistered, "notRegistered" },
		{ e_securityDenial, "securityDenial" },
		{ e_undefinedReason, "undefinedReason" },
		{ e_securityError, "securityError" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

InfoRequestNakReason * InfoRequestNakReason :: clone ( ) const {
	return new InfoRequestNakReason ( * this );
}

//
// UnknownMessageResponse
//

UnknownMessageResponse :: UnknownMessageResponse ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 4 ), m_requestSeqNum ( is ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_messageNotUnderstood ( 0 ) {
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_tokens ) )
				m_tokens = new ArrayOf_ClearToken ( is );
			if ( hasKnownExtensionToDecode ( is, e_cryptoTokens ) )
				m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
			if ( hasKnownExtensionToDecode ( is, e_integrityCheckValue ) )
				m_integrityCheckValue = new ICV ( is );
			if ( hasKnownExtensionToDecode ( is, e_messageNotUnderstood ) )
				m_messageNotUnderstood = new Asn :: OctetString ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_messageNotUnderstood;
		throw;
	}
}

UnknownMessageResponse :: UnknownMessageResponse ( ) : Asn :: Sequence ( 0, true, 4 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_messageNotUnderstood ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_messageNotUnderstood );
		m_messageNotUnderstood = new Asn :: OctetString;
	} catch ( ... ) {
		delete m_messageNotUnderstood;
		throw;
	}
}

UnknownMessageResponse & UnknownMessageResponse :: operator= ( const UnknownMessageResponse & s ) {
	Asn :: Sequence :: operator= ( s );
	m_requestSeqNum = s.m_requestSeqNum;
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_integrityCheckValue, s.m_integrityCheckValue );
	assignCopy ( m_messageNotUnderstood, s.m_messageNotUnderstood );
	return * this;
}

UnknownMessageResponse :: UnknownMessageResponse ( const UnknownMessageResponse & s ) : Asn :: Sequence ( s ), m_requestSeqNum ( s.m_requestSeqNum ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_messageNotUnderstood ( 0 ) {
	try {
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_integrityCheckValue )
			m_integrityCheckValue = new ICV ( * s.m_integrityCheckValue );
		if ( s.m_messageNotUnderstood )
			m_messageNotUnderstood = new Asn :: OctetString ( * s.m_messageNotUnderstood );
	} catch ( ... ) {
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_messageNotUnderstood;
		throw;
	}
}


void UnknownMessageResponse :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_integrityCheckValue:
			assignNew ( m_integrityCheckValue, new ICV );
			break;
		case e_messageNotUnderstood:
			assignNew ( m_messageNotUnderstood, new Asn :: OctetString );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void UnknownMessageResponse :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_integrityCheckValue:
			delete m_integrityCheckValue;
			m_integrityCheckValue = 0;
			break;
		case e_messageNotUnderstood:
			delete m_messageNotUnderstood;
			m_messageNotUnderstood = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void UnknownMessageResponse :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_requestSeqNum.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_tokens, m_tokens );
		knownExtensionEncode ( os, e_cryptoTokens, m_cryptoTokens );
		knownExtensionEncode ( os, e_integrityCheckValue, m_integrityCheckValue );
		knownExtensionEncode ( os, e_messageNotUnderstood, m_messageNotUnderstood );
		unknownExtensionsEncode ( os );
	}
}

UnknownMessageResponse :: ~UnknownMessageResponse ( ) {
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_integrityCheckValue;
	delete m_messageNotUnderstood;
}

void UnknownMessageResponse :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "requestSeqNum = " << std :: setprecision ( indent ) << m_requestSeqNum << '\n';
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_integrityCheckValue ) ) {
		os << std :: setw ( indent + 22 ) << "integrityCheckValue = " << std :: setprecision ( indent );
		m_integrityCheckValue -> ICV :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_messageNotUnderstood ) ) {
		os << std :: setw ( indent + 23 ) << "messageNotUnderstood = " << std :: setprecision ( indent );
		m_messageNotUnderstood -> Asn :: OctetString :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

UnknownMessageResponse * UnknownMessageResponse :: clone ( ) const {
	return new UnknownMessageResponse ( * this );
}

//
// ResourcesAvailableConfirm
//

ResourcesAvailableConfirm :: ResourcesAvailableConfirm ( Asn :: istream & is ) : Asn :: Sequence ( is, 4, true, 1 ), m_requestSeqNum ( is ), m_protocolIdentifier ( is ), m_nonStandardData ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_genericData ( 0 ) {
	try {
		if ( hasOptionalField ( e_nonStandardData ) )
			m_nonStandardData = new NonStandardParameter ( is );
		if ( hasOptionalField ( e_tokens ) )
			m_tokens = new ArrayOf_ClearToken ( is );
		if ( hasOptionalField ( e_cryptoTokens ) )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
		if ( hasOptionalField ( e_integrityCheckValue ) )
			m_integrityCheckValue = new ICV ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_genericData ) )
				m_genericData = new ArrayOf_GenericData ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_genericData;
		throw;
	}
}

ResourcesAvailableConfirm :: ResourcesAvailableConfirm ( ) : Asn :: Sequence ( 4, true, 1 ), m_nonStandardData ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_genericData ( 0 ) { }

ResourcesAvailableConfirm & ResourcesAvailableConfirm :: operator= ( const ResourcesAvailableConfirm & s ) {
	Asn :: Sequence :: operator= ( s );
	m_requestSeqNum = s.m_requestSeqNum;
	m_protocolIdentifier = s.m_protocolIdentifier;
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_integrityCheckValue, s.m_integrityCheckValue );
	assignCopy ( m_genericData, s.m_genericData );
	return * this;
}

ResourcesAvailableConfirm :: ResourcesAvailableConfirm ( const ResourcesAvailableConfirm & s ) : Asn :: Sequence ( s ), m_requestSeqNum ( s.m_requestSeqNum ), m_protocolIdentifier ( s.m_protocolIdentifier ), m_nonStandardData ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_genericData ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_integrityCheckValue )
			m_integrityCheckValue = new ICV ( * s.m_integrityCheckValue );
		if ( s.m_genericData )
			m_genericData = new ArrayOf_GenericData ( * s.m_genericData );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_genericData;
		throw;
	}
}


void ResourcesAvailableConfirm :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_integrityCheckValue:
			assignNew ( m_integrityCheckValue, new ICV );
			break;
		case e_genericData:
			assignNew ( m_genericData, new ArrayOf_GenericData );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void ResourcesAvailableConfirm :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_integrityCheckValue:
			delete m_integrityCheckValue;
			m_integrityCheckValue = 0;
			break;
		case e_genericData:
			delete m_genericData;
			m_genericData = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void ResourcesAvailableConfirm :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_requestSeqNum.encode ( os );
	m_protocolIdentifier.encode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( hasOptionalField ( e_tokens ) )
		m_tokens -> ArrayOf_ClearToken :: encode ( os );
	if ( hasOptionalField ( e_cryptoTokens ) )
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: encode ( os );
	if ( hasOptionalField ( e_integrityCheckValue ) )
		m_integrityCheckValue -> ICV :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_genericData, m_genericData );
		unknownExtensionsEncode ( os );
	}
}

ResourcesAvailableConfirm :: ~ResourcesAvailableConfirm ( ) {
	delete m_nonStandardData;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_integrityCheckValue;
	delete m_genericData;
}

void ResourcesAvailableConfirm :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "requestSeqNum = " << std :: setprecision ( indent ) << m_requestSeqNum << '\n';
	os << std :: setw ( indent + 21 ) << "protocolIdentifier = " << std :: setprecision ( indent ) << m_protocolIdentifier << '\n';
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_integrityCheckValue ) ) {
		os << std :: setw ( indent + 22 ) << "integrityCheckValue = " << std :: setprecision ( indent );
		m_integrityCheckValue -> ICV :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_genericData ) ) {
		os << std :: setw ( indent + 14 ) << "genericData = " << std :: setprecision ( indent );
		m_genericData -> ArrayOf_GenericData :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

ResourcesAvailableConfirm * ResourcesAvailableConfirm :: clone ( ) const {
	return new ResourcesAvailableConfirm ( * this );
}

//
// ServiceControlResponse
//

ServiceControlResponse :: ServiceControlResponse ( Asn :: istream & is ) : Asn :: Sequence ( is, 7, true, 0 ), m_requestSeqNum ( is ), m_result ( 0 ), m_nonStandardData ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ) {
	try {
		if ( hasOptionalField ( e_result ) )
			m_result = new ServiceControlResponse_result ( is );
		if ( hasOptionalField ( e_nonStandardData ) )
			m_nonStandardData = new NonStandardParameter ( is );
		if ( hasOptionalField ( e_tokens ) )
			m_tokens = new ArrayOf_ClearToken ( is );
		if ( hasOptionalField ( e_cryptoTokens ) )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
		if ( hasOptionalField ( e_integrityCheckValue ) )
			m_integrityCheckValue = new ICV ( is );
		if ( hasOptionalField ( e_featureSet ) )
			m_featureSet = new FeatureSet ( is );
		if ( hasOptionalField ( e_genericData ) )
			m_genericData = new ArrayOf_GenericData ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_result;
		delete m_nonStandardData;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_featureSet;
		delete m_genericData;
		throw;
	}
}

ServiceControlResponse :: ServiceControlResponse ( ) : Asn :: Sequence ( 7, true, 0 ), m_result ( 0 ), m_nonStandardData ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ) { }

ServiceControlResponse & ServiceControlResponse :: operator= ( const ServiceControlResponse & s ) {
	Asn :: Sequence :: operator= ( s );
	m_requestSeqNum = s.m_requestSeqNum;
	assignCopy ( m_result, s.m_result );
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_integrityCheckValue, s.m_integrityCheckValue );
	assignCopy ( m_featureSet, s.m_featureSet );
	assignCopy ( m_genericData, s.m_genericData );
	return * this;
}

ServiceControlResponse :: ServiceControlResponse ( const ServiceControlResponse & s ) : Asn :: Sequence ( s ), m_requestSeqNum ( s.m_requestSeqNum ), m_result ( 0 ), m_nonStandardData ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ) {
	try {
		if ( s.m_result )
			m_result = new ServiceControlResponse_result ( * s.m_result );
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_integrityCheckValue )
			m_integrityCheckValue = new ICV ( * s.m_integrityCheckValue );
		if ( s.m_featureSet )
			m_featureSet = new FeatureSet ( * s.m_featureSet );
		if ( s.m_genericData )
			m_genericData = new ArrayOf_GenericData ( * s.m_genericData );
	} catch ( ... ) {
		delete m_result;
		delete m_nonStandardData;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_featureSet;
		delete m_genericData;
		throw;
	}
}


void ServiceControlResponse :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_result:
			assignNew ( m_result, new ServiceControlResponse_result );
			break;
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_integrityCheckValue:
			assignNew ( m_integrityCheckValue, new ICV );
			break;
		case e_featureSet:
			assignNew ( m_featureSet, new FeatureSet );
			break;
		case e_genericData:
			assignNew ( m_genericData, new ArrayOf_GenericData );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void ServiceControlResponse :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_result:
			delete m_result;
			m_result = 0;
			break;
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_integrityCheckValue:
			delete m_integrityCheckValue;
			m_integrityCheckValue = 0;
			break;
		case e_featureSet:
			delete m_featureSet;
			m_featureSet = 0;
			break;
		case e_genericData:
			delete m_genericData;
			m_genericData = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void ServiceControlResponse :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_requestSeqNum.encode ( os );
	if ( hasOptionalField ( e_result ) )
		m_result -> ServiceControlResponse_result :: encode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( hasOptionalField ( e_tokens ) )
		m_tokens -> ArrayOf_ClearToken :: encode ( os );
	if ( hasOptionalField ( e_cryptoTokens ) )
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: encode ( os );
	if ( hasOptionalField ( e_integrityCheckValue ) )
		m_integrityCheckValue -> ICV :: encode ( os );
	if ( hasOptionalField ( e_featureSet ) )
		m_featureSet -> FeatureSet :: encode ( os );
	if ( hasOptionalField ( e_genericData ) )
		m_genericData -> ArrayOf_GenericData :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

ServiceControlResponse :: ~ServiceControlResponse ( ) {
	delete m_result;
	delete m_nonStandardData;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_integrityCheckValue;
	delete m_featureSet;
	delete m_genericData;
}

void ServiceControlResponse :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "requestSeqNum = " << std :: setprecision ( indent ) << m_requestSeqNum << '\n';
	if ( hasOptionalField ( e_result ) ) {
		os << std :: setw ( indent + 9 ) << "result = " << std :: setprecision ( indent );
		m_result -> ServiceControlResponse_result :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_integrityCheckValue ) ) {
		os << std :: setw ( indent + 22 ) << "integrityCheckValue = " << std :: setprecision ( indent );
		m_integrityCheckValue -> ICV :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_featureSet ) ) {
		os << std :: setw ( indent + 13 ) << "featureSet = " << std :: setprecision ( indent );
		m_featureSet -> FeatureSet :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_genericData ) ) {
		os << std :: setw ( indent + 14 ) << "genericData = " << std :: setprecision ( indent );
		m_genericData -> ArrayOf_GenericData :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

ServiceControlResponse * ServiceControlResponse :: clone ( ) const {
	return new ServiceControlResponse ( * this );
}

//
// ArrayOf_Asn_OctetString
//

ArrayOf_Asn_OctetString :: ArrayOf_Asn_OctetString ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_Asn_OctetString :: ArrayOf_Asn_OctetString ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_Asn_OctetString :: ArrayOf_Asn_OctetString ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_Asn_OctetString :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_Asn_OctetString :: createObject ( Asn :: istream & is ) {
	return new Asn :: OctetString ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) );
}

Asn :: Object * ArrayOf_Asn_OctetString :: createObject ( ) {
	return new Asn :: OctetString ( );
}

Asn :: OctetString & ArrayOf_Asn_OctetString :: operator[] ( std :: size_t i ) {
	return dynamic_cast < Asn :: OctetString & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_Asn_OctetString :: push_back ( const Asn :: OctetString & o ) {
	Asn :: Array :: push_back ( new Asn :: OctetString ( o ) );
}

const Asn :: OctetString & ArrayOf_Asn_OctetString :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const Asn :: OctetString & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_Asn_OctetString * ArrayOf_Asn_OctetString :: clone ( ) const {
	return new ArrayOf_Asn_OctetString ( * this );
}

//
// ArrayOf_NonStandardParameter
//

ArrayOf_NonStandardParameter :: ArrayOf_NonStandardParameter ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_NonStandardParameter :: ArrayOf_NonStandardParameter ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_NonStandardParameter :: ArrayOf_NonStandardParameter ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_NonStandardParameter :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_NonStandardParameter :: createObject ( Asn :: istream & is ) {
	return new NonStandardParameter ( is );
}

Asn :: Object * ArrayOf_NonStandardParameter :: createObject ( ) {
	return new NonStandardParameter ( );
}

NonStandardParameter & ArrayOf_NonStandardParameter :: operator[] ( std :: size_t i ) {
	return dynamic_cast < NonStandardParameter & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_NonStandardParameter :: push_back ( const NonStandardParameter & o ) {
	Asn :: Array :: push_back ( new NonStandardParameter ( o ) );
}

const NonStandardParameter & ArrayOf_NonStandardParameter :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const NonStandardParameter & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_NonStandardParameter * ArrayOf_NonStandardParameter :: clone ( ) const {
	return new ArrayOf_NonStandardParameter ( * this );
}

//
// ArrayOf_GenericData
//

ArrayOf_GenericData :: ArrayOf_GenericData ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_GenericData :: ArrayOf_GenericData ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_GenericData :: ArrayOf_GenericData ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_GenericData :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_GenericData :: createObject ( Asn :: istream & is ) {
	return new GenericData ( is );
}

Asn :: Object * ArrayOf_GenericData :: createObject ( ) {
	return new GenericData ( );
}

GenericData & ArrayOf_GenericData :: operator[] ( std :: size_t i ) {
	return dynamic_cast < GenericData & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_GenericData :: push_back ( const GenericData & o ) {
	Asn :: Array :: push_back ( new GenericData ( o ) );
}

const GenericData & ArrayOf_GenericData :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const GenericData & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_GenericData * ArrayOf_GenericData :: clone ( ) const {
	return new ArrayOf_GenericData ( * this );
}

//
// ArrayOf_ClearToken
//

ArrayOf_ClearToken :: ArrayOf_ClearToken ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_ClearToken :: ArrayOf_ClearToken ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_ClearToken :: ArrayOf_ClearToken ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_ClearToken :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_ClearToken :: createObject ( Asn :: istream & is ) {
	return new H235 :: ClearToken ( is );
}

Asn :: Object * ArrayOf_ClearToken :: createObject ( ) {
	return new H235 :: ClearToken ( );
}

H235 :: ClearToken & ArrayOf_ClearToken :: operator[] ( std :: size_t i ) {
	return dynamic_cast < H235 :: ClearToken & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_ClearToken :: push_back ( const H235 :: ClearToken & o ) {
	Asn :: Array :: push_back ( new H235 :: ClearToken ( o ) );
}

const H235 :: ClearToken & ArrayOf_ClearToken :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const H235 :: ClearToken & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_ClearToken * ArrayOf_ClearToken :: clone ( ) const {
	return new ArrayOf_ClearToken ( * this );
}

//
// ArrayOf_CryptoH323Token
//

ArrayOf_CryptoH323Token :: ArrayOf_CryptoH323Token ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_CryptoH323Token :: ArrayOf_CryptoH323Token ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_CryptoH323Token :: ArrayOf_CryptoH323Token ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_CryptoH323Token :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_CryptoH323Token :: createObject ( Asn :: istream & is ) {
	return new CryptoH323Token ( is );
}

Asn :: Object * ArrayOf_CryptoH323Token :: createObject ( ) {
	return new CryptoH323Token ( );
}

CryptoH323Token & ArrayOf_CryptoH323Token :: operator[] ( std :: size_t i ) {
	return dynamic_cast < CryptoH323Token & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_CryptoH323Token :: push_back ( const CryptoH323Token & o ) {
	Asn :: Array :: push_back ( new CryptoH323Token ( o ) );
}

const CryptoH323Token & ArrayOf_CryptoH323Token :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const CryptoH323Token & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_CryptoH323Token * ArrayOf_CryptoH323Token :: clone ( ) const {
	return new ArrayOf_CryptoH323Token ( * this );
}

//
// ArrayOf_AliasAddress
//

ArrayOf_AliasAddress :: ArrayOf_AliasAddress ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_AliasAddress :: ArrayOf_AliasAddress ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_AliasAddress :: ArrayOf_AliasAddress ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_AliasAddress :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_AliasAddress :: createObject ( Asn :: istream & is ) {
	return new AliasAddress ( is );
}

Asn :: Object * ArrayOf_AliasAddress :: createObject ( ) {
	return new AliasAddress ( );
}

AliasAddress & ArrayOf_AliasAddress :: operator[] ( std :: size_t i ) {
	return dynamic_cast < AliasAddress & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_AliasAddress :: push_back ( const AliasAddress & o ) {
	Asn :: Array :: push_back ( new AliasAddress ( o ) );
}

const AliasAddress & ArrayOf_AliasAddress :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const AliasAddress & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_AliasAddress * ArrayOf_AliasAddress :: clone ( ) const {
	return new ArrayOf_AliasAddress ( * this );
}

//
// ArrayOf_ServiceControlSession
//

ArrayOf_ServiceControlSession :: ArrayOf_ServiceControlSession ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_ServiceControlSession :: ArrayOf_ServiceControlSession ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_ServiceControlSession :: ArrayOf_ServiceControlSession ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_ServiceControlSession :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_ServiceControlSession :: createObject ( Asn :: istream & is ) {
	return new ServiceControlSession ( is );
}

Asn :: Object * ArrayOf_ServiceControlSession :: createObject ( ) {
	return new ServiceControlSession ( );
}

ServiceControlSession & ArrayOf_ServiceControlSession :: operator[] ( std :: size_t i ) {
	return dynamic_cast < ServiceControlSession & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_ServiceControlSession :: push_back ( const ServiceControlSession & o ) {
	Asn :: Array :: push_back ( new ServiceControlSession ( o ) );
}

const ServiceControlSession & ArrayOf_ServiceControlSession :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const ServiceControlSession & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_ServiceControlSession * ArrayOf_ServiceControlSession :: clone ( ) const {
	return new ArrayOf_ServiceControlSession ( * this );
}

//
// Connect-UUIE_language
//

Connect_UUIE_language :: Connect_UUIE_language ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

Connect_UUIE_language :: Connect_UUIE_language ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

Connect_UUIE_language :: Connect_UUIE_language ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * Connect_UUIE_language :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * Connect_UUIE_language :: createObject ( Asn :: istream & is ) {
	return new Connect_UUIE_language_subtype ( is );
}

Asn :: Object * Connect_UUIE_language :: createObject ( ) {
	return new Connect_UUIE_language_subtype ( );
}

Connect_UUIE_language_subtype & Connect_UUIE_language :: operator[] ( std :: size_t i ) {
	return dynamic_cast < Connect_UUIE_language_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

void Connect_UUIE_language :: push_back ( const Connect_UUIE_language_subtype & o ) {
	Asn :: Array :: push_back ( new Connect_UUIE_language_subtype ( o ) );
}

const Connect_UUIE_language_subtype & Connect_UUIE_language :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const Connect_UUIE_language_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

Connect_UUIE_language * Connect_UUIE_language :: clone ( ) const {
	return new Connect_UUIE_language ( * this );
}

//
// ArrayOf_CallReferenceValue
//

ArrayOf_CallReferenceValue :: ArrayOf_CallReferenceValue ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_CallReferenceValue :: ArrayOf_CallReferenceValue ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_CallReferenceValue :: ArrayOf_CallReferenceValue ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_CallReferenceValue :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_CallReferenceValue :: createObject ( Asn :: istream & is ) {
	return new CallReferenceValue ( is );
}

Asn :: Object * ArrayOf_CallReferenceValue :: createObject ( ) {
	return new CallReferenceValue ( );
}

CallReferenceValue & ArrayOf_CallReferenceValue :: operator[] ( std :: size_t i ) {
	return dynamic_cast < CallReferenceValue & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_CallReferenceValue :: push_back ( const CallReferenceValue & o ) {
	Asn :: Array :: push_back ( new CallReferenceValue ( o ) );
}

const CallReferenceValue & ArrayOf_CallReferenceValue :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const CallReferenceValue & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_CallReferenceValue * ArrayOf_CallReferenceValue :: clone ( ) const {
	return new ArrayOf_CallReferenceValue ( * this );
}

//
// Setup-UUIE_conferenceGoal
//

Setup_UUIE_conferenceGoal :: Setup_UUIE_conferenceGoal ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_create:
		case e_join:
		case e_invite:
		case e_capability_negotiation:
		case e_callIndependentSupplementaryService:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

Setup_UUIE_conferenceGoal :: Setup_UUIE_conferenceGoal ( ) : Asn :: Choice ( 3, true ) { }

void Setup_UUIE_conferenceGoal :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_create:
		case e_join:
		case e_invite:
		case e_capability_negotiation:
		case e_callIndependentSupplementaryService:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & Setup_UUIE_conferenceGoal :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_create, "create" },
		{ e_join, "join" },
		{ e_invite, "invite" },
		{ e_capability_negotiation, "capability_negotiation" },
		{ e_callIndependentSupplementaryService, "callIndependentSupplementaryService" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

Setup_UUIE_conferenceGoal * Setup_UUIE_conferenceGoal :: clone ( ) const {
	return new Setup_UUIE_conferenceGoal ( * this );
}

//
// ArrayOf_H245Security
//

ArrayOf_H245Security :: ArrayOf_H245Security ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_H245Security :: ArrayOf_H245Security ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_H245Security :: ArrayOf_H245Security ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_H245Security :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_H245Security :: createObject ( Asn :: istream & is ) {
	return new H245Security ( is );
}

Asn :: Object * ArrayOf_H245Security :: createObject ( ) {
	return new H245Security ( );
}

H245Security & ArrayOf_H245Security :: operator[] ( std :: size_t i ) {
	return dynamic_cast < H245Security & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_H245Security :: push_back ( const H245Security & o ) {
	Asn :: Array :: push_back ( new H245Security ( o ) );
}

const H245Security & ArrayOf_H245Security :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const H245Security & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_H245Security * ArrayOf_H245Security :: clone ( ) const {
	return new ArrayOf_H245Security ( * this );
}

//
// Setup-UUIE_language
//

Setup_UUIE_language :: Setup_UUIE_language ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

Setup_UUIE_language :: Setup_UUIE_language ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

Setup_UUIE_language :: Setup_UUIE_language ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * Setup_UUIE_language :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * Setup_UUIE_language :: createObject ( Asn :: istream & is ) {
	return new Setup_UUIE_language_subtype ( is );
}

Asn :: Object * Setup_UUIE_language :: createObject ( ) {
	return new Setup_UUIE_language_subtype ( );
}

Setup_UUIE_language_subtype & Setup_UUIE_language :: operator[] ( std :: size_t i ) {
	return dynamic_cast < Setup_UUIE_language_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

void Setup_UUIE_language :: push_back ( const Setup_UUIE_language_subtype & o ) {
	Asn :: Array :: push_back ( new Setup_UUIE_language_subtype ( o ) );
}

const Setup_UUIE_language_subtype & Setup_UUIE_language :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const Setup_UUIE_language_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

Setup_UUIE_language * Setup_UUIE_language :: clone ( ) const {
	return new Setup_UUIE_language ( * this );
}

//
// ArrayOf_SupportedProtocols
//

ArrayOf_SupportedProtocols :: ArrayOf_SupportedProtocols ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_SupportedProtocols :: ArrayOf_SupportedProtocols ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_SupportedProtocols :: ArrayOf_SupportedProtocols ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_SupportedProtocols :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_SupportedProtocols :: createObject ( Asn :: istream & is ) {
	return new SupportedProtocols ( is );
}

Asn :: Object * ArrayOf_SupportedProtocols :: createObject ( ) {
	return new SupportedProtocols ( );
}

SupportedProtocols & ArrayOf_SupportedProtocols :: operator[] ( std :: size_t i ) {
	return dynamic_cast < SupportedProtocols & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_SupportedProtocols :: push_back ( const SupportedProtocols & o ) {
	Asn :: Array :: push_back ( new SupportedProtocols ( o ) );
}

const SupportedProtocols & ArrayOf_SupportedProtocols :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const SupportedProtocols & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_SupportedProtocols * ArrayOf_SupportedProtocols :: clone ( ) const {
	return new ArrayOf_SupportedProtocols ( * this );
}

//
// ArrayOf_FeatureDescriptor
//

ArrayOf_FeatureDescriptor :: ArrayOf_FeatureDescriptor ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_FeatureDescriptor :: ArrayOf_FeatureDescriptor ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_FeatureDescriptor :: ArrayOf_FeatureDescriptor ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_FeatureDescriptor :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_FeatureDescriptor :: createObject ( Asn :: istream & is ) {
	return new FeatureDescriptor ( is );
}

Asn :: Object * ArrayOf_FeatureDescriptor :: createObject ( ) {
	return new FeatureDescriptor ( );
}

FeatureDescriptor & ArrayOf_FeatureDescriptor :: operator[] ( std :: size_t i ) {
	return dynamic_cast < FeatureDescriptor & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_FeatureDescriptor :: push_back ( const FeatureDescriptor & o ) {
	Asn :: Array :: push_back ( new FeatureDescriptor ( o ) );
}

const FeatureDescriptor & ArrayOf_FeatureDescriptor :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const FeatureDescriptor & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_FeatureDescriptor * ArrayOf_FeatureDescriptor :: clone ( ) const {
	return new ArrayOf_FeatureDescriptor ( * this );
}

//
// ArrayOf_ExtendedAliasAddress
//

ArrayOf_ExtendedAliasAddress :: ArrayOf_ExtendedAliasAddress ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_ExtendedAliasAddress :: ArrayOf_ExtendedAliasAddress ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_ExtendedAliasAddress :: ArrayOf_ExtendedAliasAddress ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_ExtendedAliasAddress :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_ExtendedAliasAddress :: createObject ( Asn :: istream & is ) {
	return new ExtendedAliasAddress ( is );
}

Asn :: Object * ArrayOf_ExtendedAliasAddress :: createObject ( ) {
	return new ExtendedAliasAddress ( );
}

ExtendedAliasAddress & ArrayOf_ExtendedAliasAddress :: operator[] ( std :: size_t i ) {
	return dynamic_cast < ExtendedAliasAddress & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_ExtendedAliasAddress :: push_back ( const ExtendedAliasAddress & o ) {
	Asn :: Array :: push_back ( new ExtendedAliasAddress ( o ) );
}

const ExtendedAliasAddress & ArrayOf_ExtendedAliasAddress :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const ExtendedAliasAddress & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_ExtendedAliasAddress * ArrayOf_ExtendedAliasAddress :: clone ( ) const {
	return new ArrayOf_ExtendedAliasAddress ( * this );
}

//
// Setup-UUIE_hopCount
//

Setup_UUIE_hopCount :: Setup_UUIE_hopCount ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 31 ) { }

Setup_UUIE_hopCount :: Setup_UUIE_hopCount ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 31 ) { }

Setup_UUIE_hopCount * Setup_UUIE_hopCount :: clone ( ) const {
	return new Setup_UUIE_hopCount ( * this );
}

//
// ArrayOf_ConferenceList
//

ArrayOf_ConferenceList :: ArrayOf_ConferenceList ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_ConferenceList :: ArrayOf_ConferenceList ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_ConferenceList :: ArrayOf_ConferenceList ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_ConferenceList :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_ConferenceList :: createObject ( Asn :: istream & is ) {
	return new ConferenceList ( is );
}

Asn :: Object * ArrayOf_ConferenceList :: createObject ( ) {
	return new ConferenceList ( );
}

ConferenceList & ArrayOf_ConferenceList :: operator[] ( std :: size_t i ) {
	return dynamic_cast < ConferenceList & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_ConferenceList :: push_back ( const ConferenceList & o ) {
	Asn :: Array :: push_back ( new ConferenceList ( o ) );
}

const ConferenceList & ArrayOf_ConferenceList :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const ConferenceList & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_ConferenceList * ArrayOf_ConferenceList :: clone ( ) const {
	return new ArrayOf_ConferenceList ( * this );
}

//
// TransportAddress_netBios
//

TransportAddress_netBios :: TransportAddress_netBios ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 16, 16 ) { }

TransportAddress_netBios :: TransportAddress_netBios ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 16, 16 ) { }

TransportAddress_netBios * TransportAddress_netBios :: clone ( ) const {
	return new TransportAddress_netBios ( * this );
}

//
// TransportAddress_nsap
//

TransportAddress_nsap :: TransportAddress_nsap ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 1, 20 ) { }

TransportAddress_nsap :: TransportAddress_nsap ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 1, 20 ) { }

TransportAddress_nsap * TransportAddress_nsap :: clone ( ) const {
	return new TransportAddress_nsap ( * this );
}

//
// EndpointType_set
//

EndpointType_set :: EndpointType_set ( Asn :: istream & is ) : Asn :: BitString ( is, Asn :: fixedConstraint, 32, 32 ) { }

EndpointType_set :: EndpointType_set ( const Asn :: string & v, unsigned b ) : Asn :: BitString ( b ? : unsigned ( v.size ( ) * 8 ), v, Asn :: fixedConstraint, 32, 32 ) {
}

EndpointType_set * EndpointType_set :: clone ( ) const {
	return new EndpointType_set ( * this );
}

//
// ArrayOf_TunnelledProtocol
//

ArrayOf_TunnelledProtocol :: ArrayOf_TunnelledProtocol ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_TunnelledProtocol :: ArrayOf_TunnelledProtocol ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_TunnelledProtocol :: ArrayOf_TunnelledProtocol ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_TunnelledProtocol :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_TunnelledProtocol :: createObject ( Asn :: istream & is ) {
	return new TunnelledProtocol ( is );
}

Asn :: Object * ArrayOf_TunnelledProtocol :: createObject ( ) {
	return new TunnelledProtocol ( );
}

TunnelledProtocol & ArrayOf_TunnelledProtocol :: operator[] ( std :: size_t i ) {
	return dynamic_cast < TunnelledProtocol & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_TunnelledProtocol :: push_back ( const TunnelledProtocol & o ) {
	Asn :: Array :: push_back ( new TunnelledProtocol ( o ) );
}

const TunnelledProtocol & ArrayOf_TunnelledProtocol :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const TunnelledProtocol & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_TunnelledProtocol * ArrayOf_TunnelledProtocol :: clone ( ) const {
	return new ArrayOf_TunnelledProtocol ( * this );
}

//
// ArrayOf_DataRate
//

ArrayOf_DataRate :: ArrayOf_DataRate ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_DataRate :: ArrayOf_DataRate ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_DataRate :: ArrayOf_DataRate ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_DataRate :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_DataRate :: createObject ( Asn :: istream & is ) {
	return new DataRate ( is );
}

Asn :: Object * ArrayOf_DataRate :: createObject ( ) {
	return new DataRate ( );
}

DataRate & ArrayOf_DataRate :: operator[] ( std :: size_t i ) {
	return dynamic_cast < DataRate & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_DataRate :: push_back ( const DataRate & o ) {
	Asn :: Array :: push_back ( new DataRate ( o ) );
}

const DataRate & ArrayOf_DataRate :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const DataRate & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_DataRate * ArrayOf_DataRate :: clone ( ) const {
	return new ArrayOf_DataRate ( * this );
}

//
// ArrayOf_SupportedPrefix
//

ArrayOf_SupportedPrefix :: ArrayOf_SupportedPrefix ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_SupportedPrefix :: ArrayOf_SupportedPrefix ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_SupportedPrefix :: ArrayOf_SupportedPrefix ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_SupportedPrefix :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_SupportedPrefix :: createObject ( Asn :: istream & is ) {
	return new SupportedPrefix ( is );
}

Asn :: Object * ArrayOf_SupportedPrefix :: createObject ( ) {
	return new SupportedPrefix ( );
}

SupportedPrefix & ArrayOf_SupportedPrefix :: operator[] ( std :: size_t i ) {
	return dynamic_cast < SupportedPrefix & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_SupportedPrefix :: push_back ( const SupportedPrefix & o ) {
	Asn :: Array :: push_back ( new SupportedPrefix ( o ) );
}

const SupportedPrefix & ArrayOf_SupportedPrefix :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const SupportedPrefix & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_SupportedPrefix * ArrayOf_SupportedPrefix :: clone ( ) const {
	return new ArrayOf_SupportedPrefix ( * this );
}

//
// VendorIdentifier_productId
//

VendorIdentifier_productId :: VendorIdentifier_productId ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 1, 256 ) { }

VendorIdentifier_productId :: VendorIdentifier_productId ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 1, 256 ) { }

VendorIdentifier_productId * VendorIdentifier_productId :: clone ( ) const {
	return new VendorIdentifier_productId ( * this );
}

//
// VendorIdentifier_versionId
//

VendorIdentifier_versionId :: VendorIdentifier_versionId ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 1, 256 ) { }

VendorIdentifier_versionId :: VendorIdentifier_versionId ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 1, 256 ) { }

VendorIdentifier_versionId * VendorIdentifier_versionId :: clone ( ) const {
	return new VendorIdentifier_versionId ( * this );
}

//
// H221NonStandard_t35CountryCode
//

H221NonStandard_t35CountryCode :: H221NonStandard_t35CountryCode ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 255 ) { }

H221NonStandard_t35CountryCode :: H221NonStandard_t35CountryCode ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 255 ) { }

H221NonStandard_t35CountryCode * H221NonStandard_t35CountryCode :: clone ( ) const {
	return new H221NonStandard_t35CountryCode ( * this );
}

//
// H221NonStandard_t35Extension
//

H221NonStandard_t35Extension :: H221NonStandard_t35Extension ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 255 ) { }

H221NonStandard_t35Extension :: H221NonStandard_t35Extension ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 255 ) { }

H221NonStandard_t35Extension * H221NonStandard_t35Extension :: clone ( ) const {
	return new H221NonStandard_t35Extension ( * this );
}

//
// H221NonStandard_manufacturerCode
//

H221NonStandard_manufacturerCode :: H221NonStandard_manufacturerCode ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

H221NonStandard_manufacturerCode :: H221NonStandard_manufacturerCode ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

H221NonStandard_manufacturerCode * H221NonStandard_manufacturerCode :: clone ( ) const {
	return new H221NonStandard_manufacturerCode ( * this );
}

//
// TunnelledProtocol_subIdentifier
//

TunnelledProtocol_subIdentifier :: TunnelledProtocol_subIdentifier ( Asn :: istream & is ) : Asn :: IA5String ( is, Asn :: fixedConstraint, 1, 64 ) { }

TunnelledProtocol_subIdentifier :: TunnelledProtocol_subIdentifier ( const Asn :: string & v ) : Asn :: IA5String ( v, Asn :: fixedConstraint, 1, 64 ) { }

TunnelledProtocol_subIdentifier * TunnelledProtocol_subIdentifier :: clone ( ) const {
	return new TunnelledProtocol_subIdentifier ( * this );
}

//
// TunnelledProtocolAlternateIdentifier_protocolType
//

TunnelledProtocolAlternateIdentifier_protocolType :: TunnelledProtocolAlternateIdentifier_protocolType ( Asn :: istream & is ) : Asn :: IA5String ( is, Asn :: fixedConstraint, 1, 64 ) { }

TunnelledProtocolAlternateIdentifier_protocolType :: TunnelledProtocolAlternateIdentifier_protocolType ( const Asn :: string & v ) : Asn :: IA5String ( v, Asn :: fixedConstraint, 1, 64 ) { }

TunnelledProtocolAlternateIdentifier_protocolType * TunnelledProtocolAlternateIdentifier_protocolType :: clone ( ) const {
	return new TunnelledProtocolAlternateIdentifier_protocolType ( * this );
}

//
// TunnelledProtocolAlternateIdentifier_protocolVariant
//

TunnelledProtocolAlternateIdentifier_protocolVariant :: TunnelledProtocolAlternateIdentifier_protocolVariant ( Asn :: istream & is ) : Asn :: IA5String ( is, Asn :: fixedConstraint, 1, 64 ) { }

TunnelledProtocolAlternateIdentifier_protocolVariant :: TunnelledProtocolAlternateIdentifier_protocolVariant ( const Asn :: string & v ) : Asn :: IA5String ( v, Asn :: fixedConstraint, 1, 64 ) { }

TunnelledProtocolAlternateIdentifier_protocolVariant * TunnelledProtocolAlternateIdentifier_protocolVariant :: clone ( ) const {
	return new TunnelledProtocolAlternateIdentifier_protocolVariant ( * this );
}

//
// AliasAddress_dialedDigits
//

AliasAddress_dialedDigits :: AliasAddress_dialedDigits ( Asn :: istream & is ) : Asn :: IA5String ( is, Asn :: fixedConstraint, 1, 128, "#*,0123456789", sizeof ( "0123456789#*," ) > 17 ? 8 : 4 ) { }

AliasAddress_dialedDigits :: AliasAddress_dialedDigits ( const Asn :: string & v ) : Asn :: IA5String ( v, Asn :: fixedConstraint, 1, 128, "#*,0123456789", sizeof ( "0123456789#*," ) > 17 ? 8 : 4 ) { }

AliasAddress_dialedDigits * AliasAddress_dialedDigits :: clone ( ) const {
	return new AliasAddress_dialedDigits ( * this );
}

//
// AliasAddress_h323-ID
//

AliasAddress_h323_ID :: AliasAddress_h323_ID ( Asn :: istream & is ) : Asn :: BMPString ( is, Asn :: fixedConstraint, 1, 256 ) { }

AliasAddress_h323_ID :: AliasAddress_h323_ID ( const Asn :: string & v ) : Asn :: BMPString ( v, Asn :: fixedConstraint, 1, 256 ) { }

AliasAddress_h323_ID * AliasAddress_h323_ID :: clone ( ) const {
	return new AliasAddress_h323_ID ( * this );
}

//
// AliasAddress_url-ID
//

AliasAddress_url_ID :: AliasAddress_url_ID ( Asn :: istream & is ) : Asn :: IA5String ( is, Asn :: fixedConstraint, 1, 512 ) { }

AliasAddress_url_ID :: AliasAddress_url_ID ( const Asn :: string & v ) : Asn :: IA5String ( v, Asn :: fixedConstraint, 1, 512 ) { }

AliasAddress_url_ID * AliasAddress_url_ID :: clone ( ) const {
	return new AliasAddress_url_ID ( * this );
}

//
// AliasAddress_email-ID
//

AliasAddress_email_ID :: AliasAddress_email_ID ( Asn :: istream & is ) : Asn :: IA5String ( is, Asn :: fixedConstraint, 1, 512 ) { }

AliasAddress_email_ID :: AliasAddress_email_ID ( const Asn :: string & v ) : Asn :: IA5String ( v, Asn :: fixedConstraint, 1, 512 ) { }

AliasAddress_email_ID * AliasAddress_email_ID :: clone ( ) const {
	return new AliasAddress_email_ID ( * this );
}

//
// ANSI-41-UIM_imsi
//

ANSI_41_UIM_imsi :: ANSI_41_UIM_imsi ( Asn :: istream & is ) : Asn :: IA5String ( is, Asn :: fixedConstraint, 3, 16, "#*0123456789abc", sizeof ( "0123456789#*abc" ) > 17 ? 8 : 4 ) { }

ANSI_41_UIM_imsi :: ANSI_41_UIM_imsi ( const Asn :: string & v ) : Asn :: IA5String ( v, Asn :: fixedConstraint, 3, 16, "#*0123456789abc", sizeof ( "0123456789#*abc" ) > 17 ? 8 : 4 ) { }

ANSI_41_UIM_imsi * ANSI_41_UIM_imsi :: clone ( ) const {
	return new ANSI_41_UIM_imsi ( * this );
}

//
// ANSI-41-UIM_min
//

ANSI_41_UIM_min :: ANSI_41_UIM_min ( Asn :: istream & is ) : Asn :: IA5String ( is, Asn :: fixedConstraint, 3, 16, "#*0123456789abc", sizeof ( "0123456789#*abc" ) > 17 ? 8 : 4 ) { }

ANSI_41_UIM_min :: ANSI_41_UIM_min ( const Asn :: string & v ) : Asn :: IA5String ( v, Asn :: fixedConstraint, 3, 16, "#*0123456789abc", sizeof ( "0123456789#*abc" ) > 17 ? 8 : 4 ) { }

ANSI_41_UIM_min * ANSI_41_UIM_min :: clone ( ) const {
	return new ANSI_41_UIM_min ( * this );
}

//
// ANSI-41-UIM_mdn
//

ANSI_41_UIM_mdn :: ANSI_41_UIM_mdn ( Asn :: istream & is ) : Asn :: IA5String ( is, Asn :: fixedConstraint, 3, 16, "#*0123456789abc", sizeof ( "0123456789#*abc" ) > 17 ? 8 : 4 ) { }

ANSI_41_UIM_mdn :: ANSI_41_UIM_mdn ( const Asn :: string & v ) : Asn :: IA5String ( v, Asn :: fixedConstraint, 3, 16, "#*0123456789abc", sizeof ( "0123456789#*abc" ) > 17 ? 8 : 4 ) { }

ANSI_41_UIM_mdn * ANSI_41_UIM_mdn :: clone ( ) const {
	return new ANSI_41_UIM_mdn ( * this );
}

//
// ANSI-41-UIM_msisdn
//

ANSI_41_UIM_msisdn :: ANSI_41_UIM_msisdn ( Asn :: istream & is ) : Asn :: IA5String ( is, Asn :: fixedConstraint, 3, 16, "#*0123456789abc", sizeof ( "0123456789#*abc" ) > 17 ? 8 : 4 ) { }

ANSI_41_UIM_msisdn :: ANSI_41_UIM_msisdn ( const Asn :: string & v ) : Asn :: IA5String ( v, Asn :: fixedConstraint, 3, 16, "#*0123456789abc", sizeof ( "0123456789#*abc" ) > 17 ? 8 : 4 ) { }

ANSI_41_UIM_msisdn * ANSI_41_UIM_msisdn :: clone ( ) const {
	return new ANSI_41_UIM_msisdn ( * this );
}

//
// ANSI-41-UIM_esn
//

ANSI_41_UIM_esn :: ANSI_41_UIM_esn ( Asn :: istream & is ) : Asn :: IA5String ( is, Asn :: fixedConstraint, 16, 16, "#*0123456789abc", sizeof ( "0123456789#*abc" ) > 17 ? 8 : 4 ) { }

ANSI_41_UIM_esn :: ANSI_41_UIM_esn ( const Asn :: string & v ) : Asn :: IA5String ( v, Asn :: fixedConstraint, 16, 16, "#*0123456789abc", sizeof ( "0123456789#*abc" ) > 17 ? 8 : 4 ) { }

ANSI_41_UIM_esn * ANSI_41_UIM_esn :: clone ( ) const {
	return new ANSI_41_UIM_esn ( * this );
}

//
// ANSI-41-UIM_mscid
//

ANSI_41_UIM_mscid :: ANSI_41_UIM_mscid ( Asn :: istream & is ) : Asn :: IA5String ( is, Asn :: fixedConstraint, 3, 16, "#*0123456789abc", sizeof ( "0123456789#*abc" ) > 17 ? 8 : 4 ) { }

ANSI_41_UIM_mscid :: ANSI_41_UIM_mscid ( const Asn :: string & v ) : Asn :: IA5String ( v, Asn :: fixedConstraint, 3, 16, "#*0123456789abc", sizeof ( "0123456789#*abc" ) > 17 ? 8 : 4 ) { }

ANSI_41_UIM_mscid * ANSI_41_UIM_mscid :: clone ( ) const {
	return new ANSI_41_UIM_mscid ( * this );
}

//
// ANSI-41-UIM_systemMyTypeCode
//

ANSI_41_UIM_systemMyTypeCode :: ANSI_41_UIM_systemMyTypeCode ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 1, 1 ) { }

ANSI_41_UIM_systemMyTypeCode :: ANSI_41_UIM_systemMyTypeCode ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 1, 1 ) { }

ANSI_41_UIM_systemMyTypeCode * ANSI_41_UIM_systemMyTypeCode :: clone ( ) const {
	return new ANSI_41_UIM_systemMyTypeCode ( * this );
}

//
// ANSI-41-UIM_systemAccessType
//

ANSI_41_UIM_systemAccessType :: ANSI_41_UIM_systemAccessType ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 1, 1 ) { }

ANSI_41_UIM_systemAccessType :: ANSI_41_UIM_systemAccessType ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 1, 1 ) { }

ANSI_41_UIM_systemAccessType * ANSI_41_UIM_systemAccessType :: clone ( ) const {
	return new ANSI_41_UIM_systemAccessType ( * this );
}

//
// ANSI-41-UIM_qualificationInformationCode
//

ANSI_41_UIM_qualificationInformationCode :: ANSI_41_UIM_qualificationInformationCode ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 1, 1 ) { }

ANSI_41_UIM_qualificationInformationCode :: ANSI_41_UIM_qualificationInformationCode ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 1, 1 ) { }

ANSI_41_UIM_qualificationInformationCode * ANSI_41_UIM_qualificationInformationCode :: clone ( ) const {
	return new ANSI_41_UIM_qualificationInformationCode ( * this );
}

//
// ANSI-41-UIM_sesn
//

ANSI_41_UIM_sesn :: ANSI_41_UIM_sesn ( Asn :: istream & is ) : Asn :: IA5String ( is, Asn :: fixedConstraint, 16, 16, "#*0123456789abc", sizeof ( "0123456789#*abc" ) > 17 ? 8 : 4 ) { }

ANSI_41_UIM_sesn :: ANSI_41_UIM_sesn ( const Asn :: string & v ) : Asn :: IA5String ( v, Asn :: fixedConstraint, 16, 16, "#*0123456789abc", sizeof ( "0123456789#*abc" ) > 17 ? 8 : 4 ) { }

ANSI_41_UIM_sesn * ANSI_41_UIM_sesn :: clone ( ) const {
	return new ANSI_41_UIM_sesn ( * this );
}

//
// ANSI-41-UIM_soc
//

ANSI_41_UIM_soc :: ANSI_41_UIM_soc ( Asn :: istream & is ) : Asn :: IA5String ( is, Asn :: fixedConstraint, 3, 16, "#*0123456789abc", sizeof ( "0123456789#*abc" ) > 17 ? 8 : 4 ) { }

ANSI_41_UIM_soc :: ANSI_41_UIM_soc ( const Asn :: string & v ) : Asn :: IA5String ( v, Asn :: fixedConstraint, 3, 16, "#*0123456789abc", sizeof ( "0123456789#*abc" ) > 17 ? 8 : 4 ) { }

ANSI_41_UIM_soc * ANSI_41_UIM_soc :: clone ( ) const {
	return new ANSI_41_UIM_soc ( * this );
}

//
// GSM-UIM_imsi
//

GSM_UIM_imsi :: GSM_UIM_imsi ( Asn :: istream & is ) : Asn :: IA5String ( is, Asn :: fixedConstraint, 3, 16, "#*0123456789abc", sizeof ( "0123456789#*abc" ) > 17 ? 8 : 4 ) { }

GSM_UIM_imsi :: GSM_UIM_imsi ( const Asn :: string & v ) : Asn :: IA5String ( v, Asn :: fixedConstraint, 3, 16, "#*0123456789abc", sizeof ( "0123456789#*abc" ) > 17 ? 8 : 4 ) { }

GSM_UIM_imsi * GSM_UIM_imsi :: clone ( ) const {
	return new GSM_UIM_imsi ( * this );
}

//
// GSM-UIM_tmsi
//

GSM_UIM_tmsi :: GSM_UIM_tmsi ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 1, 4 ) { }

GSM_UIM_tmsi :: GSM_UIM_tmsi ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 1, 4 ) { }

GSM_UIM_tmsi * GSM_UIM_tmsi :: clone ( ) const {
	return new GSM_UIM_tmsi ( * this );
}

//
// GSM-UIM_msisdn
//

GSM_UIM_msisdn :: GSM_UIM_msisdn ( Asn :: istream & is ) : Asn :: IA5String ( is, Asn :: fixedConstraint, 3, 16, "#*0123456789abc", sizeof ( "0123456789#*abc" ) > 17 ? 8 : 4 ) { }

GSM_UIM_msisdn :: GSM_UIM_msisdn ( const Asn :: string & v ) : Asn :: IA5String ( v, Asn :: fixedConstraint, 3, 16, "#*0123456789abc", sizeof ( "0123456789#*abc" ) > 17 ? 8 : 4 ) { }

GSM_UIM_msisdn * GSM_UIM_msisdn :: clone ( ) const {
	return new GSM_UIM_msisdn ( * this );
}

//
// GSM-UIM_imei
//

GSM_UIM_imei :: GSM_UIM_imei ( Asn :: istream & is ) : Asn :: IA5String ( is, Asn :: fixedConstraint, 15, 16, "#*0123456789abc", sizeof ( "0123456789#*abc" ) > 17 ? 8 : 4 ) { }

GSM_UIM_imei :: GSM_UIM_imei ( const Asn :: string & v ) : Asn :: IA5String ( v, Asn :: fixedConstraint, 15, 16, "#*0123456789abc", sizeof ( "0123456789#*abc" ) > 17 ? 8 : 4 ) { }

GSM_UIM_imei * GSM_UIM_imei :: clone ( ) const {
	return new GSM_UIM_imei ( * this );
}

//
// GSM-UIM_hplmn
//

GSM_UIM_hplmn :: GSM_UIM_hplmn ( Asn :: istream & is ) : Asn :: IA5String ( is, Asn :: fixedConstraint, 1, 4, "#*0123456789abc", sizeof ( "0123456789#*abc" ) > 17 ? 8 : 4 ) { }

GSM_UIM_hplmn :: GSM_UIM_hplmn ( const Asn :: string & v ) : Asn :: IA5String ( v, Asn :: fixedConstraint, 1, 4, "#*0123456789abc", sizeof ( "0123456789#*abc" ) > 17 ? 8 : 4 ) { }

GSM_UIM_hplmn * GSM_UIM_hplmn :: clone ( ) const {
	return new GSM_UIM_hplmn ( * this );
}

//
// GSM-UIM_vplmn
//

GSM_UIM_vplmn :: GSM_UIM_vplmn ( Asn :: istream & is ) : Asn :: IA5String ( is, Asn :: fixedConstraint, 1, 4, "#*0123456789abc", sizeof ( "0123456789#*abc" ) > 17 ? 8 : 4 ) { }

GSM_UIM_vplmn :: GSM_UIM_vplmn ( const Asn :: string & v ) : Asn :: IA5String ( v, Asn :: fixedConstraint, 1, 4, "#*0123456789abc", sizeof ( "0123456789#*abc" ) > 17 ? 8 : 4 ) { }

GSM_UIM_vplmn * GSM_UIM_vplmn :: clone ( ) const {
	return new GSM_UIM_vplmn ( * this );
}

//
// ArrayOf_TransportAddress
//

ArrayOf_TransportAddress :: ArrayOf_TransportAddress ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_TransportAddress :: ArrayOf_TransportAddress ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_TransportAddress :: ArrayOf_TransportAddress ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_TransportAddress :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_TransportAddress :: createObject ( Asn :: istream & is ) {
	return new TransportAddress ( is );
}

Asn :: Object * ArrayOf_TransportAddress :: createObject ( ) {
	return new TransportAddress ( );
}

TransportAddress & ArrayOf_TransportAddress :: operator[] ( std :: size_t i ) {
	return dynamic_cast < TransportAddress & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_TransportAddress :: push_back ( const TransportAddress & o ) {
	Asn :: Array :: push_back ( new TransportAddress ( o ) );
}

const TransportAddress & ArrayOf_TransportAddress :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const TransportAddress & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_TransportAddress * ArrayOf_TransportAddress :: clone ( ) const {
	return new ArrayOf_TransportAddress ( * this );
}

//
// Endpoint_priority
//

Endpoint_priority :: Endpoint_priority ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 127 ) { }

Endpoint_priority :: Endpoint_priority ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 127 ) { }

Endpoint_priority * Endpoint_priority :: clone ( ) const {
	return new Endpoint_priority ( * this );
}

//
// AlternateGK_priority
//

AlternateGK_priority :: AlternateGK_priority ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 127 ) { }

AlternateGK_priority :: AlternateGK_priority ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 127 ) { }

AlternateGK_priority * AlternateGK_priority :: clone ( ) const {
	return new AlternateGK_priority ( * this );
}

//
// ArrayOf_AlternateGK
//

ArrayOf_AlternateGK :: ArrayOf_AlternateGK ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_AlternateGK :: ArrayOf_AlternateGK ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_AlternateGK :: ArrayOf_AlternateGK ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_AlternateGK :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_AlternateGK :: createObject ( Asn :: istream & is ) {
	return new AlternateGK ( is );
}

Asn :: Object * ArrayOf_AlternateGK :: createObject ( ) {
	return new AlternateGK ( );
}

AlternateGK & ArrayOf_AlternateGK :: operator[] ( std :: size_t i ) {
	return dynamic_cast < AlternateGK & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_AlternateGK :: push_back ( const AlternateGK & o ) {
	Asn :: Array :: push_back ( new AlternateGK ( o ) );
}

const AlternateGK & ArrayOf_AlternateGK :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const AlternateGK & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_AlternateGK * ArrayOf_AlternateGK :: clone ( ) const {
	return new ArrayOf_AlternateGK ( * this );
}

//
// CryptoH323Token_cryptoGKPwdHash
//

CryptoH323Token_cryptoGKPwdHash :: CryptoH323Token_cryptoGKPwdHash ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, false, 0 ), m_gatekeeperId ( is ), m_timeStamp ( is ), m_token ( is ) {
}

CryptoH323Token_cryptoGKPwdHash :: CryptoH323Token_cryptoGKPwdHash ( ) : Asn :: Sequence ( 0, false, 0 ) { }

void CryptoH323Token_cryptoGKPwdHash :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_gatekeeperId.encode ( os );
	m_timeStamp.encode ( os );
	m_token.encode ( os );
}

void CryptoH323Token_cryptoGKPwdHash :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 15 ) << "gatekeeperId = " << std :: setprecision ( indent ) << m_gatekeeperId << '\n';
	os << std :: setw ( indent + 12 ) << "timeStamp = " << std :: setprecision ( indent ) << m_timeStamp << '\n';
	os << std :: setw ( indent + 8 ) << "token = " << std :: setprecision ( indent ) << m_token << '\n';
	os << std :: setw ( indent - 1 ) << '}';
}

CryptoH323Token_cryptoGKPwdHash * CryptoH323Token_cryptoGKPwdHash :: clone ( ) const {
	return new CryptoH323Token_cryptoGKPwdHash ( * this );
}

//
// DataRate_channelMultiplier
//

DataRate_channelMultiplier :: DataRate_channelMultiplier ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 256 ) { }

DataRate_channelMultiplier :: DataRate_channelMultiplier ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 256 ) { }

DataRate_channelMultiplier * DataRate_channelMultiplier :: clone ( ) const {
	return new DataRate_channelMultiplier ( * this );
}

//
// CapacityReportingSpecification_when
//

CapacityReportingSpecification_when :: CapacityReportingSpecification_when ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 0 ), m_callStart ( 0 ), m_callEnd ( 0 ) {
	try {
		if ( hasOptionalField ( e_callStart ) )
			m_callStart = new Asn :: Null ( is );
		if ( hasOptionalField ( e_callEnd ) )
			m_callEnd = new Asn :: Null ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_callStart;
		delete m_callEnd;
		throw;
	}
}

CapacityReportingSpecification_when :: CapacityReportingSpecification_when ( ) : Asn :: Sequence ( 2, true, 0 ), m_callStart ( 0 ), m_callEnd ( 0 ) { }

CapacityReportingSpecification_when & CapacityReportingSpecification_when :: operator= ( const CapacityReportingSpecification_when & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_callStart, s.m_callStart );
	assignCopy ( m_callEnd, s.m_callEnd );
	return * this;
}

CapacityReportingSpecification_when :: CapacityReportingSpecification_when ( const CapacityReportingSpecification_when & s ) : Asn :: Sequence ( s ), m_callStart ( 0 ), m_callEnd ( 0 ) {
	try {
		if ( s.m_callStart )
			m_callStart = new Asn :: Null ( * s.m_callStart );
		if ( s.m_callEnd )
			m_callEnd = new Asn :: Null ( * s.m_callEnd );
	} catch ( ... ) {
		delete m_callStart;
		delete m_callEnd;
		throw;
	}
}


void CapacityReportingSpecification_when :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_callStart:
			assignNew ( m_callStart, new Asn :: Null );
			break;
		case e_callEnd:
			assignNew ( m_callEnd, new Asn :: Null );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void CapacityReportingSpecification_when :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_callStart:
			delete m_callStart;
			m_callStart = 0;
			break;
		case e_callEnd:
			delete m_callEnd;
			m_callEnd = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void CapacityReportingSpecification_when :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_callStart ) )
		m_callStart -> Asn :: Null :: encode ( os );
	if ( hasOptionalField ( e_callEnd ) )
		m_callEnd -> Asn :: Null :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

CapacityReportingSpecification_when :: ~CapacityReportingSpecification_when ( ) {
	delete m_callStart;
	delete m_callEnd;
}

void CapacityReportingSpecification_when :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_callStart ) ) {
		os << std :: setw ( indent + 12 ) << "callStart = " << std :: setprecision ( indent );
		m_callStart -> Asn :: Null :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_callEnd ) ) {
		os << std :: setw ( indent + 10 ) << "callEnd = " << std :: setprecision ( indent );
		m_callEnd -> Asn :: Null :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

CapacityReportingSpecification_when * CapacityReportingSpecification_when :: clone ( ) const {
	return new CapacityReportingSpecification_when ( * this );
}

//
// ArrayOf_CallsAvailable
//

ArrayOf_CallsAvailable :: ArrayOf_CallsAvailable ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_CallsAvailable :: ArrayOf_CallsAvailable ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_CallsAvailable :: ArrayOf_CallsAvailable ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_CallsAvailable :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_CallsAvailable :: createObject ( Asn :: istream & is ) {
	return new CallsAvailable ( is );
}

Asn :: Object * ArrayOf_CallsAvailable :: createObject ( ) {
	return new CallsAvailable ( );
}

CallsAvailable & ArrayOf_CallsAvailable :: operator[] ( std :: size_t i ) {
	return dynamic_cast < CallsAvailable & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_CallsAvailable :: push_back ( const CallsAvailable & o ) {
	Asn :: Array :: push_back ( new CallsAvailable ( o ) );
}

const CallsAvailable & ArrayOf_CallsAvailable :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const CallsAvailable & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_CallsAvailable * ArrayOf_CallsAvailable :: clone ( ) const {
	return new ArrayOf_CallsAvailable ( * this );
}

//
// CallsAvailable_calls
//

CallsAvailable_calls :: CallsAvailable_calls ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 4294967295U ) { }

CallsAvailable_calls :: CallsAvailable_calls ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 4294967295U ) { }

CallsAvailable_calls * CallsAvailable_calls :: clone ( ) const {
	return new CallsAvailable_calls ( * this );
}

//
// CallsAvailable_group
//

CallsAvailable_group :: CallsAvailable_group ( Asn :: istream & is ) : Asn :: IA5String ( is, Asn :: fixedConstraint, 1, 128 ) { }

CallsAvailable_group :: CallsAvailable_group ( const Asn :: string & v ) : Asn :: IA5String ( v, Asn :: fixedConstraint, 1, 128 ) { }

CallsAvailable_group * CallsAvailable_group :: clone ( ) const {
	return new CallsAvailable_group ( * this );
}

//
// CicInfo_cic
//

CicInfo_cic :: CicInfo_cic ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

CicInfo_cic :: CicInfo_cic ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

CicInfo_cic :: CicInfo_cic ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * CicInfo_cic :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * CicInfo_cic :: createObject ( Asn :: istream & is ) {
	return new CicInfo_cic_subtype ( is );
}

Asn :: Object * CicInfo_cic :: createObject ( ) {
	return new CicInfo_cic_subtype ( );
}

CicInfo_cic_subtype & CicInfo_cic :: operator[] ( std :: size_t i ) {
	return dynamic_cast < CicInfo_cic_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

void CicInfo_cic :: push_back ( const CicInfo_cic_subtype & o ) {
	Asn :: Array :: push_back ( new CicInfo_cic_subtype ( o ) );
}

const CicInfo_cic_subtype & CicInfo_cic :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const CicInfo_cic_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

CicInfo_cic * CicInfo_cic :: clone ( ) const {
	return new CicInfo_cic ( * this );
}

//
// CicInfo_pointCode
//

CicInfo_pointCode :: CicInfo_pointCode ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 2, 5 ) { }

CicInfo_pointCode :: CicInfo_pointCode ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 2, 5 ) { }

CicInfo_pointCode * CicInfo_pointCode :: clone ( ) const {
	return new CicInfo_pointCode ( * this );
}

//
// GroupID_member
//

GroupID_member :: GroupID_member ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

GroupID_member :: GroupID_member ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

GroupID_member :: GroupID_member ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * GroupID_member :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * GroupID_member :: createObject ( Asn :: istream & is ) {
	return new GroupID_member_subtype ( is );
}

Asn :: Object * GroupID_member :: createObject ( ) {
	return new GroupID_member_subtype ( );
}

GroupID_member_subtype & GroupID_member :: operator[] ( std :: size_t i ) {
	return dynamic_cast < GroupID_member_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

void GroupID_member :: push_back ( const GroupID_member_subtype & o ) {
	Asn :: Array :: push_back ( new GroupID_member_subtype ( o ) );
}

const GroupID_member_subtype & GroupID_member :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const GroupID_member_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

GroupID_member * GroupID_member :: clone ( ) const {
	return new GroupID_member ( * this );
}

//
// GroupID_group
//

GroupID_group :: GroupID_group ( Asn :: istream & is ) : Asn :: IA5String ( is, Asn :: fixedConstraint, 1, 128 ) { }

GroupID_group :: GroupID_group ( const Asn :: string & v ) : Asn :: IA5String ( v, Asn :: fixedConstraint, 1, 128 ) { }

GroupID_group * GroupID_group :: clone ( ) const {
	return new GroupID_group ( * this );
}

//
// CarrierInfo_carrierIdentificationCode
//

CarrierInfo_carrierIdentificationCode :: CarrierInfo_carrierIdentificationCode ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 3, 4 ) { }

CarrierInfo_carrierIdentificationCode :: CarrierInfo_carrierIdentificationCode ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 3, 4 ) { }

CarrierInfo_carrierIdentificationCode * CarrierInfo_carrierIdentificationCode :: clone ( ) const {
	return new CarrierInfo_carrierIdentificationCode ( * this );
}

//
// CarrierInfo_carrierName
//

CarrierInfo_carrierName :: CarrierInfo_carrierName ( Asn :: istream & is ) : Asn :: IA5String ( is, Asn :: fixedConstraint, 1, 128 ) { }

CarrierInfo_carrierName :: CarrierInfo_carrierName ( const Asn :: string & v ) : Asn :: IA5String ( v, Asn :: fixedConstraint, 1, 128 ) { }

CarrierInfo_carrierName * CarrierInfo_carrierName :: clone ( ) const {
	return new CarrierInfo_carrierName ( * this );
}

//
// ServiceControlDescriptor_url
//

ServiceControlDescriptor_url :: ServiceControlDescriptor_url ( Asn :: istream & is ) : Asn :: IA5String ( is, Asn :: fixedConstraint, 0, 512 ) { }

ServiceControlDescriptor_url :: ServiceControlDescriptor_url ( const Asn :: string & v ) : Asn :: IA5String ( v, Asn :: fixedConstraint, 0, 512 ) { }

ServiceControlDescriptor_url * ServiceControlDescriptor_url :: clone ( ) const {
	return new ServiceControlDescriptor_url ( * this );
}

//
// ServiceControlSession_sessionId
//

ServiceControlSession_sessionId :: ServiceControlSession_sessionId ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 255 ) { }

ServiceControlSession_sessionId :: ServiceControlSession_sessionId ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 255 ) { }

ServiceControlSession_sessionId * ServiceControlSession_sessionId :: clone ( ) const {
	return new ServiceControlSession_sessionId ( * this );
}

//
// ServiceControlSession_reason
//

ServiceControlSession_reason :: ServiceControlSession_reason ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_open:
		case e_refresh:
		case e_close:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

ServiceControlSession_reason :: ServiceControlSession_reason ( ) : Asn :: Choice ( 3, true ) { }

void ServiceControlSession_reason :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_open:
		case e_refresh:
		case e_close:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & ServiceControlSession_reason :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_open, "open" },
		{ e_refresh, "refresh" },
		{ e_close, "close" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

ServiceControlSession_reason * ServiceControlSession_reason :: clone ( ) const {
	return new ServiceControlSession_reason ( * this );
}

//
// RasUsageSpecification_when
//

RasUsageSpecification_when :: RasUsageSpecification_when ( Asn :: istream & is ) : Asn :: Sequence ( is, 3, true, 0 ), m_start ( 0 ), m_end ( 0 ), m_inIrr ( 0 ) {
	try {
		if ( hasOptionalField ( e_start ) )
			m_start = new Asn :: Null ( is );
		if ( hasOptionalField ( e_end ) )
			m_end = new Asn :: Null ( is );
		if ( hasOptionalField ( e_inIrr ) )
			m_inIrr = new Asn :: Null ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_start;
		delete m_end;
		delete m_inIrr;
		throw;
	}
}

RasUsageSpecification_when :: RasUsageSpecification_when ( ) : Asn :: Sequence ( 3, true, 0 ), m_start ( 0 ), m_end ( 0 ), m_inIrr ( 0 ) { }

RasUsageSpecification_when & RasUsageSpecification_when :: operator= ( const RasUsageSpecification_when & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_start, s.m_start );
	assignCopy ( m_end, s.m_end );
	assignCopy ( m_inIrr, s.m_inIrr );
	return * this;
}

RasUsageSpecification_when :: RasUsageSpecification_when ( const RasUsageSpecification_when & s ) : Asn :: Sequence ( s ), m_start ( 0 ), m_end ( 0 ), m_inIrr ( 0 ) {
	try {
		if ( s.m_start )
			m_start = new Asn :: Null ( * s.m_start );
		if ( s.m_end )
			m_end = new Asn :: Null ( * s.m_end );
		if ( s.m_inIrr )
			m_inIrr = new Asn :: Null ( * s.m_inIrr );
	} catch ( ... ) {
		delete m_start;
		delete m_end;
		delete m_inIrr;
		throw;
	}
}


void RasUsageSpecification_when :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_start:
			assignNew ( m_start, new Asn :: Null );
			break;
		case e_end:
			assignNew ( m_end, new Asn :: Null );
			break;
		case e_inIrr:
			assignNew ( m_inIrr, new Asn :: Null );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void RasUsageSpecification_when :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_start:
			delete m_start;
			m_start = 0;
			break;
		case e_end:
			delete m_end;
			m_end = 0;
			break;
		case e_inIrr:
			delete m_inIrr;
			m_inIrr = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void RasUsageSpecification_when :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_start ) )
		m_start -> Asn :: Null :: encode ( os );
	if ( hasOptionalField ( e_end ) )
		m_end -> Asn :: Null :: encode ( os );
	if ( hasOptionalField ( e_inIrr ) )
		m_inIrr -> Asn :: Null :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

RasUsageSpecification_when :: ~RasUsageSpecification_when ( ) {
	delete m_start;
	delete m_end;
	delete m_inIrr;
}

void RasUsageSpecification_when :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_start ) ) {
		os << std :: setw ( indent + 8 ) << "start = " << std :: setprecision ( indent );
		m_start -> Asn :: Null :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_end ) ) {
		os << std :: setw ( indent + 6 ) << "end = " << std :: setprecision ( indent );
		m_end -> Asn :: Null :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_inIrr ) ) {
		os << std :: setw ( indent + 8 ) << "inIrr = " << std :: setprecision ( indent );
		m_inIrr -> Asn :: Null :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RasUsageSpecification_when * RasUsageSpecification_when :: clone ( ) const {
	return new RasUsageSpecification_when ( * this );
}

//
// RasUsageSpecification_callStartingPoint
//

RasUsageSpecification_callStartingPoint :: RasUsageSpecification_callStartingPoint ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 0 ), m_alerting ( 0 ), m_connect ( 0 ) {
	try {
		if ( hasOptionalField ( e_alerting ) )
			m_alerting = new Asn :: Null ( is );
		if ( hasOptionalField ( e_connect ) )
			m_connect = new Asn :: Null ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_alerting;
		delete m_connect;
		throw;
	}
}

RasUsageSpecification_callStartingPoint :: RasUsageSpecification_callStartingPoint ( ) : Asn :: Sequence ( 2, true, 0 ), m_alerting ( 0 ), m_connect ( 0 ) { }

RasUsageSpecification_callStartingPoint & RasUsageSpecification_callStartingPoint :: operator= ( const RasUsageSpecification_callStartingPoint & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_alerting, s.m_alerting );
	assignCopy ( m_connect, s.m_connect );
	return * this;
}

RasUsageSpecification_callStartingPoint :: RasUsageSpecification_callStartingPoint ( const RasUsageSpecification_callStartingPoint & s ) : Asn :: Sequence ( s ), m_alerting ( 0 ), m_connect ( 0 ) {
	try {
		if ( s.m_alerting )
			m_alerting = new Asn :: Null ( * s.m_alerting );
		if ( s.m_connect )
			m_connect = new Asn :: Null ( * s.m_connect );
	} catch ( ... ) {
		delete m_alerting;
		delete m_connect;
		throw;
	}
}


void RasUsageSpecification_callStartingPoint :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_alerting:
			assignNew ( m_alerting, new Asn :: Null );
			break;
		case e_connect:
			assignNew ( m_connect, new Asn :: Null );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void RasUsageSpecification_callStartingPoint :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_alerting:
			delete m_alerting;
			m_alerting = 0;
			break;
		case e_connect:
			delete m_connect;
			m_connect = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void RasUsageSpecification_callStartingPoint :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_alerting ) )
		m_alerting -> Asn :: Null :: encode ( os );
	if ( hasOptionalField ( e_connect ) )
		m_connect -> Asn :: Null :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

RasUsageSpecification_callStartingPoint :: ~RasUsageSpecification_callStartingPoint ( ) {
	delete m_alerting;
	delete m_connect;
}

void RasUsageSpecification_callStartingPoint :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_alerting ) ) {
		os << std :: setw ( indent + 11 ) << "alerting = " << std :: setprecision ( indent );
		m_alerting -> Asn :: Null :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_connect ) ) {
		os << std :: setw ( indent + 10 ) << "connect = " << std :: setprecision ( indent );
		m_connect -> Asn :: Null :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RasUsageSpecification_callStartingPoint * RasUsageSpecification_callStartingPoint :: clone ( ) const {
	return new RasUsageSpecification_callStartingPoint ( * this );
}

//
// CallTerminationCause_releaseCompleteCauseIE
//

CallTerminationCause_releaseCompleteCauseIE :: CallTerminationCause_releaseCompleteCauseIE ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 2, 32 ) { }

CallTerminationCause_releaseCompleteCauseIE :: CallTerminationCause_releaseCompleteCauseIE ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 2, 32 ) { }

CallTerminationCause_releaseCompleteCauseIE * CallTerminationCause_releaseCompleteCauseIE :: clone ( ) const {
	return new CallTerminationCause_releaseCompleteCauseIE ( * this );
}

//
// CallCreditServiceControl_amountString
//

CallCreditServiceControl_amountString :: CallCreditServiceControl_amountString ( Asn :: istream & is ) : Asn :: BMPString ( is, Asn :: fixedConstraint, 1, 512 ) { }

CallCreditServiceControl_amountString :: CallCreditServiceControl_amountString ( const Asn :: string & v ) : Asn :: BMPString ( v, Asn :: fixedConstraint, 1, 512 ) { }

CallCreditServiceControl_amountString * CallCreditServiceControl_amountString :: clone ( ) const {
	return new CallCreditServiceControl_amountString ( * this );
}

//
// CallCreditServiceControl_billingMode
//

CallCreditServiceControl_billingMode :: CallCreditServiceControl_billingMode ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_credit:
		case e_debit:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

CallCreditServiceControl_billingMode :: CallCreditServiceControl_billingMode ( ) : Asn :: Choice ( 2, true ) { }

void CallCreditServiceControl_billingMode :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_credit:
		case e_debit:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & CallCreditServiceControl_billingMode :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_credit, "credit" },
		{ e_debit, "debit" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

CallCreditServiceControl_billingMode * CallCreditServiceControl_billingMode :: clone ( ) const {
	return new CallCreditServiceControl_billingMode ( * this );
}

//
// CallCreditServiceControl_callDurationLimit
//

CallCreditServiceControl_callDurationLimit :: CallCreditServiceControl_callDurationLimit ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 4294967295U ) { }

CallCreditServiceControl_callDurationLimit :: CallCreditServiceControl_callDurationLimit ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 4294967295U ) { }

CallCreditServiceControl_callDurationLimit * CallCreditServiceControl_callDurationLimit :: clone ( ) const {
	return new CallCreditServiceControl_callDurationLimit ( * this );
}

//
// CallCreditServiceControl_callStartingPoint
//

CallCreditServiceControl_callStartingPoint :: CallCreditServiceControl_callStartingPoint ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_alerting:
		case e_connect:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

CallCreditServiceControl_callStartingPoint :: CallCreditServiceControl_callStartingPoint ( ) : Asn :: Choice ( 2, true ) { }

void CallCreditServiceControl_callStartingPoint :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_alerting:
		case e_connect:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & CallCreditServiceControl_callStartingPoint :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_alerting, "alerting" },
		{ e_connect, "connect" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

CallCreditServiceControl_callStartingPoint * CallCreditServiceControl_callStartingPoint :: clone ( ) const {
	return new CallCreditServiceControl_callStartingPoint ( * this );
}

//
// GenericData_parameters
//

GenericData_parameters :: GenericData_parameters ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 512 ) { }

GenericData_parameters :: GenericData_parameters ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 512 ) { }

GenericData_parameters :: GenericData_parameters ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 512 ) { }


Asn :: Object * GenericData_parameters :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * GenericData_parameters :: createObject ( Asn :: istream & is ) {
	return new EnumeratedParameter ( is );
}

Asn :: Object * GenericData_parameters :: createObject ( ) {
	return new EnumeratedParameter ( );
}

EnumeratedParameter & GenericData_parameters :: operator[] ( std :: size_t i ) {
	return dynamic_cast < EnumeratedParameter & > ( Asn :: Array :: operator[] ( i ) );
}

void GenericData_parameters :: push_back ( const EnumeratedParameter & o ) {
	Asn :: Array :: push_back ( new EnumeratedParameter ( o ) );
}

const EnumeratedParameter & GenericData_parameters :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const EnumeratedParameter & > ( Asn :: Array :: operator[] ( i ) );
}

GenericData_parameters * GenericData_parameters :: clone ( ) const {
	return new GenericData_parameters ( * this );
}

//
// GenericIdentifier_standard
//

GenericIdentifier_standard :: GenericIdentifier_standard ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: extendableConstraint, 0, 16383 ) { }

GenericIdentifier_standard :: GenericIdentifier_standard ( unsigned v ) : Asn :: Integer ( v, Asn :: extendableConstraint, 0, 16383 ) { }

GenericIdentifier_standard * GenericIdentifier_standard :: clone ( ) const {
	return new GenericIdentifier_standard ( * this );
}

//
// Content_number8
//

Content_number8 :: Content_number8 ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 255 ) { }

Content_number8 :: Content_number8 ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 255 ) { }

Content_number8 * Content_number8 :: clone ( ) const {
	return new Content_number8 ( * this );
}

//
// Content_number16
//

Content_number16 :: Content_number16 ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

Content_number16 :: Content_number16 ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

Content_number16 * Content_number16 :: clone ( ) const {
	return new Content_number16 ( * this );
}

//
// Content_number32
//

Content_number32 :: Content_number32 ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 4294967295U ) { }

Content_number32 :: Content_number32 ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 4294967295U ) { }

Content_number32 * Content_number32 :: clone ( ) const {
	return new Content_number32 ( * this );
}

//
// Content_compound
//

Content_compound :: Content_compound ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 512 ) { }

Content_compound :: Content_compound ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 512 ) { }

Content_compound :: Content_compound ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 512 ) { }


Asn :: Object * Content_compound :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * Content_compound :: createObject ( Asn :: istream & is ) {
	return new EnumeratedParameter ( is );
}

Asn :: Object * Content_compound :: createObject ( ) {
	return new EnumeratedParameter ( );
}

EnumeratedParameter & Content_compound :: operator[] ( std :: size_t i ) {
	return dynamic_cast < EnumeratedParameter & > ( Asn :: Array :: operator[] ( i ) );
}

void Content_compound :: push_back ( const EnumeratedParameter & o ) {
	Asn :: Array :: push_back ( new EnumeratedParameter ( o ) );
}

const EnumeratedParameter & Content_compound :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const EnumeratedParameter & > ( Asn :: Array :: operator[] ( i ) );
}

Content_compound * Content_compound :: clone ( ) const {
	return new Content_compound ( * this );
}

//
// Content_nested
//

Content_nested :: Content_nested ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 16 ) { }

Content_nested :: Content_nested ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 16 ) { }

Content_nested :: Content_nested ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 16 ) { }


Asn :: Object * Content_nested :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * Content_nested :: createObject ( Asn :: istream & is ) {
	return new GenericData ( is );
}

Asn :: Object * Content_nested :: createObject ( ) {
	return new GenericData ( );
}

GenericData & Content_nested :: operator[] ( std :: size_t i ) {
	return dynamic_cast < GenericData & > ( Asn :: Array :: operator[] ( i ) );
}

void Content_nested :: push_back ( const GenericData & o ) {
	Asn :: Array :: push_back ( new GenericData ( o ) );
}

const GenericData & Content_nested :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const GenericData & > ( Asn :: Array :: operator[] ( i ) );
}

Content_nested * Content_nested :: clone ( ) const {
	return new Content_nested ( * this );
}

//
// RTPSession_ssrc
//

RTPSession_ssrc :: RTPSession_ssrc ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 4294967295U ) { }

RTPSession_ssrc :: RTPSession_ssrc ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 4294967295U ) { }

RTPSession_ssrc * RTPSession_ssrc :: clone ( ) const {
	return new RTPSession_ssrc ( * this );
}

//
// RTPSession_sessionId
//

RTPSession_sessionId :: RTPSession_sessionId ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 255 ) { }

RTPSession_sessionId :: RTPSession_sessionId ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 255 ) { }

RTPSession_sessionId * RTPSession_sessionId :: clone ( ) const {
	return new RTPSession_sessionId ( * this );
}

//
// RTPSession_associatedSessionIds
//

RTPSession_associatedSessionIds :: RTPSession_associatedSessionIds ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

RTPSession_associatedSessionIds :: RTPSession_associatedSessionIds ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

RTPSession_associatedSessionIds :: RTPSession_associatedSessionIds ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * RTPSession_associatedSessionIds :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * RTPSession_associatedSessionIds :: createObject ( Asn :: istream & is ) {
	return new RTPSession_associatedSessionIds_subtype ( is );
}

Asn :: Object * RTPSession_associatedSessionIds :: createObject ( ) {
	return new RTPSession_associatedSessionIds_subtype ( );
}

RTPSession_associatedSessionIds_subtype & RTPSession_associatedSessionIds :: operator[] ( std :: size_t i ) {
	return dynamic_cast < RTPSession_associatedSessionIds_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

void RTPSession_associatedSessionIds :: push_back ( const RTPSession_associatedSessionIds_subtype & o ) {
	Asn :: Array :: push_back ( new RTPSession_associatedSessionIds_subtype ( o ) );
}

const RTPSession_associatedSessionIds_subtype & RTPSession_associatedSessionIds :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const RTPSession_associatedSessionIds_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

RTPSession_associatedSessionIds * RTPSession_associatedSessionIds :: clone ( ) const {
	return new RTPSession_associatedSessionIds ( * this );
}

//
// ArrayOf_AdmissionConfirm
//

ArrayOf_AdmissionConfirm :: ArrayOf_AdmissionConfirm ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_AdmissionConfirm :: ArrayOf_AdmissionConfirm ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_AdmissionConfirm :: ArrayOf_AdmissionConfirm ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_AdmissionConfirm :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_AdmissionConfirm :: createObject ( Asn :: istream & is ) {
	return new AdmissionConfirm ( is );
}

Asn :: Object * ArrayOf_AdmissionConfirm :: createObject ( ) {
	return new AdmissionConfirm ( );
}

AdmissionConfirm & ArrayOf_AdmissionConfirm :: operator[] ( std :: size_t i ) {
	return dynamic_cast < AdmissionConfirm & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_AdmissionConfirm :: push_back ( const AdmissionConfirm & o ) {
	Asn :: Array :: push_back ( new AdmissionConfirm ( o ) );
}

const AdmissionConfirm & ArrayOf_AdmissionConfirm :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const AdmissionConfirm & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_AdmissionConfirm * ArrayOf_AdmissionConfirm :: clone ( ) const {
	return new ArrayOf_AdmissionConfirm ( * this );
}

//
// ArrayOf_Endpoint
//

ArrayOf_Endpoint :: ArrayOf_Endpoint ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_Endpoint :: ArrayOf_Endpoint ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_Endpoint :: ArrayOf_Endpoint ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_Endpoint :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_Endpoint :: createObject ( Asn :: istream & is ) {
	return new Endpoint ( is );
}

Asn :: Object * ArrayOf_Endpoint :: createObject ( ) {
	return new Endpoint ( );
}

Endpoint & ArrayOf_Endpoint :: operator[] ( std :: size_t i ) {
	return dynamic_cast < Endpoint & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_Endpoint :: push_back ( const Endpoint & o ) {
	Asn :: Array :: push_back ( new Endpoint ( o ) );
}

const Endpoint & ArrayOf_Endpoint :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const Endpoint & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_Endpoint * ArrayOf_Endpoint :: clone ( ) const {
	return new ArrayOf_Endpoint ( * this );
}

//
// ArrayOf_AuthenticationMechanism
//

ArrayOf_AuthenticationMechanism :: ArrayOf_AuthenticationMechanism ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_AuthenticationMechanism :: ArrayOf_AuthenticationMechanism ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_AuthenticationMechanism :: ArrayOf_AuthenticationMechanism ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_AuthenticationMechanism :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_AuthenticationMechanism :: createObject ( Asn :: istream & is ) {
	return new H235 :: AuthenticationMechanism ( is );
}

Asn :: Object * ArrayOf_AuthenticationMechanism :: createObject ( ) {
	return new H235 :: AuthenticationMechanism ( );
}

H235 :: AuthenticationMechanism & ArrayOf_AuthenticationMechanism :: operator[] ( std :: size_t i ) {
	return dynamic_cast < H235 :: AuthenticationMechanism & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_AuthenticationMechanism :: push_back ( const H235 :: AuthenticationMechanism & o ) {
	Asn :: Array :: push_back ( new H235 :: AuthenticationMechanism ( o ) );
}

const H235 :: AuthenticationMechanism & ArrayOf_AuthenticationMechanism :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const H235 :: AuthenticationMechanism & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_AuthenticationMechanism * ArrayOf_AuthenticationMechanism :: clone ( ) const {
	return new ArrayOf_AuthenticationMechanism ( * this );
}

//
// ArrayOf_Asn_ObjectId
//

ArrayOf_Asn_ObjectId :: ArrayOf_Asn_ObjectId ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_Asn_ObjectId :: ArrayOf_Asn_ObjectId ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_Asn_ObjectId :: ArrayOf_Asn_ObjectId ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_Asn_ObjectId :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_Asn_ObjectId :: createObject ( Asn :: istream & is ) {
	return new Asn :: ObjectId ( is );
}

Asn :: Object * ArrayOf_Asn_ObjectId :: createObject ( ) {
	return new Asn :: ObjectId ( );
}

Asn :: ObjectId & ArrayOf_Asn_ObjectId :: operator[] ( std :: size_t i ) {
	return dynamic_cast < Asn :: ObjectId & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_Asn_ObjectId :: push_back ( const Asn :: ObjectId & o ) {
	Asn :: Array :: push_back ( new Asn :: ObjectId ( o ) );
}

const Asn :: ObjectId & ArrayOf_Asn_ObjectId :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const Asn :: ObjectId & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_Asn_ObjectId * ArrayOf_Asn_ObjectId :: clone ( ) const {
	return new ArrayOf_Asn_ObjectId ( * this );
}

//
// ArrayOf_IntegrityMechanism
//

ArrayOf_IntegrityMechanism :: ArrayOf_IntegrityMechanism ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_IntegrityMechanism :: ArrayOf_IntegrityMechanism ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_IntegrityMechanism :: ArrayOf_IntegrityMechanism ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_IntegrityMechanism :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_IntegrityMechanism :: createObject ( Asn :: istream & is ) {
	return new IntegrityMechanism ( is );
}

Asn :: Object * ArrayOf_IntegrityMechanism :: createObject ( ) {
	return new IntegrityMechanism ( );
}

IntegrityMechanism & ArrayOf_IntegrityMechanism :: operator[] ( std :: size_t i ) {
	return dynamic_cast < IntegrityMechanism & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_IntegrityMechanism :: push_back ( const IntegrityMechanism & o ) {
	Asn :: Array :: push_back ( new IntegrityMechanism ( o ) );
}

const IntegrityMechanism & ArrayOf_IntegrityMechanism :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const IntegrityMechanism & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_IntegrityMechanism * ArrayOf_IntegrityMechanism :: clone ( ) const {
	return new ArrayOf_IntegrityMechanism ( * this );
}

//
// ArrayOf_AddressPattern
//

ArrayOf_AddressPattern :: ArrayOf_AddressPattern ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_AddressPattern :: ArrayOf_AddressPattern ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_AddressPattern :: ArrayOf_AddressPattern ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_AddressPattern :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_AddressPattern :: createObject ( Asn :: istream & is ) {
	return new AddressPattern ( is );
}

Asn :: Object * ArrayOf_AddressPattern :: createObject ( ) {
	return new AddressPattern ( );
}

AddressPattern & ArrayOf_AddressPattern :: operator[] ( std :: size_t i ) {
	return dynamic_cast < AddressPattern & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_AddressPattern :: push_back ( const AddressPattern & o ) {
	Asn :: Array :: push_back ( new AddressPattern ( o ) );
}

const AddressPattern & ArrayOf_AddressPattern :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const AddressPattern & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_AddressPattern * ArrayOf_AddressPattern :: clone ( ) const {
	return new ArrayOf_AddressPattern ( * this );
}

//
// ArrayOf_H248PackagesDescriptor
//

ArrayOf_H248PackagesDescriptor :: ArrayOf_H248PackagesDescriptor ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_H248PackagesDescriptor :: ArrayOf_H248PackagesDescriptor ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_H248PackagesDescriptor :: ArrayOf_H248PackagesDescriptor ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_H248PackagesDescriptor :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_H248PackagesDescriptor :: createObject ( Asn :: istream & is ) {
	return new H248PackagesDescriptor ( is );
}

Asn :: Object * ArrayOf_H248PackagesDescriptor :: createObject ( ) {
	return new H248PackagesDescriptor ( );
}

H248PackagesDescriptor & ArrayOf_H248PackagesDescriptor :: operator[] ( std :: size_t i ) {
	return dynamic_cast < H248PackagesDescriptor & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_H248PackagesDescriptor :: push_back ( const H248PackagesDescriptor & o ) {
	Asn :: Array :: push_back ( new H248PackagesDescriptor ( o ) );
}

const H248PackagesDescriptor & ArrayOf_H248PackagesDescriptor :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const H248PackagesDescriptor & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_H248PackagesDescriptor * ArrayOf_H248PackagesDescriptor :: clone ( ) const {
	return new ArrayOf_H248PackagesDescriptor ( * this );
}

//
// RegistrationRequest_language
//

RegistrationRequest_language :: RegistrationRequest_language ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

RegistrationRequest_language :: RegistrationRequest_language ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

RegistrationRequest_language :: RegistrationRequest_language ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * RegistrationRequest_language :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * RegistrationRequest_language :: createObject ( Asn :: istream & is ) {
	return new RegistrationRequest_language_subtype ( is );
}

Asn :: Object * RegistrationRequest_language :: createObject ( ) {
	return new RegistrationRequest_language_subtype ( );
}

RegistrationRequest_language_subtype & RegistrationRequest_language :: operator[] ( std :: size_t i ) {
	return dynamic_cast < RegistrationRequest_language_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

void RegistrationRequest_language :: push_back ( const RegistrationRequest_language_subtype & o ) {
	Asn :: Array :: push_back ( new RegistrationRequest_language_subtype ( o ) );
}

const RegistrationRequest_language_subtype & RegistrationRequest_language :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const RegistrationRequest_language_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

RegistrationRequest_language * RegistrationRequest_language :: clone ( ) const {
	return new RegistrationRequest_language ( * this );
}

//
// RegistrationConfirm_preGrantedARQ
//

RegistrationConfirm_preGrantedARQ :: RegistrationConfirm_preGrantedARQ ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 4 ), m_makeCall ( is ), m_useGKCallSignalAddressToMakeCall ( is ), m_answerCall ( is ), m_useGKCallSignalAddressToAnswer ( is ), m_irrFrequencyInCall ( 0 ), m_totalBandwidthRestriction ( 0 ), m_alternateTransportAddresses ( 0 ), m_useSpecifiedTransport ( 0 ) {
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_irrFrequencyInCall ) )
				m_irrFrequencyInCall = new RegistrationConfirm_preGrantedARQ_irrFrequencyInCall ( is );
			if ( hasKnownExtensionToDecode ( is, e_totalBandwidthRestriction ) )
				m_totalBandwidthRestriction = new BandWidth ( is );
			if ( hasKnownExtensionToDecode ( is, e_alternateTransportAddresses ) )
				m_alternateTransportAddresses = new AlternateTransportAddresses ( is );
			if ( hasKnownExtensionToDecode ( is, e_useSpecifiedTransport ) )
				m_useSpecifiedTransport = new UseSpecifiedTransport ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_irrFrequencyInCall;
		delete m_totalBandwidthRestriction;
		delete m_alternateTransportAddresses;
		delete m_useSpecifiedTransport;
		throw;
	}
}

RegistrationConfirm_preGrantedARQ :: RegistrationConfirm_preGrantedARQ ( ) : Asn :: Sequence ( 0, true, 4 ), m_irrFrequencyInCall ( 0 ), m_totalBandwidthRestriction ( 0 ), m_alternateTransportAddresses ( 0 ), m_useSpecifiedTransport ( 0 ) { }

RegistrationConfirm_preGrantedARQ & RegistrationConfirm_preGrantedARQ :: operator= ( const RegistrationConfirm_preGrantedARQ & s ) {
	Asn :: Sequence :: operator= ( s );
	m_makeCall = s.m_makeCall;
	m_useGKCallSignalAddressToMakeCall = s.m_useGKCallSignalAddressToMakeCall;
	m_answerCall = s.m_answerCall;
	m_useGKCallSignalAddressToAnswer = s.m_useGKCallSignalAddressToAnswer;
	assignCopy ( m_irrFrequencyInCall, s.m_irrFrequencyInCall );
	assignCopy ( m_totalBandwidthRestriction, s.m_totalBandwidthRestriction );
	assignCopy ( m_alternateTransportAddresses, s.m_alternateTransportAddresses );
	assignCopy ( m_useSpecifiedTransport, s.m_useSpecifiedTransport );
	return * this;
}

RegistrationConfirm_preGrantedARQ :: RegistrationConfirm_preGrantedARQ ( const RegistrationConfirm_preGrantedARQ & s ) : Asn :: Sequence ( s ), m_makeCall ( s.m_makeCall ), m_useGKCallSignalAddressToMakeCall ( s.m_useGKCallSignalAddressToMakeCall ), m_answerCall ( s.m_answerCall ), m_useGKCallSignalAddressToAnswer ( s.m_useGKCallSignalAddressToAnswer ), m_irrFrequencyInCall ( 0 ), m_totalBandwidthRestriction ( 0 ), m_alternateTransportAddresses ( 0 ), m_useSpecifiedTransport ( 0 ) {
	try {
		if ( s.m_irrFrequencyInCall )
			m_irrFrequencyInCall = new RegistrationConfirm_preGrantedARQ_irrFrequencyInCall ( * s.m_irrFrequencyInCall );
		if ( s.m_totalBandwidthRestriction )
			m_totalBandwidthRestriction = new BandWidth ( * s.m_totalBandwidthRestriction );
		if ( s.m_alternateTransportAddresses )
			m_alternateTransportAddresses = new AlternateTransportAddresses ( * s.m_alternateTransportAddresses );
		if ( s.m_useSpecifiedTransport )
			m_useSpecifiedTransport = new UseSpecifiedTransport ( * s.m_useSpecifiedTransport );
	} catch ( ... ) {
		delete m_irrFrequencyInCall;
		delete m_totalBandwidthRestriction;
		delete m_alternateTransportAddresses;
		delete m_useSpecifiedTransport;
		throw;
	}
}


void RegistrationConfirm_preGrantedARQ :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_irrFrequencyInCall:
			assignNew ( m_irrFrequencyInCall, new RegistrationConfirm_preGrantedARQ_irrFrequencyInCall );
			break;
		case e_totalBandwidthRestriction:
			assignNew ( m_totalBandwidthRestriction, new BandWidth );
			break;
		case e_alternateTransportAddresses:
			assignNew ( m_alternateTransportAddresses, new AlternateTransportAddresses );
			break;
		case e_useSpecifiedTransport:
			assignNew ( m_useSpecifiedTransport, new UseSpecifiedTransport );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void RegistrationConfirm_preGrantedARQ :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_irrFrequencyInCall:
			delete m_irrFrequencyInCall;
			m_irrFrequencyInCall = 0;
			break;
		case e_totalBandwidthRestriction:
			delete m_totalBandwidthRestriction;
			m_totalBandwidthRestriction = 0;
			break;
		case e_alternateTransportAddresses:
			delete m_alternateTransportAddresses;
			m_alternateTransportAddresses = 0;
			break;
		case e_useSpecifiedTransport:
			delete m_useSpecifiedTransport;
			m_useSpecifiedTransport = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void RegistrationConfirm_preGrantedARQ :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_makeCall.encode ( os );
	m_useGKCallSignalAddressToMakeCall.encode ( os );
	m_answerCall.encode ( os );
	m_useGKCallSignalAddressToAnswer.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_irrFrequencyInCall, m_irrFrequencyInCall );
		knownExtensionEncode ( os, e_totalBandwidthRestriction, m_totalBandwidthRestriction );
		knownExtensionEncode ( os, e_alternateTransportAddresses, m_alternateTransportAddresses );
		knownExtensionEncode ( os, e_useSpecifiedTransport, m_useSpecifiedTransport );
		unknownExtensionsEncode ( os );
	}
}

RegistrationConfirm_preGrantedARQ :: ~RegistrationConfirm_preGrantedARQ ( ) {
	delete m_irrFrequencyInCall;
	delete m_totalBandwidthRestriction;
	delete m_alternateTransportAddresses;
	delete m_useSpecifiedTransport;
}

void RegistrationConfirm_preGrantedARQ :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 11 ) << "makeCall = " << std :: setprecision ( indent ) << m_makeCall << '\n';
	os << std :: setw ( indent + 35 ) << "useGKCallSignalAddressToMakeCall = " << std :: setprecision ( indent ) << m_useGKCallSignalAddressToMakeCall << '\n';
	os << std :: setw ( indent + 13 ) << "answerCall = " << std :: setprecision ( indent ) << m_answerCall << '\n';
	os << std :: setw ( indent + 33 ) << "useGKCallSignalAddressToAnswer = " << std :: setprecision ( indent ) << m_useGKCallSignalAddressToAnswer << '\n';
	if ( hasOptionalField ( e_irrFrequencyInCall ) ) {
		os << std :: setw ( indent + 21 ) << "irrFrequencyInCall = " << std :: setprecision ( indent );
		m_irrFrequencyInCall -> RegistrationConfirm_preGrantedARQ_irrFrequencyInCall :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_totalBandwidthRestriction ) ) {
		os << std :: setw ( indent + 28 ) << "totalBandwidthRestriction = " << std :: setprecision ( indent );
		m_totalBandwidthRestriction -> BandWidth :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_alternateTransportAddresses ) ) {
		os << std :: setw ( indent + 30 ) << "alternateTransportAddresses = " << std :: setprecision ( indent );
		m_alternateTransportAddresses -> AlternateTransportAddresses :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_useSpecifiedTransport ) ) {
		os << std :: setw ( indent + 24 ) << "useSpecifiedTransport = " << std :: setprecision ( indent );
		m_useSpecifiedTransport -> UseSpecifiedTransport :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RegistrationConfirm_preGrantedARQ * RegistrationConfirm_preGrantedARQ :: clone ( ) const {
	return new RegistrationConfirm_preGrantedARQ ( * this );
}

//
// ArrayOf_RasUsageSpecification
//

ArrayOf_RasUsageSpecification :: ArrayOf_RasUsageSpecification ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_RasUsageSpecification :: ArrayOf_RasUsageSpecification ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_RasUsageSpecification :: ArrayOf_RasUsageSpecification ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_RasUsageSpecification :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_RasUsageSpecification :: createObject ( Asn :: istream & is ) {
	return new RasUsageSpecification ( is );
}

Asn :: Object * ArrayOf_RasUsageSpecification :: createObject ( ) {
	return new RasUsageSpecification ( );
}

RasUsageSpecification & ArrayOf_RasUsageSpecification :: operator[] ( std :: size_t i ) {
	return dynamic_cast < RasUsageSpecification & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_RasUsageSpecification :: push_back ( const RasUsageSpecification & o ) {
	Asn :: Array :: push_back ( new RasUsageSpecification ( o ) );
}

const RasUsageSpecification & ArrayOf_RasUsageSpecification :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const RasUsageSpecification & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_RasUsageSpecification * ArrayOf_RasUsageSpecification :: clone ( ) const {
	return new ArrayOf_RasUsageSpecification ( * this );
}

//
// RegistrationRejectReason_invalidTerminalAliases
//

RegistrationRejectReason_invalidTerminalAliases :: RegistrationRejectReason_invalidTerminalAliases ( Asn :: istream & is ) : Asn :: Sequence ( is, 3, true, 0 ), m_terminalAlias ( 0 ), m_terminalAliasPattern ( 0 ), m_supportedPrefixes ( 0 ) {
	try {
		if ( hasOptionalField ( e_terminalAlias ) )
			m_terminalAlias = new ArrayOf_AliasAddress ( is );
		if ( hasOptionalField ( e_terminalAliasPattern ) )
			m_terminalAliasPattern = new ArrayOf_AddressPattern ( is );
		if ( hasOptionalField ( e_supportedPrefixes ) )
			m_supportedPrefixes = new ArrayOf_SupportedPrefix ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_terminalAlias;
		delete m_terminalAliasPattern;
		delete m_supportedPrefixes;
		throw;
	}
}

RegistrationRejectReason_invalidTerminalAliases :: RegistrationRejectReason_invalidTerminalAliases ( ) : Asn :: Sequence ( 3, true, 0 ), m_terminalAlias ( 0 ), m_terminalAliasPattern ( 0 ), m_supportedPrefixes ( 0 ) { }

RegistrationRejectReason_invalidTerminalAliases & RegistrationRejectReason_invalidTerminalAliases :: operator= ( const RegistrationRejectReason_invalidTerminalAliases & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_terminalAlias, s.m_terminalAlias );
	assignCopy ( m_terminalAliasPattern, s.m_terminalAliasPattern );
	assignCopy ( m_supportedPrefixes, s.m_supportedPrefixes );
	return * this;
}

RegistrationRejectReason_invalidTerminalAliases :: RegistrationRejectReason_invalidTerminalAliases ( const RegistrationRejectReason_invalidTerminalAliases & s ) : Asn :: Sequence ( s ), m_terminalAlias ( 0 ), m_terminalAliasPattern ( 0 ), m_supportedPrefixes ( 0 ) {
	try {
		if ( s.m_terminalAlias )
			m_terminalAlias = new ArrayOf_AliasAddress ( * s.m_terminalAlias );
		if ( s.m_terminalAliasPattern )
			m_terminalAliasPattern = new ArrayOf_AddressPattern ( * s.m_terminalAliasPattern );
		if ( s.m_supportedPrefixes )
			m_supportedPrefixes = new ArrayOf_SupportedPrefix ( * s.m_supportedPrefixes );
	} catch ( ... ) {
		delete m_terminalAlias;
		delete m_terminalAliasPattern;
		delete m_supportedPrefixes;
		throw;
	}
}


void RegistrationRejectReason_invalidTerminalAliases :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_terminalAlias:
			assignNew ( m_terminalAlias, new ArrayOf_AliasAddress );
			break;
		case e_terminalAliasPattern:
			assignNew ( m_terminalAliasPattern, new ArrayOf_AddressPattern );
			break;
		case e_supportedPrefixes:
			assignNew ( m_supportedPrefixes, new ArrayOf_SupportedPrefix );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void RegistrationRejectReason_invalidTerminalAliases :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_terminalAlias:
			delete m_terminalAlias;
			m_terminalAlias = 0;
			break;
		case e_terminalAliasPattern:
			delete m_terminalAliasPattern;
			m_terminalAliasPattern = 0;
			break;
		case e_supportedPrefixes:
			delete m_supportedPrefixes;
			m_supportedPrefixes = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void RegistrationRejectReason_invalidTerminalAliases :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_terminalAlias ) )
		m_terminalAlias -> ArrayOf_AliasAddress :: encode ( os );
	if ( hasOptionalField ( e_terminalAliasPattern ) )
		m_terminalAliasPattern -> ArrayOf_AddressPattern :: encode ( os );
	if ( hasOptionalField ( e_supportedPrefixes ) )
		m_supportedPrefixes -> ArrayOf_SupportedPrefix :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

RegistrationRejectReason_invalidTerminalAliases :: ~RegistrationRejectReason_invalidTerminalAliases ( ) {
	delete m_terminalAlias;
	delete m_terminalAliasPattern;
	delete m_supportedPrefixes;
}

void RegistrationRejectReason_invalidTerminalAliases :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_terminalAlias ) ) {
		os << std :: setw ( indent + 16 ) << "terminalAlias = " << std :: setprecision ( indent );
		m_terminalAlias -> ArrayOf_AliasAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_terminalAliasPattern ) ) {
		os << std :: setw ( indent + 23 ) << "terminalAliasPattern = " << std :: setprecision ( indent );
		m_terminalAliasPattern -> ArrayOf_AddressPattern :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_supportedPrefixes ) ) {
		os << std :: setw ( indent + 20 ) << "supportedPrefixes = " << std :: setprecision ( indent );
		m_supportedPrefixes -> ArrayOf_SupportedPrefix :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RegistrationRejectReason_invalidTerminalAliases * RegistrationRejectReason_invalidTerminalAliases :: clone ( ) const {
	return new RegistrationRejectReason_invalidTerminalAliases ( * this );
}

//
// TransportQOS_qOSCapabilities
//

TransportQOS_qOSCapabilities :: TransportQOS_qOSCapabilities ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 256 ) { }

TransportQOS_qOSCapabilities :: TransportQOS_qOSCapabilities ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 256 ) { }

TransportQOS_qOSCapabilities :: TransportQOS_qOSCapabilities ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 256 ) { }


Asn :: Object * TransportQOS_qOSCapabilities :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * TransportQOS_qOSCapabilities :: createObject ( Asn :: istream & is ) {
	return new H245 :: QOSCapability ( is );
}

Asn :: Object * TransportQOS_qOSCapabilities :: createObject ( ) {
	return new H245 :: QOSCapability ( );
}

H245 :: QOSCapability & TransportQOS_qOSCapabilities :: operator[] ( std :: size_t i ) {
	return dynamic_cast < H245 :: QOSCapability & > ( Asn :: Array :: operator[] ( i ) );
}

void TransportQOS_qOSCapabilities :: push_back ( const H245 :: QOSCapability & o ) {
	Asn :: Array :: push_back ( new H245 :: QOSCapability ( o ) );
}

const H245 :: QOSCapability & TransportQOS_qOSCapabilities :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const H245 :: QOSCapability & > ( Asn :: Array :: operator[] ( i ) );
}

TransportQOS_qOSCapabilities * TransportQOS_qOSCapabilities :: clone ( ) const {
	return new TransportQOS_qOSCapabilities ( * this );
}

//
// AdmissionConfirm_irrFrequency
//

AdmissionConfirm_irrFrequency :: AdmissionConfirm_irrFrequency ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 65535 ) { }

AdmissionConfirm_irrFrequency :: AdmissionConfirm_irrFrequency ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 65535 ) { }

AdmissionConfirm_irrFrequency * AdmissionConfirm_irrFrequency :: clone ( ) const {
	return new AdmissionConfirm_irrFrequency ( * this );
}

//
// AdmissionConfirm_language
//

AdmissionConfirm_language :: AdmissionConfirm_language ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

AdmissionConfirm_language :: AdmissionConfirm_language ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

AdmissionConfirm_language :: AdmissionConfirm_language ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * AdmissionConfirm_language :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * AdmissionConfirm_language :: createObject ( Asn :: istream & is ) {
	return new AdmissionConfirm_language_subtype ( is );
}

Asn :: Object * AdmissionConfirm_language :: createObject ( ) {
	return new AdmissionConfirm_language_subtype ( );
}

AdmissionConfirm_language_subtype & AdmissionConfirm_language :: operator[] ( std :: size_t i ) {
	return dynamic_cast < AdmissionConfirm_language_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

void AdmissionConfirm_language :: push_back ( const AdmissionConfirm_language_subtype & o ) {
	Asn :: Array :: push_back ( new AdmissionConfirm_language_subtype ( o ) );
}

const AdmissionConfirm_language_subtype & AdmissionConfirm_language :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const AdmissionConfirm_language_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

AdmissionConfirm_language * AdmissionConfirm_language :: clone ( ) const {
	return new AdmissionConfirm_language ( * this );
}

//
// ArrayOf_PartyNumber
//

ArrayOf_PartyNumber :: ArrayOf_PartyNumber ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_PartyNumber :: ArrayOf_PartyNumber ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_PartyNumber :: ArrayOf_PartyNumber ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_PartyNumber :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_PartyNumber :: createObject ( Asn :: istream & is ) {
	return new PartyNumber ( is );
}

Asn :: Object * ArrayOf_PartyNumber :: createObject ( ) {
	return new PartyNumber ( );
}

PartyNumber & ArrayOf_PartyNumber :: operator[] ( std :: size_t i ) {
	return dynamic_cast < PartyNumber & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_PartyNumber :: push_back ( const PartyNumber & o ) {
	Asn :: Array :: push_back ( new PartyNumber ( o ) );
}

const PartyNumber & ArrayOf_PartyNumber :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const PartyNumber & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_PartyNumber * ArrayOf_PartyNumber :: clone ( ) const {
	return new ArrayOf_PartyNumber ( * this );
}

//
// ArrayOf_BandwidthDetails
//

ArrayOf_BandwidthDetails :: ArrayOf_BandwidthDetails ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_BandwidthDetails :: ArrayOf_BandwidthDetails ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_BandwidthDetails :: ArrayOf_BandwidthDetails ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_BandwidthDetails :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_BandwidthDetails :: createObject ( Asn :: istream & is ) {
	return new BandwidthDetails ( is );
}

Asn :: Object * ArrayOf_BandwidthDetails :: createObject ( ) {
	return new BandwidthDetails ( );
}

BandwidthDetails & ArrayOf_BandwidthDetails :: operator[] ( std :: size_t i ) {
	return dynamic_cast < BandwidthDetails & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_BandwidthDetails :: push_back ( const BandwidthDetails & o ) {
	Asn :: Array :: push_back ( new BandwidthDetails ( o ) );
}

const BandwidthDetails & ArrayOf_BandwidthDetails :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const BandwidthDetails & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_BandwidthDetails * ArrayOf_BandwidthDetails :: clone ( ) const {
	return new ArrayOf_BandwidthDetails ( * this );
}

//
// LocationRequest_hopCount
//

LocationRequest_hopCount :: LocationRequest_hopCount ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 255 ) { }

LocationRequest_hopCount :: LocationRequest_hopCount ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 255 ) { }

LocationRequest_hopCount * LocationRequest_hopCount :: clone ( ) const {
	return new LocationRequest_hopCount ( * this );
}

//
// LocationRequest_language
//

LocationRequest_language :: LocationRequest_language ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

LocationRequest_language :: LocationRequest_language ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

LocationRequest_language :: LocationRequest_language ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * LocationRequest_language :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * LocationRequest_language :: createObject ( Asn :: istream & is ) {
	return new LocationRequest_language_subtype ( is );
}

Asn :: Object * LocationRequest_language :: createObject ( ) {
	return new LocationRequest_language_subtype ( );
}

LocationRequest_language_subtype & LocationRequest_language :: operator[] ( std :: size_t i ) {
	return dynamic_cast < LocationRequest_language_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

void LocationRequest_language :: push_back ( const LocationRequest_language_subtype & o ) {
	Asn :: Array :: push_back ( new LocationRequest_language_subtype ( o ) );
}

const LocationRequest_language_subtype & LocationRequest_language :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const LocationRequest_language_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

LocationRequest_language * LocationRequest_language :: clone ( ) const {
	return new LocationRequest_language ( * this );
}

//
// InfoRequest_nextSegmentRequested
//

InfoRequest_nextSegmentRequested :: InfoRequest_nextSegmentRequested ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

InfoRequest_nextSegmentRequested :: InfoRequest_nextSegmentRequested ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

InfoRequest_nextSegmentRequested * InfoRequest_nextSegmentRequested :: clone ( ) const {
	return new InfoRequest_nextSegmentRequested ( * this );
}

//
// InfoRequestResponse_perCallInfo
//

InfoRequestResponse_perCallInfo :: InfoRequestResponse_perCallInfo ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

InfoRequestResponse_perCallInfo :: InfoRequestResponse_perCallInfo ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

InfoRequestResponse_perCallInfo :: InfoRequestResponse_perCallInfo ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * InfoRequestResponse_perCallInfo :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * InfoRequestResponse_perCallInfo :: createObject ( Asn :: istream & is ) {
	return new InfoRequestResponse_perCallInfo_subtype ( is );
}

Asn :: Object * InfoRequestResponse_perCallInfo :: createObject ( ) {
	return new InfoRequestResponse_perCallInfo_subtype ( );
}

InfoRequestResponse_perCallInfo_subtype & InfoRequestResponse_perCallInfo :: operator[] ( std :: size_t i ) {
	return dynamic_cast < InfoRequestResponse_perCallInfo_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

void InfoRequestResponse_perCallInfo :: push_back ( const InfoRequestResponse_perCallInfo_subtype & o ) {
	Asn :: Array :: push_back ( new InfoRequestResponse_perCallInfo_subtype ( o ) );
}

const InfoRequestResponse_perCallInfo_subtype & InfoRequestResponse_perCallInfo :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const InfoRequestResponse_perCallInfo_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

InfoRequestResponse_perCallInfo * InfoRequestResponse_perCallInfo :: clone ( ) const {
	return new InfoRequestResponse_perCallInfo ( * this );
}

//
// InfoRequestResponseStatus_segment
//

InfoRequestResponseStatus_segment :: InfoRequestResponseStatus_segment ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

InfoRequestResponseStatus_segment :: InfoRequestResponseStatus_segment ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

InfoRequestResponseStatus_segment * InfoRequestResponseStatus_segment :: clone ( ) const {
	return new InfoRequestResponseStatus_segment ( * this );
}

//
// RequestInProgress_delay
//

RequestInProgress_delay :: RequestInProgress_delay ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 65535 ) { }

RequestInProgress_delay :: RequestInProgress_delay ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 65535 ) { }

RequestInProgress_delay * RequestInProgress_delay :: clone ( ) const {
	return new RequestInProgress_delay ( * this );
}

//
// ServiceControlIndication_callSpecific
//

ServiceControlIndication_callSpecific :: ServiceControlIndication_callSpecific ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_callIdentifier ( is ), m_conferenceID ( is ), m_answeredCall ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

ServiceControlIndication_callSpecific :: ServiceControlIndication_callSpecific ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void ServiceControlIndication_callSpecific :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_callIdentifier.encode ( os );
	m_conferenceID.encode ( os );
	m_answeredCall.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void ServiceControlIndication_callSpecific :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 17 ) << "callIdentifier = " << std :: setprecision ( indent ) << m_callIdentifier << '\n';
	os << std :: setw ( indent + 15 ) << "conferenceID = " << std :: setprecision ( indent ) << m_conferenceID << '\n';
	os << std :: setw ( indent + 15 ) << "answeredCall = " << std :: setprecision ( indent ) << m_answeredCall << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

ServiceControlIndication_callSpecific * ServiceControlIndication_callSpecific :: clone ( ) const {
	return new ServiceControlIndication_callSpecific ( * this );
}

//
// ServiceControlResponse_result
//

ServiceControlResponse_result :: ServiceControlResponse_result ( Asn :: istream & is ) : Asn :: Choice ( is, 5, true ) {
	switch ( tag ) {
		case e_started:
		case e_failed:
		case e_stopped:
		case e_notAvailable:
		case e_neededFeatureNotSupported:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

ServiceControlResponse_result :: ServiceControlResponse_result ( ) : Asn :: Choice ( 5, true ) { }

void ServiceControlResponse_result :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_started:
		case e_failed:
		case e_stopped:
		case e_notAvailable:
		case e_neededFeatureNotSupported:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & ServiceControlResponse_result :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_started, "started" },
		{ e_failed, "failed" },
		{ e_stopped, "stopped" },
		{ e_notAvailable, "notAvailable" },
		{ e_neededFeatureNotSupported, "neededFeatureNotSupported" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

ServiceControlResponse_result * ServiceControlResponse_result :: clone ( ) const {
	return new ServiceControlResponse_result ( * this );
}

//
// H323-UserInformation_user-data_protocol-discriminator
//

H323_UserInformation_user_data_protocol_discriminator :: H323_UserInformation_user_data_protocol_discriminator ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 255 ) { }

H323_UserInformation_user_data_protocol_discriminator :: H323_UserInformation_user_data_protocol_discriminator ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 255 ) { }

H323_UserInformation_user_data_protocol_discriminator * H323_UserInformation_user_data_protocol_discriminator :: clone ( ) const {
	return new H323_UserInformation_user_data_protocol_discriminator ( * this );
}

//
// H323-UserInformation_user-data_user-information
//

H323_UserInformation_user_data_user_information :: H323_UserInformation_user_data_user_information ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 1, 131 ) { }

H323_UserInformation_user_data_user_information :: H323_UserInformation_user_data_user_information ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 1, 131 ) { }

H323_UserInformation_user_data_user_information * H323_UserInformation_user_data_user_information :: clone ( ) const {
	return new H323_UserInformation_user_data_user_information ( * this );
}

//
// Connect-UUIE_language_subtype
//

Connect_UUIE_language_subtype :: Connect_UUIE_language_subtype ( Asn :: istream & is ) : Asn :: IA5String ( is, Asn :: fixedConstraint, 1, 32 ) { }

Connect_UUIE_language_subtype :: Connect_UUIE_language_subtype ( const Asn :: string & v ) : Asn :: IA5String ( v, Asn :: fixedConstraint, 1, 32 ) { }

Connect_UUIE_language_subtype * Connect_UUIE_language_subtype :: clone ( ) const {
	return new Connect_UUIE_language_subtype ( * this );
}

//
// Setup-UUIE_connectionParameters_numberOfScnConnections
//

Setup_UUIE_connectionParameters_numberOfScnConnections :: Setup_UUIE_connectionParameters_numberOfScnConnections ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

Setup_UUIE_connectionParameters_numberOfScnConnections :: Setup_UUIE_connectionParameters_numberOfScnConnections ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

Setup_UUIE_connectionParameters_numberOfScnConnections * Setup_UUIE_connectionParameters_numberOfScnConnections :: clone ( ) const {
	return new Setup_UUIE_connectionParameters_numberOfScnConnections ( * this );
}

//
// Setup-UUIE_language_subtype
//

Setup_UUIE_language_subtype :: Setup_UUIE_language_subtype ( Asn :: istream & is ) : Asn :: IA5String ( is, Asn :: fixedConstraint, 1, 32 ) { }

Setup_UUIE_language_subtype :: Setup_UUIE_language_subtype ( const Asn :: string & v ) : Asn :: IA5String ( v, Asn :: fixedConstraint, 1, 32 ) { }

Setup_UUIE_language_subtype * Setup_UUIE_language_subtype :: clone ( ) const {
	return new Setup_UUIE_language_subtype ( * this );
}

//
// TransportAddress_ipAddress_ip
//

TransportAddress_ipAddress_ip :: TransportAddress_ipAddress_ip ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 4, 4 ) { }

TransportAddress_ipAddress_ip :: TransportAddress_ipAddress_ip ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 4, 4 ) { }

TransportAddress_ipAddress_ip * TransportAddress_ipAddress_ip :: clone ( ) const {
	return new TransportAddress_ipAddress_ip ( * this );
}

//
// TransportAddress_ipAddress_port
//

TransportAddress_ipAddress_port :: TransportAddress_ipAddress_port ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

TransportAddress_ipAddress_port :: TransportAddress_ipAddress_port ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

TransportAddress_ipAddress_port * TransportAddress_ipAddress_port :: clone ( ) const {
	return new TransportAddress_ipAddress_port ( * this );
}

//
// TransportAddress_ipSourceRoute_ip
//

TransportAddress_ipSourceRoute_ip :: TransportAddress_ipSourceRoute_ip ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 4, 4 ) { }

TransportAddress_ipSourceRoute_ip :: TransportAddress_ipSourceRoute_ip ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 4, 4 ) { }

TransportAddress_ipSourceRoute_ip * TransportAddress_ipSourceRoute_ip :: clone ( ) const {
	return new TransportAddress_ipSourceRoute_ip ( * this );
}

//
// TransportAddress_ipSourceRoute_port
//

TransportAddress_ipSourceRoute_port :: TransportAddress_ipSourceRoute_port ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

TransportAddress_ipSourceRoute_port :: TransportAddress_ipSourceRoute_port ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

TransportAddress_ipSourceRoute_port * TransportAddress_ipSourceRoute_port :: clone ( ) const {
	return new TransportAddress_ipSourceRoute_port ( * this );
}

//
// TransportAddress_ipSourceRoute_route
//

TransportAddress_ipSourceRoute_route :: TransportAddress_ipSourceRoute_route ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

TransportAddress_ipSourceRoute_route :: TransportAddress_ipSourceRoute_route ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

TransportAddress_ipSourceRoute_route :: TransportAddress_ipSourceRoute_route ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * TransportAddress_ipSourceRoute_route :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * TransportAddress_ipSourceRoute_route :: createObject ( Asn :: istream & is ) {
	return new TransportAddress_ipSourceRoute_route_subtype ( is );
}

Asn :: Object * TransportAddress_ipSourceRoute_route :: createObject ( ) {
	return new TransportAddress_ipSourceRoute_route_subtype ( );
}

TransportAddress_ipSourceRoute_route_subtype & TransportAddress_ipSourceRoute_route :: operator[] ( std :: size_t i ) {
	return dynamic_cast < TransportAddress_ipSourceRoute_route_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

void TransportAddress_ipSourceRoute_route :: push_back ( const TransportAddress_ipSourceRoute_route_subtype & o ) {
	Asn :: Array :: push_back ( new TransportAddress_ipSourceRoute_route_subtype ( o ) );
}

const TransportAddress_ipSourceRoute_route_subtype & TransportAddress_ipSourceRoute_route :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const TransportAddress_ipSourceRoute_route_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

TransportAddress_ipSourceRoute_route * TransportAddress_ipSourceRoute_route :: clone ( ) const {
	return new TransportAddress_ipSourceRoute_route ( * this );
}

//
// TransportAddress_ipSourceRoute_routing
//

TransportAddress_ipSourceRoute_routing :: TransportAddress_ipSourceRoute_routing ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_strict:
		case e_loose:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

TransportAddress_ipSourceRoute_routing :: TransportAddress_ipSourceRoute_routing ( ) : Asn :: Choice ( 2, true ) { }

void TransportAddress_ipSourceRoute_routing :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_strict:
		case e_loose:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & TransportAddress_ipSourceRoute_routing :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_strict, "strict" },
		{ e_loose, "loose" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

TransportAddress_ipSourceRoute_routing * TransportAddress_ipSourceRoute_routing :: clone ( ) const {
	return new TransportAddress_ipSourceRoute_routing ( * this );
}

//
// TransportAddress_ipxAddress_node
//

TransportAddress_ipxAddress_node :: TransportAddress_ipxAddress_node ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 6, 6 ) { }

TransportAddress_ipxAddress_node :: TransportAddress_ipxAddress_node ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 6, 6 ) { }

TransportAddress_ipxAddress_node * TransportAddress_ipxAddress_node :: clone ( ) const {
	return new TransportAddress_ipxAddress_node ( * this );
}

//
// TransportAddress_ipxAddress_netnum
//

TransportAddress_ipxAddress_netnum :: TransportAddress_ipxAddress_netnum ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 4, 4 ) { }

TransportAddress_ipxAddress_netnum :: TransportAddress_ipxAddress_netnum ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 4, 4 ) { }

TransportAddress_ipxAddress_netnum * TransportAddress_ipxAddress_netnum :: clone ( ) const {
	return new TransportAddress_ipxAddress_netnum ( * this );
}

//
// TransportAddress_ipxAddress_port
//

TransportAddress_ipxAddress_port :: TransportAddress_ipxAddress_port ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 2, 2 ) { }

TransportAddress_ipxAddress_port :: TransportAddress_ipxAddress_port ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 2, 2 ) { }

TransportAddress_ipxAddress_port * TransportAddress_ipxAddress_port :: clone ( ) const {
	return new TransportAddress_ipxAddress_port ( * this );
}

//
// TransportAddress_ip6Address_ip
//

TransportAddress_ip6Address_ip :: TransportAddress_ip6Address_ip ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 16, 16 ) { }

TransportAddress_ip6Address_ip :: TransportAddress_ip6Address_ip ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 16, 16 ) { }

TransportAddress_ip6Address_ip * TransportAddress_ip6Address_ip :: clone ( ) const {
	return new TransportAddress_ip6Address_ip ( * this );
}

//
// TransportAddress_ip6Address_port
//

TransportAddress_ip6Address_port :: TransportAddress_ip6Address_port ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

TransportAddress_ip6Address_port :: TransportAddress_ip6Address_port ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

TransportAddress_ip6Address_port * TransportAddress_ip6Address_port :: clone ( ) const {
	return new TransportAddress_ip6Address_port ( * this );
}

//
// ANSI-41-UIM_system-id_sid
//

ANSI_41_UIM_system_id_sid :: ANSI_41_UIM_system_id_sid ( Asn :: istream & is ) : Asn :: IA5String ( is, Asn :: fixedConstraint, 1, 4, "#*0123456789abc", sizeof ( "0123456789#*abc" ) > 17 ? 8 : 4 ) { }

ANSI_41_UIM_system_id_sid :: ANSI_41_UIM_system_id_sid ( const Asn :: string & v ) : Asn :: IA5String ( v, Asn :: fixedConstraint, 1, 4, "#*0123456789abc", sizeof ( "0123456789#*abc" ) > 17 ? 8 : 4 ) { }

ANSI_41_UIM_system_id_sid * ANSI_41_UIM_system_id_sid :: clone ( ) const {
	return new ANSI_41_UIM_system_id_sid ( * this );
}

//
// ANSI-41-UIM_system-id_mid
//

ANSI_41_UIM_system_id_mid :: ANSI_41_UIM_system_id_mid ( Asn :: istream & is ) : Asn :: IA5String ( is, Asn :: fixedConstraint, 1, 4, "#*0123456789abc", sizeof ( "0123456789#*abc" ) > 17 ? 8 : 4 ) { }

ANSI_41_UIM_system_id_mid :: ANSI_41_UIM_system_id_mid ( const Asn :: string & v ) : Asn :: IA5String ( v, Asn :: fixedConstraint, 1, 4, "#*0123456789abc", sizeof ( "0123456789#*abc" ) > 17 ? 8 : 4 ) { }

ANSI_41_UIM_system_id_mid * ANSI_41_UIM_system_id_mid :: clone ( ) const {
	return new ANSI_41_UIM_system_id_mid ( * this );
}

//
// CicInfo_cic_subtype
//

CicInfo_cic_subtype :: CicInfo_cic_subtype ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 2, 4 ) { }

CicInfo_cic_subtype :: CicInfo_cic_subtype ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 2, 4 ) { }

CicInfo_cic_subtype * CicInfo_cic_subtype :: clone ( ) const {
	return new CicInfo_cic_subtype ( * this );
}

//
// GroupID_member_subtype
//

GroupID_member_subtype :: GroupID_member_subtype ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

GroupID_member_subtype :: GroupID_member_subtype ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

GroupID_member_subtype * GroupID_member_subtype :: clone ( ) const {
	return new GroupID_member_subtype ( * this );
}

//
// RTPSession_associatedSessionIds_subtype
//

RTPSession_associatedSessionIds_subtype :: RTPSession_associatedSessionIds_subtype ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 255 ) { }

RTPSession_associatedSessionIds_subtype :: RTPSession_associatedSessionIds_subtype ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 255 ) { }

RTPSession_associatedSessionIds_subtype * RTPSession_associatedSessionIds_subtype :: clone ( ) const {
	return new RTPSession_associatedSessionIds_subtype ( * this );
}

//
// RegistrationRequest_language_subtype
//

RegistrationRequest_language_subtype :: RegistrationRequest_language_subtype ( Asn :: istream & is ) : Asn :: IA5String ( is, Asn :: fixedConstraint, 1, 32 ) { }

RegistrationRequest_language_subtype :: RegistrationRequest_language_subtype ( const Asn :: string & v ) : Asn :: IA5String ( v, Asn :: fixedConstraint, 1, 32 ) { }

RegistrationRequest_language_subtype * RegistrationRequest_language_subtype :: clone ( ) const {
	return new RegistrationRequest_language_subtype ( * this );
}

//
// RegistrationConfirm_preGrantedARQ_irrFrequencyInCall
//

RegistrationConfirm_preGrantedARQ_irrFrequencyInCall :: RegistrationConfirm_preGrantedARQ_irrFrequencyInCall ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 65535 ) { }

RegistrationConfirm_preGrantedARQ_irrFrequencyInCall :: RegistrationConfirm_preGrantedARQ_irrFrequencyInCall ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 65535 ) { }

RegistrationConfirm_preGrantedARQ_irrFrequencyInCall * RegistrationConfirm_preGrantedARQ_irrFrequencyInCall :: clone ( ) const {
	return new RegistrationConfirm_preGrantedARQ_irrFrequencyInCall ( * this );
}

//
// AdmissionConfirm_language_subtype
//

AdmissionConfirm_language_subtype :: AdmissionConfirm_language_subtype ( Asn :: istream & is ) : Asn :: IA5String ( is, Asn :: fixedConstraint, 1, 32 ) { }

AdmissionConfirm_language_subtype :: AdmissionConfirm_language_subtype ( const Asn :: string & v ) : Asn :: IA5String ( v, Asn :: fixedConstraint, 1, 32 ) { }

AdmissionConfirm_language_subtype * AdmissionConfirm_language_subtype :: clone ( ) const {
	return new AdmissionConfirm_language_subtype ( * this );
}

//
// LocationRequest_language_subtype
//

LocationRequest_language_subtype :: LocationRequest_language_subtype ( Asn :: istream & is ) : Asn :: IA5String ( is, Asn :: fixedConstraint, 1, 32 ) { }

LocationRequest_language_subtype :: LocationRequest_language_subtype ( const Asn :: string & v ) : Asn :: IA5String ( v, Asn :: fixedConstraint, 1, 32 ) { }

LocationRequest_language_subtype * LocationRequest_language_subtype :: clone ( ) const {
	return new LocationRequest_language_subtype ( * this );
}

//
// InfoRequestResponse_perCallInfo_subtype
//

InfoRequestResponse_perCallInfo_subtype :: InfoRequestResponse_perCallInfo_subtype ( Asn :: istream & is ) : Asn :: Sequence ( is, 5, true, 8 ), m_nonStandardData ( hasOptionalField ( e_nonStandardData ) ? pushTemporaryMember ( new NonStandardParameter ( is ) ) : 0 ), m_callReferenceValue ( is ), m_conferenceID ( is ), m_originator ( hasOptionalField ( e_originator ) ? pushTemporaryMember ( new Asn :: Boolean ( is ) ) : 0 ), m_audio ( hasOptionalField ( e_audio ) ? pushTemporaryMember ( new ArrayOf_RTPSession ( is ) ) : 0 ), m_video ( hasOptionalField ( e_video ) ? pushTemporaryMember ( new ArrayOf_RTPSession ( is ) ) : 0 ), m_data ( hasOptionalField ( e_data ) ? pushTemporaryMember ( new ArrayOf_TransportChannelInfo ( is ) ) : 0 ), m_h245 ( is ), m_callSignaling ( is ), m_callType ( is ), m_bandWidth ( is ), m_callModel ( is ), m_callIdentifier ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_substituteConfIDs ( 0 ), m_pdu ( 0 ), m_callLinkage ( 0 ), m_usageInformation ( 0 ), m_circuitInfo ( 0 ) {
	clearTemporaryMembers ( );
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_callIdentifier ) )
				m_callIdentifier = new CallIdentifier ( is );
			if ( hasKnownExtensionToDecode ( is, e_tokens ) )
				m_tokens = new ArrayOf_ClearToken ( is );
			if ( hasKnownExtensionToDecode ( is, e_cryptoTokens ) )
				m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
			if ( hasKnownExtensionToDecode ( is, e_substituteConfIDs ) )
				m_substituteConfIDs = new ArrayOf_ConferenceIdentifier ( is );
			if ( hasKnownExtensionToDecode ( is, e_pdu ) )
				m_pdu = new InfoRequestResponse_perCallInfo_subtype_pdu ( is );
			if ( hasKnownExtensionToDecode ( is, e_callLinkage ) )
				m_callLinkage = new CallLinkage ( is );
			if ( hasKnownExtensionToDecode ( is, e_usageInformation ) )
				m_usageInformation = new RasUsageInformation ( is );
			if ( hasKnownExtensionToDecode ( is, e_circuitInfo ) )
				m_circuitInfo = new CircuitInfo ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_originator;
		delete m_audio;
		delete m_video;
		delete m_data;
		delete m_callIdentifier;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_substituteConfIDs;
		delete m_pdu;
		delete m_callLinkage;
		delete m_usageInformation;
		delete m_circuitInfo;
		throw;
	}
}

InfoRequestResponse_perCallInfo_subtype :: InfoRequestResponse_perCallInfo_subtype ( ) : Asn :: Sequence ( 5, true, 8 ), m_nonStandardData ( 0 ), m_originator ( 0 ), m_audio ( 0 ), m_video ( 0 ), m_data ( 0 ), m_callIdentifier ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_substituteConfIDs ( 0 ), m_pdu ( 0 ), m_callLinkage ( 0 ), m_usageInformation ( 0 ), m_circuitInfo ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_callIdentifier );
		m_callIdentifier = new CallIdentifier;
		Asn :: Sequence :: includeOptionalField ( e_substituteConfIDs );
		m_substituteConfIDs = new ArrayOf_ConferenceIdentifier;
	} catch ( ... ) {
		delete m_callIdentifier;
		delete m_substituteConfIDs;
		throw;
	}
}

InfoRequestResponse_perCallInfo_subtype & InfoRequestResponse_perCallInfo_subtype :: operator= ( const InfoRequestResponse_perCallInfo_subtype & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	m_callReferenceValue = s.m_callReferenceValue;
	m_conferenceID = s.m_conferenceID;
	assignCopy ( m_originator, s.m_originator );
	assignCopy ( m_audio, s.m_audio );
	assignCopy ( m_video, s.m_video );
	assignCopy ( m_data, s.m_data );
	m_h245 = s.m_h245;
	m_callSignaling = s.m_callSignaling;
	m_callType = s.m_callType;
	m_bandWidth = s.m_bandWidth;
	m_callModel = s.m_callModel;
	assignCopy ( m_callIdentifier, s.m_callIdentifier );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_substituteConfIDs, s.m_substituteConfIDs );
	assignCopy ( m_pdu, s.m_pdu );
	assignCopy ( m_callLinkage, s.m_callLinkage );
	assignCopy ( m_usageInformation, s.m_usageInformation );
	assignCopy ( m_circuitInfo, s.m_circuitInfo );
	return * this;
}

InfoRequestResponse_perCallInfo_subtype :: InfoRequestResponse_perCallInfo_subtype ( const InfoRequestResponse_perCallInfo_subtype & s ) : Asn :: Sequence ( s ), m_nonStandardData ( 0 ), m_callReferenceValue ( s.m_callReferenceValue ), m_conferenceID ( s.m_conferenceID ), m_originator ( 0 ), m_audio ( 0 ), m_video ( 0 ), m_data ( 0 ), m_h245 ( s.m_h245 ), m_callSignaling ( s.m_callSignaling ), m_callType ( s.m_callType ), m_bandWidth ( s.m_bandWidth ), m_callModel ( s.m_callModel ), m_callIdentifier ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_substituteConfIDs ( 0 ), m_pdu ( 0 ), m_callLinkage ( 0 ), m_usageInformation ( 0 ), m_circuitInfo ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_originator )
			m_originator = new Asn :: Boolean ( * s.m_originator );
		if ( s.m_audio )
			m_audio = new ArrayOf_RTPSession ( * s.m_audio );
		if ( s.m_video )
			m_video = new ArrayOf_RTPSession ( * s.m_video );
		if ( s.m_data )
			m_data = new ArrayOf_TransportChannelInfo ( * s.m_data );
		if ( s.m_callIdentifier )
			m_callIdentifier = new CallIdentifier ( * s.m_callIdentifier );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_substituteConfIDs )
			m_substituteConfIDs = new ArrayOf_ConferenceIdentifier ( * s.m_substituteConfIDs );
		if ( s.m_pdu )
			m_pdu = new InfoRequestResponse_perCallInfo_subtype_pdu ( * s.m_pdu );
		if ( s.m_callLinkage )
			m_callLinkage = new CallLinkage ( * s.m_callLinkage );
		if ( s.m_usageInformation )
			m_usageInformation = new RasUsageInformation ( * s.m_usageInformation );
		if ( s.m_circuitInfo )
			m_circuitInfo = new CircuitInfo ( * s.m_circuitInfo );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_originator;
		delete m_audio;
		delete m_video;
		delete m_data;
		delete m_callIdentifier;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_substituteConfIDs;
		delete m_pdu;
		delete m_callLinkage;
		delete m_usageInformation;
		delete m_circuitInfo;
		throw;
	}
}


void InfoRequestResponse_perCallInfo_subtype :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_originator:
			assignNew ( m_originator, new Asn :: Boolean );
			break;
		case e_audio:
			assignNew ( m_audio, new ArrayOf_RTPSession );
			break;
		case e_video:
			assignNew ( m_video, new ArrayOf_RTPSession );
			break;
		case e_data:
			assignNew ( m_data, new ArrayOf_TransportChannelInfo );
			break;
		case e_callIdentifier:
			assignNew ( m_callIdentifier, new CallIdentifier );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_substituteConfIDs:
			assignNew ( m_substituteConfIDs, new ArrayOf_ConferenceIdentifier );
			break;
		case e_pdu:
			assignNew ( m_pdu, new InfoRequestResponse_perCallInfo_subtype_pdu );
			break;
		case e_callLinkage:
			assignNew ( m_callLinkage, new CallLinkage );
			break;
		case e_usageInformation:
			assignNew ( m_usageInformation, new RasUsageInformation );
			break;
		case e_circuitInfo:
			assignNew ( m_circuitInfo, new CircuitInfo );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void InfoRequestResponse_perCallInfo_subtype :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_originator:
			delete m_originator;
			m_originator = 0;
			break;
		case e_audio:
			delete m_audio;
			m_audio = 0;
			break;
		case e_video:
			delete m_video;
			m_video = 0;
			break;
		case e_data:
			delete m_data;
			m_data = 0;
			break;
		case e_callIdentifier:
			delete m_callIdentifier;
			m_callIdentifier = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_substituteConfIDs:
			delete m_substituteConfIDs;
			m_substituteConfIDs = 0;
			break;
		case e_pdu:
			delete m_pdu;
			m_pdu = 0;
			break;
		case e_callLinkage:
			delete m_callLinkage;
			m_callLinkage = 0;
			break;
		case e_usageInformation:
			delete m_usageInformation;
			m_usageInformation = 0;
			break;
		case e_circuitInfo:
			delete m_circuitInfo;
			m_circuitInfo = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void InfoRequestResponse_perCallInfo_subtype :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	m_callReferenceValue.encode ( os );
	m_conferenceID.encode ( os );
	if ( hasOptionalField ( e_originator ) )
		m_originator -> Asn :: Boolean :: encode ( os );
	if ( hasOptionalField ( e_audio ) )
		m_audio -> ArrayOf_RTPSession :: encode ( os );
	if ( hasOptionalField ( e_video ) )
		m_video -> ArrayOf_RTPSession :: encode ( os );
	if ( hasOptionalField ( e_data ) )
		m_data -> ArrayOf_TransportChannelInfo :: encode ( os );
	m_h245.encode ( os );
	m_callSignaling.encode ( os );
	m_callType.encode ( os );
	m_bandWidth.encode ( os );
	m_callModel.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_callIdentifier, m_callIdentifier );
		knownExtensionEncode ( os, e_tokens, m_tokens );
		knownExtensionEncode ( os, e_cryptoTokens, m_cryptoTokens );
		knownExtensionEncode ( os, e_substituteConfIDs, m_substituteConfIDs );
		knownExtensionEncode ( os, e_pdu, m_pdu );
		knownExtensionEncode ( os, e_callLinkage, m_callLinkage );
		knownExtensionEncode ( os, e_usageInformation, m_usageInformation );
		knownExtensionEncode ( os, e_circuitInfo, m_circuitInfo );
		unknownExtensionsEncode ( os );
	}
}

InfoRequestResponse_perCallInfo_subtype :: ~InfoRequestResponse_perCallInfo_subtype ( ) {
	delete m_nonStandardData;
	delete m_originator;
	delete m_audio;
	delete m_video;
	delete m_data;
	delete m_callIdentifier;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_substituteConfIDs;
	delete m_pdu;
	delete m_callLinkage;
	delete m_usageInformation;
	delete m_circuitInfo;
}

void InfoRequestResponse_perCallInfo_subtype :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 21 ) << "callReferenceValue = " << std :: setprecision ( indent ) << m_callReferenceValue << '\n';
	os << std :: setw ( indent + 15 ) << "conferenceID = " << std :: setprecision ( indent ) << m_conferenceID << '\n';
	if ( hasOptionalField ( e_originator ) ) {
		os << std :: setw ( indent + 13 ) << "originator = " << std :: setprecision ( indent );
		m_originator -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_audio ) ) {
		os << std :: setw ( indent + 8 ) << "audio = " << std :: setprecision ( indent );
		m_audio -> ArrayOf_RTPSession :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_video ) ) {
		os << std :: setw ( indent + 8 ) << "video = " << std :: setprecision ( indent );
		m_video -> ArrayOf_RTPSession :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_data ) ) {
		os << std :: setw ( indent + 7 ) << "data = " << std :: setprecision ( indent );
		m_data -> ArrayOf_TransportChannelInfo :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 7 ) << "h245 = " << std :: setprecision ( indent ) << m_h245 << '\n';
	os << std :: setw ( indent + 16 ) << "callSignaling = " << std :: setprecision ( indent ) << m_callSignaling << '\n';
	os << std :: setw ( indent + 11 ) << "callType = " << std :: setprecision ( indent ) << m_callType << '\n';
	os << std :: setw ( indent + 12 ) << "bandWidth = " << std :: setprecision ( indent ) << m_bandWidth << '\n';
	os << std :: setw ( indent + 12 ) << "callModel = " << std :: setprecision ( indent ) << m_callModel << '\n';
	if ( hasOptionalField ( e_callIdentifier ) ) {
		os << std :: setw ( indent + 17 ) << "callIdentifier = " << std :: setprecision ( indent );
		m_callIdentifier -> CallIdentifier :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_substituteConfIDs ) ) {
		os << std :: setw ( indent + 20 ) << "substituteConfIDs = " << std :: setprecision ( indent );
		m_substituteConfIDs -> ArrayOf_ConferenceIdentifier :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_pdu ) ) {
		os << std :: setw ( indent + 6 ) << "pdu = " << std :: setprecision ( indent );
		m_pdu -> InfoRequestResponse_perCallInfo_subtype_pdu :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_callLinkage ) ) {
		os << std :: setw ( indent + 14 ) << "callLinkage = " << std :: setprecision ( indent );
		m_callLinkage -> CallLinkage :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_usageInformation ) ) {
		os << std :: setw ( indent + 19 ) << "usageInformation = " << std :: setprecision ( indent );
		m_usageInformation -> RasUsageInformation :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_circuitInfo ) ) {
		os << std :: setw ( indent + 14 ) << "circuitInfo = " << std :: setprecision ( indent );
		m_circuitInfo -> CircuitInfo :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

InfoRequestResponse_perCallInfo_subtype * InfoRequestResponse_perCallInfo_subtype :: clone ( ) const {
	return new InfoRequestResponse_perCallInfo_subtype ( * this );
}

//
// TransportAddress_ipSourceRoute_route_subtype
//

TransportAddress_ipSourceRoute_route_subtype :: TransportAddress_ipSourceRoute_route_subtype ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 4, 4 ) { }

TransportAddress_ipSourceRoute_route_subtype :: TransportAddress_ipSourceRoute_route_subtype ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 4, 4 ) { }

TransportAddress_ipSourceRoute_route_subtype * TransportAddress_ipSourceRoute_route_subtype :: clone ( ) const {
	return new TransportAddress_ipSourceRoute_route_subtype ( * this );
}

//
// ArrayOf_RTPSession
//

ArrayOf_RTPSession :: ArrayOf_RTPSession ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_RTPSession :: ArrayOf_RTPSession ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_RTPSession :: ArrayOf_RTPSession ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_RTPSession :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_RTPSession :: createObject ( Asn :: istream & is ) {
	return new RTPSession ( is );
}

Asn :: Object * ArrayOf_RTPSession :: createObject ( ) {
	return new RTPSession ( );
}

RTPSession & ArrayOf_RTPSession :: operator[] ( std :: size_t i ) {
	return dynamic_cast < RTPSession & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_RTPSession :: push_back ( const RTPSession & o ) {
	Asn :: Array :: push_back ( new RTPSession ( o ) );
}

const RTPSession & ArrayOf_RTPSession :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const RTPSession & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_RTPSession * ArrayOf_RTPSession :: clone ( ) const {
	return new ArrayOf_RTPSession ( * this );
}

//
// ArrayOf_TransportChannelInfo
//

ArrayOf_TransportChannelInfo :: ArrayOf_TransportChannelInfo ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_TransportChannelInfo :: ArrayOf_TransportChannelInfo ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_TransportChannelInfo :: ArrayOf_TransportChannelInfo ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_TransportChannelInfo :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_TransportChannelInfo :: createObject ( Asn :: istream & is ) {
	return new TransportChannelInfo ( is );
}

Asn :: Object * ArrayOf_TransportChannelInfo :: createObject ( ) {
	return new TransportChannelInfo ( );
}

TransportChannelInfo & ArrayOf_TransportChannelInfo :: operator[] ( std :: size_t i ) {
	return dynamic_cast < TransportChannelInfo & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_TransportChannelInfo :: push_back ( const TransportChannelInfo & o ) {
	Asn :: Array :: push_back ( new TransportChannelInfo ( o ) );
}

const TransportChannelInfo & ArrayOf_TransportChannelInfo :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const TransportChannelInfo & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_TransportChannelInfo * ArrayOf_TransportChannelInfo :: clone ( ) const {
	return new ArrayOf_TransportChannelInfo ( * this );
}

//
// ArrayOf_ConferenceIdentifier
//

ArrayOf_ConferenceIdentifier :: ArrayOf_ConferenceIdentifier ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_ConferenceIdentifier :: ArrayOf_ConferenceIdentifier ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_ConferenceIdentifier :: ArrayOf_ConferenceIdentifier ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_ConferenceIdentifier :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_ConferenceIdentifier :: createObject ( Asn :: istream & is ) {
	return new ConferenceIdentifier ( is );
}

Asn :: Object * ArrayOf_ConferenceIdentifier :: createObject ( ) {
	return new ConferenceIdentifier ( );
}

ConferenceIdentifier & ArrayOf_ConferenceIdentifier :: operator[] ( std :: size_t i ) {
	return dynamic_cast < ConferenceIdentifier & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_ConferenceIdentifier :: push_back ( const ConferenceIdentifier & o ) {
	Asn :: Array :: push_back ( new ConferenceIdentifier ( o ) );
}

const ConferenceIdentifier & ArrayOf_ConferenceIdentifier :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const ConferenceIdentifier & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_ConferenceIdentifier * ArrayOf_ConferenceIdentifier :: clone ( ) const {
	return new ArrayOf_ConferenceIdentifier ( * this );
}

//
// InfoRequestResponse_perCallInfo_subtype_pdu
//

InfoRequestResponse_perCallInfo_subtype_pdu :: InfoRequestResponse_perCallInfo_subtype_pdu ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

InfoRequestResponse_perCallInfo_subtype_pdu :: InfoRequestResponse_perCallInfo_subtype_pdu ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

InfoRequestResponse_perCallInfo_subtype_pdu :: InfoRequestResponse_perCallInfo_subtype_pdu ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * InfoRequestResponse_perCallInfo_subtype_pdu :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * InfoRequestResponse_perCallInfo_subtype_pdu :: createObject ( Asn :: istream & is ) {
	return new InfoRequestResponse_perCallInfo_subtype_pdu_subtype ( is );
}

Asn :: Object * InfoRequestResponse_perCallInfo_subtype_pdu :: createObject ( ) {
	return new InfoRequestResponse_perCallInfo_subtype_pdu_subtype ( );
}

InfoRequestResponse_perCallInfo_subtype_pdu_subtype & InfoRequestResponse_perCallInfo_subtype_pdu :: operator[] ( std :: size_t i ) {
	return dynamic_cast < InfoRequestResponse_perCallInfo_subtype_pdu_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

void InfoRequestResponse_perCallInfo_subtype_pdu :: push_back ( const InfoRequestResponse_perCallInfo_subtype_pdu_subtype & o ) {
	Asn :: Array :: push_back ( new InfoRequestResponse_perCallInfo_subtype_pdu_subtype ( o ) );
}

const InfoRequestResponse_perCallInfo_subtype_pdu_subtype & InfoRequestResponse_perCallInfo_subtype_pdu :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const InfoRequestResponse_perCallInfo_subtype_pdu_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

InfoRequestResponse_perCallInfo_subtype_pdu * InfoRequestResponse_perCallInfo_subtype_pdu :: clone ( ) const {
	return new InfoRequestResponse_perCallInfo_subtype_pdu ( * this );
}

//
// Alerting-UUIE
//

Alerting_UUIE :: Alerting_UUIE ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 14 ), m_protocolIdentifier ( is ), m_destinationInfo ( is ), m_h245Address ( 0 ), m_callIdentifier ( 0 ), m_h245SecurityMode ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_fastStart ( 0 ), m_multipleCalls ( 0 ), m_maintainConnection ( 0 ), m_alertingAddress ( 0 ), m_presentationIndicator ( 0 ), m_screeningIndicator ( 0 ), m_fastConnectRefused ( 0 ), m_serviceControl ( 0 ), m_capacity ( 0 ), m_featureSet ( 0 ) {
	try {
		if ( hasOptionalField ( e_h245Address ) )
			m_h245Address = new TransportAddress ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_callIdentifier ) )
				m_callIdentifier = new CallIdentifier ( is );
			if ( hasKnownExtensionToDecode ( is, e_h245SecurityMode ) )
				m_h245SecurityMode = new H245Security ( is );
			if ( hasKnownExtensionToDecode ( is, e_tokens ) )
				m_tokens = new ArrayOf_ClearToken ( is );
			if ( hasKnownExtensionToDecode ( is, e_cryptoTokens ) )
				m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
			if ( hasKnownExtensionToDecode ( is, e_fastStart ) )
				m_fastStart = new ArrayOf_Asn_OctetString ( is );
			if ( hasKnownExtensionToDecode ( is, e_multipleCalls ) )
				m_multipleCalls = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_maintainConnection ) )
				m_maintainConnection = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_alertingAddress ) )
				m_alertingAddress = new ArrayOf_AliasAddress ( is );
			if ( hasKnownExtensionToDecode ( is, e_presentationIndicator ) )
				m_presentationIndicator = new PresentationIndicator ( is );
			if ( hasKnownExtensionToDecode ( is, e_screeningIndicator ) )
				m_screeningIndicator = new ScreeningIndicator ( is );
			if ( hasKnownExtensionToDecode ( is, e_fastConnectRefused ) )
				m_fastConnectRefused = new Asn :: Null ( is );
			if ( hasKnownExtensionToDecode ( is, e_serviceControl ) )
				m_serviceControl = new ArrayOf_ServiceControlSession ( is );
			if ( hasKnownExtensionToDecode ( is, e_capacity ) )
				m_capacity = new CallCapacity ( is );
			if ( hasKnownExtensionToDecode ( is, e_featureSet ) )
				m_featureSet = new FeatureSet ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_h245Address;
		delete m_callIdentifier;
		delete m_h245SecurityMode;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_fastStart;
		delete m_multipleCalls;
		delete m_maintainConnection;
		delete m_alertingAddress;
		delete m_presentationIndicator;
		delete m_screeningIndicator;
		delete m_fastConnectRefused;
		delete m_serviceControl;
		delete m_capacity;
		delete m_featureSet;
		throw;
	}
}

Alerting_UUIE :: Alerting_UUIE ( ) : Asn :: Sequence ( 1, true, 14 ), m_h245Address ( 0 ), m_callIdentifier ( 0 ), m_h245SecurityMode ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_fastStart ( 0 ), m_multipleCalls ( 0 ), m_maintainConnection ( 0 ), m_alertingAddress ( 0 ), m_presentationIndicator ( 0 ), m_screeningIndicator ( 0 ), m_fastConnectRefused ( 0 ), m_serviceControl ( 0 ), m_capacity ( 0 ), m_featureSet ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_callIdentifier );
		m_callIdentifier = new CallIdentifier;
		Asn :: Sequence :: includeOptionalField ( e_multipleCalls );
		m_multipleCalls = new Asn :: Boolean;
		Asn :: Sequence :: includeOptionalField ( e_maintainConnection );
		m_maintainConnection = new Asn :: Boolean;
	} catch ( ... ) {
		delete m_callIdentifier;
		delete m_multipleCalls;
		delete m_maintainConnection;
		throw;
	}
}

Alerting_UUIE & Alerting_UUIE :: operator= ( const Alerting_UUIE & s ) {
	Asn :: Sequence :: operator= ( s );
	m_protocolIdentifier = s.m_protocolIdentifier;
	m_destinationInfo = s.m_destinationInfo;
	assignCopy ( m_h245Address, s.m_h245Address );
	assignCopy ( m_callIdentifier, s.m_callIdentifier );
	assignCopy ( m_h245SecurityMode, s.m_h245SecurityMode );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_fastStart, s.m_fastStart );
	assignCopy ( m_multipleCalls, s.m_multipleCalls );
	assignCopy ( m_maintainConnection, s.m_maintainConnection );
	assignCopy ( m_alertingAddress, s.m_alertingAddress );
	assignCopy ( m_presentationIndicator, s.m_presentationIndicator );
	assignCopy ( m_screeningIndicator, s.m_screeningIndicator );
	assignCopy ( m_fastConnectRefused, s.m_fastConnectRefused );
	assignCopy ( m_serviceControl, s.m_serviceControl );
	assignCopy ( m_capacity, s.m_capacity );
	assignCopy ( m_featureSet, s.m_featureSet );
	return * this;
}

Alerting_UUIE :: Alerting_UUIE ( const Alerting_UUIE & s ) : Asn :: Sequence ( s ), m_protocolIdentifier ( s.m_protocolIdentifier ), m_destinationInfo ( s.m_destinationInfo ), m_h245Address ( 0 ), m_callIdentifier ( 0 ), m_h245SecurityMode ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_fastStart ( 0 ), m_multipleCalls ( 0 ), m_maintainConnection ( 0 ), m_alertingAddress ( 0 ), m_presentationIndicator ( 0 ), m_screeningIndicator ( 0 ), m_fastConnectRefused ( 0 ), m_serviceControl ( 0 ), m_capacity ( 0 ), m_featureSet ( 0 ) {
	try {
		if ( s.m_h245Address )
			m_h245Address = new TransportAddress ( * s.m_h245Address );
		if ( s.m_callIdentifier )
			m_callIdentifier = new CallIdentifier ( * s.m_callIdentifier );
		if ( s.m_h245SecurityMode )
			m_h245SecurityMode = new H245Security ( * s.m_h245SecurityMode );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_fastStart )
			m_fastStart = new ArrayOf_Asn_OctetString ( * s.m_fastStart );
		if ( s.m_multipleCalls )
			m_multipleCalls = new Asn :: Boolean ( * s.m_multipleCalls );
		if ( s.m_maintainConnection )
			m_maintainConnection = new Asn :: Boolean ( * s.m_maintainConnection );
		if ( s.m_alertingAddress )
			m_alertingAddress = new ArrayOf_AliasAddress ( * s.m_alertingAddress );
		if ( s.m_presentationIndicator )
			m_presentationIndicator = new PresentationIndicator ( * s.m_presentationIndicator );
		if ( s.m_screeningIndicator )
			m_screeningIndicator = new ScreeningIndicator ( * s.m_screeningIndicator );
		if ( s.m_fastConnectRefused )
			m_fastConnectRefused = new Asn :: Null ( * s.m_fastConnectRefused );
		if ( s.m_serviceControl )
			m_serviceControl = new ArrayOf_ServiceControlSession ( * s.m_serviceControl );
		if ( s.m_capacity )
			m_capacity = new CallCapacity ( * s.m_capacity );
		if ( s.m_featureSet )
			m_featureSet = new FeatureSet ( * s.m_featureSet );
	} catch ( ... ) {
		delete m_h245Address;
		delete m_callIdentifier;
		delete m_h245SecurityMode;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_fastStart;
		delete m_multipleCalls;
		delete m_maintainConnection;
		delete m_alertingAddress;
		delete m_presentationIndicator;
		delete m_screeningIndicator;
		delete m_fastConnectRefused;
		delete m_serviceControl;
		delete m_capacity;
		delete m_featureSet;
		throw;
	}
}


void Alerting_UUIE :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_h245Address:
			assignNew ( m_h245Address, new TransportAddress );
			break;
		case e_callIdentifier:
			assignNew ( m_callIdentifier, new CallIdentifier );
			break;
		case e_h245SecurityMode:
			assignNew ( m_h245SecurityMode, new H245Security );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_fastStart:
			assignNew ( m_fastStart, new ArrayOf_Asn_OctetString );
			break;
		case e_multipleCalls:
			assignNew ( m_multipleCalls, new Asn :: Boolean );
			break;
		case e_maintainConnection:
			assignNew ( m_maintainConnection, new Asn :: Boolean );
			break;
		case e_alertingAddress:
			assignNew ( m_alertingAddress, new ArrayOf_AliasAddress );
			break;
		case e_presentationIndicator:
			assignNew ( m_presentationIndicator, new PresentationIndicator );
			break;
		case e_screeningIndicator:
			assignNew ( m_screeningIndicator, new ScreeningIndicator );
			break;
		case e_fastConnectRefused:
			assignNew ( m_fastConnectRefused, new Asn :: Null );
			break;
		case e_serviceControl:
			assignNew ( m_serviceControl, new ArrayOf_ServiceControlSession );
			break;
		case e_capacity:
			assignNew ( m_capacity, new CallCapacity );
			break;
		case e_featureSet:
			assignNew ( m_featureSet, new FeatureSet );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void Alerting_UUIE :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_h245Address:
			delete m_h245Address;
			m_h245Address = 0;
			break;
		case e_callIdentifier:
			delete m_callIdentifier;
			m_callIdentifier = 0;
			break;
		case e_h245SecurityMode:
			delete m_h245SecurityMode;
			m_h245SecurityMode = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_fastStart:
			delete m_fastStart;
			m_fastStart = 0;
			break;
		case e_multipleCalls:
			delete m_multipleCalls;
			m_multipleCalls = 0;
			break;
		case e_maintainConnection:
			delete m_maintainConnection;
			m_maintainConnection = 0;
			break;
		case e_alertingAddress:
			delete m_alertingAddress;
			m_alertingAddress = 0;
			break;
		case e_presentationIndicator:
			delete m_presentationIndicator;
			m_presentationIndicator = 0;
			break;
		case e_screeningIndicator:
			delete m_screeningIndicator;
			m_screeningIndicator = 0;
			break;
		case e_fastConnectRefused:
			delete m_fastConnectRefused;
			m_fastConnectRefused = 0;
			break;
		case e_serviceControl:
			delete m_serviceControl;
			m_serviceControl = 0;
			break;
		case e_capacity:
			delete m_capacity;
			m_capacity = 0;
			break;
		case e_featureSet:
			delete m_featureSet;
			m_featureSet = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void Alerting_UUIE :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_protocolIdentifier.encode ( os );
	m_destinationInfo.encode ( os );
	if ( hasOptionalField ( e_h245Address ) )
		m_h245Address -> TransportAddress :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_callIdentifier, m_callIdentifier );
		knownExtensionEncode ( os, e_h245SecurityMode, m_h245SecurityMode );
		knownExtensionEncode ( os, e_tokens, m_tokens );
		knownExtensionEncode ( os, e_cryptoTokens, m_cryptoTokens );
		knownExtensionEncode ( os, e_fastStart, m_fastStart );
		knownExtensionEncode ( os, e_multipleCalls, m_multipleCalls );
		knownExtensionEncode ( os, e_maintainConnection, m_maintainConnection );
		knownExtensionEncode ( os, e_alertingAddress, m_alertingAddress );
		knownExtensionEncode ( os, e_presentationIndicator, m_presentationIndicator );
		knownExtensionEncode ( os, e_screeningIndicator, m_screeningIndicator );
		knownExtensionEncode ( os, e_fastConnectRefused, m_fastConnectRefused );
		knownExtensionEncode ( os, e_serviceControl, m_serviceControl );
		knownExtensionEncode ( os, e_capacity, m_capacity );
		knownExtensionEncode ( os, e_featureSet, m_featureSet );
		unknownExtensionsEncode ( os );
	}
}

Alerting_UUIE :: ~Alerting_UUIE ( ) {
	delete m_h245Address;
	delete m_callIdentifier;
	delete m_h245SecurityMode;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_fastStart;
	delete m_multipleCalls;
	delete m_maintainConnection;
	delete m_alertingAddress;
	delete m_presentationIndicator;
	delete m_screeningIndicator;
	delete m_fastConnectRefused;
	delete m_serviceControl;
	delete m_capacity;
	delete m_featureSet;
}

void Alerting_UUIE :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 21 ) << "protocolIdentifier = " << std :: setprecision ( indent ) << m_protocolIdentifier << '\n';
	os << std :: setw ( indent + 18 ) << "destinationInfo = " << std :: setprecision ( indent ) << m_destinationInfo << '\n';
	if ( hasOptionalField ( e_h245Address ) ) {
		os << std :: setw ( indent + 14 ) << "h245Address = " << std :: setprecision ( indent );
		m_h245Address -> TransportAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_callIdentifier ) ) {
		os << std :: setw ( indent + 17 ) << "callIdentifier = " << std :: setprecision ( indent );
		m_callIdentifier -> CallIdentifier :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_h245SecurityMode ) ) {
		os << std :: setw ( indent + 19 ) << "h245SecurityMode = " << std :: setprecision ( indent );
		m_h245SecurityMode -> H245Security :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_fastStart ) ) {
		os << std :: setw ( indent + 12 ) << "fastStart = " << std :: setprecision ( indent );
		m_fastStart -> ArrayOf_Asn_OctetString :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_multipleCalls ) ) {
		os << std :: setw ( indent + 16 ) << "multipleCalls = " << std :: setprecision ( indent );
		m_multipleCalls -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_maintainConnection ) ) {
		os << std :: setw ( indent + 21 ) << "maintainConnection = " << std :: setprecision ( indent );
		m_maintainConnection -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_alertingAddress ) ) {
		os << std :: setw ( indent + 18 ) << "alertingAddress = " << std :: setprecision ( indent );
		m_alertingAddress -> ArrayOf_AliasAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_presentationIndicator ) ) {
		os << std :: setw ( indent + 24 ) << "presentationIndicator = " << std :: setprecision ( indent );
		m_presentationIndicator -> PresentationIndicator :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_screeningIndicator ) ) {
		os << std :: setw ( indent + 21 ) << "screeningIndicator = " << std :: setprecision ( indent );
		m_screeningIndicator -> ScreeningIndicator :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_fastConnectRefused ) ) {
		os << std :: setw ( indent + 21 ) << "fastConnectRefused = " << std :: setprecision ( indent );
		m_fastConnectRefused -> Asn :: Null :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_serviceControl ) ) {
		os << std :: setw ( indent + 17 ) << "serviceControl = " << std :: setprecision ( indent );
		m_serviceControl -> ArrayOf_ServiceControlSession :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_capacity ) ) {
		os << std :: setw ( indent + 11 ) << "capacity = " << std :: setprecision ( indent );
		m_capacity -> CallCapacity :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_featureSet ) ) {
		os << std :: setw ( indent + 13 ) << "featureSet = " << std :: setprecision ( indent );
		m_featureSet -> FeatureSet :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

Alerting_UUIE * Alerting_UUIE :: clone ( ) const {
	return new Alerting_UUIE ( * this );
}

//
// CallProceeding-UUIE
//

CallProceeding_UUIE :: CallProceeding_UUIE ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 9 ), m_protocolIdentifier ( is ), m_destinationInfo ( is ), m_h245Address ( 0 ), m_callIdentifier ( 0 ), m_h245SecurityMode ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_fastStart ( 0 ), m_multipleCalls ( 0 ), m_maintainConnection ( 0 ), m_fastConnectRefused ( 0 ), m_featureSet ( 0 ) {
	try {
		if ( hasOptionalField ( e_h245Address ) )
			m_h245Address = new TransportAddress ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_callIdentifier ) )
				m_callIdentifier = new CallIdentifier ( is );
			if ( hasKnownExtensionToDecode ( is, e_h245SecurityMode ) )
				m_h245SecurityMode = new H245Security ( is );
			if ( hasKnownExtensionToDecode ( is, e_tokens ) )
				m_tokens = new ArrayOf_ClearToken ( is );
			if ( hasKnownExtensionToDecode ( is, e_cryptoTokens ) )
				m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
			if ( hasKnownExtensionToDecode ( is, e_fastStart ) )
				m_fastStart = new ArrayOf_Asn_OctetString ( is );
			if ( hasKnownExtensionToDecode ( is, e_multipleCalls ) )
				m_multipleCalls = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_maintainConnection ) )
				m_maintainConnection = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_fastConnectRefused ) )
				m_fastConnectRefused = new Asn :: Null ( is );
			if ( hasKnownExtensionToDecode ( is, e_featureSet ) )
				m_featureSet = new FeatureSet ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_h245Address;
		delete m_callIdentifier;
		delete m_h245SecurityMode;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_fastStart;
		delete m_multipleCalls;
		delete m_maintainConnection;
		delete m_fastConnectRefused;
		delete m_featureSet;
		throw;
	}
}

CallProceeding_UUIE :: CallProceeding_UUIE ( ) : Asn :: Sequence ( 1, true, 9 ), m_h245Address ( 0 ), m_callIdentifier ( 0 ), m_h245SecurityMode ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_fastStart ( 0 ), m_multipleCalls ( 0 ), m_maintainConnection ( 0 ), m_fastConnectRefused ( 0 ), m_featureSet ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_callIdentifier );
		m_callIdentifier = new CallIdentifier;
		Asn :: Sequence :: includeOptionalField ( e_multipleCalls );
		m_multipleCalls = new Asn :: Boolean;
		Asn :: Sequence :: includeOptionalField ( e_maintainConnection );
		m_maintainConnection = new Asn :: Boolean;
	} catch ( ... ) {
		delete m_callIdentifier;
		delete m_multipleCalls;
		delete m_maintainConnection;
		throw;
	}
}

CallProceeding_UUIE & CallProceeding_UUIE :: operator= ( const CallProceeding_UUIE & s ) {
	Asn :: Sequence :: operator= ( s );
	m_protocolIdentifier = s.m_protocolIdentifier;
	m_destinationInfo = s.m_destinationInfo;
	assignCopy ( m_h245Address, s.m_h245Address );
	assignCopy ( m_callIdentifier, s.m_callIdentifier );
	assignCopy ( m_h245SecurityMode, s.m_h245SecurityMode );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_fastStart, s.m_fastStart );
	assignCopy ( m_multipleCalls, s.m_multipleCalls );
	assignCopy ( m_maintainConnection, s.m_maintainConnection );
	assignCopy ( m_fastConnectRefused, s.m_fastConnectRefused );
	assignCopy ( m_featureSet, s.m_featureSet );
	return * this;
}

CallProceeding_UUIE :: CallProceeding_UUIE ( const CallProceeding_UUIE & s ) : Asn :: Sequence ( s ), m_protocolIdentifier ( s.m_protocolIdentifier ), m_destinationInfo ( s.m_destinationInfo ), m_h245Address ( 0 ), m_callIdentifier ( 0 ), m_h245SecurityMode ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_fastStart ( 0 ), m_multipleCalls ( 0 ), m_maintainConnection ( 0 ), m_fastConnectRefused ( 0 ), m_featureSet ( 0 ) {
	try {
		if ( s.m_h245Address )
			m_h245Address = new TransportAddress ( * s.m_h245Address );
		if ( s.m_callIdentifier )
			m_callIdentifier = new CallIdentifier ( * s.m_callIdentifier );
		if ( s.m_h245SecurityMode )
			m_h245SecurityMode = new H245Security ( * s.m_h245SecurityMode );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_fastStart )
			m_fastStart = new ArrayOf_Asn_OctetString ( * s.m_fastStart );
		if ( s.m_multipleCalls )
			m_multipleCalls = new Asn :: Boolean ( * s.m_multipleCalls );
		if ( s.m_maintainConnection )
			m_maintainConnection = new Asn :: Boolean ( * s.m_maintainConnection );
		if ( s.m_fastConnectRefused )
			m_fastConnectRefused = new Asn :: Null ( * s.m_fastConnectRefused );
		if ( s.m_featureSet )
			m_featureSet = new FeatureSet ( * s.m_featureSet );
	} catch ( ... ) {
		delete m_h245Address;
		delete m_callIdentifier;
		delete m_h245SecurityMode;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_fastStart;
		delete m_multipleCalls;
		delete m_maintainConnection;
		delete m_fastConnectRefused;
		delete m_featureSet;
		throw;
	}
}


void CallProceeding_UUIE :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_h245Address:
			assignNew ( m_h245Address, new TransportAddress );
			break;
		case e_callIdentifier:
			assignNew ( m_callIdentifier, new CallIdentifier );
			break;
		case e_h245SecurityMode:
			assignNew ( m_h245SecurityMode, new H245Security );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_fastStart:
			assignNew ( m_fastStart, new ArrayOf_Asn_OctetString );
			break;
		case e_multipleCalls:
			assignNew ( m_multipleCalls, new Asn :: Boolean );
			break;
		case e_maintainConnection:
			assignNew ( m_maintainConnection, new Asn :: Boolean );
			break;
		case e_fastConnectRefused:
			assignNew ( m_fastConnectRefused, new Asn :: Null );
			break;
		case e_featureSet:
			assignNew ( m_featureSet, new FeatureSet );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void CallProceeding_UUIE :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_h245Address:
			delete m_h245Address;
			m_h245Address = 0;
			break;
		case e_callIdentifier:
			delete m_callIdentifier;
			m_callIdentifier = 0;
			break;
		case e_h245SecurityMode:
			delete m_h245SecurityMode;
			m_h245SecurityMode = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_fastStart:
			delete m_fastStart;
			m_fastStart = 0;
			break;
		case e_multipleCalls:
			delete m_multipleCalls;
			m_multipleCalls = 0;
			break;
		case e_maintainConnection:
			delete m_maintainConnection;
			m_maintainConnection = 0;
			break;
		case e_fastConnectRefused:
			delete m_fastConnectRefused;
			m_fastConnectRefused = 0;
			break;
		case e_featureSet:
			delete m_featureSet;
			m_featureSet = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void CallProceeding_UUIE :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_protocolIdentifier.encode ( os );
	m_destinationInfo.encode ( os );
	if ( hasOptionalField ( e_h245Address ) )
		m_h245Address -> TransportAddress :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_callIdentifier, m_callIdentifier );
		knownExtensionEncode ( os, e_h245SecurityMode, m_h245SecurityMode );
		knownExtensionEncode ( os, e_tokens, m_tokens );
		knownExtensionEncode ( os, e_cryptoTokens, m_cryptoTokens );
		knownExtensionEncode ( os, e_fastStart, m_fastStart );
		knownExtensionEncode ( os, e_multipleCalls, m_multipleCalls );
		knownExtensionEncode ( os, e_maintainConnection, m_maintainConnection );
		knownExtensionEncode ( os, e_fastConnectRefused, m_fastConnectRefused );
		knownExtensionEncode ( os, e_featureSet, m_featureSet );
		unknownExtensionsEncode ( os );
	}
}

CallProceeding_UUIE :: ~CallProceeding_UUIE ( ) {
	delete m_h245Address;
	delete m_callIdentifier;
	delete m_h245SecurityMode;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_fastStart;
	delete m_multipleCalls;
	delete m_maintainConnection;
	delete m_fastConnectRefused;
	delete m_featureSet;
}

void CallProceeding_UUIE :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 21 ) << "protocolIdentifier = " << std :: setprecision ( indent ) << m_protocolIdentifier << '\n';
	os << std :: setw ( indent + 18 ) << "destinationInfo = " << std :: setprecision ( indent ) << m_destinationInfo << '\n';
	if ( hasOptionalField ( e_h245Address ) ) {
		os << std :: setw ( indent + 14 ) << "h245Address = " << std :: setprecision ( indent );
		m_h245Address -> TransportAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_callIdentifier ) ) {
		os << std :: setw ( indent + 17 ) << "callIdentifier = " << std :: setprecision ( indent );
		m_callIdentifier -> CallIdentifier :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_h245SecurityMode ) ) {
		os << std :: setw ( indent + 19 ) << "h245SecurityMode = " << std :: setprecision ( indent );
		m_h245SecurityMode -> H245Security :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_fastStart ) ) {
		os << std :: setw ( indent + 12 ) << "fastStart = " << std :: setprecision ( indent );
		m_fastStart -> ArrayOf_Asn_OctetString :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_multipleCalls ) ) {
		os << std :: setw ( indent + 16 ) << "multipleCalls = " << std :: setprecision ( indent );
		m_multipleCalls -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_maintainConnection ) ) {
		os << std :: setw ( indent + 21 ) << "maintainConnection = " << std :: setprecision ( indent );
		m_maintainConnection -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_fastConnectRefused ) ) {
		os << std :: setw ( indent + 21 ) << "fastConnectRefused = " << std :: setprecision ( indent );
		m_fastConnectRefused -> Asn :: Null :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_featureSet ) ) {
		os << std :: setw ( indent + 13 ) << "featureSet = " << std :: setprecision ( indent );
		m_featureSet -> FeatureSet :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

CallProceeding_UUIE * CallProceeding_UUIE :: clone ( ) const {
	return new CallProceeding_UUIE ( * this );
}

//
// Connect-UUIE
//

Connect_UUIE :: Connect_UUIE ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 15 ), m_protocolIdentifier ( is ), m_h245Address ( hasOptionalField ( e_h245Address ) ? pushTemporaryMember ( new TransportAddress ( is ) ) : 0 ), m_destinationInfo ( is ), m_conferenceID ( is ), m_callIdentifier ( 0 ), m_h245SecurityMode ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_fastStart ( 0 ), m_multipleCalls ( 0 ), m_maintainConnection ( 0 ), m_language ( 0 ), m_connectedAddress ( 0 ), m_presentationIndicator ( 0 ), m_screeningIndicator ( 0 ), m_fastConnectRefused ( 0 ), m_serviceControl ( 0 ), m_capacity ( 0 ), m_featureSet ( 0 ) {
	clearTemporaryMembers ( );
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_callIdentifier ) )
				m_callIdentifier = new CallIdentifier ( is );
			if ( hasKnownExtensionToDecode ( is, e_h245SecurityMode ) )
				m_h245SecurityMode = new H245Security ( is );
			if ( hasKnownExtensionToDecode ( is, e_tokens ) )
				m_tokens = new ArrayOf_ClearToken ( is );
			if ( hasKnownExtensionToDecode ( is, e_cryptoTokens ) )
				m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
			if ( hasKnownExtensionToDecode ( is, e_fastStart ) )
				m_fastStart = new ArrayOf_Asn_OctetString ( is );
			if ( hasKnownExtensionToDecode ( is, e_multipleCalls ) )
				m_multipleCalls = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_maintainConnection ) )
				m_maintainConnection = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_language ) )
				m_language = new Connect_UUIE_language ( is );
			if ( hasKnownExtensionToDecode ( is, e_connectedAddress ) )
				m_connectedAddress = new ArrayOf_AliasAddress ( is );
			if ( hasKnownExtensionToDecode ( is, e_presentationIndicator ) )
				m_presentationIndicator = new PresentationIndicator ( is );
			if ( hasKnownExtensionToDecode ( is, e_screeningIndicator ) )
				m_screeningIndicator = new ScreeningIndicator ( is );
			if ( hasKnownExtensionToDecode ( is, e_fastConnectRefused ) )
				m_fastConnectRefused = new Asn :: Null ( is );
			if ( hasKnownExtensionToDecode ( is, e_serviceControl ) )
				m_serviceControl = new ArrayOf_ServiceControlSession ( is );
			if ( hasKnownExtensionToDecode ( is, e_capacity ) )
				m_capacity = new CallCapacity ( is );
			if ( hasKnownExtensionToDecode ( is, e_featureSet ) )
				m_featureSet = new FeatureSet ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_h245Address;
		delete m_callIdentifier;
		delete m_h245SecurityMode;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_fastStart;
		delete m_multipleCalls;
		delete m_maintainConnection;
		delete m_language;
		delete m_connectedAddress;
		delete m_presentationIndicator;
		delete m_screeningIndicator;
		delete m_fastConnectRefused;
		delete m_serviceControl;
		delete m_capacity;
		delete m_featureSet;
		throw;
	}
}

Connect_UUIE :: Connect_UUIE ( ) : Asn :: Sequence ( 1, true, 15 ), m_h245Address ( 0 ), m_callIdentifier ( 0 ), m_h245SecurityMode ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_fastStart ( 0 ), m_multipleCalls ( 0 ), m_maintainConnection ( 0 ), m_language ( 0 ), m_connectedAddress ( 0 ), m_presentationIndicator ( 0 ), m_screeningIndicator ( 0 ), m_fastConnectRefused ( 0 ), m_serviceControl ( 0 ), m_capacity ( 0 ), m_featureSet ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_callIdentifier );
		m_callIdentifier = new CallIdentifier;
		Asn :: Sequence :: includeOptionalField ( e_multipleCalls );
		m_multipleCalls = new Asn :: Boolean;
		Asn :: Sequence :: includeOptionalField ( e_maintainConnection );
		m_maintainConnection = new Asn :: Boolean;
	} catch ( ... ) {
		delete m_callIdentifier;
		delete m_multipleCalls;
		delete m_maintainConnection;
		throw;
	}
}

Connect_UUIE & Connect_UUIE :: operator= ( const Connect_UUIE & s ) {
	Asn :: Sequence :: operator= ( s );
	m_protocolIdentifier = s.m_protocolIdentifier;
	assignCopy ( m_h245Address, s.m_h245Address );
	m_destinationInfo = s.m_destinationInfo;
	m_conferenceID = s.m_conferenceID;
	assignCopy ( m_callIdentifier, s.m_callIdentifier );
	assignCopy ( m_h245SecurityMode, s.m_h245SecurityMode );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_fastStart, s.m_fastStart );
	assignCopy ( m_multipleCalls, s.m_multipleCalls );
	assignCopy ( m_maintainConnection, s.m_maintainConnection );
	assignCopy ( m_language, s.m_language );
	assignCopy ( m_connectedAddress, s.m_connectedAddress );
	assignCopy ( m_presentationIndicator, s.m_presentationIndicator );
	assignCopy ( m_screeningIndicator, s.m_screeningIndicator );
	assignCopy ( m_fastConnectRefused, s.m_fastConnectRefused );
	assignCopy ( m_serviceControl, s.m_serviceControl );
	assignCopy ( m_capacity, s.m_capacity );
	assignCopy ( m_featureSet, s.m_featureSet );
	return * this;
}

Connect_UUIE :: Connect_UUIE ( const Connect_UUIE & s ) : Asn :: Sequence ( s ), m_protocolIdentifier ( s.m_protocolIdentifier ), m_h245Address ( 0 ), m_destinationInfo ( s.m_destinationInfo ), m_conferenceID ( s.m_conferenceID ), m_callIdentifier ( 0 ), m_h245SecurityMode ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_fastStart ( 0 ), m_multipleCalls ( 0 ), m_maintainConnection ( 0 ), m_language ( 0 ), m_connectedAddress ( 0 ), m_presentationIndicator ( 0 ), m_screeningIndicator ( 0 ), m_fastConnectRefused ( 0 ), m_serviceControl ( 0 ), m_capacity ( 0 ), m_featureSet ( 0 ) {
	try {
		if ( s.m_h245Address )
			m_h245Address = new TransportAddress ( * s.m_h245Address );
		if ( s.m_callIdentifier )
			m_callIdentifier = new CallIdentifier ( * s.m_callIdentifier );
		if ( s.m_h245SecurityMode )
			m_h245SecurityMode = new H245Security ( * s.m_h245SecurityMode );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_fastStart )
			m_fastStart = new ArrayOf_Asn_OctetString ( * s.m_fastStart );
		if ( s.m_multipleCalls )
			m_multipleCalls = new Asn :: Boolean ( * s.m_multipleCalls );
		if ( s.m_maintainConnection )
			m_maintainConnection = new Asn :: Boolean ( * s.m_maintainConnection );
		if ( s.m_language )
			m_language = new Connect_UUIE_language ( * s.m_language );
		if ( s.m_connectedAddress )
			m_connectedAddress = new ArrayOf_AliasAddress ( * s.m_connectedAddress );
		if ( s.m_presentationIndicator )
			m_presentationIndicator = new PresentationIndicator ( * s.m_presentationIndicator );
		if ( s.m_screeningIndicator )
			m_screeningIndicator = new ScreeningIndicator ( * s.m_screeningIndicator );
		if ( s.m_fastConnectRefused )
			m_fastConnectRefused = new Asn :: Null ( * s.m_fastConnectRefused );
		if ( s.m_serviceControl )
			m_serviceControl = new ArrayOf_ServiceControlSession ( * s.m_serviceControl );
		if ( s.m_capacity )
			m_capacity = new CallCapacity ( * s.m_capacity );
		if ( s.m_featureSet )
			m_featureSet = new FeatureSet ( * s.m_featureSet );
	} catch ( ... ) {
		delete m_h245Address;
		delete m_callIdentifier;
		delete m_h245SecurityMode;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_fastStart;
		delete m_multipleCalls;
		delete m_maintainConnection;
		delete m_language;
		delete m_connectedAddress;
		delete m_presentationIndicator;
		delete m_screeningIndicator;
		delete m_fastConnectRefused;
		delete m_serviceControl;
		delete m_capacity;
		delete m_featureSet;
		throw;
	}
}


void Connect_UUIE :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_h245Address:
			assignNew ( m_h245Address, new TransportAddress );
			break;
		case e_callIdentifier:
			assignNew ( m_callIdentifier, new CallIdentifier );
			break;
		case e_h245SecurityMode:
			assignNew ( m_h245SecurityMode, new H245Security );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_fastStart:
			assignNew ( m_fastStart, new ArrayOf_Asn_OctetString );
			break;
		case e_multipleCalls:
			assignNew ( m_multipleCalls, new Asn :: Boolean );
			break;
		case e_maintainConnection:
			assignNew ( m_maintainConnection, new Asn :: Boolean );
			break;
		case e_language:
			assignNew ( m_language, new Connect_UUIE_language );
			break;
		case e_connectedAddress:
			assignNew ( m_connectedAddress, new ArrayOf_AliasAddress );
			break;
		case e_presentationIndicator:
			assignNew ( m_presentationIndicator, new PresentationIndicator );
			break;
		case e_screeningIndicator:
			assignNew ( m_screeningIndicator, new ScreeningIndicator );
			break;
		case e_fastConnectRefused:
			assignNew ( m_fastConnectRefused, new Asn :: Null );
			break;
		case e_serviceControl:
			assignNew ( m_serviceControl, new ArrayOf_ServiceControlSession );
			break;
		case e_capacity:
			assignNew ( m_capacity, new CallCapacity );
			break;
		case e_featureSet:
			assignNew ( m_featureSet, new FeatureSet );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void Connect_UUIE :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_h245Address:
			delete m_h245Address;
			m_h245Address = 0;
			break;
		case e_callIdentifier:
			delete m_callIdentifier;
			m_callIdentifier = 0;
			break;
		case e_h245SecurityMode:
			delete m_h245SecurityMode;
			m_h245SecurityMode = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_fastStart:
			delete m_fastStart;
			m_fastStart = 0;
			break;
		case e_multipleCalls:
			delete m_multipleCalls;
			m_multipleCalls = 0;
			break;
		case e_maintainConnection:
			delete m_maintainConnection;
			m_maintainConnection = 0;
			break;
		case e_language:
			delete m_language;
			m_language = 0;
			break;
		case e_connectedAddress:
			delete m_connectedAddress;
			m_connectedAddress = 0;
			break;
		case e_presentationIndicator:
			delete m_presentationIndicator;
			m_presentationIndicator = 0;
			break;
		case e_screeningIndicator:
			delete m_screeningIndicator;
			m_screeningIndicator = 0;
			break;
		case e_fastConnectRefused:
			delete m_fastConnectRefused;
			m_fastConnectRefused = 0;
			break;
		case e_serviceControl:
			delete m_serviceControl;
			m_serviceControl = 0;
			break;
		case e_capacity:
			delete m_capacity;
			m_capacity = 0;
			break;
		case e_featureSet:
			delete m_featureSet;
			m_featureSet = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void Connect_UUIE :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_protocolIdentifier.encode ( os );
	if ( hasOptionalField ( e_h245Address ) )
		m_h245Address -> TransportAddress :: encode ( os );
	m_destinationInfo.encode ( os );
	m_conferenceID.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_callIdentifier, m_callIdentifier );
		knownExtensionEncode ( os, e_h245SecurityMode, m_h245SecurityMode );
		knownExtensionEncode ( os, e_tokens, m_tokens );
		knownExtensionEncode ( os, e_cryptoTokens, m_cryptoTokens );
		knownExtensionEncode ( os, e_fastStart, m_fastStart );
		knownExtensionEncode ( os, e_multipleCalls, m_multipleCalls );
		knownExtensionEncode ( os, e_maintainConnection, m_maintainConnection );
		knownExtensionEncode ( os, e_language, m_language );
		knownExtensionEncode ( os, e_connectedAddress, m_connectedAddress );
		knownExtensionEncode ( os, e_presentationIndicator, m_presentationIndicator );
		knownExtensionEncode ( os, e_screeningIndicator, m_screeningIndicator );
		knownExtensionEncode ( os, e_fastConnectRefused, m_fastConnectRefused );
		knownExtensionEncode ( os, e_serviceControl, m_serviceControl );
		knownExtensionEncode ( os, e_capacity, m_capacity );
		knownExtensionEncode ( os, e_featureSet, m_featureSet );
		unknownExtensionsEncode ( os );
	}
}

Connect_UUIE :: ~Connect_UUIE ( ) {
	delete m_h245Address;
	delete m_callIdentifier;
	delete m_h245SecurityMode;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_fastStart;
	delete m_multipleCalls;
	delete m_maintainConnection;
	delete m_language;
	delete m_connectedAddress;
	delete m_presentationIndicator;
	delete m_screeningIndicator;
	delete m_fastConnectRefused;
	delete m_serviceControl;
	delete m_capacity;
	delete m_featureSet;
}

void Connect_UUIE :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 21 ) << "protocolIdentifier = " << std :: setprecision ( indent ) << m_protocolIdentifier << '\n';
	if ( hasOptionalField ( e_h245Address ) ) {
		os << std :: setw ( indent + 14 ) << "h245Address = " << std :: setprecision ( indent );
		m_h245Address -> TransportAddress :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 18 ) << "destinationInfo = " << std :: setprecision ( indent ) << m_destinationInfo << '\n';
	os << std :: setw ( indent + 15 ) << "conferenceID = " << std :: setprecision ( indent ) << m_conferenceID << '\n';
	if ( hasOptionalField ( e_callIdentifier ) ) {
		os << std :: setw ( indent + 17 ) << "callIdentifier = " << std :: setprecision ( indent );
		m_callIdentifier -> CallIdentifier :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_h245SecurityMode ) ) {
		os << std :: setw ( indent + 19 ) << "h245SecurityMode = " << std :: setprecision ( indent );
		m_h245SecurityMode -> H245Security :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_fastStart ) ) {
		os << std :: setw ( indent + 12 ) << "fastStart = " << std :: setprecision ( indent );
		m_fastStart -> ArrayOf_Asn_OctetString :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_multipleCalls ) ) {
		os << std :: setw ( indent + 16 ) << "multipleCalls = " << std :: setprecision ( indent );
		m_multipleCalls -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_maintainConnection ) ) {
		os << std :: setw ( indent + 21 ) << "maintainConnection = " << std :: setprecision ( indent );
		m_maintainConnection -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_language ) ) {
		os << std :: setw ( indent + 11 ) << "language = " << std :: setprecision ( indent );
		m_language -> Connect_UUIE_language :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_connectedAddress ) ) {
		os << std :: setw ( indent + 19 ) << "connectedAddress = " << std :: setprecision ( indent );
		m_connectedAddress -> ArrayOf_AliasAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_presentationIndicator ) ) {
		os << std :: setw ( indent + 24 ) << "presentationIndicator = " << std :: setprecision ( indent );
		m_presentationIndicator -> PresentationIndicator :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_screeningIndicator ) ) {
		os << std :: setw ( indent + 21 ) << "screeningIndicator = " << std :: setprecision ( indent );
		m_screeningIndicator -> ScreeningIndicator :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_fastConnectRefused ) ) {
		os << std :: setw ( indent + 21 ) << "fastConnectRefused = " << std :: setprecision ( indent );
		m_fastConnectRefused -> Asn :: Null :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_serviceControl ) ) {
		os << std :: setw ( indent + 17 ) << "serviceControl = " << std :: setprecision ( indent );
		m_serviceControl -> ArrayOf_ServiceControlSession :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_capacity ) ) {
		os << std :: setw ( indent + 11 ) << "capacity = " << std :: setprecision ( indent );
		m_capacity -> CallCapacity :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_featureSet ) ) {
		os << std :: setw ( indent + 13 ) << "featureSet = " << std :: setprecision ( indent );
		m_featureSet -> FeatureSet :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

Connect_UUIE * Connect_UUIE :: clone ( ) const {
	return new Connect_UUIE ( * this );
}

//
// Information-UUIE
//

Information_UUIE :: Information_UUIE ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 6 ), m_protocolIdentifier ( is ), m_callIdentifier ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_fastStart ( 0 ), m_fastConnectRefused ( 0 ), m_circuitInfo ( 0 ) {
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_callIdentifier ) )
				m_callIdentifier = new CallIdentifier ( is );
			if ( hasKnownExtensionToDecode ( is, e_tokens ) )
				m_tokens = new ArrayOf_ClearToken ( is );
			if ( hasKnownExtensionToDecode ( is, e_cryptoTokens ) )
				m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
			if ( hasKnownExtensionToDecode ( is, e_fastStart ) )
				m_fastStart = new ArrayOf_Asn_OctetString ( is );
			if ( hasKnownExtensionToDecode ( is, e_fastConnectRefused ) )
				m_fastConnectRefused = new Asn :: Null ( is );
			if ( hasKnownExtensionToDecode ( is, e_circuitInfo ) )
				m_circuitInfo = new CircuitInfo ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_callIdentifier;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_fastStart;
		delete m_fastConnectRefused;
		delete m_circuitInfo;
		throw;
	}
}

Information_UUIE :: Information_UUIE ( ) : Asn :: Sequence ( 0, true, 6 ), m_callIdentifier ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_fastStart ( 0 ), m_fastConnectRefused ( 0 ), m_circuitInfo ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_callIdentifier );
		m_callIdentifier = new CallIdentifier;
	} catch ( ... ) {
		delete m_callIdentifier;
		throw;
	}
}

Information_UUIE & Information_UUIE :: operator= ( const Information_UUIE & s ) {
	Asn :: Sequence :: operator= ( s );
	m_protocolIdentifier = s.m_protocolIdentifier;
	assignCopy ( m_callIdentifier, s.m_callIdentifier );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_fastStart, s.m_fastStart );
	assignCopy ( m_fastConnectRefused, s.m_fastConnectRefused );
	assignCopy ( m_circuitInfo, s.m_circuitInfo );
	return * this;
}

Information_UUIE :: Information_UUIE ( const Information_UUIE & s ) : Asn :: Sequence ( s ), m_protocolIdentifier ( s.m_protocolIdentifier ), m_callIdentifier ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_fastStart ( 0 ), m_fastConnectRefused ( 0 ), m_circuitInfo ( 0 ) {
	try {
		if ( s.m_callIdentifier )
			m_callIdentifier = new CallIdentifier ( * s.m_callIdentifier );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_fastStart )
			m_fastStart = new ArrayOf_Asn_OctetString ( * s.m_fastStart );
		if ( s.m_fastConnectRefused )
			m_fastConnectRefused = new Asn :: Null ( * s.m_fastConnectRefused );
		if ( s.m_circuitInfo )
			m_circuitInfo = new CircuitInfo ( * s.m_circuitInfo );
	} catch ( ... ) {
		delete m_callIdentifier;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_fastStart;
		delete m_fastConnectRefused;
		delete m_circuitInfo;
		throw;
	}
}


void Information_UUIE :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_callIdentifier:
			assignNew ( m_callIdentifier, new CallIdentifier );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_fastStart:
			assignNew ( m_fastStart, new ArrayOf_Asn_OctetString );
			break;
		case e_fastConnectRefused:
			assignNew ( m_fastConnectRefused, new Asn :: Null );
			break;
		case e_circuitInfo:
			assignNew ( m_circuitInfo, new CircuitInfo );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void Information_UUIE :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_callIdentifier:
			delete m_callIdentifier;
			m_callIdentifier = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_fastStart:
			delete m_fastStart;
			m_fastStart = 0;
			break;
		case e_fastConnectRefused:
			delete m_fastConnectRefused;
			m_fastConnectRefused = 0;
			break;
		case e_circuitInfo:
			delete m_circuitInfo;
			m_circuitInfo = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void Information_UUIE :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_protocolIdentifier.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_callIdentifier, m_callIdentifier );
		knownExtensionEncode ( os, e_tokens, m_tokens );
		knownExtensionEncode ( os, e_cryptoTokens, m_cryptoTokens );
		knownExtensionEncode ( os, e_fastStart, m_fastStart );
		knownExtensionEncode ( os, e_fastConnectRefused, m_fastConnectRefused );
		knownExtensionEncode ( os, e_circuitInfo, m_circuitInfo );
		unknownExtensionsEncode ( os );
	}
}

Information_UUIE :: ~Information_UUIE ( ) {
	delete m_callIdentifier;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_fastStart;
	delete m_fastConnectRefused;
	delete m_circuitInfo;
}

void Information_UUIE :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 21 ) << "protocolIdentifier = " << std :: setprecision ( indent ) << m_protocolIdentifier << '\n';
	if ( hasOptionalField ( e_callIdentifier ) ) {
		os << std :: setw ( indent + 17 ) << "callIdentifier = " << std :: setprecision ( indent );
		m_callIdentifier -> CallIdentifier :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_fastStart ) ) {
		os << std :: setw ( indent + 12 ) << "fastStart = " << std :: setprecision ( indent );
		m_fastStart -> ArrayOf_Asn_OctetString :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_fastConnectRefused ) ) {
		os << std :: setw ( indent + 21 ) << "fastConnectRefused = " << std :: setprecision ( indent );
		m_fastConnectRefused -> Asn :: Null :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_circuitInfo ) ) {
		os << std :: setw ( indent + 14 ) << "circuitInfo = " << std :: setprecision ( indent );
		m_circuitInfo -> CircuitInfo :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

Information_UUIE * Information_UUIE :: clone ( ) const {
	return new Information_UUIE ( * this );
}

//
// ReleaseComplete-UUIE
//

ReleaseComplete_UUIE :: ReleaseComplete_UUIE ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 9 ), m_protocolIdentifier ( is ), m_reason ( 0 ), m_callIdentifier ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_busyAddress ( 0 ), m_presentationIndicator ( 0 ), m_screeningIndicator ( 0 ), m_capacity ( 0 ), m_serviceControl ( 0 ), m_featureSet ( 0 ) {
	try {
		if ( hasOptionalField ( e_reason ) )
			m_reason = new ReleaseCompleteReason ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_callIdentifier ) )
				m_callIdentifier = new CallIdentifier ( is );
			if ( hasKnownExtensionToDecode ( is, e_tokens ) )
				m_tokens = new ArrayOf_ClearToken ( is );
			if ( hasKnownExtensionToDecode ( is, e_cryptoTokens ) )
				m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
			if ( hasKnownExtensionToDecode ( is, e_busyAddress ) )
				m_busyAddress = new ArrayOf_AliasAddress ( is );
			if ( hasKnownExtensionToDecode ( is, e_presentationIndicator ) )
				m_presentationIndicator = new PresentationIndicator ( is );
			if ( hasKnownExtensionToDecode ( is, e_screeningIndicator ) )
				m_screeningIndicator = new ScreeningIndicator ( is );
			if ( hasKnownExtensionToDecode ( is, e_capacity ) )
				m_capacity = new CallCapacity ( is );
			if ( hasKnownExtensionToDecode ( is, e_serviceControl ) )
				m_serviceControl = new ArrayOf_ServiceControlSession ( is );
			if ( hasKnownExtensionToDecode ( is, e_featureSet ) )
				m_featureSet = new FeatureSet ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_reason;
		delete m_callIdentifier;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_busyAddress;
		delete m_presentationIndicator;
		delete m_screeningIndicator;
		delete m_capacity;
		delete m_serviceControl;
		delete m_featureSet;
		throw;
	}
}

ReleaseComplete_UUIE :: ReleaseComplete_UUIE ( ) : Asn :: Sequence ( 1, true, 9 ), m_reason ( 0 ), m_callIdentifier ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_busyAddress ( 0 ), m_presentationIndicator ( 0 ), m_screeningIndicator ( 0 ), m_capacity ( 0 ), m_serviceControl ( 0 ), m_featureSet ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_callIdentifier );
		m_callIdentifier = new CallIdentifier;
	} catch ( ... ) {
		delete m_callIdentifier;
		throw;
	}
}

ReleaseComplete_UUIE & ReleaseComplete_UUIE :: operator= ( const ReleaseComplete_UUIE & s ) {
	Asn :: Sequence :: operator= ( s );
	m_protocolIdentifier = s.m_protocolIdentifier;
	assignCopy ( m_reason, s.m_reason );
	assignCopy ( m_callIdentifier, s.m_callIdentifier );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_busyAddress, s.m_busyAddress );
	assignCopy ( m_presentationIndicator, s.m_presentationIndicator );
	assignCopy ( m_screeningIndicator, s.m_screeningIndicator );
	assignCopy ( m_capacity, s.m_capacity );
	assignCopy ( m_serviceControl, s.m_serviceControl );
	assignCopy ( m_featureSet, s.m_featureSet );
	return * this;
}

ReleaseComplete_UUIE :: ReleaseComplete_UUIE ( const ReleaseComplete_UUIE & s ) : Asn :: Sequence ( s ), m_protocolIdentifier ( s.m_protocolIdentifier ), m_reason ( 0 ), m_callIdentifier ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_busyAddress ( 0 ), m_presentationIndicator ( 0 ), m_screeningIndicator ( 0 ), m_capacity ( 0 ), m_serviceControl ( 0 ), m_featureSet ( 0 ) {
	try {
		if ( s.m_reason )
			m_reason = new ReleaseCompleteReason ( * s.m_reason );
		if ( s.m_callIdentifier )
			m_callIdentifier = new CallIdentifier ( * s.m_callIdentifier );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_busyAddress )
			m_busyAddress = new ArrayOf_AliasAddress ( * s.m_busyAddress );
		if ( s.m_presentationIndicator )
			m_presentationIndicator = new PresentationIndicator ( * s.m_presentationIndicator );
		if ( s.m_screeningIndicator )
			m_screeningIndicator = new ScreeningIndicator ( * s.m_screeningIndicator );
		if ( s.m_capacity )
			m_capacity = new CallCapacity ( * s.m_capacity );
		if ( s.m_serviceControl )
			m_serviceControl = new ArrayOf_ServiceControlSession ( * s.m_serviceControl );
		if ( s.m_featureSet )
			m_featureSet = new FeatureSet ( * s.m_featureSet );
	} catch ( ... ) {
		delete m_reason;
		delete m_callIdentifier;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_busyAddress;
		delete m_presentationIndicator;
		delete m_screeningIndicator;
		delete m_capacity;
		delete m_serviceControl;
		delete m_featureSet;
		throw;
	}
}


void ReleaseComplete_UUIE :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_reason:
			assignNew ( m_reason, new ReleaseCompleteReason );
			break;
		case e_callIdentifier:
			assignNew ( m_callIdentifier, new CallIdentifier );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_busyAddress:
			assignNew ( m_busyAddress, new ArrayOf_AliasAddress );
			break;
		case e_presentationIndicator:
			assignNew ( m_presentationIndicator, new PresentationIndicator );
			break;
		case e_screeningIndicator:
			assignNew ( m_screeningIndicator, new ScreeningIndicator );
			break;
		case e_capacity:
			assignNew ( m_capacity, new CallCapacity );
			break;
		case e_serviceControl:
			assignNew ( m_serviceControl, new ArrayOf_ServiceControlSession );
			break;
		case e_featureSet:
			assignNew ( m_featureSet, new FeatureSet );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void ReleaseComplete_UUIE :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_reason:
			delete m_reason;
			m_reason = 0;
			break;
		case e_callIdentifier:
			delete m_callIdentifier;
			m_callIdentifier = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_busyAddress:
			delete m_busyAddress;
			m_busyAddress = 0;
			break;
		case e_presentationIndicator:
			delete m_presentationIndicator;
			m_presentationIndicator = 0;
			break;
		case e_screeningIndicator:
			delete m_screeningIndicator;
			m_screeningIndicator = 0;
			break;
		case e_capacity:
			delete m_capacity;
			m_capacity = 0;
			break;
		case e_serviceControl:
			delete m_serviceControl;
			m_serviceControl = 0;
			break;
		case e_featureSet:
			delete m_featureSet;
			m_featureSet = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void ReleaseComplete_UUIE :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_protocolIdentifier.encode ( os );
	if ( hasOptionalField ( e_reason ) )
		m_reason -> ReleaseCompleteReason :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_callIdentifier, m_callIdentifier );
		knownExtensionEncode ( os, e_tokens, m_tokens );
		knownExtensionEncode ( os, e_cryptoTokens, m_cryptoTokens );
		knownExtensionEncode ( os, e_busyAddress, m_busyAddress );
		knownExtensionEncode ( os, e_presentationIndicator, m_presentationIndicator );
		knownExtensionEncode ( os, e_screeningIndicator, m_screeningIndicator );
		knownExtensionEncode ( os, e_capacity, m_capacity );
		knownExtensionEncode ( os, e_serviceControl, m_serviceControl );
		knownExtensionEncode ( os, e_featureSet, m_featureSet );
		unknownExtensionsEncode ( os );
	}
}

ReleaseComplete_UUIE :: ~ReleaseComplete_UUIE ( ) {
	delete m_reason;
	delete m_callIdentifier;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_busyAddress;
	delete m_presentationIndicator;
	delete m_screeningIndicator;
	delete m_capacity;
	delete m_serviceControl;
	delete m_featureSet;
}

void ReleaseComplete_UUIE :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 21 ) << "protocolIdentifier = " << std :: setprecision ( indent ) << m_protocolIdentifier << '\n';
	if ( hasOptionalField ( e_reason ) ) {
		os << std :: setw ( indent + 9 ) << "reason = " << std :: setprecision ( indent );
		m_reason -> ReleaseCompleteReason :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_callIdentifier ) ) {
		os << std :: setw ( indent + 17 ) << "callIdentifier = " << std :: setprecision ( indent );
		m_callIdentifier -> CallIdentifier :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_busyAddress ) ) {
		os << std :: setw ( indent + 14 ) << "busyAddress = " << std :: setprecision ( indent );
		m_busyAddress -> ArrayOf_AliasAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_presentationIndicator ) ) {
		os << std :: setw ( indent + 24 ) << "presentationIndicator = " << std :: setprecision ( indent );
		m_presentationIndicator -> PresentationIndicator :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_screeningIndicator ) ) {
		os << std :: setw ( indent + 21 ) << "screeningIndicator = " << std :: setprecision ( indent );
		m_screeningIndicator -> ScreeningIndicator :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_capacity ) ) {
		os << std :: setw ( indent + 11 ) << "capacity = " << std :: setprecision ( indent );
		m_capacity -> CallCapacity :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_serviceControl ) ) {
		os << std :: setw ( indent + 17 ) << "serviceControl = " << std :: setprecision ( indent );
		m_serviceControl -> ArrayOf_ServiceControlSession :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_featureSet ) ) {
		os << std :: setw ( indent + 13 ) << "featureSet = " << std :: setprecision ( indent );
		m_featureSet -> FeatureSet :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

ReleaseComplete_UUIE * ReleaseComplete_UUIE :: clone ( ) const {
	return new ReleaseComplete_UUIE ( * this );
}

//
// Setup-UUIE
//

Setup_UUIE :: Setup_UUIE ( Asn :: istream & is ) : Asn :: Sequence ( is, 7, true, 27 ), m_protocolIdentifier ( is ), m_h245Address ( hasOptionalField ( e_h245Address ) ? pushTemporaryMember ( new TransportAddress ( is ) ) : 0 ), m_sourceAddress ( hasOptionalField ( e_sourceAddress ) ? pushTemporaryMember ( new ArrayOf_AliasAddress ( is ) ) : 0 ), m_sourceInfo ( is ), m_destinationAddress ( hasOptionalField ( e_destinationAddress ) ? pushTemporaryMember ( new ArrayOf_AliasAddress ( is ) ) : 0 ), m_destCallSignalAddress ( hasOptionalField ( e_destCallSignalAddress ) ? pushTemporaryMember ( new TransportAddress ( is ) ) : 0 ), m_destExtraCallInfo ( hasOptionalField ( e_destExtraCallInfo ) ? pushTemporaryMember ( new ArrayOf_AliasAddress ( is ) ) : 0 ), m_destExtraCRV ( hasOptionalField ( e_destExtraCRV ) ? pushTemporaryMember ( new ArrayOf_CallReferenceValue ( is ) ) : 0 ), m_activeMC ( is ), m_conferenceID ( is ), m_conferenceGoal ( is ), m_callServices ( hasOptionalField ( e_callServices ) ? pushTemporaryMember ( new QseriesOptions ( is ) ) : 0 ), m_callType ( is ), m_sourceCallSignalAddress ( 0 ), m_remoteExtensionAddress ( 0 ), m_callIdentifier ( 0 ), m_h245SecurityCapability ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_fastStart ( 0 ), m_mediaWaitForConnect ( 0 ), m_canOverlapSend ( 0 ), m_endpointIdentifier ( 0 ), m_multipleCalls ( 0 ), m_maintainConnection ( 0 ), m_connectionParameters ( 0 ), m_language ( 0 ), m_presentationIndicator ( 0 ), m_screeningIndicator ( 0 ), m_serviceControl ( 0 ), m_symmetricOperationRequired ( 0 ), m_capacity ( 0 ), m_circuitInfo ( 0 ), m_desiredProtocols ( 0 ), m_neededFeatures ( 0 ), m_desiredFeatures ( 0 ), m_supportedFeatures ( 0 ), m_parallelH245Control ( 0 ), m_additionalSourceAddresses ( 0 ), m_hopCount ( 0 ) {
	clearTemporaryMembers ( );
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_sourceCallSignalAddress ) )
				m_sourceCallSignalAddress = new TransportAddress ( is );
			if ( hasKnownExtensionToDecode ( is, e_remoteExtensionAddress ) )
				m_remoteExtensionAddress = new AliasAddress ( is );
			if ( hasKnownExtensionToDecode ( is, e_callIdentifier ) )
				m_callIdentifier = new CallIdentifier ( is );
			if ( hasKnownExtensionToDecode ( is, e_h245SecurityCapability ) )
				m_h245SecurityCapability = new ArrayOf_H245Security ( is );
			if ( hasKnownExtensionToDecode ( is, e_tokens ) )
				m_tokens = new ArrayOf_ClearToken ( is );
			if ( hasKnownExtensionToDecode ( is, e_cryptoTokens ) )
				m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
			if ( hasKnownExtensionToDecode ( is, e_fastStart ) )
				m_fastStart = new ArrayOf_Asn_OctetString ( is );
			if ( hasKnownExtensionToDecode ( is, e_mediaWaitForConnect ) )
				m_mediaWaitForConnect = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_canOverlapSend ) )
				m_canOverlapSend = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_endpointIdentifier ) )
				m_endpointIdentifier = new EndpointIdentifier ( is );
			if ( hasKnownExtensionToDecode ( is, e_multipleCalls ) )
				m_multipleCalls = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_maintainConnection ) )
				m_maintainConnection = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_connectionParameters ) )
				m_connectionParameters = new Setup_UUIE_connectionParameters ( is );
			if ( hasKnownExtensionToDecode ( is, e_language ) )
				m_language = new Setup_UUIE_language ( is );
			if ( hasKnownExtensionToDecode ( is, e_presentationIndicator ) )
				m_presentationIndicator = new PresentationIndicator ( is );
			if ( hasKnownExtensionToDecode ( is, e_screeningIndicator ) )
				m_screeningIndicator = new ScreeningIndicator ( is );
			if ( hasKnownExtensionToDecode ( is, e_serviceControl ) )
				m_serviceControl = new ArrayOf_ServiceControlSession ( is );
			if ( hasKnownExtensionToDecode ( is, e_symmetricOperationRequired ) )
				m_symmetricOperationRequired = new Asn :: Null ( is );
			if ( hasKnownExtensionToDecode ( is, e_capacity ) )
				m_capacity = new CallCapacity ( is );
			if ( hasKnownExtensionToDecode ( is, e_circuitInfo ) )
				m_circuitInfo = new CircuitInfo ( is );
			if ( hasKnownExtensionToDecode ( is, e_desiredProtocols ) )
				m_desiredProtocols = new ArrayOf_SupportedProtocols ( is );
			if ( hasKnownExtensionToDecode ( is, e_neededFeatures ) )
				m_neededFeatures = new ArrayOf_FeatureDescriptor ( is );
			if ( hasKnownExtensionToDecode ( is, e_desiredFeatures ) )
				m_desiredFeatures = new ArrayOf_FeatureDescriptor ( is );
			if ( hasKnownExtensionToDecode ( is, e_supportedFeatures ) )
				m_supportedFeatures = new ArrayOf_FeatureDescriptor ( is );
			if ( hasKnownExtensionToDecode ( is, e_parallelH245Control ) )
				m_parallelH245Control = new ArrayOf_Asn_OctetString ( is );
			if ( hasKnownExtensionToDecode ( is, e_additionalSourceAddresses ) )
				m_additionalSourceAddresses = new ArrayOf_ExtendedAliasAddress ( is );
			if ( hasKnownExtensionToDecode ( is, e_hopCount ) )
				m_hopCount = new Setup_UUIE_hopCount ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_h245Address;
		delete m_sourceAddress;
		delete m_destinationAddress;
		delete m_destCallSignalAddress;
		delete m_destExtraCallInfo;
		delete m_destExtraCRV;
		delete m_callServices;
		delete m_sourceCallSignalAddress;
		delete m_remoteExtensionAddress;
		delete m_callIdentifier;
		delete m_h245SecurityCapability;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_fastStart;
		delete m_mediaWaitForConnect;
		delete m_canOverlapSend;
		delete m_endpointIdentifier;
		delete m_multipleCalls;
		delete m_maintainConnection;
		delete m_connectionParameters;
		delete m_language;
		delete m_presentationIndicator;
		delete m_screeningIndicator;
		delete m_serviceControl;
		delete m_symmetricOperationRequired;
		delete m_capacity;
		delete m_circuitInfo;
		delete m_desiredProtocols;
		delete m_neededFeatures;
		delete m_desiredFeatures;
		delete m_supportedFeatures;
		delete m_parallelH245Control;
		delete m_additionalSourceAddresses;
		delete m_hopCount;
		throw;
	}
}

Setup_UUIE :: Setup_UUIE ( ) : Asn :: Sequence ( 7, true, 27 ), m_h245Address ( 0 ), m_sourceAddress ( 0 ), m_destinationAddress ( 0 ), m_destCallSignalAddress ( 0 ), m_destExtraCallInfo ( 0 ), m_destExtraCRV ( 0 ), m_callServices ( 0 ), m_sourceCallSignalAddress ( 0 ), m_remoteExtensionAddress ( 0 ), m_callIdentifier ( 0 ), m_h245SecurityCapability ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_fastStart ( 0 ), m_mediaWaitForConnect ( 0 ), m_canOverlapSend ( 0 ), m_endpointIdentifier ( 0 ), m_multipleCalls ( 0 ), m_maintainConnection ( 0 ), m_connectionParameters ( 0 ), m_language ( 0 ), m_presentationIndicator ( 0 ), m_screeningIndicator ( 0 ), m_serviceControl ( 0 ), m_symmetricOperationRequired ( 0 ), m_capacity ( 0 ), m_circuitInfo ( 0 ), m_desiredProtocols ( 0 ), m_neededFeatures ( 0 ), m_desiredFeatures ( 0 ), m_supportedFeatures ( 0 ), m_parallelH245Control ( 0 ), m_additionalSourceAddresses ( 0 ), m_hopCount ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_callIdentifier );
		m_callIdentifier = new CallIdentifier;
		Asn :: Sequence :: includeOptionalField ( e_mediaWaitForConnect );
		m_mediaWaitForConnect = new Asn :: Boolean;
		Asn :: Sequence :: includeOptionalField ( e_canOverlapSend );
		m_canOverlapSend = new Asn :: Boolean;
		Asn :: Sequence :: includeOptionalField ( e_multipleCalls );
		m_multipleCalls = new Asn :: Boolean;
		Asn :: Sequence :: includeOptionalField ( e_maintainConnection );
		m_maintainConnection = new Asn :: Boolean;
	} catch ( ... ) {
		delete m_callIdentifier;
		delete m_mediaWaitForConnect;
		delete m_canOverlapSend;
		delete m_multipleCalls;
		delete m_maintainConnection;
		throw;
	}
}

Setup_UUIE & Setup_UUIE :: operator= ( const Setup_UUIE & s ) {
	Asn :: Sequence :: operator= ( s );
	m_protocolIdentifier = s.m_protocolIdentifier;
	assignCopy ( m_h245Address, s.m_h245Address );
	assignCopy ( m_sourceAddress, s.m_sourceAddress );
	m_sourceInfo = s.m_sourceInfo;
	assignCopy ( m_destinationAddress, s.m_destinationAddress );
	assignCopy ( m_destCallSignalAddress, s.m_destCallSignalAddress );
	assignCopy ( m_destExtraCallInfo, s.m_destExtraCallInfo );
	assignCopy ( m_destExtraCRV, s.m_destExtraCRV );
	m_activeMC = s.m_activeMC;
	m_conferenceID = s.m_conferenceID;
	m_conferenceGoal = s.m_conferenceGoal;
	assignCopy ( m_callServices, s.m_callServices );
	m_callType = s.m_callType;
	assignCopy ( m_sourceCallSignalAddress, s.m_sourceCallSignalAddress );
	assignCopy ( m_remoteExtensionAddress, s.m_remoteExtensionAddress );
	assignCopy ( m_callIdentifier, s.m_callIdentifier );
	assignCopy ( m_h245SecurityCapability, s.m_h245SecurityCapability );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_fastStart, s.m_fastStart );
	assignCopy ( m_mediaWaitForConnect, s.m_mediaWaitForConnect );
	assignCopy ( m_canOverlapSend, s.m_canOverlapSend );
	assignCopy ( m_endpointIdentifier, s.m_endpointIdentifier );
	assignCopy ( m_multipleCalls, s.m_multipleCalls );
	assignCopy ( m_maintainConnection, s.m_maintainConnection );
	assignCopy ( m_connectionParameters, s.m_connectionParameters );
	assignCopy ( m_language, s.m_language );
	assignCopy ( m_presentationIndicator, s.m_presentationIndicator );
	assignCopy ( m_screeningIndicator, s.m_screeningIndicator );
	assignCopy ( m_serviceControl, s.m_serviceControl );
	assignCopy ( m_symmetricOperationRequired, s.m_symmetricOperationRequired );
	assignCopy ( m_capacity, s.m_capacity );
	assignCopy ( m_circuitInfo, s.m_circuitInfo );
	assignCopy ( m_desiredProtocols, s.m_desiredProtocols );
	assignCopy ( m_neededFeatures, s.m_neededFeatures );
	assignCopy ( m_desiredFeatures, s.m_desiredFeatures );
	assignCopy ( m_supportedFeatures, s.m_supportedFeatures );
	assignCopy ( m_parallelH245Control, s.m_parallelH245Control );
	assignCopy ( m_additionalSourceAddresses, s.m_additionalSourceAddresses );
	assignCopy ( m_hopCount, s.m_hopCount );
	return * this;
}

Setup_UUIE :: Setup_UUIE ( const Setup_UUIE & s ) : Asn :: Sequence ( s ), m_protocolIdentifier ( s.m_protocolIdentifier ), m_h245Address ( 0 ), m_sourceAddress ( 0 ), m_sourceInfo ( s.m_sourceInfo ), m_destinationAddress ( 0 ), m_destCallSignalAddress ( 0 ), m_destExtraCallInfo ( 0 ), m_destExtraCRV ( 0 ), m_activeMC ( s.m_activeMC ), m_conferenceID ( s.m_conferenceID ), m_conferenceGoal ( s.m_conferenceGoal ), m_callServices ( 0 ), m_callType ( s.m_callType ), m_sourceCallSignalAddress ( 0 ), m_remoteExtensionAddress ( 0 ), m_callIdentifier ( 0 ), m_h245SecurityCapability ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_fastStart ( 0 ), m_mediaWaitForConnect ( 0 ), m_canOverlapSend ( 0 ), m_endpointIdentifier ( 0 ), m_multipleCalls ( 0 ), m_maintainConnection ( 0 ), m_connectionParameters ( 0 ), m_language ( 0 ), m_presentationIndicator ( 0 ), m_screeningIndicator ( 0 ), m_serviceControl ( 0 ), m_symmetricOperationRequired ( 0 ), m_capacity ( 0 ), m_circuitInfo ( 0 ), m_desiredProtocols ( 0 ), m_neededFeatures ( 0 ), m_desiredFeatures ( 0 ), m_supportedFeatures ( 0 ), m_parallelH245Control ( 0 ), m_additionalSourceAddresses ( 0 ), m_hopCount ( 0 ) {
	try {
		if ( s.m_h245Address )
			m_h245Address = new TransportAddress ( * s.m_h245Address );
		if ( s.m_sourceAddress )
			m_sourceAddress = new ArrayOf_AliasAddress ( * s.m_sourceAddress );
		if ( s.m_destinationAddress )
			m_destinationAddress = new ArrayOf_AliasAddress ( * s.m_destinationAddress );
		if ( s.m_destCallSignalAddress )
			m_destCallSignalAddress = new TransportAddress ( * s.m_destCallSignalAddress );
		if ( s.m_destExtraCallInfo )
			m_destExtraCallInfo = new ArrayOf_AliasAddress ( * s.m_destExtraCallInfo );
		if ( s.m_destExtraCRV )
			m_destExtraCRV = new ArrayOf_CallReferenceValue ( * s.m_destExtraCRV );
		if ( s.m_callServices )
			m_callServices = new QseriesOptions ( * s.m_callServices );
		if ( s.m_sourceCallSignalAddress )
			m_sourceCallSignalAddress = new TransportAddress ( * s.m_sourceCallSignalAddress );
		if ( s.m_remoteExtensionAddress )
			m_remoteExtensionAddress = new AliasAddress ( * s.m_remoteExtensionAddress );
		if ( s.m_callIdentifier )
			m_callIdentifier = new CallIdentifier ( * s.m_callIdentifier );
		if ( s.m_h245SecurityCapability )
			m_h245SecurityCapability = new ArrayOf_H245Security ( * s.m_h245SecurityCapability );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_fastStart )
			m_fastStart = new ArrayOf_Asn_OctetString ( * s.m_fastStart );
		if ( s.m_mediaWaitForConnect )
			m_mediaWaitForConnect = new Asn :: Boolean ( * s.m_mediaWaitForConnect );
		if ( s.m_canOverlapSend )
			m_canOverlapSend = new Asn :: Boolean ( * s.m_canOverlapSend );
		if ( s.m_endpointIdentifier )
			m_endpointIdentifier = new EndpointIdentifier ( * s.m_endpointIdentifier );
		if ( s.m_multipleCalls )
			m_multipleCalls = new Asn :: Boolean ( * s.m_multipleCalls );
		if ( s.m_maintainConnection )
			m_maintainConnection = new Asn :: Boolean ( * s.m_maintainConnection );
		if ( s.m_connectionParameters )
			m_connectionParameters = new Setup_UUIE_connectionParameters ( * s.m_connectionParameters );
		if ( s.m_language )
			m_language = new Setup_UUIE_language ( * s.m_language );
		if ( s.m_presentationIndicator )
			m_presentationIndicator = new PresentationIndicator ( * s.m_presentationIndicator );
		if ( s.m_screeningIndicator )
			m_screeningIndicator = new ScreeningIndicator ( * s.m_screeningIndicator );
		if ( s.m_serviceControl )
			m_serviceControl = new ArrayOf_ServiceControlSession ( * s.m_serviceControl );
		if ( s.m_symmetricOperationRequired )
			m_symmetricOperationRequired = new Asn :: Null ( * s.m_symmetricOperationRequired );
		if ( s.m_capacity )
			m_capacity = new CallCapacity ( * s.m_capacity );
		if ( s.m_circuitInfo )
			m_circuitInfo = new CircuitInfo ( * s.m_circuitInfo );
		if ( s.m_desiredProtocols )
			m_desiredProtocols = new ArrayOf_SupportedProtocols ( * s.m_desiredProtocols );
		if ( s.m_neededFeatures )
			m_neededFeatures = new ArrayOf_FeatureDescriptor ( * s.m_neededFeatures );
		if ( s.m_desiredFeatures )
			m_desiredFeatures = new ArrayOf_FeatureDescriptor ( * s.m_desiredFeatures );
		if ( s.m_supportedFeatures )
			m_supportedFeatures = new ArrayOf_FeatureDescriptor ( * s.m_supportedFeatures );
		if ( s.m_parallelH245Control )
			m_parallelH245Control = new ArrayOf_Asn_OctetString ( * s.m_parallelH245Control );
		if ( s.m_additionalSourceAddresses )
			m_additionalSourceAddresses = new ArrayOf_ExtendedAliasAddress ( * s.m_additionalSourceAddresses );
		if ( s.m_hopCount )
			m_hopCount = new Setup_UUIE_hopCount ( * s.m_hopCount );
	} catch ( ... ) {
		delete m_h245Address;
		delete m_sourceAddress;
		delete m_destinationAddress;
		delete m_destCallSignalAddress;
		delete m_destExtraCallInfo;
		delete m_destExtraCRV;
		delete m_callServices;
		delete m_sourceCallSignalAddress;
		delete m_remoteExtensionAddress;
		delete m_callIdentifier;
		delete m_h245SecurityCapability;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_fastStart;
		delete m_mediaWaitForConnect;
		delete m_canOverlapSend;
		delete m_endpointIdentifier;
		delete m_multipleCalls;
		delete m_maintainConnection;
		delete m_connectionParameters;
		delete m_language;
		delete m_presentationIndicator;
		delete m_screeningIndicator;
		delete m_serviceControl;
		delete m_symmetricOperationRequired;
		delete m_capacity;
		delete m_circuitInfo;
		delete m_desiredProtocols;
		delete m_neededFeatures;
		delete m_desiredFeatures;
		delete m_supportedFeatures;
		delete m_parallelH245Control;
		delete m_additionalSourceAddresses;
		delete m_hopCount;
		throw;
	}
}


void Setup_UUIE :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_h245Address:
			assignNew ( m_h245Address, new TransportAddress );
			break;
		case e_sourceAddress:
			assignNew ( m_sourceAddress, new ArrayOf_AliasAddress );
			break;
		case e_destinationAddress:
			assignNew ( m_destinationAddress, new ArrayOf_AliasAddress );
			break;
		case e_destCallSignalAddress:
			assignNew ( m_destCallSignalAddress, new TransportAddress );
			break;
		case e_destExtraCallInfo:
			assignNew ( m_destExtraCallInfo, new ArrayOf_AliasAddress );
			break;
		case e_destExtraCRV:
			assignNew ( m_destExtraCRV, new ArrayOf_CallReferenceValue );
			break;
		case e_callServices:
			assignNew ( m_callServices, new QseriesOptions );
			break;
		case e_sourceCallSignalAddress:
			assignNew ( m_sourceCallSignalAddress, new TransportAddress );
			break;
		case e_remoteExtensionAddress:
			assignNew ( m_remoteExtensionAddress, new AliasAddress );
			break;
		case e_callIdentifier:
			assignNew ( m_callIdentifier, new CallIdentifier );
			break;
		case e_h245SecurityCapability:
			assignNew ( m_h245SecurityCapability, new ArrayOf_H245Security );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_fastStart:
			assignNew ( m_fastStart, new ArrayOf_Asn_OctetString );
			break;
		case e_mediaWaitForConnect:
			assignNew ( m_mediaWaitForConnect, new Asn :: Boolean );
			break;
		case e_canOverlapSend:
			assignNew ( m_canOverlapSend, new Asn :: Boolean );
			break;
		case e_endpointIdentifier:
			assignNew ( m_endpointIdentifier, new EndpointIdentifier );
			break;
		case e_multipleCalls:
			assignNew ( m_multipleCalls, new Asn :: Boolean );
			break;
		case e_maintainConnection:
			assignNew ( m_maintainConnection, new Asn :: Boolean );
			break;
		case e_connectionParameters:
			assignNew ( m_connectionParameters, new Setup_UUIE_connectionParameters );
			break;
		case e_language:
			assignNew ( m_language, new Setup_UUIE_language );
			break;
		case e_presentationIndicator:
			assignNew ( m_presentationIndicator, new PresentationIndicator );
			break;
		case e_screeningIndicator:
			assignNew ( m_screeningIndicator, new ScreeningIndicator );
			break;
		case e_serviceControl:
			assignNew ( m_serviceControl, new ArrayOf_ServiceControlSession );
			break;
		case e_symmetricOperationRequired:
			assignNew ( m_symmetricOperationRequired, new Asn :: Null );
			break;
		case e_capacity:
			assignNew ( m_capacity, new CallCapacity );
			break;
		case e_circuitInfo:
			assignNew ( m_circuitInfo, new CircuitInfo );
			break;
		case e_desiredProtocols:
			assignNew ( m_desiredProtocols, new ArrayOf_SupportedProtocols );
			break;
		case e_neededFeatures:
			assignNew ( m_neededFeatures, new ArrayOf_FeatureDescriptor );
			break;
		case e_desiredFeatures:
			assignNew ( m_desiredFeatures, new ArrayOf_FeatureDescriptor );
			break;
		case e_supportedFeatures:
			assignNew ( m_supportedFeatures, new ArrayOf_FeatureDescriptor );
			break;
		case e_parallelH245Control:
			assignNew ( m_parallelH245Control, new ArrayOf_Asn_OctetString );
			break;
		case e_additionalSourceAddresses:
			assignNew ( m_additionalSourceAddresses, new ArrayOf_ExtendedAliasAddress );
			break;
		case e_hopCount:
			assignNew ( m_hopCount, new Setup_UUIE_hopCount );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void Setup_UUIE :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_h245Address:
			delete m_h245Address;
			m_h245Address = 0;
			break;
		case e_sourceAddress:
			delete m_sourceAddress;
			m_sourceAddress = 0;
			break;
		case e_destinationAddress:
			delete m_destinationAddress;
			m_destinationAddress = 0;
			break;
		case e_destCallSignalAddress:
			delete m_destCallSignalAddress;
			m_destCallSignalAddress = 0;
			break;
		case e_destExtraCallInfo:
			delete m_destExtraCallInfo;
			m_destExtraCallInfo = 0;
			break;
		case e_destExtraCRV:
			delete m_destExtraCRV;
			m_destExtraCRV = 0;
			break;
		case e_callServices:
			delete m_callServices;
			m_callServices = 0;
			break;
		case e_sourceCallSignalAddress:
			delete m_sourceCallSignalAddress;
			m_sourceCallSignalAddress = 0;
			break;
		case e_remoteExtensionAddress:
			delete m_remoteExtensionAddress;
			m_remoteExtensionAddress = 0;
			break;
		case e_callIdentifier:
			delete m_callIdentifier;
			m_callIdentifier = 0;
			break;
		case e_h245SecurityCapability:
			delete m_h245SecurityCapability;
			m_h245SecurityCapability = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_fastStart:
			delete m_fastStart;
			m_fastStart = 0;
			break;
		case e_mediaWaitForConnect:
			delete m_mediaWaitForConnect;
			m_mediaWaitForConnect = 0;
			break;
		case e_canOverlapSend:
			delete m_canOverlapSend;
			m_canOverlapSend = 0;
			break;
		case e_endpointIdentifier:
			delete m_endpointIdentifier;
			m_endpointIdentifier = 0;
			break;
		case e_multipleCalls:
			delete m_multipleCalls;
			m_multipleCalls = 0;
			break;
		case e_maintainConnection:
			delete m_maintainConnection;
			m_maintainConnection = 0;
			break;
		case e_connectionParameters:
			delete m_connectionParameters;
			m_connectionParameters = 0;
			break;
		case e_language:
			delete m_language;
			m_language = 0;
			break;
		case e_presentationIndicator:
			delete m_presentationIndicator;
			m_presentationIndicator = 0;
			break;
		case e_screeningIndicator:
			delete m_screeningIndicator;
			m_screeningIndicator = 0;
			break;
		case e_serviceControl:
			delete m_serviceControl;
			m_serviceControl = 0;
			break;
		case e_symmetricOperationRequired:
			delete m_symmetricOperationRequired;
			m_symmetricOperationRequired = 0;
			break;
		case e_capacity:
			delete m_capacity;
			m_capacity = 0;
			break;
		case e_circuitInfo:
			delete m_circuitInfo;
			m_circuitInfo = 0;
			break;
		case e_desiredProtocols:
			delete m_desiredProtocols;
			m_desiredProtocols = 0;
			break;
		case e_neededFeatures:
			delete m_neededFeatures;
			m_neededFeatures = 0;
			break;
		case e_desiredFeatures:
			delete m_desiredFeatures;
			m_desiredFeatures = 0;
			break;
		case e_supportedFeatures:
			delete m_supportedFeatures;
			m_supportedFeatures = 0;
			break;
		case e_parallelH245Control:
			delete m_parallelH245Control;
			m_parallelH245Control = 0;
			break;
		case e_additionalSourceAddresses:
			delete m_additionalSourceAddresses;
			m_additionalSourceAddresses = 0;
			break;
		case e_hopCount:
			delete m_hopCount;
			m_hopCount = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void Setup_UUIE :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_protocolIdentifier.encode ( os );
	if ( hasOptionalField ( e_h245Address ) )
		m_h245Address -> TransportAddress :: encode ( os );
	if ( hasOptionalField ( e_sourceAddress ) )
		m_sourceAddress -> ArrayOf_AliasAddress :: encode ( os );
	m_sourceInfo.encode ( os );
	if ( hasOptionalField ( e_destinationAddress ) )
		m_destinationAddress -> ArrayOf_AliasAddress :: encode ( os );
	if ( hasOptionalField ( e_destCallSignalAddress ) )
		m_destCallSignalAddress -> TransportAddress :: encode ( os );
	if ( hasOptionalField ( e_destExtraCallInfo ) )
		m_destExtraCallInfo -> ArrayOf_AliasAddress :: encode ( os );
	if ( hasOptionalField ( e_destExtraCRV ) )
		m_destExtraCRV -> ArrayOf_CallReferenceValue :: encode ( os );
	m_activeMC.encode ( os );
	m_conferenceID.encode ( os );
	m_conferenceGoal.encode ( os );
	if ( hasOptionalField ( e_callServices ) )
		m_callServices -> QseriesOptions :: encode ( os );
	m_callType.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_sourceCallSignalAddress, m_sourceCallSignalAddress );
		knownExtensionEncode ( os, e_remoteExtensionAddress, m_remoteExtensionAddress );
		knownExtensionEncode ( os, e_callIdentifier, m_callIdentifier );
		knownExtensionEncode ( os, e_h245SecurityCapability, m_h245SecurityCapability );
		knownExtensionEncode ( os, e_tokens, m_tokens );
		knownExtensionEncode ( os, e_cryptoTokens, m_cryptoTokens );
		knownExtensionEncode ( os, e_fastStart, m_fastStart );
		knownExtensionEncode ( os, e_mediaWaitForConnect, m_mediaWaitForConnect );
		knownExtensionEncode ( os, e_canOverlapSend, m_canOverlapSend );
		knownExtensionEncode ( os, e_endpointIdentifier, m_endpointIdentifier );
		knownExtensionEncode ( os, e_multipleCalls, m_multipleCalls );
		knownExtensionEncode ( os, e_maintainConnection, m_maintainConnection );
		knownExtensionEncode ( os, e_connectionParameters, m_connectionParameters );
		knownExtensionEncode ( os, e_language, m_language );
		knownExtensionEncode ( os, e_presentationIndicator, m_presentationIndicator );
		knownExtensionEncode ( os, e_screeningIndicator, m_screeningIndicator );
		knownExtensionEncode ( os, e_serviceControl, m_serviceControl );
		knownExtensionEncode ( os, e_symmetricOperationRequired, m_symmetricOperationRequired );
		knownExtensionEncode ( os, e_capacity, m_capacity );
		knownExtensionEncode ( os, e_circuitInfo, m_circuitInfo );
		knownExtensionEncode ( os, e_desiredProtocols, m_desiredProtocols );
		knownExtensionEncode ( os, e_neededFeatures, m_neededFeatures );
		knownExtensionEncode ( os, e_desiredFeatures, m_desiredFeatures );
		knownExtensionEncode ( os, e_supportedFeatures, m_supportedFeatures );
		knownExtensionEncode ( os, e_parallelH245Control, m_parallelH245Control );
		knownExtensionEncode ( os, e_additionalSourceAddresses, m_additionalSourceAddresses );
		knownExtensionEncode ( os, e_hopCount, m_hopCount );
		unknownExtensionsEncode ( os );
	}
}

Setup_UUIE :: ~Setup_UUIE ( ) {
	delete m_h245Address;
	delete m_sourceAddress;
	delete m_destinationAddress;
	delete m_destCallSignalAddress;
	delete m_destExtraCallInfo;
	delete m_destExtraCRV;
	delete m_callServices;
	delete m_sourceCallSignalAddress;
	delete m_remoteExtensionAddress;
	delete m_callIdentifier;
	delete m_h245SecurityCapability;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_fastStart;
	delete m_mediaWaitForConnect;
	delete m_canOverlapSend;
	delete m_endpointIdentifier;
	delete m_multipleCalls;
	delete m_maintainConnection;
	delete m_connectionParameters;
	delete m_language;
	delete m_presentationIndicator;
	delete m_screeningIndicator;
	delete m_serviceControl;
	delete m_symmetricOperationRequired;
	delete m_capacity;
	delete m_circuitInfo;
	delete m_desiredProtocols;
	delete m_neededFeatures;
	delete m_desiredFeatures;
	delete m_supportedFeatures;
	delete m_parallelH245Control;
	delete m_additionalSourceAddresses;
	delete m_hopCount;
}

void Setup_UUIE :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 21 ) << "protocolIdentifier = " << std :: setprecision ( indent ) << m_protocolIdentifier << '\n';
	if ( hasOptionalField ( e_h245Address ) ) {
		os << std :: setw ( indent + 14 ) << "h245Address = " << std :: setprecision ( indent );
		m_h245Address -> TransportAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_sourceAddress ) ) {
		os << std :: setw ( indent + 16 ) << "sourceAddress = " << std :: setprecision ( indent );
		m_sourceAddress -> ArrayOf_AliasAddress :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 13 ) << "sourceInfo = " << std :: setprecision ( indent ) << m_sourceInfo << '\n';
	if ( hasOptionalField ( e_destinationAddress ) ) {
		os << std :: setw ( indent + 21 ) << "destinationAddress = " << std :: setprecision ( indent );
		m_destinationAddress -> ArrayOf_AliasAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_destCallSignalAddress ) ) {
		os << std :: setw ( indent + 24 ) << "destCallSignalAddress = " << std :: setprecision ( indent );
		m_destCallSignalAddress -> TransportAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_destExtraCallInfo ) ) {
		os << std :: setw ( indent + 20 ) << "destExtraCallInfo = " << std :: setprecision ( indent );
		m_destExtraCallInfo -> ArrayOf_AliasAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_destExtraCRV ) ) {
		os << std :: setw ( indent + 15 ) << "destExtraCRV = " << std :: setprecision ( indent );
		m_destExtraCRV -> ArrayOf_CallReferenceValue :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 11 ) << "activeMC = " << std :: setprecision ( indent ) << m_activeMC << '\n';
	os << std :: setw ( indent + 15 ) << "conferenceID = " << std :: setprecision ( indent ) << m_conferenceID << '\n';
	os << std :: setw ( indent + 17 ) << "conferenceGoal = " << std :: setprecision ( indent ) << m_conferenceGoal << '\n';
	if ( hasOptionalField ( e_callServices ) ) {
		os << std :: setw ( indent + 15 ) << "callServices = " << std :: setprecision ( indent );
		m_callServices -> QseriesOptions :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 11 ) << "callType = " << std :: setprecision ( indent ) << m_callType << '\n';
	if ( hasOptionalField ( e_sourceCallSignalAddress ) ) {
		os << std :: setw ( indent + 26 ) << "sourceCallSignalAddress = " << std :: setprecision ( indent );
		m_sourceCallSignalAddress -> TransportAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_remoteExtensionAddress ) ) {
		os << std :: setw ( indent + 25 ) << "remoteExtensionAddress = " << std :: setprecision ( indent );
		m_remoteExtensionAddress -> AliasAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_callIdentifier ) ) {
		os << std :: setw ( indent + 17 ) << "callIdentifier = " << std :: setprecision ( indent );
		m_callIdentifier -> CallIdentifier :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_h245SecurityCapability ) ) {
		os << std :: setw ( indent + 25 ) << "h245SecurityCapability = " << std :: setprecision ( indent );
		m_h245SecurityCapability -> ArrayOf_H245Security :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_fastStart ) ) {
		os << std :: setw ( indent + 12 ) << "fastStart = " << std :: setprecision ( indent );
		m_fastStart -> ArrayOf_Asn_OctetString :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_mediaWaitForConnect ) ) {
		os << std :: setw ( indent + 22 ) << "mediaWaitForConnect = " << std :: setprecision ( indent );
		m_mediaWaitForConnect -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_canOverlapSend ) ) {
		os << std :: setw ( indent + 17 ) << "canOverlapSend = " << std :: setprecision ( indent );
		m_canOverlapSend -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_endpointIdentifier ) ) {
		os << std :: setw ( indent + 21 ) << "endpointIdentifier = " << std :: setprecision ( indent );
		m_endpointIdentifier -> EndpointIdentifier :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_multipleCalls ) ) {
		os << std :: setw ( indent + 16 ) << "multipleCalls = " << std :: setprecision ( indent );
		m_multipleCalls -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_maintainConnection ) ) {
		os << std :: setw ( indent + 21 ) << "maintainConnection = " << std :: setprecision ( indent );
		m_maintainConnection -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_connectionParameters ) ) {
		os << std :: setw ( indent + 23 ) << "connectionParameters = " << std :: setprecision ( indent );
		m_connectionParameters -> Setup_UUIE_connectionParameters :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_language ) ) {
		os << std :: setw ( indent + 11 ) << "language = " << std :: setprecision ( indent );
		m_language -> Setup_UUIE_language :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_presentationIndicator ) ) {
		os << std :: setw ( indent + 24 ) << "presentationIndicator = " << std :: setprecision ( indent );
		m_presentationIndicator -> PresentationIndicator :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_screeningIndicator ) ) {
		os << std :: setw ( indent + 21 ) << "screeningIndicator = " << std :: setprecision ( indent );
		m_screeningIndicator -> ScreeningIndicator :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_serviceControl ) ) {
		os << std :: setw ( indent + 17 ) << "serviceControl = " << std :: setprecision ( indent );
		m_serviceControl -> ArrayOf_ServiceControlSession :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_symmetricOperationRequired ) ) {
		os << std :: setw ( indent + 29 ) << "symmetricOperationRequired = " << std :: setprecision ( indent );
		m_symmetricOperationRequired -> Asn :: Null :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_capacity ) ) {
		os << std :: setw ( indent + 11 ) << "capacity = " << std :: setprecision ( indent );
		m_capacity -> CallCapacity :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_circuitInfo ) ) {
		os << std :: setw ( indent + 14 ) << "circuitInfo = " << std :: setprecision ( indent );
		m_circuitInfo -> CircuitInfo :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_desiredProtocols ) ) {
		os << std :: setw ( indent + 19 ) << "desiredProtocols = " << std :: setprecision ( indent );
		m_desiredProtocols -> ArrayOf_SupportedProtocols :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_neededFeatures ) ) {
		os << std :: setw ( indent + 17 ) << "neededFeatures = " << std :: setprecision ( indent );
		m_neededFeatures -> ArrayOf_FeatureDescriptor :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_desiredFeatures ) ) {
		os << std :: setw ( indent + 18 ) << "desiredFeatures = " << std :: setprecision ( indent );
		m_desiredFeatures -> ArrayOf_FeatureDescriptor :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_supportedFeatures ) ) {
		os << std :: setw ( indent + 20 ) << "supportedFeatures = " << std :: setprecision ( indent );
		m_supportedFeatures -> ArrayOf_FeatureDescriptor :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_parallelH245Control ) ) {
		os << std :: setw ( indent + 22 ) << "parallelH245Control = " << std :: setprecision ( indent );
		m_parallelH245Control -> ArrayOf_Asn_OctetString :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_additionalSourceAddresses ) ) {
		os << std :: setw ( indent + 28 ) << "additionalSourceAddresses = " << std :: setprecision ( indent );
		m_additionalSourceAddresses -> ArrayOf_ExtendedAliasAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_hopCount ) ) {
		os << std :: setw ( indent + 11 ) << "hopCount = " << std :: setprecision ( indent );
		m_hopCount -> Setup_UUIE_hopCount :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

Setup_UUIE * Setup_UUIE :: clone ( ) const {
	return new Setup_UUIE ( * this );
}

//
// Facility-UUIE
//

Facility_UUIE :: Facility_UUIE ( Asn :: istream & is ) : Asn :: Sequence ( is, 3, true, 16 ), m_protocolIdentifier ( is ), m_alternativeAddress ( hasOptionalField ( e_alternativeAddress ) ? pushTemporaryMember ( new TransportAddress ( is ) ) : 0 ), m_alternativeAliasAddress ( hasOptionalField ( e_alternativeAliasAddress ) ? pushTemporaryMember ( new ArrayOf_AliasAddress ( is ) ) : 0 ), m_conferenceID ( hasOptionalField ( e_conferenceID ) ? pushTemporaryMember ( new ConferenceIdentifier ( is ) ) : 0 ), m_reason ( is ), m_callIdentifier ( 0 ), m_destExtraCallInfo ( 0 ), m_remoteExtensionAddress ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_conferences ( 0 ), m_h245Address ( 0 ), m_fastStart ( 0 ), m_multipleCalls ( 0 ), m_maintainConnection ( 0 ), m_fastConnectRefused ( 0 ), m_serviceControl ( 0 ), m_circuitInfo ( 0 ), m_featureSet ( 0 ), m_destinationInfo ( 0 ), m_h245SecurityMode ( 0 ) {
	clearTemporaryMembers ( );
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_callIdentifier ) )
				m_callIdentifier = new CallIdentifier ( is );
			if ( hasKnownExtensionToDecode ( is, e_destExtraCallInfo ) )
				m_destExtraCallInfo = new ArrayOf_AliasAddress ( is );
			if ( hasKnownExtensionToDecode ( is, e_remoteExtensionAddress ) )
				m_remoteExtensionAddress = new AliasAddress ( is );
			if ( hasKnownExtensionToDecode ( is, e_tokens ) )
				m_tokens = new ArrayOf_ClearToken ( is );
			if ( hasKnownExtensionToDecode ( is, e_cryptoTokens ) )
				m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
			if ( hasKnownExtensionToDecode ( is, e_conferences ) )
				m_conferences = new ArrayOf_ConferenceList ( is );
			if ( hasKnownExtensionToDecode ( is, e_h245Address ) )
				m_h245Address = new TransportAddress ( is );
			if ( hasKnownExtensionToDecode ( is, e_fastStart ) )
				m_fastStart = new ArrayOf_Asn_OctetString ( is );
			if ( hasKnownExtensionToDecode ( is, e_multipleCalls ) )
				m_multipleCalls = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_maintainConnection ) )
				m_maintainConnection = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_fastConnectRefused ) )
				m_fastConnectRefused = new Asn :: Null ( is );
			if ( hasKnownExtensionToDecode ( is, e_serviceControl ) )
				m_serviceControl = new ArrayOf_ServiceControlSession ( is );
			if ( hasKnownExtensionToDecode ( is, e_circuitInfo ) )
				m_circuitInfo = new CircuitInfo ( is );
			if ( hasKnownExtensionToDecode ( is, e_featureSet ) )
				m_featureSet = new FeatureSet ( is );
			if ( hasKnownExtensionToDecode ( is, e_destinationInfo ) )
				m_destinationInfo = new EndpointType ( is );
			if ( hasKnownExtensionToDecode ( is, e_h245SecurityMode ) )
				m_h245SecurityMode = new H245Security ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_alternativeAddress;
		delete m_alternativeAliasAddress;
		delete m_conferenceID;
		delete m_callIdentifier;
		delete m_destExtraCallInfo;
		delete m_remoteExtensionAddress;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_conferences;
		delete m_h245Address;
		delete m_fastStart;
		delete m_multipleCalls;
		delete m_maintainConnection;
		delete m_fastConnectRefused;
		delete m_serviceControl;
		delete m_circuitInfo;
		delete m_featureSet;
		delete m_destinationInfo;
		delete m_h245SecurityMode;
		throw;
	}
}

Facility_UUIE :: Facility_UUIE ( ) : Asn :: Sequence ( 3, true, 16 ), m_alternativeAddress ( 0 ), m_alternativeAliasAddress ( 0 ), m_conferenceID ( 0 ), m_callIdentifier ( 0 ), m_destExtraCallInfo ( 0 ), m_remoteExtensionAddress ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_conferences ( 0 ), m_h245Address ( 0 ), m_fastStart ( 0 ), m_multipleCalls ( 0 ), m_maintainConnection ( 0 ), m_fastConnectRefused ( 0 ), m_serviceControl ( 0 ), m_circuitInfo ( 0 ), m_featureSet ( 0 ), m_destinationInfo ( 0 ), m_h245SecurityMode ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_callIdentifier );
		m_callIdentifier = new CallIdentifier;
		Asn :: Sequence :: includeOptionalField ( e_multipleCalls );
		m_multipleCalls = new Asn :: Boolean;
		Asn :: Sequence :: includeOptionalField ( e_maintainConnection );
		m_maintainConnection = new Asn :: Boolean;
	} catch ( ... ) {
		delete m_callIdentifier;
		delete m_multipleCalls;
		delete m_maintainConnection;
		throw;
	}
}

Facility_UUIE & Facility_UUIE :: operator= ( const Facility_UUIE & s ) {
	Asn :: Sequence :: operator= ( s );
	m_protocolIdentifier = s.m_protocolIdentifier;
	assignCopy ( m_alternativeAddress, s.m_alternativeAddress );
	assignCopy ( m_alternativeAliasAddress, s.m_alternativeAliasAddress );
	assignCopy ( m_conferenceID, s.m_conferenceID );
	m_reason = s.m_reason;
	assignCopy ( m_callIdentifier, s.m_callIdentifier );
	assignCopy ( m_destExtraCallInfo, s.m_destExtraCallInfo );
	assignCopy ( m_remoteExtensionAddress, s.m_remoteExtensionAddress );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_conferences, s.m_conferences );
	assignCopy ( m_h245Address, s.m_h245Address );
	assignCopy ( m_fastStart, s.m_fastStart );
	assignCopy ( m_multipleCalls, s.m_multipleCalls );
	assignCopy ( m_maintainConnection, s.m_maintainConnection );
	assignCopy ( m_fastConnectRefused, s.m_fastConnectRefused );
	assignCopy ( m_serviceControl, s.m_serviceControl );
	assignCopy ( m_circuitInfo, s.m_circuitInfo );
	assignCopy ( m_featureSet, s.m_featureSet );
	assignCopy ( m_destinationInfo, s.m_destinationInfo );
	assignCopy ( m_h245SecurityMode, s.m_h245SecurityMode );
	return * this;
}

Facility_UUIE :: Facility_UUIE ( const Facility_UUIE & s ) : Asn :: Sequence ( s ), m_protocolIdentifier ( s.m_protocolIdentifier ), m_alternativeAddress ( 0 ), m_alternativeAliasAddress ( 0 ), m_conferenceID ( 0 ), m_reason ( s.m_reason ), m_callIdentifier ( 0 ), m_destExtraCallInfo ( 0 ), m_remoteExtensionAddress ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_conferences ( 0 ), m_h245Address ( 0 ), m_fastStart ( 0 ), m_multipleCalls ( 0 ), m_maintainConnection ( 0 ), m_fastConnectRefused ( 0 ), m_serviceControl ( 0 ), m_circuitInfo ( 0 ), m_featureSet ( 0 ), m_destinationInfo ( 0 ), m_h245SecurityMode ( 0 ) {
	try {
		if ( s.m_alternativeAddress )
			m_alternativeAddress = new TransportAddress ( * s.m_alternativeAddress );
		if ( s.m_alternativeAliasAddress )
			m_alternativeAliasAddress = new ArrayOf_AliasAddress ( * s.m_alternativeAliasAddress );
		if ( s.m_conferenceID )
			m_conferenceID = new ConferenceIdentifier ( * s.m_conferenceID );
		if ( s.m_callIdentifier )
			m_callIdentifier = new CallIdentifier ( * s.m_callIdentifier );
		if ( s.m_destExtraCallInfo )
			m_destExtraCallInfo = new ArrayOf_AliasAddress ( * s.m_destExtraCallInfo );
		if ( s.m_remoteExtensionAddress )
			m_remoteExtensionAddress = new AliasAddress ( * s.m_remoteExtensionAddress );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_conferences )
			m_conferences = new ArrayOf_ConferenceList ( * s.m_conferences );
		if ( s.m_h245Address )
			m_h245Address = new TransportAddress ( * s.m_h245Address );
		if ( s.m_fastStart )
			m_fastStart = new ArrayOf_Asn_OctetString ( * s.m_fastStart );
		if ( s.m_multipleCalls )
			m_multipleCalls = new Asn :: Boolean ( * s.m_multipleCalls );
		if ( s.m_maintainConnection )
			m_maintainConnection = new Asn :: Boolean ( * s.m_maintainConnection );
		if ( s.m_fastConnectRefused )
			m_fastConnectRefused = new Asn :: Null ( * s.m_fastConnectRefused );
		if ( s.m_serviceControl )
			m_serviceControl = new ArrayOf_ServiceControlSession ( * s.m_serviceControl );
		if ( s.m_circuitInfo )
			m_circuitInfo = new CircuitInfo ( * s.m_circuitInfo );
		if ( s.m_featureSet )
			m_featureSet = new FeatureSet ( * s.m_featureSet );
		if ( s.m_destinationInfo )
			m_destinationInfo = new EndpointType ( * s.m_destinationInfo );
		if ( s.m_h245SecurityMode )
			m_h245SecurityMode = new H245Security ( * s.m_h245SecurityMode );
	} catch ( ... ) {
		delete m_alternativeAddress;
		delete m_alternativeAliasAddress;
		delete m_conferenceID;
		delete m_callIdentifier;
		delete m_destExtraCallInfo;
		delete m_remoteExtensionAddress;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_conferences;
		delete m_h245Address;
		delete m_fastStart;
		delete m_multipleCalls;
		delete m_maintainConnection;
		delete m_fastConnectRefused;
		delete m_serviceControl;
		delete m_circuitInfo;
		delete m_featureSet;
		delete m_destinationInfo;
		delete m_h245SecurityMode;
		throw;
	}
}


void Facility_UUIE :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_alternativeAddress:
			assignNew ( m_alternativeAddress, new TransportAddress );
			break;
		case e_alternativeAliasAddress:
			assignNew ( m_alternativeAliasAddress, new ArrayOf_AliasAddress );
			break;
		case e_conferenceID:
			assignNew ( m_conferenceID, new ConferenceIdentifier );
			break;
		case e_callIdentifier:
			assignNew ( m_callIdentifier, new CallIdentifier );
			break;
		case e_destExtraCallInfo:
			assignNew ( m_destExtraCallInfo, new ArrayOf_AliasAddress );
			break;
		case e_remoteExtensionAddress:
			assignNew ( m_remoteExtensionAddress, new AliasAddress );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_conferences:
			assignNew ( m_conferences, new ArrayOf_ConferenceList );
			break;
		case e_h245Address:
			assignNew ( m_h245Address, new TransportAddress );
			break;
		case e_fastStart:
			assignNew ( m_fastStart, new ArrayOf_Asn_OctetString );
			break;
		case e_multipleCalls:
			assignNew ( m_multipleCalls, new Asn :: Boolean );
			break;
		case e_maintainConnection:
			assignNew ( m_maintainConnection, new Asn :: Boolean );
			break;
		case e_fastConnectRefused:
			assignNew ( m_fastConnectRefused, new Asn :: Null );
			break;
		case e_serviceControl:
			assignNew ( m_serviceControl, new ArrayOf_ServiceControlSession );
			break;
		case e_circuitInfo:
			assignNew ( m_circuitInfo, new CircuitInfo );
			break;
		case e_featureSet:
			assignNew ( m_featureSet, new FeatureSet );
			break;
		case e_destinationInfo:
			assignNew ( m_destinationInfo, new EndpointType );
			break;
		case e_h245SecurityMode:
			assignNew ( m_h245SecurityMode, new H245Security );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void Facility_UUIE :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_alternativeAddress:
			delete m_alternativeAddress;
			m_alternativeAddress = 0;
			break;
		case e_alternativeAliasAddress:
			delete m_alternativeAliasAddress;
			m_alternativeAliasAddress = 0;
			break;
		case e_conferenceID:
			delete m_conferenceID;
			m_conferenceID = 0;
			break;
		case e_callIdentifier:
			delete m_callIdentifier;
			m_callIdentifier = 0;
			break;
		case e_destExtraCallInfo:
			delete m_destExtraCallInfo;
			m_destExtraCallInfo = 0;
			break;
		case e_remoteExtensionAddress:
			delete m_remoteExtensionAddress;
			m_remoteExtensionAddress = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_conferences:
			delete m_conferences;
			m_conferences = 0;
			break;
		case e_h245Address:
			delete m_h245Address;
			m_h245Address = 0;
			break;
		case e_fastStart:
			delete m_fastStart;
			m_fastStart = 0;
			break;
		case e_multipleCalls:
			delete m_multipleCalls;
			m_multipleCalls = 0;
			break;
		case e_maintainConnection:
			delete m_maintainConnection;
			m_maintainConnection = 0;
			break;
		case e_fastConnectRefused:
			delete m_fastConnectRefused;
			m_fastConnectRefused = 0;
			break;
		case e_serviceControl:
			delete m_serviceControl;
			m_serviceControl = 0;
			break;
		case e_circuitInfo:
			delete m_circuitInfo;
			m_circuitInfo = 0;
			break;
		case e_featureSet:
			delete m_featureSet;
			m_featureSet = 0;
			break;
		case e_destinationInfo:
			delete m_destinationInfo;
			m_destinationInfo = 0;
			break;
		case e_h245SecurityMode:
			delete m_h245SecurityMode;
			m_h245SecurityMode = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void Facility_UUIE :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_protocolIdentifier.encode ( os );
	if ( hasOptionalField ( e_alternativeAddress ) )
		m_alternativeAddress -> TransportAddress :: encode ( os );
	if ( hasOptionalField ( e_alternativeAliasAddress ) )
		m_alternativeAliasAddress -> ArrayOf_AliasAddress :: encode ( os );
	if ( hasOptionalField ( e_conferenceID ) )
		m_conferenceID -> ConferenceIdentifier :: encode ( os );
	m_reason.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_callIdentifier, m_callIdentifier );
		knownExtensionEncode ( os, e_destExtraCallInfo, m_destExtraCallInfo );
		knownExtensionEncode ( os, e_remoteExtensionAddress, m_remoteExtensionAddress );
		knownExtensionEncode ( os, e_tokens, m_tokens );
		knownExtensionEncode ( os, e_cryptoTokens, m_cryptoTokens );
		knownExtensionEncode ( os, e_conferences, m_conferences );
		knownExtensionEncode ( os, e_h245Address, m_h245Address );
		knownExtensionEncode ( os, e_fastStart, m_fastStart );
		knownExtensionEncode ( os, e_multipleCalls, m_multipleCalls );
		knownExtensionEncode ( os, e_maintainConnection, m_maintainConnection );
		knownExtensionEncode ( os, e_fastConnectRefused, m_fastConnectRefused );
		knownExtensionEncode ( os, e_serviceControl, m_serviceControl );
		knownExtensionEncode ( os, e_circuitInfo, m_circuitInfo );
		knownExtensionEncode ( os, e_featureSet, m_featureSet );
		knownExtensionEncode ( os, e_destinationInfo, m_destinationInfo );
		knownExtensionEncode ( os, e_h245SecurityMode, m_h245SecurityMode );
		unknownExtensionsEncode ( os );
	}
}

Facility_UUIE :: ~Facility_UUIE ( ) {
	delete m_alternativeAddress;
	delete m_alternativeAliasAddress;
	delete m_conferenceID;
	delete m_callIdentifier;
	delete m_destExtraCallInfo;
	delete m_remoteExtensionAddress;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_conferences;
	delete m_h245Address;
	delete m_fastStart;
	delete m_multipleCalls;
	delete m_maintainConnection;
	delete m_fastConnectRefused;
	delete m_serviceControl;
	delete m_circuitInfo;
	delete m_featureSet;
	delete m_destinationInfo;
	delete m_h245SecurityMode;
}

void Facility_UUIE :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 21 ) << "protocolIdentifier = " << std :: setprecision ( indent ) << m_protocolIdentifier << '\n';
	if ( hasOptionalField ( e_alternativeAddress ) ) {
		os << std :: setw ( indent + 21 ) << "alternativeAddress = " << std :: setprecision ( indent );
		m_alternativeAddress -> TransportAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_alternativeAliasAddress ) ) {
		os << std :: setw ( indent + 26 ) << "alternativeAliasAddress = " << std :: setprecision ( indent );
		m_alternativeAliasAddress -> ArrayOf_AliasAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_conferenceID ) ) {
		os << std :: setw ( indent + 15 ) << "conferenceID = " << std :: setprecision ( indent );
		m_conferenceID -> ConferenceIdentifier :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 9 ) << "reason = " << std :: setprecision ( indent ) << m_reason << '\n';
	if ( hasOptionalField ( e_callIdentifier ) ) {
		os << std :: setw ( indent + 17 ) << "callIdentifier = " << std :: setprecision ( indent );
		m_callIdentifier -> CallIdentifier :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_destExtraCallInfo ) ) {
		os << std :: setw ( indent + 20 ) << "destExtraCallInfo = " << std :: setprecision ( indent );
		m_destExtraCallInfo -> ArrayOf_AliasAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_remoteExtensionAddress ) ) {
		os << std :: setw ( indent + 25 ) << "remoteExtensionAddress = " << std :: setprecision ( indent );
		m_remoteExtensionAddress -> AliasAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_conferences ) ) {
		os << std :: setw ( indent + 14 ) << "conferences = " << std :: setprecision ( indent );
		m_conferences -> ArrayOf_ConferenceList :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_h245Address ) ) {
		os << std :: setw ( indent + 14 ) << "h245Address = " << std :: setprecision ( indent );
		m_h245Address -> TransportAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_fastStart ) ) {
		os << std :: setw ( indent + 12 ) << "fastStart = " << std :: setprecision ( indent );
		m_fastStart -> ArrayOf_Asn_OctetString :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_multipleCalls ) ) {
		os << std :: setw ( indent + 16 ) << "multipleCalls = " << std :: setprecision ( indent );
		m_multipleCalls -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_maintainConnection ) ) {
		os << std :: setw ( indent + 21 ) << "maintainConnection = " << std :: setprecision ( indent );
		m_maintainConnection -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_fastConnectRefused ) ) {
		os << std :: setw ( indent + 21 ) << "fastConnectRefused = " << std :: setprecision ( indent );
		m_fastConnectRefused -> Asn :: Null :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_serviceControl ) ) {
		os << std :: setw ( indent + 17 ) << "serviceControl = " << std :: setprecision ( indent );
		m_serviceControl -> ArrayOf_ServiceControlSession :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_circuitInfo ) ) {
		os << std :: setw ( indent + 14 ) << "circuitInfo = " << std :: setprecision ( indent );
		m_circuitInfo -> CircuitInfo :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_featureSet ) ) {
		os << std :: setw ( indent + 13 ) << "featureSet = " << std :: setprecision ( indent );
		m_featureSet -> FeatureSet :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_destinationInfo ) ) {
		os << std :: setw ( indent + 18 ) << "destinationInfo = " << std :: setprecision ( indent );
		m_destinationInfo -> EndpointType :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_h245SecurityMode ) ) {
		os << std :: setw ( indent + 19 ) << "h245SecurityMode = " << std :: setprecision ( indent );
		m_h245SecurityMode -> H245Security :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

Facility_UUIE * Facility_UUIE :: clone ( ) const {
	return new Facility_UUIE ( * this );
}

//
// Progress-UUIE
//

Progress_UUIE :: Progress_UUIE ( Asn :: istream & is ) : Asn :: Sequence ( is, 5, true, 3 ), m_protocolIdentifier ( is ), m_destinationInfo ( is ), m_h245Address ( hasOptionalField ( e_h245Address ) ? pushTemporaryMember ( new TransportAddress ( is ) ) : 0 ), m_callIdentifier ( is ), m_h245SecurityMode ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_fastStart ( 0 ), m_multipleCalls ( 0 ), m_maintainConnection ( 0 ), m_fastConnectRefused ( 0 ) {
	clearTemporaryMembers ( );
	try {
		if ( hasOptionalField ( e_h245SecurityMode ) )
			m_h245SecurityMode = new H245Security ( is );
		if ( hasOptionalField ( e_tokens ) )
			m_tokens = new ArrayOf_ClearToken ( is );
		if ( hasOptionalField ( e_cryptoTokens ) )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
		if ( hasOptionalField ( e_fastStart ) )
			m_fastStart = new ArrayOf_Asn_OctetString ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_multipleCalls ) )
				m_multipleCalls = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_maintainConnection ) )
				m_maintainConnection = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_fastConnectRefused ) )
				m_fastConnectRefused = new Asn :: Null ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_h245Address;
		delete m_h245SecurityMode;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_fastStart;
		delete m_multipleCalls;
		delete m_maintainConnection;
		delete m_fastConnectRefused;
		throw;
	}
}

Progress_UUIE :: Progress_UUIE ( ) : Asn :: Sequence ( 5, true, 3 ), m_h245Address ( 0 ), m_h245SecurityMode ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_fastStart ( 0 ), m_multipleCalls ( 0 ), m_maintainConnection ( 0 ), m_fastConnectRefused ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_multipleCalls );
		m_multipleCalls = new Asn :: Boolean;
		Asn :: Sequence :: includeOptionalField ( e_maintainConnection );
		m_maintainConnection = new Asn :: Boolean;
	} catch ( ... ) {
		delete m_multipleCalls;
		delete m_maintainConnection;
		throw;
	}
}

Progress_UUIE & Progress_UUIE :: operator= ( const Progress_UUIE & s ) {
	Asn :: Sequence :: operator= ( s );
	m_protocolIdentifier = s.m_protocolIdentifier;
	m_destinationInfo = s.m_destinationInfo;
	assignCopy ( m_h245Address, s.m_h245Address );
	m_callIdentifier = s.m_callIdentifier;
	assignCopy ( m_h245SecurityMode, s.m_h245SecurityMode );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_fastStart, s.m_fastStart );
	assignCopy ( m_multipleCalls, s.m_multipleCalls );
	assignCopy ( m_maintainConnection, s.m_maintainConnection );
	assignCopy ( m_fastConnectRefused, s.m_fastConnectRefused );
	return * this;
}

Progress_UUIE :: Progress_UUIE ( const Progress_UUIE & s ) : Asn :: Sequence ( s ), m_protocolIdentifier ( s.m_protocolIdentifier ), m_destinationInfo ( s.m_destinationInfo ), m_h245Address ( 0 ), m_callIdentifier ( s.m_callIdentifier ), m_h245SecurityMode ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_fastStart ( 0 ), m_multipleCalls ( 0 ), m_maintainConnection ( 0 ), m_fastConnectRefused ( 0 ) {
	try {
		if ( s.m_h245Address )
			m_h245Address = new TransportAddress ( * s.m_h245Address );
		if ( s.m_h245SecurityMode )
			m_h245SecurityMode = new H245Security ( * s.m_h245SecurityMode );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_fastStart )
			m_fastStart = new ArrayOf_Asn_OctetString ( * s.m_fastStart );
		if ( s.m_multipleCalls )
			m_multipleCalls = new Asn :: Boolean ( * s.m_multipleCalls );
		if ( s.m_maintainConnection )
			m_maintainConnection = new Asn :: Boolean ( * s.m_maintainConnection );
		if ( s.m_fastConnectRefused )
			m_fastConnectRefused = new Asn :: Null ( * s.m_fastConnectRefused );
	} catch ( ... ) {
		delete m_h245Address;
		delete m_h245SecurityMode;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_fastStart;
		delete m_multipleCalls;
		delete m_maintainConnection;
		delete m_fastConnectRefused;
		throw;
	}
}


void Progress_UUIE :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_h245Address:
			assignNew ( m_h245Address, new TransportAddress );
			break;
		case e_h245SecurityMode:
			assignNew ( m_h245SecurityMode, new H245Security );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_fastStart:
			assignNew ( m_fastStart, new ArrayOf_Asn_OctetString );
			break;
		case e_multipleCalls:
			assignNew ( m_multipleCalls, new Asn :: Boolean );
			break;
		case e_maintainConnection:
			assignNew ( m_maintainConnection, new Asn :: Boolean );
			break;
		case e_fastConnectRefused:
			assignNew ( m_fastConnectRefused, new Asn :: Null );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void Progress_UUIE :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_h245Address:
			delete m_h245Address;
			m_h245Address = 0;
			break;
		case e_h245SecurityMode:
			delete m_h245SecurityMode;
			m_h245SecurityMode = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_fastStart:
			delete m_fastStart;
			m_fastStart = 0;
			break;
		case e_multipleCalls:
			delete m_multipleCalls;
			m_multipleCalls = 0;
			break;
		case e_maintainConnection:
			delete m_maintainConnection;
			m_maintainConnection = 0;
			break;
		case e_fastConnectRefused:
			delete m_fastConnectRefused;
			m_fastConnectRefused = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void Progress_UUIE :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_protocolIdentifier.encode ( os );
	m_destinationInfo.encode ( os );
	if ( hasOptionalField ( e_h245Address ) )
		m_h245Address -> TransportAddress :: encode ( os );
	m_callIdentifier.encode ( os );
	if ( hasOptionalField ( e_h245SecurityMode ) )
		m_h245SecurityMode -> H245Security :: encode ( os );
	if ( hasOptionalField ( e_tokens ) )
		m_tokens -> ArrayOf_ClearToken :: encode ( os );
	if ( hasOptionalField ( e_cryptoTokens ) )
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: encode ( os );
	if ( hasOptionalField ( e_fastStart ) )
		m_fastStart -> ArrayOf_Asn_OctetString :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_multipleCalls, m_multipleCalls );
		knownExtensionEncode ( os, e_maintainConnection, m_maintainConnection );
		knownExtensionEncode ( os, e_fastConnectRefused, m_fastConnectRefused );
		unknownExtensionsEncode ( os );
	}
}

Progress_UUIE :: ~Progress_UUIE ( ) {
	delete m_h245Address;
	delete m_h245SecurityMode;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_fastStart;
	delete m_multipleCalls;
	delete m_maintainConnection;
	delete m_fastConnectRefused;
}

void Progress_UUIE :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 21 ) << "protocolIdentifier = " << std :: setprecision ( indent ) << m_protocolIdentifier << '\n';
	os << std :: setw ( indent + 18 ) << "destinationInfo = " << std :: setprecision ( indent ) << m_destinationInfo << '\n';
	if ( hasOptionalField ( e_h245Address ) ) {
		os << std :: setw ( indent + 14 ) << "h245Address = " << std :: setprecision ( indent );
		m_h245Address -> TransportAddress :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 17 ) << "callIdentifier = " << std :: setprecision ( indent ) << m_callIdentifier << '\n';
	if ( hasOptionalField ( e_h245SecurityMode ) ) {
		os << std :: setw ( indent + 19 ) << "h245SecurityMode = " << std :: setprecision ( indent );
		m_h245SecurityMode -> H245Security :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_fastStart ) ) {
		os << std :: setw ( indent + 12 ) << "fastStart = " << std :: setprecision ( indent );
		m_fastStart -> ArrayOf_Asn_OctetString :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_multipleCalls ) ) {
		os << std :: setw ( indent + 16 ) << "multipleCalls = " << std :: setprecision ( indent );
		m_multipleCalls -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_maintainConnection ) ) {
		os << std :: setw ( indent + 21 ) << "maintainConnection = " << std :: setprecision ( indent );
		m_maintainConnection -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_fastConnectRefused ) ) {
		os << std :: setw ( indent + 21 ) << "fastConnectRefused = " << std :: setprecision ( indent );
		m_fastConnectRefused -> Asn :: Null :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

Progress_UUIE * Progress_UUIE :: clone ( ) const {
	return new Progress_UUIE ( * this );
}

//
// Status-UUIE
//

Status_UUIE :: Status_UUIE ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 0 ), m_protocolIdentifier ( is ), m_callIdentifier ( is ), m_tokens ( 0 ), m_cryptoTokens ( 0 ) {
	try {
		if ( hasOptionalField ( e_tokens ) )
			m_tokens = new ArrayOf_ClearToken ( is );
		if ( hasOptionalField ( e_cryptoTokens ) )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_tokens;
		delete m_cryptoTokens;
		throw;
	}
}

Status_UUIE :: Status_UUIE ( ) : Asn :: Sequence ( 2, true, 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ) { }

Status_UUIE & Status_UUIE :: operator= ( const Status_UUIE & s ) {
	Asn :: Sequence :: operator= ( s );
	m_protocolIdentifier = s.m_protocolIdentifier;
	m_callIdentifier = s.m_callIdentifier;
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	return * this;
}

Status_UUIE :: Status_UUIE ( const Status_UUIE & s ) : Asn :: Sequence ( s ), m_protocolIdentifier ( s.m_protocolIdentifier ), m_callIdentifier ( s.m_callIdentifier ), m_tokens ( 0 ), m_cryptoTokens ( 0 ) {
	try {
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
	} catch ( ... ) {
		delete m_tokens;
		delete m_cryptoTokens;
		throw;
	}
}


void Status_UUIE :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void Status_UUIE :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void Status_UUIE :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_protocolIdentifier.encode ( os );
	m_callIdentifier.encode ( os );
	if ( hasOptionalField ( e_tokens ) )
		m_tokens -> ArrayOf_ClearToken :: encode ( os );
	if ( hasOptionalField ( e_cryptoTokens ) )
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

Status_UUIE :: ~Status_UUIE ( ) {
	delete m_tokens;
	delete m_cryptoTokens;
}

void Status_UUIE :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 21 ) << "protocolIdentifier = " << std :: setprecision ( indent ) << m_protocolIdentifier << '\n';
	os << std :: setw ( indent + 17 ) << "callIdentifier = " << std :: setprecision ( indent ) << m_callIdentifier << '\n';
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

Status_UUIE * Status_UUIE :: clone ( ) const {
	return new Status_UUIE ( * this );
}

//
// StatusInquiry-UUIE
//

StatusInquiry_UUIE :: StatusInquiry_UUIE ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 0 ), m_protocolIdentifier ( is ), m_callIdentifier ( is ), m_tokens ( 0 ), m_cryptoTokens ( 0 ) {
	try {
		if ( hasOptionalField ( e_tokens ) )
			m_tokens = new ArrayOf_ClearToken ( is );
		if ( hasOptionalField ( e_cryptoTokens ) )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_tokens;
		delete m_cryptoTokens;
		throw;
	}
}

StatusInquiry_UUIE :: StatusInquiry_UUIE ( ) : Asn :: Sequence ( 2, true, 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ) { }

StatusInquiry_UUIE & StatusInquiry_UUIE :: operator= ( const StatusInquiry_UUIE & s ) {
	Asn :: Sequence :: operator= ( s );
	m_protocolIdentifier = s.m_protocolIdentifier;
	m_callIdentifier = s.m_callIdentifier;
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	return * this;
}

StatusInquiry_UUIE :: StatusInquiry_UUIE ( const StatusInquiry_UUIE & s ) : Asn :: Sequence ( s ), m_protocolIdentifier ( s.m_protocolIdentifier ), m_callIdentifier ( s.m_callIdentifier ), m_tokens ( 0 ), m_cryptoTokens ( 0 ) {
	try {
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
	} catch ( ... ) {
		delete m_tokens;
		delete m_cryptoTokens;
		throw;
	}
}


void StatusInquiry_UUIE :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void StatusInquiry_UUIE :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void StatusInquiry_UUIE :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_protocolIdentifier.encode ( os );
	m_callIdentifier.encode ( os );
	if ( hasOptionalField ( e_tokens ) )
		m_tokens -> ArrayOf_ClearToken :: encode ( os );
	if ( hasOptionalField ( e_cryptoTokens ) )
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

StatusInquiry_UUIE :: ~StatusInquiry_UUIE ( ) {
	delete m_tokens;
	delete m_cryptoTokens;
}

void StatusInquiry_UUIE :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 21 ) << "protocolIdentifier = " << std :: setprecision ( indent ) << m_protocolIdentifier << '\n';
	os << std :: setw ( indent + 17 ) << "callIdentifier = " << std :: setprecision ( indent ) << m_callIdentifier << '\n';
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

StatusInquiry_UUIE * StatusInquiry_UUIE :: clone ( ) const {
	return new StatusInquiry_UUIE ( * this );
}

//
// SetupAcknowledge-UUIE
//

SetupAcknowledge_UUIE :: SetupAcknowledge_UUIE ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 0 ), m_protocolIdentifier ( is ), m_callIdentifier ( is ), m_tokens ( 0 ), m_cryptoTokens ( 0 ) {
	try {
		if ( hasOptionalField ( e_tokens ) )
			m_tokens = new ArrayOf_ClearToken ( is );
		if ( hasOptionalField ( e_cryptoTokens ) )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_tokens;
		delete m_cryptoTokens;
		throw;
	}
}

SetupAcknowledge_UUIE :: SetupAcknowledge_UUIE ( ) : Asn :: Sequence ( 2, true, 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ) { }

SetupAcknowledge_UUIE & SetupAcknowledge_UUIE :: operator= ( const SetupAcknowledge_UUIE & s ) {
	Asn :: Sequence :: operator= ( s );
	m_protocolIdentifier = s.m_protocolIdentifier;
	m_callIdentifier = s.m_callIdentifier;
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	return * this;
}

SetupAcknowledge_UUIE :: SetupAcknowledge_UUIE ( const SetupAcknowledge_UUIE & s ) : Asn :: Sequence ( s ), m_protocolIdentifier ( s.m_protocolIdentifier ), m_callIdentifier ( s.m_callIdentifier ), m_tokens ( 0 ), m_cryptoTokens ( 0 ) {
	try {
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
	} catch ( ... ) {
		delete m_tokens;
		delete m_cryptoTokens;
		throw;
	}
}


void SetupAcknowledge_UUIE :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void SetupAcknowledge_UUIE :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void SetupAcknowledge_UUIE :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_protocolIdentifier.encode ( os );
	m_callIdentifier.encode ( os );
	if ( hasOptionalField ( e_tokens ) )
		m_tokens -> ArrayOf_ClearToken :: encode ( os );
	if ( hasOptionalField ( e_cryptoTokens ) )
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

SetupAcknowledge_UUIE :: ~SetupAcknowledge_UUIE ( ) {
	delete m_tokens;
	delete m_cryptoTokens;
}

void SetupAcknowledge_UUIE :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 21 ) << "protocolIdentifier = " << std :: setprecision ( indent ) << m_protocolIdentifier << '\n';
	os << std :: setw ( indent + 17 ) << "callIdentifier = " << std :: setprecision ( indent ) << m_callIdentifier << '\n';
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

SetupAcknowledge_UUIE * SetupAcknowledge_UUIE :: clone ( ) const {
	return new SetupAcknowledge_UUIE ( * this );
}

//
// Notify-UUIE
//

Notify_UUIE :: Notify_UUIE ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 0 ), m_protocolIdentifier ( is ), m_callIdentifier ( is ), m_tokens ( 0 ), m_cryptoTokens ( 0 ) {
	try {
		if ( hasOptionalField ( e_tokens ) )
			m_tokens = new ArrayOf_ClearToken ( is );
		if ( hasOptionalField ( e_cryptoTokens ) )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_tokens;
		delete m_cryptoTokens;
		throw;
	}
}

Notify_UUIE :: Notify_UUIE ( ) : Asn :: Sequence ( 2, true, 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ) { }

Notify_UUIE & Notify_UUIE :: operator= ( const Notify_UUIE & s ) {
	Asn :: Sequence :: operator= ( s );
	m_protocolIdentifier = s.m_protocolIdentifier;
	m_callIdentifier = s.m_callIdentifier;
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	return * this;
}

Notify_UUIE :: Notify_UUIE ( const Notify_UUIE & s ) : Asn :: Sequence ( s ), m_protocolIdentifier ( s.m_protocolIdentifier ), m_callIdentifier ( s.m_callIdentifier ), m_tokens ( 0 ), m_cryptoTokens ( 0 ) {
	try {
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
	} catch ( ... ) {
		delete m_tokens;
		delete m_cryptoTokens;
		throw;
	}
}


void Notify_UUIE :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void Notify_UUIE :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void Notify_UUIE :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_protocolIdentifier.encode ( os );
	m_callIdentifier.encode ( os );
	if ( hasOptionalField ( e_tokens ) )
		m_tokens -> ArrayOf_ClearToken :: encode ( os );
	if ( hasOptionalField ( e_cryptoTokens ) )
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

Notify_UUIE :: ~Notify_UUIE ( ) {
	delete m_tokens;
	delete m_cryptoTokens;
}

void Notify_UUIE :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 21 ) << "protocolIdentifier = " << std :: setprecision ( indent ) << m_protocolIdentifier << '\n';
	os << std :: setw ( indent + 17 ) << "callIdentifier = " << std :: setprecision ( indent ) << m_callIdentifier << '\n';
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

Notify_UUIE * Notify_UUIE :: clone ( ) const {
	return new Notify_UUIE ( * this );
}

//
// NonStandardProtocol
//

NonStandardProtocol :: NonStandardProtocol ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 0 ), m_nonStandardData ( hasOptionalField ( e_nonStandardData ) ? pushTemporaryMember ( new NonStandardParameter ( is ) ) : 0 ), m_dataRatesSupported ( hasOptionalField ( e_dataRatesSupported ) ? pushTemporaryMember ( new ArrayOf_DataRate ( is ) ) : 0 ), m_supportedPrefixes ( is ) {
	clearTemporaryMembers ( );
	try {
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_dataRatesSupported;
		throw;
	}
}

NonStandardProtocol :: NonStandardProtocol ( ) : Asn :: Sequence ( 2, true, 0 ), m_nonStandardData ( 0 ), m_dataRatesSupported ( 0 ) { }

NonStandardProtocol & NonStandardProtocol :: operator= ( const NonStandardProtocol & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	assignCopy ( m_dataRatesSupported, s.m_dataRatesSupported );
	m_supportedPrefixes = s.m_supportedPrefixes;
	return * this;
}

NonStandardProtocol :: NonStandardProtocol ( const NonStandardProtocol & s ) : Asn :: Sequence ( s ), m_nonStandardData ( 0 ), m_dataRatesSupported ( 0 ), m_supportedPrefixes ( s.m_supportedPrefixes ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_dataRatesSupported )
			m_dataRatesSupported = new ArrayOf_DataRate ( * s.m_dataRatesSupported );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_dataRatesSupported;
		throw;
	}
}


void NonStandardProtocol :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_dataRatesSupported:
			assignNew ( m_dataRatesSupported, new ArrayOf_DataRate );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void NonStandardProtocol :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_dataRatesSupported:
			delete m_dataRatesSupported;
			m_dataRatesSupported = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void NonStandardProtocol :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( hasOptionalField ( e_dataRatesSupported ) )
		m_dataRatesSupported -> ArrayOf_DataRate :: encode ( os );
	m_supportedPrefixes.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

NonStandardProtocol :: ~NonStandardProtocol ( ) {
	delete m_nonStandardData;
	delete m_dataRatesSupported;
}

void NonStandardProtocol :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_dataRatesSupported ) ) {
		os << std :: setw ( indent + 21 ) << "dataRatesSupported = " << std :: setprecision ( indent );
		m_dataRatesSupported -> ArrayOf_DataRate :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 20 ) << "supportedPrefixes = " << std :: setprecision ( indent ) << m_supportedPrefixes << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

NonStandardProtocol * NonStandardProtocol :: clone ( ) const {
	return new NonStandardProtocol ( * this );
}

//
// T38FaxAnnexbOnlyCaps
//

T38FaxAnnexbOnlyCaps :: T38FaxAnnexbOnlyCaps ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 0 ), m_nonStandardData ( hasOptionalField ( e_nonStandardData ) ? pushTemporaryMember ( new NonStandardParameter ( is ) ) : 0 ), m_dataRatesSupported ( hasOptionalField ( e_dataRatesSupported ) ? pushTemporaryMember ( new ArrayOf_DataRate ( is ) ) : 0 ), m_supportedPrefixes ( is ), m_t38FaxProtocol ( is ), m_t38FaxProfile ( is ) {
	clearTemporaryMembers ( );
	try {
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_dataRatesSupported;
		throw;
	}
}

T38FaxAnnexbOnlyCaps :: T38FaxAnnexbOnlyCaps ( ) : Asn :: Sequence ( 2, true, 0 ), m_nonStandardData ( 0 ), m_dataRatesSupported ( 0 ) { }

T38FaxAnnexbOnlyCaps & T38FaxAnnexbOnlyCaps :: operator= ( const T38FaxAnnexbOnlyCaps & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	assignCopy ( m_dataRatesSupported, s.m_dataRatesSupported );
	m_supportedPrefixes = s.m_supportedPrefixes;
	m_t38FaxProtocol = s.m_t38FaxProtocol;
	m_t38FaxProfile = s.m_t38FaxProfile;
	return * this;
}

T38FaxAnnexbOnlyCaps :: T38FaxAnnexbOnlyCaps ( const T38FaxAnnexbOnlyCaps & s ) : Asn :: Sequence ( s ), m_nonStandardData ( 0 ), m_dataRatesSupported ( 0 ), m_supportedPrefixes ( s.m_supportedPrefixes ), m_t38FaxProtocol ( s.m_t38FaxProtocol ), m_t38FaxProfile ( s.m_t38FaxProfile ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_dataRatesSupported )
			m_dataRatesSupported = new ArrayOf_DataRate ( * s.m_dataRatesSupported );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_dataRatesSupported;
		throw;
	}
}


void T38FaxAnnexbOnlyCaps :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_dataRatesSupported:
			assignNew ( m_dataRatesSupported, new ArrayOf_DataRate );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void T38FaxAnnexbOnlyCaps :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_dataRatesSupported:
			delete m_dataRatesSupported;
			m_dataRatesSupported = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void T38FaxAnnexbOnlyCaps :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( hasOptionalField ( e_dataRatesSupported ) )
		m_dataRatesSupported -> ArrayOf_DataRate :: encode ( os );
	m_supportedPrefixes.encode ( os );
	m_t38FaxProtocol.encode ( os );
	m_t38FaxProfile.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

T38FaxAnnexbOnlyCaps :: ~T38FaxAnnexbOnlyCaps ( ) {
	delete m_nonStandardData;
	delete m_dataRatesSupported;
}

void T38FaxAnnexbOnlyCaps :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_dataRatesSupported ) ) {
		os << std :: setw ( indent + 21 ) << "dataRatesSupported = " << std :: setprecision ( indent );
		m_dataRatesSupported -> ArrayOf_DataRate :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 20 ) << "supportedPrefixes = " << std :: setprecision ( indent ) << m_supportedPrefixes << '\n';
	os << std :: setw ( indent + 17 ) << "t38FaxProtocol = " << std :: setprecision ( indent ) << m_t38FaxProtocol << '\n';
	os << std :: setw ( indent + 16 ) << "t38FaxProfile = " << std :: setprecision ( indent ) << m_t38FaxProfile << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

T38FaxAnnexbOnlyCaps * T38FaxAnnexbOnlyCaps :: clone ( ) const {
	return new T38FaxAnnexbOnlyCaps ( * this );
}

//
// H221NonStandard
//

H221NonStandard :: H221NonStandard ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_t35CountryCode ( is ), m_t35Extension ( is ), m_manufacturerCode ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

H221NonStandard :: H221NonStandard ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void H221NonStandard :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_t35CountryCode.encode ( os );
	m_t35Extension.encode ( os );
	m_manufacturerCode.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void H221NonStandard :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 17 ) << "t35CountryCode = " << std :: setprecision ( indent ) << m_t35CountryCode << '\n';
	os << std :: setw ( indent + 15 ) << "t35Extension = " << std :: setprecision ( indent ) << m_t35Extension << '\n';
	os << std :: setw ( indent + 19 ) << "manufacturerCode = " << std :: setprecision ( indent ) << m_manufacturerCode << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H221NonStandard * H221NonStandard :: clone ( ) const {
	return new H221NonStandard ( * this );
}

//
// TunnelledProtocolAlternateIdentifier
//

TunnelledProtocolAlternateIdentifier :: TunnelledProtocolAlternateIdentifier ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_protocolType ( is ), m_protocolVariant ( 0 ) {
	try {
		if ( hasOptionalField ( e_protocolVariant ) )
			m_protocolVariant = new TunnelledProtocolAlternateIdentifier_protocolVariant ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_protocolVariant;
		throw;
	}
}

TunnelledProtocolAlternateIdentifier :: TunnelledProtocolAlternateIdentifier ( ) : Asn :: Sequence ( 1, true, 0 ), m_protocolVariant ( 0 ) { }

TunnelledProtocolAlternateIdentifier & TunnelledProtocolAlternateIdentifier :: operator= ( const TunnelledProtocolAlternateIdentifier & s ) {
	Asn :: Sequence :: operator= ( s );
	m_protocolType = s.m_protocolType;
	assignCopy ( m_protocolVariant, s.m_protocolVariant );
	return * this;
}

TunnelledProtocolAlternateIdentifier :: TunnelledProtocolAlternateIdentifier ( const TunnelledProtocolAlternateIdentifier & s ) : Asn :: Sequence ( s ), m_protocolType ( s.m_protocolType ), m_protocolVariant ( 0 ) {
	try {
		if ( s.m_protocolVariant )
			m_protocolVariant = new TunnelledProtocolAlternateIdentifier_protocolVariant ( * s.m_protocolVariant );
	} catch ( ... ) {
		delete m_protocolVariant;
		throw;
	}
}


void TunnelledProtocolAlternateIdentifier :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_protocolVariant:
			assignNew ( m_protocolVariant, new TunnelledProtocolAlternateIdentifier_protocolVariant );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void TunnelledProtocolAlternateIdentifier :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_protocolVariant:
			delete m_protocolVariant;
			m_protocolVariant = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void TunnelledProtocolAlternateIdentifier :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_protocolType.encode ( os );
	if ( hasOptionalField ( e_protocolVariant ) )
		m_protocolVariant -> TunnelledProtocolAlternateIdentifier_protocolVariant :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

TunnelledProtocolAlternateIdentifier :: ~TunnelledProtocolAlternateIdentifier ( ) {
	delete m_protocolVariant;
}

void TunnelledProtocolAlternateIdentifier :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 15 ) << "protocolType = " << std :: setprecision ( indent ) << m_protocolType << '\n';
	if ( hasOptionalField ( e_protocolVariant ) ) {
		os << std :: setw ( indent + 18 ) << "protocolVariant = " << std :: setprecision ( indent );
		m_protocolVariant -> TunnelledProtocolAlternateIdentifier_protocolVariant :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

TunnelledProtocolAlternateIdentifier * TunnelledProtocolAlternateIdentifier :: clone ( ) const {
	return new TunnelledProtocolAlternateIdentifier ( * this );
}

//
// NonStandardIdentifier
//

NonStandardIdentifier :: NonStandardIdentifier ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_object:
			choice = new Asn :: ObjectId ( is );
			break;
		case e_h221NonStandard:
			choice = new H221NonStandard ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

NonStandardIdentifier :: NonStandardIdentifier ( ) : Asn :: Choice ( 2, true ) { }

void NonStandardIdentifier :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_object:
			o = new Asn :: ObjectId;
			break;
		case e_h221NonStandard:
			o = new H221NonStandard;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & NonStandardIdentifier :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_object, "object" },
		{ e_h221NonStandard, "h221NonStandard" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

NonStandardIdentifier * NonStandardIdentifier :: clone ( ) const {
	return new NonStandardIdentifier ( * this );
}

//
// PublicPartyNumber
//

PublicPartyNumber :: PublicPartyNumber ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, false, 0 ), m_publicTypeOfNumber ( is ), m_publicNumberDigits ( is ) {
}

PublicPartyNumber :: PublicPartyNumber ( ) : Asn :: Sequence ( 0, false, 0 ) { }

void PublicPartyNumber :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_publicTypeOfNumber.encode ( os );
	m_publicNumberDigits.encode ( os );
}

void PublicPartyNumber :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 21 ) << "publicTypeOfNumber = " << std :: setprecision ( indent ) << m_publicTypeOfNumber << '\n';
	os << std :: setw ( indent + 21 ) << "publicNumberDigits = " << std :: setprecision ( indent ) << m_publicNumberDigits << '\n';
	os << std :: setw ( indent - 1 ) << '}';
}

PublicPartyNumber * PublicPartyNumber :: clone ( ) const {
	return new PublicPartyNumber ( * this );
}

//
// PrivatePartyNumber
//

PrivatePartyNumber :: PrivatePartyNumber ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, false, 0 ), m_privateTypeOfNumber ( is ), m_privateNumberDigits ( is ) {
}

PrivatePartyNumber :: PrivatePartyNumber ( ) : Asn :: Sequence ( 0, false, 0 ) { }

void PrivatePartyNumber :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_privateTypeOfNumber.encode ( os );
	m_privateNumberDigits.encode ( os );
}

void PrivatePartyNumber :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 22 ) << "privateTypeOfNumber = " << std :: setprecision ( indent ) << m_privateTypeOfNumber << '\n';
	os << std :: setw ( indent + 22 ) << "privateNumberDigits = " << std :: setprecision ( indent ) << m_privateNumberDigits << '\n';
	os << std :: setw ( indent - 1 ) << '}';
}

PrivatePartyNumber * PrivatePartyNumber :: clone ( ) const {
	return new PrivatePartyNumber ( * this );
}

//
// GSM-UIM
//

GSM_UIM :: GSM_UIM ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_imsi ( is ), m_tmsi ( hasOptionalField ( e_tmsi ) ? pushTemporaryMember ( new GSM_UIM_tmsi ( is ) ) : 0 ), m_msisdn ( is ), m_imei ( is ), m_hplmn ( is ), m_vplmn ( is ) {
	clearTemporaryMembers ( );
	try {
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_tmsi;
		throw;
	}
}

GSM_UIM :: GSM_UIM ( ) : Asn :: Sequence ( 1, true, 0 ), m_tmsi ( 0 ) { }

GSM_UIM & GSM_UIM :: operator= ( const GSM_UIM & s ) {
	Asn :: Sequence :: operator= ( s );
	m_imsi = s.m_imsi;
	assignCopy ( m_tmsi, s.m_tmsi );
	m_msisdn = s.m_msisdn;
	m_imei = s.m_imei;
	m_hplmn = s.m_hplmn;
	m_vplmn = s.m_vplmn;
	return * this;
}

GSM_UIM :: GSM_UIM ( const GSM_UIM & s ) : Asn :: Sequence ( s ), m_imsi ( s.m_imsi ), m_tmsi ( 0 ), m_msisdn ( s.m_msisdn ), m_imei ( s.m_imei ), m_hplmn ( s.m_hplmn ), m_vplmn ( s.m_vplmn ) {
	try {
		if ( s.m_tmsi )
			m_tmsi = new GSM_UIM_tmsi ( * s.m_tmsi );
	} catch ( ... ) {
		delete m_tmsi;
		throw;
	}
}


void GSM_UIM :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_tmsi:
			assignNew ( m_tmsi, new GSM_UIM_tmsi );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void GSM_UIM :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_tmsi:
			delete m_tmsi;
			m_tmsi = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void GSM_UIM :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_imsi.encode ( os );
	if ( hasOptionalField ( e_tmsi ) )
		m_tmsi -> GSM_UIM_tmsi :: encode ( os );
	m_msisdn.encode ( os );
	m_imei.encode ( os );
	m_hplmn.encode ( os );
	m_vplmn.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

GSM_UIM :: ~GSM_UIM ( ) {
	delete m_tmsi;
}

void GSM_UIM :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 7 ) << "imsi = " << std :: setprecision ( indent ) << m_imsi << '\n';
	if ( hasOptionalField ( e_tmsi ) ) {
		os << std :: setw ( indent + 7 ) << "tmsi = " << std :: setprecision ( indent );
		m_tmsi -> GSM_UIM_tmsi :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 9 ) << "msisdn = " << std :: setprecision ( indent ) << m_msisdn << '\n';
	os << std :: setw ( indent + 7 ) << "imei = " << std :: setprecision ( indent ) << m_imei << '\n';
	os << std :: setw ( indent + 8 ) << "hplmn = " << std :: setprecision ( indent ) << m_hplmn << '\n';
	os << std :: setw ( indent + 8 ) << "vplmn = " << std :: setprecision ( indent ) << m_vplmn << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

GSM_UIM * GSM_UIM :: clone ( ) const {
	return new GSM_UIM ( * this );
}

//
// IsupPublicPartyNumber
//

IsupPublicPartyNumber :: IsupPublicPartyNumber ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_natureOfAddress ( is ), m_address ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

IsupPublicPartyNumber :: IsupPublicPartyNumber ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void IsupPublicPartyNumber :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_natureOfAddress.encode ( os );
	m_address.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void IsupPublicPartyNumber :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 18 ) << "natureOfAddress = " << std :: setprecision ( indent ) << m_natureOfAddress << '\n';
	os << std :: setw ( indent + 10 ) << "address = " << std :: setprecision ( indent ) << m_address << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

IsupPublicPartyNumber * IsupPublicPartyNumber :: clone ( ) const {
	return new IsupPublicPartyNumber ( * this );
}

//
// IsupPrivatePartyNumber
//

IsupPrivatePartyNumber :: IsupPrivatePartyNumber ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_privateTypeOfNumber ( is ), m_address ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

IsupPrivatePartyNumber :: IsupPrivatePartyNumber ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void IsupPrivatePartyNumber :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_privateTypeOfNumber.encode ( os );
	m_address.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void IsupPrivatePartyNumber :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 22 ) << "privateTypeOfNumber = " << std :: setprecision ( indent ) << m_privateTypeOfNumber << '\n';
	os << std :: setw ( indent + 10 ) << "address = " << std :: setprecision ( indent ) << m_address << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

IsupPrivatePartyNumber * IsupPrivatePartyNumber :: clone ( ) const {
	return new IsupPrivatePartyNumber ( * this );
}

//
// AltGKInfo
//

AltGKInfo :: AltGKInfo ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_alternateGatekeeper ( is ), m_altGKisPermanent ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

AltGKInfo :: AltGKInfo ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void AltGKInfo :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_alternateGatekeeper.encode ( os );
	m_altGKisPermanent.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void AltGKInfo :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 22 ) << "alternateGatekeeper = " << std :: setprecision ( indent ) << m_alternateGatekeeper << '\n';
	os << std :: setw ( indent + 19 ) << "altGKisPermanent = " << std :: setprecision ( indent ) << m_altGKisPermanent << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

AltGKInfo * AltGKInfo :: clone ( ) const {
	return new AltGKInfo ( * this );
}

//
// QseriesOptions
//

QseriesOptions :: QseriesOptions ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_q932Full ( is ), m_q951Full ( is ), m_q952Full ( is ), m_q953Full ( is ), m_q955Full ( is ), m_q956Full ( is ), m_q957Full ( is ), m_q954Info ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

QseriesOptions :: QseriesOptions ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void QseriesOptions :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_q932Full.encode ( os );
	m_q951Full.encode ( os );
	m_q952Full.encode ( os );
	m_q953Full.encode ( os );
	m_q955Full.encode ( os );
	m_q956Full.encode ( os );
	m_q957Full.encode ( os );
	m_q954Info.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void QseriesOptions :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 11 ) << "q932Full = " << std :: setprecision ( indent ) << m_q932Full << '\n';
	os << std :: setw ( indent + 11 ) << "q951Full = " << std :: setprecision ( indent ) << m_q951Full << '\n';
	os << std :: setw ( indent + 11 ) << "q952Full = " << std :: setprecision ( indent ) << m_q952Full << '\n';
	os << std :: setw ( indent + 11 ) << "q953Full = " << std :: setprecision ( indent ) << m_q953Full << '\n';
	os << std :: setw ( indent + 11 ) << "q955Full = " << std :: setprecision ( indent ) << m_q955Full << '\n';
	os << std :: setw ( indent + 11 ) << "q956Full = " << std :: setprecision ( indent ) << m_q956Full << '\n';
	os << std :: setw ( indent + 11 ) << "q957Full = " << std :: setprecision ( indent ) << m_q957Full << '\n';
	os << std :: setw ( indent + 11 ) << "q954Info = " << std :: setprecision ( indent ) << m_q954Info << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

QseriesOptions * QseriesOptions :: clone ( ) const {
	return new QseriesOptions ( * this );
}

//
// CapacityReportingSpecification
//

CapacityReportingSpecification :: CapacityReportingSpecification ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_when ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

CapacityReportingSpecification :: CapacityReportingSpecification ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void CapacityReportingSpecification :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_when.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void CapacityReportingSpecification :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 7 ) << "when = " << std :: setprecision ( indent ) << m_when << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

CapacityReportingSpecification * CapacityReportingSpecification :: clone ( ) const {
	return new CapacityReportingSpecification ( * this );
}

//
// CallsAvailable
//

CallsAvailable :: CallsAvailable ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 1 ), m_calls ( is ), m_group ( 0 ), m_carrier ( 0 ) {
	try {
		if ( hasOptionalField ( e_group ) )
			m_group = new CallsAvailable_group ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_carrier ) )
				m_carrier = new CarrierInfo ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_group;
		delete m_carrier;
		throw;
	}
}

CallsAvailable :: CallsAvailable ( ) : Asn :: Sequence ( 1, true, 1 ), m_group ( 0 ), m_carrier ( 0 ) { }

CallsAvailable & CallsAvailable :: operator= ( const CallsAvailable & s ) {
	Asn :: Sequence :: operator= ( s );
	m_calls = s.m_calls;
	assignCopy ( m_group, s.m_group );
	assignCopy ( m_carrier, s.m_carrier );
	return * this;
}

CallsAvailable :: CallsAvailable ( const CallsAvailable & s ) : Asn :: Sequence ( s ), m_calls ( s.m_calls ), m_group ( 0 ), m_carrier ( 0 ) {
	try {
		if ( s.m_group )
			m_group = new CallsAvailable_group ( * s.m_group );
		if ( s.m_carrier )
			m_carrier = new CarrierInfo ( * s.m_carrier );
	} catch ( ... ) {
		delete m_group;
		delete m_carrier;
		throw;
	}
}


void CallsAvailable :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_group:
			assignNew ( m_group, new CallsAvailable_group );
			break;
		case e_carrier:
			assignNew ( m_carrier, new CarrierInfo );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void CallsAvailable :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_group:
			delete m_group;
			m_group = 0;
			break;
		case e_carrier:
			delete m_carrier;
			m_carrier = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void CallsAvailable :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_calls.encode ( os );
	if ( hasOptionalField ( e_group ) )
		m_group -> CallsAvailable_group :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_carrier, m_carrier );
		unknownExtensionsEncode ( os );
	}
}

CallsAvailable :: ~CallsAvailable ( ) {
	delete m_group;
	delete m_carrier;
}

void CallsAvailable :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 8 ) << "calls = " << std :: setprecision ( indent ) << m_calls << '\n';
	if ( hasOptionalField ( e_group ) ) {
		os << std :: setw ( indent + 8 ) << "group = " << std :: setprecision ( indent );
		m_group -> CallsAvailable_group :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_carrier ) ) {
		os << std :: setw ( indent + 10 ) << "carrier = " << std :: setprecision ( indent );
		m_carrier -> CarrierInfo :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

CallsAvailable * CallsAvailable :: clone ( ) const {
	return new CallsAvailable ( * this );
}

//
// CicInfo
//

CicInfo :: CicInfo ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_cic ( is ), m_pointCode ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

CicInfo :: CicInfo ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void CicInfo :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_cic.encode ( os );
	m_pointCode.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void CicInfo :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 6 ) << "cic = " << std :: setprecision ( indent ) << m_cic << '\n';
	os << std :: setw ( indent + 12 ) << "pointCode = " << std :: setprecision ( indent ) << m_pointCode << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

CicInfo * CicInfo :: clone ( ) const {
	return new CicInfo ( * this );
}

//
// GroupID
//

GroupID :: GroupID ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_member ( hasOptionalField ( e_member ) ? pushTemporaryMember ( new GroupID_member ( is ) ) : 0 ), m_group ( is ) {
	clearTemporaryMembers ( );
	try {
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_member;
		throw;
	}
}

GroupID :: GroupID ( ) : Asn :: Sequence ( 1, true, 0 ), m_member ( 0 ) { }

GroupID & GroupID :: operator= ( const GroupID & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_member, s.m_member );
	m_group = s.m_group;
	return * this;
}

GroupID :: GroupID ( const GroupID & s ) : Asn :: Sequence ( s ), m_member ( 0 ), m_group ( s.m_group ) {
	try {
		if ( s.m_member )
			m_member = new GroupID_member ( * s.m_member );
	} catch ( ... ) {
		delete m_member;
		throw;
	}
}


void GroupID :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_member:
			assignNew ( m_member, new GroupID_member );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void GroupID :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_member:
			delete m_member;
			m_member = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void GroupID :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_member ) )
		m_member -> GroupID_member :: encode ( os );
	m_group.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

GroupID :: ~GroupID ( ) {
	delete m_member;
}

void GroupID :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_member ) ) {
		os << std :: setw ( indent + 9 ) << "member = " << std :: setprecision ( indent );
		m_member -> GroupID_member :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 8 ) << "group = " << std :: setprecision ( indent ) << m_group << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

GroupID * GroupID :: clone ( ) const {
	return new GroupID ( * this );
}

//
// ServiceControlSession
//

ServiceControlSession :: ServiceControlSession ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_sessionId ( is ), m_contents ( hasOptionalField ( e_contents ) ? pushTemporaryMember ( new ServiceControlDescriptor ( is ) ) : 0 ), m_reason ( is ) {
	clearTemporaryMembers ( );
	try {
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_contents;
		throw;
	}
}

ServiceControlSession :: ServiceControlSession ( ) : Asn :: Sequence ( 1, true, 0 ), m_contents ( 0 ) { }

ServiceControlSession & ServiceControlSession :: operator= ( const ServiceControlSession & s ) {
	Asn :: Sequence :: operator= ( s );
	m_sessionId = s.m_sessionId;
	assignCopy ( m_contents, s.m_contents );
	m_reason = s.m_reason;
	return * this;
}

ServiceControlSession :: ServiceControlSession ( const ServiceControlSession & s ) : Asn :: Sequence ( s ), m_sessionId ( s.m_sessionId ), m_contents ( 0 ), m_reason ( s.m_reason ) {
	try {
		if ( s.m_contents )
			m_contents = new ServiceControlDescriptor ( * s.m_contents );
	} catch ( ... ) {
		delete m_contents;
		throw;
	}
}


void ServiceControlSession :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_contents:
			assignNew ( m_contents, new ServiceControlDescriptor );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void ServiceControlSession :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_contents:
			delete m_contents;
			m_contents = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void ServiceControlSession :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_sessionId.encode ( os );
	if ( hasOptionalField ( e_contents ) )
		m_contents -> ServiceControlDescriptor :: encode ( os );
	m_reason.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

ServiceControlSession :: ~ServiceControlSession ( ) {
	delete m_contents;
}

void ServiceControlSession :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 12 ) << "sessionId = " << std :: setprecision ( indent ) << m_sessionId << '\n';
	if ( hasOptionalField ( e_contents ) ) {
		os << std :: setw ( indent + 11 ) << "contents = " << std :: setprecision ( indent );
		m_contents -> ServiceControlDescriptor :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 9 ) << "reason = " << std :: setprecision ( indent ) << m_reason << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

ServiceControlSession * ServiceControlSession :: clone ( ) const {
	return new ServiceControlSession ( * this );
}

//
// RasUsageInfoTypes
//

RasUsageInfoTypes :: RasUsageInfoTypes ( Asn :: istream & is ) : Asn :: Sequence ( is, 3, true, 0 ), m_nonStandardUsageTypes ( is ), m_startTime ( 0 ), m_endTime ( 0 ), m_terminationCause ( 0 ) {
	try {
		if ( hasOptionalField ( e_startTime ) )
			m_startTime = new Asn :: Null ( is );
		if ( hasOptionalField ( e_endTime ) )
			m_endTime = new Asn :: Null ( is );
		if ( hasOptionalField ( e_terminationCause ) )
			m_terminationCause = new Asn :: Null ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_startTime;
		delete m_endTime;
		delete m_terminationCause;
		throw;
	}
}

RasUsageInfoTypes :: RasUsageInfoTypes ( ) : Asn :: Sequence ( 3, true, 0 ), m_startTime ( 0 ), m_endTime ( 0 ), m_terminationCause ( 0 ) { }

RasUsageInfoTypes & RasUsageInfoTypes :: operator= ( const RasUsageInfoTypes & s ) {
	Asn :: Sequence :: operator= ( s );
	m_nonStandardUsageTypes = s.m_nonStandardUsageTypes;
	assignCopy ( m_startTime, s.m_startTime );
	assignCopy ( m_endTime, s.m_endTime );
	assignCopy ( m_terminationCause, s.m_terminationCause );
	return * this;
}

RasUsageInfoTypes :: RasUsageInfoTypes ( const RasUsageInfoTypes & s ) : Asn :: Sequence ( s ), m_nonStandardUsageTypes ( s.m_nonStandardUsageTypes ), m_startTime ( 0 ), m_endTime ( 0 ), m_terminationCause ( 0 ) {
	try {
		if ( s.m_startTime )
			m_startTime = new Asn :: Null ( * s.m_startTime );
		if ( s.m_endTime )
			m_endTime = new Asn :: Null ( * s.m_endTime );
		if ( s.m_terminationCause )
			m_terminationCause = new Asn :: Null ( * s.m_terminationCause );
	} catch ( ... ) {
		delete m_startTime;
		delete m_endTime;
		delete m_terminationCause;
		throw;
	}
}


void RasUsageInfoTypes :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_startTime:
			assignNew ( m_startTime, new Asn :: Null );
			break;
		case e_endTime:
			assignNew ( m_endTime, new Asn :: Null );
			break;
		case e_terminationCause:
			assignNew ( m_terminationCause, new Asn :: Null );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void RasUsageInfoTypes :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_startTime:
			delete m_startTime;
			m_startTime = 0;
			break;
		case e_endTime:
			delete m_endTime;
			m_endTime = 0;
			break;
		case e_terminationCause:
			delete m_terminationCause;
			m_terminationCause = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void RasUsageInfoTypes :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_nonStandardUsageTypes.encode ( os );
	if ( hasOptionalField ( e_startTime ) )
		m_startTime -> Asn :: Null :: encode ( os );
	if ( hasOptionalField ( e_endTime ) )
		m_endTime -> Asn :: Null :: encode ( os );
	if ( hasOptionalField ( e_terminationCause ) )
		m_terminationCause -> Asn :: Null :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

RasUsageInfoTypes :: ~RasUsageInfoTypes ( ) {
	delete m_startTime;
	delete m_endTime;
	delete m_terminationCause;
}

void RasUsageInfoTypes :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 24 ) << "nonStandardUsageTypes = " << std :: setprecision ( indent ) << m_nonStandardUsageTypes << '\n';
	if ( hasOptionalField ( e_startTime ) ) {
		os << std :: setw ( indent + 12 ) << "startTime = " << std :: setprecision ( indent );
		m_startTime -> Asn :: Null :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_endTime ) ) {
		os << std :: setw ( indent + 10 ) << "endTime = " << std :: setprecision ( indent );
		m_endTime -> Asn :: Null :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_terminationCause ) ) {
		os << std :: setw ( indent + 19 ) << "terminationCause = " << std :: setprecision ( indent );
		m_terminationCause -> Asn :: Null :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RasUsageInfoTypes * RasUsageInfoTypes :: clone ( ) const {
	return new RasUsageInfoTypes ( * this );
}

//
// RasUsageSpecification
//

RasUsageSpecification :: RasUsageSpecification ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_when ( is ), m_callStartingPoint ( hasOptionalField ( e_callStartingPoint ) ? pushTemporaryMember ( new RasUsageSpecification_callStartingPoint ( is ) ) : 0 ), m_required ( is ) {
	clearTemporaryMembers ( );
	try {
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_callStartingPoint;
		throw;
	}
}

RasUsageSpecification :: RasUsageSpecification ( ) : Asn :: Sequence ( 1, true, 0 ), m_callStartingPoint ( 0 ) { }

RasUsageSpecification & RasUsageSpecification :: operator= ( const RasUsageSpecification & s ) {
	Asn :: Sequence :: operator= ( s );
	m_when = s.m_when;
	assignCopy ( m_callStartingPoint, s.m_callStartingPoint );
	m_required = s.m_required;
	return * this;
}

RasUsageSpecification :: RasUsageSpecification ( const RasUsageSpecification & s ) : Asn :: Sequence ( s ), m_when ( s.m_when ), m_callStartingPoint ( 0 ), m_required ( s.m_required ) {
	try {
		if ( s.m_callStartingPoint )
			m_callStartingPoint = new RasUsageSpecification_callStartingPoint ( * s.m_callStartingPoint );
	} catch ( ... ) {
		delete m_callStartingPoint;
		throw;
	}
}


void RasUsageSpecification :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_callStartingPoint:
			assignNew ( m_callStartingPoint, new RasUsageSpecification_callStartingPoint );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void RasUsageSpecification :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_callStartingPoint:
			delete m_callStartingPoint;
			m_callStartingPoint = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void RasUsageSpecification :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_when.encode ( os );
	if ( hasOptionalField ( e_callStartingPoint ) )
		m_callStartingPoint -> RasUsageSpecification_callStartingPoint :: encode ( os );
	m_required.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

RasUsageSpecification :: ~RasUsageSpecification ( ) {
	delete m_callStartingPoint;
}

void RasUsageSpecification :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 7 ) << "when = " << std :: setprecision ( indent ) << m_when << '\n';
	if ( hasOptionalField ( e_callStartingPoint ) ) {
		os << std :: setw ( indent + 20 ) << "callStartingPoint = " << std :: setprecision ( indent );
		m_callStartingPoint -> RasUsageSpecification_callStartingPoint :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 11 ) << "required = " << std :: setprecision ( indent ) << m_required << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RasUsageSpecification * RasUsageSpecification :: clone ( ) const {
	return new RasUsageSpecification ( * this );
}

//
// RasUsageInformation
//

RasUsageInformation :: RasUsageInformation ( Asn :: istream & is ) : Asn :: Sequence ( is, 3, true, 0 ), m_nonStandardUsageFields ( is ), m_alertingTime ( 0 ), m_connectTime ( 0 ), m_endTime ( 0 ) {
	try {
		if ( hasOptionalField ( e_alertingTime ) )
			m_alertingTime = new H235 :: TimeStamp ( is );
		if ( hasOptionalField ( e_connectTime ) )
			m_connectTime = new H235 :: TimeStamp ( is );
		if ( hasOptionalField ( e_endTime ) )
			m_endTime = new H235 :: TimeStamp ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_alertingTime;
		delete m_connectTime;
		delete m_endTime;
		throw;
	}
}

RasUsageInformation :: RasUsageInformation ( ) : Asn :: Sequence ( 3, true, 0 ), m_alertingTime ( 0 ), m_connectTime ( 0 ), m_endTime ( 0 ) { }

RasUsageInformation & RasUsageInformation :: operator= ( const RasUsageInformation & s ) {
	Asn :: Sequence :: operator= ( s );
	m_nonStandardUsageFields = s.m_nonStandardUsageFields;
	assignCopy ( m_alertingTime, s.m_alertingTime );
	assignCopy ( m_connectTime, s.m_connectTime );
	assignCopy ( m_endTime, s.m_endTime );
	return * this;
}

RasUsageInformation :: RasUsageInformation ( const RasUsageInformation & s ) : Asn :: Sequence ( s ), m_nonStandardUsageFields ( s.m_nonStandardUsageFields ), m_alertingTime ( 0 ), m_connectTime ( 0 ), m_endTime ( 0 ) {
	try {
		if ( s.m_alertingTime )
			m_alertingTime = new H235 :: TimeStamp ( * s.m_alertingTime );
		if ( s.m_connectTime )
			m_connectTime = new H235 :: TimeStamp ( * s.m_connectTime );
		if ( s.m_endTime )
			m_endTime = new H235 :: TimeStamp ( * s.m_endTime );
	} catch ( ... ) {
		delete m_alertingTime;
		delete m_connectTime;
		delete m_endTime;
		throw;
	}
}


void RasUsageInformation :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_alertingTime:
			assignNew ( m_alertingTime, new H235 :: TimeStamp );
			break;
		case e_connectTime:
			assignNew ( m_connectTime, new H235 :: TimeStamp );
			break;
		case e_endTime:
			assignNew ( m_endTime, new H235 :: TimeStamp );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void RasUsageInformation :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_alertingTime:
			delete m_alertingTime;
			m_alertingTime = 0;
			break;
		case e_connectTime:
			delete m_connectTime;
			m_connectTime = 0;
			break;
		case e_endTime:
			delete m_endTime;
			m_endTime = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void RasUsageInformation :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_nonStandardUsageFields.encode ( os );
	if ( hasOptionalField ( e_alertingTime ) )
		m_alertingTime -> H235 :: TimeStamp :: encode ( os );
	if ( hasOptionalField ( e_connectTime ) )
		m_connectTime -> H235 :: TimeStamp :: encode ( os );
	if ( hasOptionalField ( e_endTime ) )
		m_endTime -> H235 :: TimeStamp :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

RasUsageInformation :: ~RasUsageInformation ( ) {
	delete m_alertingTime;
	delete m_connectTime;
	delete m_endTime;
}

void RasUsageInformation :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 25 ) << "nonStandardUsageFields = " << std :: setprecision ( indent ) << m_nonStandardUsageFields << '\n';
	if ( hasOptionalField ( e_alertingTime ) ) {
		os << std :: setw ( indent + 15 ) << "alertingTime = " << std :: setprecision ( indent );
		m_alertingTime -> H235 :: TimeStamp :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_connectTime ) ) {
		os << std :: setw ( indent + 14 ) << "connectTime = " << std :: setprecision ( indent );
		m_connectTime -> H235 :: TimeStamp :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_endTime ) ) {
		os << std :: setw ( indent + 10 ) << "endTime = " << std :: setprecision ( indent );
		m_endTime -> H235 :: TimeStamp :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RasUsageInformation * RasUsageInformation :: clone ( ) const {
	return new RasUsageInformation ( * this );
}

//
// BandwidthDetails
//

BandwidthDetails :: BandwidthDetails ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_sender ( is ), m_multicast ( is ), m_bandwidth ( is ), m_rtcpAddresses ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

BandwidthDetails :: BandwidthDetails ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void BandwidthDetails :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_sender.encode ( os );
	m_multicast.encode ( os );
	m_bandwidth.encode ( os );
	m_rtcpAddresses.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void BandwidthDetails :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 9 ) << "sender = " << std :: setprecision ( indent ) << m_sender << '\n';
	os << std :: setw ( indent + 12 ) << "multicast = " << std :: setprecision ( indent ) << m_multicast << '\n';
	os << std :: setw ( indent + 12 ) << "bandwidth = " << std :: setprecision ( indent ) << m_bandwidth << '\n';
	os << std :: setw ( indent + 16 ) << "rtcpAddresses = " << std :: setprecision ( indent ) << m_rtcpAddresses << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

BandwidthDetails * BandwidthDetails :: clone ( ) const {
	return new BandwidthDetails ( * this );
}

//
// GenericIdentifier
//

GenericIdentifier :: GenericIdentifier ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_standard:
			choice = new GenericIdentifier_standard ( is );
			break;
		case e_oid:
			choice = new Asn :: ObjectId ( is );
			break;
		case e_nonStandard:
			choice = new GloballyUniqueID ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

GenericIdentifier :: GenericIdentifier ( ) : Asn :: Choice ( 3, true ) { }

void GenericIdentifier :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_standard:
			o = new GenericIdentifier_standard;
			break;
		case e_oid:
			o = new Asn :: ObjectId;
			break;
		case e_nonStandard:
			o = new GloballyUniqueID;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & GenericIdentifier :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_standard, "standard" },
		{ e_oid, "oid" },
		{ e_nonStandard, "nonStandard" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

GenericIdentifier * GenericIdentifier :: clone ( ) const {
	return new GenericIdentifier ( * this );
}

//
// EnumeratedParameter
//

EnumeratedParameter :: EnumeratedParameter ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_id ( is ), m_content ( 0 ) {
	try {
		if ( hasOptionalField ( e_content ) )
			m_content = new Content ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_content;
		throw;
	}
}

EnumeratedParameter :: EnumeratedParameter ( ) : Asn :: Sequence ( 1, true, 0 ), m_content ( 0 ) { }

EnumeratedParameter & EnumeratedParameter :: operator= ( const EnumeratedParameter & s ) {
	Asn :: Sequence :: operator= ( s );
	m_id = s.m_id;
	assignCopy ( m_content, s.m_content );
	return * this;
}

EnumeratedParameter :: EnumeratedParameter ( const EnumeratedParameter & s ) : Asn :: Sequence ( s ), m_id ( s.m_id ), m_content ( 0 ) {
	try {
		if ( s.m_content )
			m_content = new Content ( * s.m_content );
	} catch ( ... ) {
		delete m_content;
		throw;
	}
}


void EnumeratedParameter :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_content:
			assignNew ( m_content, new Content );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void EnumeratedParameter :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_content:
			delete m_content;
			m_content = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void EnumeratedParameter :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_id.encode ( os );
	if ( hasOptionalField ( e_content ) )
		m_content -> Content :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

EnumeratedParameter :: ~EnumeratedParameter ( ) {
	delete m_content;
}

void EnumeratedParameter :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 5 ) << "id = " << std :: setprecision ( indent ) << m_id << '\n';
	if ( hasOptionalField ( e_content ) ) {
		os << std :: setw ( indent + 10 ) << "content = " << std :: setprecision ( indent );
		m_content -> Content :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

EnumeratedParameter * EnumeratedParameter :: clone ( ) const {
	return new EnumeratedParameter ( * this );
}

//
// RTPSession
//

RTPSession :: RTPSession ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 2 ), m_rtpAddress ( is ), m_rtcpAddress ( is ), m_cname ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ), m_ssrc ( is ), m_sessionId ( is ), m_associatedSessionIds ( is ), m_multicast ( 0 ), m_bandwidth ( 0 ) {
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_multicast ) )
				m_multicast = new Asn :: Null ( is );
			if ( hasKnownExtensionToDecode ( is, e_bandwidth ) )
				m_bandwidth = new BandWidth ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_multicast;
		delete m_bandwidth;
		throw;
	}
}

RTPSession :: RTPSession ( ) : Asn :: Sequence ( 0, true, 2 ), m_multicast ( 0 ), m_bandwidth ( 0 ) { }

RTPSession & RTPSession :: operator= ( const RTPSession & s ) {
	Asn :: Sequence :: operator= ( s );
	m_rtpAddress = s.m_rtpAddress;
	m_rtcpAddress = s.m_rtcpAddress;
	m_cname = s.m_cname;
	m_ssrc = s.m_ssrc;
	m_sessionId = s.m_sessionId;
	m_associatedSessionIds = s.m_associatedSessionIds;
	assignCopy ( m_multicast, s.m_multicast );
	assignCopy ( m_bandwidth, s.m_bandwidth );
	return * this;
}

RTPSession :: RTPSession ( const RTPSession & s ) : Asn :: Sequence ( s ), m_rtpAddress ( s.m_rtpAddress ), m_rtcpAddress ( s.m_rtcpAddress ), m_cname ( s.m_cname ), m_ssrc ( s.m_ssrc ), m_sessionId ( s.m_sessionId ), m_associatedSessionIds ( s.m_associatedSessionIds ), m_multicast ( 0 ), m_bandwidth ( 0 ) {
	try {
		if ( s.m_multicast )
			m_multicast = new Asn :: Null ( * s.m_multicast );
		if ( s.m_bandwidth )
			m_bandwidth = new BandWidth ( * s.m_bandwidth );
	} catch ( ... ) {
		delete m_multicast;
		delete m_bandwidth;
		throw;
	}
}


void RTPSession :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_multicast:
			assignNew ( m_multicast, new Asn :: Null );
			break;
		case e_bandwidth:
			assignNew ( m_bandwidth, new BandWidth );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void RTPSession :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_multicast:
			delete m_multicast;
			m_multicast = 0;
			break;
		case e_bandwidth:
			delete m_bandwidth;
			m_bandwidth = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void RTPSession :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_rtpAddress.encode ( os );
	m_rtcpAddress.encode ( os );
	m_cname.encode ( os );
	m_ssrc.encode ( os );
	m_sessionId.encode ( os );
	m_associatedSessionIds.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_multicast, m_multicast );
		knownExtensionEncode ( os, e_bandwidth, m_bandwidth );
		unknownExtensionsEncode ( os );
	}
}

RTPSession :: ~RTPSession ( ) {
	delete m_multicast;
	delete m_bandwidth;
}

void RTPSession :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 13 ) << "rtpAddress = " << std :: setprecision ( indent ) << m_rtpAddress << '\n';
	os << std :: setw ( indent + 14 ) << "rtcpAddress = " << std :: setprecision ( indent ) << m_rtcpAddress << '\n';
	os << std :: setw ( indent + 8 ) << "cname = " << std :: setprecision ( indent ) << m_cname << '\n';
	os << std :: setw ( indent + 7 ) << "ssrc = " << std :: setprecision ( indent ) << m_ssrc << '\n';
	os << std :: setw ( indent + 12 ) << "sessionId = " << std :: setprecision ( indent ) << m_sessionId << '\n';
	os << std :: setw ( indent + 23 ) << "associatedSessionIds = " << std :: setprecision ( indent ) << m_associatedSessionIds << '\n';
	if ( hasOptionalField ( e_multicast ) ) {
		os << std :: setw ( indent + 12 ) << "multicast = " << std :: setprecision ( indent );
		m_multicast -> Asn :: Null :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_bandwidth ) ) {
		os << std :: setw ( indent + 12 ) << "bandwidth = " << std :: setprecision ( indent );
		m_bandwidth -> BandWidth :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RTPSession * RTPSession :: clone ( ) const {
	return new RTPSession ( * this );
}

//
// GatekeeperReject
//

GatekeeperReject :: GatekeeperReject ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 6 ), m_requestSeqNum ( is ), m_protocolIdentifier ( is ), m_nonStandardData ( hasOptionalField ( e_nonStandardData ) ? pushTemporaryMember ( new NonStandardParameter ( is ) ) : 0 ), m_gatekeeperIdentifier ( hasOptionalField ( e_gatekeeperIdentifier ) ? pushTemporaryMember ( new GatekeeperIdentifier ( is ) ) : 0 ), m_rejectReason ( is ), m_altGKInfo ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ) {
	clearTemporaryMembers ( );
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_altGKInfo ) )
				m_altGKInfo = new AltGKInfo ( is );
			if ( hasKnownExtensionToDecode ( is, e_tokens ) )
				m_tokens = new ArrayOf_ClearToken ( is );
			if ( hasKnownExtensionToDecode ( is, e_cryptoTokens ) )
				m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
			if ( hasKnownExtensionToDecode ( is, e_integrityCheckValue ) )
				m_integrityCheckValue = new ICV ( is );
			if ( hasKnownExtensionToDecode ( is, e_featureSet ) )
				m_featureSet = new FeatureSet ( is );
			if ( hasKnownExtensionToDecode ( is, e_genericData ) )
				m_genericData = new ArrayOf_GenericData ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_gatekeeperIdentifier;
		delete m_altGKInfo;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_featureSet;
		delete m_genericData;
		throw;
	}
}

GatekeeperReject :: GatekeeperReject ( ) : Asn :: Sequence ( 2, true, 6 ), m_nonStandardData ( 0 ), m_gatekeeperIdentifier ( 0 ), m_altGKInfo ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ) { }

GatekeeperReject & GatekeeperReject :: operator= ( const GatekeeperReject & s ) {
	Asn :: Sequence :: operator= ( s );
	m_requestSeqNum = s.m_requestSeqNum;
	m_protocolIdentifier = s.m_protocolIdentifier;
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	assignCopy ( m_gatekeeperIdentifier, s.m_gatekeeperIdentifier );
	m_rejectReason = s.m_rejectReason;
	assignCopy ( m_altGKInfo, s.m_altGKInfo );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_integrityCheckValue, s.m_integrityCheckValue );
	assignCopy ( m_featureSet, s.m_featureSet );
	assignCopy ( m_genericData, s.m_genericData );
	return * this;
}

GatekeeperReject :: GatekeeperReject ( const GatekeeperReject & s ) : Asn :: Sequence ( s ), m_requestSeqNum ( s.m_requestSeqNum ), m_protocolIdentifier ( s.m_protocolIdentifier ), m_nonStandardData ( 0 ), m_gatekeeperIdentifier ( 0 ), m_rejectReason ( s.m_rejectReason ), m_altGKInfo ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_gatekeeperIdentifier )
			m_gatekeeperIdentifier = new GatekeeperIdentifier ( * s.m_gatekeeperIdentifier );
		if ( s.m_altGKInfo )
			m_altGKInfo = new AltGKInfo ( * s.m_altGKInfo );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_integrityCheckValue )
			m_integrityCheckValue = new ICV ( * s.m_integrityCheckValue );
		if ( s.m_featureSet )
			m_featureSet = new FeatureSet ( * s.m_featureSet );
		if ( s.m_genericData )
			m_genericData = new ArrayOf_GenericData ( * s.m_genericData );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_gatekeeperIdentifier;
		delete m_altGKInfo;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_featureSet;
		delete m_genericData;
		throw;
	}
}


void GatekeeperReject :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_gatekeeperIdentifier:
			assignNew ( m_gatekeeperIdentifier, new GatekeeperIdentifier );
			break;
		case e_altGKInfo:
			assignNew ( m_altGKInfo, new AltGKInfo );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_integrityCheckValue:
			assignNew ( m_integrityCheckValue, new ICV );
			break;
		case e_featureSet:
			assignNew ( m_featureSet, new FeatureSet );
			break;
		case e_genericData:
			assignNew ( m_genericData, new ArrayOf_GenericData );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void GatekeeperReject :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_gatekeeperIdentifier:
			delete m_gatekeeperIdentifier;
			m_gatekeeperIdentifier = 0;
			break;
		case e_altGKInfo:
			delete m_altGKInfo;
			m_altGKInfo = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_integrityCheckValue:
			delete m_integrityCheckValue;
			m_integrityCheckValue = 0;
			break;
		case e_featureSet:
			delete m_featureSet;
			m_featureSet = 0;
			break;
		case e_genericData:
			delete m_genericData;
			m_genericData = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void GatekeeperReject :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_requestSeqNum.encode ( os );
	m_protocolIdentifier.encode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( hasOptionalField ( e_gatekeeperIdentifier ) )
		m_gatekeeperIdentifier -> GatekeeperIdentifier :: encode ( os );
	m_rejectReason.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_altGKInfo, m_altGKInfo );
		knownExtensionEncode ( os, e_tokens, m_tokens );
		knownExtensionEncode ( os, e_cryptoTokens, m_cryptoTokens );
		knownExtensionEncode ( os, e_integrityCheckValue, m_integrityCheckValue );
		knownExtensionEncode ( os, e_featureSet, m_featureSet );
		knownExtensionEncode ( os, e_genericData, m_genericData );
		unknownExtensionsEncode ( os );
	}
}

GatekeeperReject :: ~GatekeeperReject ( ) {
	delete m_nonStandardData;
	delete m_gatekeeperIdentifier;
	delete m_altGKInfo;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_integrityCheckValue;
	delete m_featureSet;
	delete m_genericData;
}

void GatekeeperReject :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "requestSeqNum = " << std :: setprecision ( indent ) << m_requestSeqNum << '\n';
	os << std :: setw ( indent + 21 ) << "protocolIdentifier = " << std :: setprecision ( indent ) << m_protocolIdentifier << '\n';
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_gatekeeperIdentifier ) ) {
		os << std :: setw ( indent + 23 ) << "gatekeeperIdentifier = " << std :: setprecision ( indent );
		m_gatekeeperIdentifier -> GatekeeperIdentifier :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 15 ) << "rejectReason = " << std :: setprecision ( indent ) << m_rejectReason << '\n';
	if ( hasOptionalField ( e_altGKInfo ) ) {
		os << std :: setw ( indent + 12 ) << "altGKInfo = " << std :: setprecision ( indent );
		m_altGKInfo -> AltGKInfo :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_integrityCheckValue ) ) {
		os << std :: setw ( indent + 22 ) << "integrityCheckValue = " << std :: setprecision ( indent );
		m_integrityCheckValue -> ICV :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_featureSet ) ) {
		os << std :: setw ( indent + 13 ) << "featureSet = " << std :: setprecision ( indent );
		m_featureSet -> FeatureSet :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_genericData ) ) {
		os << std :: setw ( indent + 14 ) << "genericData = " << std :: setprecision ( indent );
		m_genericData -> ArrayOf_GenericData :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

GatekeeperReject * GatekeeperReject :: clone ( ) const {
	return new GatekeeperReject ( * this );
}

//
// RegistrationConfirm
//

RegistrationConfirm :: RegistrationConfirm ( Asn :: istream & is ) : Asn :: Sequence ( is, 3, true, 20 ), m_requestSeqNum ( is ), m_protocolIdentifier ( is ), m_nonStandardData ( hasOptionalField ( e_nonStandardData ) ? pushTemporaryMember ( new NonStandardParameter ( is ) ) : 0 ), m_callSignalAddress ( is ), m_terminalAlias ( hasOptionalField ( e_terminalAlias ) ? pushTemporaryMember ( new ArrayOf_AliasAddress ( is ) ) : 0 ), m_gatekeeperIdentifier ( hasOptionalField ( e_gatekeeperIdentifier ) ? pushTemporaryMember ( new GatekeeperIdentifier ( is ) ) : 0 ), m_endpointIdentifier ( is ), m_alternateGatekeeper ( 0 ), m_timeToLive ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_willRespondToIRR ( 0 ), m_preGrantedARQ ( 0 ), m_maintainConnection ( 0 ), m_serviceControl ( 0 ), m_supportsAdditiveRegistration ( 0 ), m_terminalAliasPattern ( 0 ), m_supportedPrefixes ( 0 ), m_usageSpec ( 0 ), m_featureServerAlias ( 0 ), m_capacityReportingSpec ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ), m_assignedGatekeeper ( 0 ), m_rehomingModel ( 0 ), m_transportQOS ( 0 ) {
	clearTemporaryMembers ( );
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_alternateGatekeeper ) )
				m_alternateGatekeeper = new ArrayOf_AlternateGK ( is );
			if ( hasKnownExtensionToDecode ( is, e_timeToLive ) )
				m_timeToLive = new TimeToLive ( is );
			if ( hasKnownExtensionToDecode ( is, e_tokens ) )
				m_tokens = new ArrayOf_ClearToken ( is );
			if ( hasKnownExtensionToDecode ( is, e_cryptoTokens ) )
				m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
			if ( hasKnownExtensionToDecode ( is, e_integrityCheckValue ) )
				m_integrityCheckValue = new ICV ( is );
			if ( hasKnownExtensionToDecode ( is, e_willRespondToIRR ) )
				m_willRespondToIRR = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_preGrantedARQ ) )
				m_preGrantedARQ = new RegistrationConfirm_preGrantedARQ ( is );
			if ( hasKnownExtensionToDecode ( is, e_maintainConnection ) )
				m_maintainConnection = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_serviceControl ) )
				m_serviceControl = new ArrayOf_ServiceControlSession ( is );
			if ( hasKnownExtensionToDecode ( is, e_supportsAdditiveRegistration ) )
				m_supportsAdditiveRegistration = new Asn :: Null ( is );
			if ( hasKnownExtensionToDecode ( is, e_terminalAliasPattern ) )
				m_terminalAliasPattern = new ArrayOf_AddressPattern ( is );
			if ( hasKnownExtensionToDecode ( is, e_supportedPrefixes ) )
				m_supportedPrefixes = new ArrayOf_SupportedPrefix ( is );
			if ( hasKnownExtensionToDecode ( is, e_usageSpec ) )
				m_usageSpec = new ArrayOf_RasUsageSpecification ( is );
			if ( hasKnownExtensionToDecode ( is, e_featureServerAlias ) )
				m_featureServerAlias = new AliasAddress ( is );
			if ( hasKnownExtensionToDecode ( is, e_capacityReportingSpec ) )
				m_capacityReportingSpec = new CapacityReportingSpecification ( is );
			if ( hasKnownExtensionToDecode ( is, e_featureSet ) )
				m_featureSet = new FeatureSet ( is );
			if ( hasKnownExtensionToDecode ( is, e_genericData ) )
				m_genericData = new ArrayOf_GenericData ( is );
			if ( hasKnownExtensionToDecode ( is, e_assignedGatekeeper ) )
				m_assignedGatekeeper = new AlternateGK ( is );
			if ( hasKnownExtensionToDecode ( is, e_rehomingModel ) )
				m_rehomingModel = new RehomingModel ( is );
			if ( hasKnownExtensionToDecode ( is, e_transportQOS ) )
				m_transportQOS = new TransportQOS ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_terminalAlias;
		delete m_gatekeeperIdentifier;
		delete m_alternateGatekeeper;
		delete m_timeToLive;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_willRespondToIRR;
		delete m_preGrantedARQ;
		delete m_maintainConnection;
		delete m_serviceControl;
		delete m_supportsAdditiveRegistration;
		delete m_terminalAliasPattern;
		delete m_supportedPrefixes;
		delete m_usageSpec;
		delete m_featureServerAlias;
		delete m_capacityReportingSpec;
		delete m_featureSet;
		delete m_genericData;
		delete m_assignedGatekeeper;
		delete m_rehomingModel;
		delete m_transportQOS;
		throw;
	}
}

RegistrationConfirm :: RegistrationConfirm ( ) : Asn :: Sequence ( 3, true, 20 ), m_nonStandardData ( 0 ), m_terminalAlias ( 0 ), m_gatekeeperIdentifier ( 0 ), m_alternateGatekeeper ( 0 ), m_timeToLive ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_willRespondToIRR ( 0 ), m_preGrantedARQ ( 0 ), m_maintainConnection ( 0 ), m_serviceControl ( 0 ), m_supportsAdditiveRegistration ( 0 ), m_terminalAliasPattern ( 0 ), m_supportedPrefixes ( 0 ), m_usageSpec ( 0 ), m_featureServerAlias ( 0 ), m_capacityReportingSpec ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ), m_assignedGatekeeper ( 0 ), m_rehomingModel ( 0 ), m_transportQOS ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_willRespondToIRR );
		m_willRespondToIRR = new Asn :: Boolean;
		Asn :: Sequence :: includeOptionalField ( e_maintainConnection );
		m_maintainConnection = new Asn :: Boolean;
	} catch ( ... ) {
		delete m_willRespondToIRR;
		delete m_maintainConnection;
		throw;
	}
}

RegistrationConfirm & RegistrationConfirm :: operator= ( const RegistrationConfirm & s ) {
	Asn :: Sequence :: operator= ( s );
	m_requestSeqNum = s.m_requestSeqNum;
	m_protocolIdentifier = s.m_protocolIdentifier;
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	m_callSignalAddress = s.m_callSignalAddress;
	assignCopy ( m_terminalAlias, s.m_terminalAlias );
	assignCopy ( m_gatekeeperIdentifier, s.m_gatekeeperIdentifier );
	m_endpointIdentifier = s.m_endpointIdentifier;
	assignCopy ( m_alternateGatekeeper, s.m_alternateGatekeeper );
	assignCopy ( m_timeToLive, s.m_timeToLive );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_integrityCheckValue, s.m_integrityCheckValue );
	assignCopy ( m_willRespondToIRR, s.m_willRespondToIRR );
	assignCopy ( m_preGrantedARQ, s.m_preGrantedARQ );
	assignCopy ( m_maintainConnection, s.m_maintainConnection );
	assignCopy ( m_serviceControl, s.m_serviceControl );
	assignCopy ( m_supportsAdditiveRegistration, s.m_supportsAdditiveRegistration );
	assignCopy ( m_terminalAliasPattern, s.m_terminalAliasPattern );
	assignCopy ( m_supportedPrefixes, s.m_supportedPrefixes );
	assignCopy ( m_usageSpec, s.m_usageSpec );
	assignCopy ( m_featureServerAlias, s.m_featureServerAlias );
	assignCopy ( m_capacityReportingSpec, s.m_capacityReportingSpec );
	assignCopy ( m_featureSet, s.m_featureSet );
	assignCopy ( m_genericData, s.m_genericData );
	assignCopy ( m_assignedGatekeeper, s.m_assignedGatekeeper );
	assignCopy ( m_rehomingModel, s.m_rehomingModel );
	assignCopy ( m_transportQOS, s.m_transportQOS );
	return * this;
}

RegistrationConfirm :: RegistrationConfirm ( const RegistrationConfirm & s ) : Asn :: Sequence ( s ), m_requestSeqNum ( s.m_requestSeqNum ), m_protocolIdentifier ( s.m_protocolIdentifier ), m_nonStandardData ( 0 ), m_callSignalAddress ( s.m_callSignalAddress ), m_terminalAlias ( 0 ), m_gatekeeperIdentifier ( 0 ), m_endpointIdentifier ( s.m_endpointIdentifier ), m_alternateGatekeeper ( 0 ), m_timeToLive ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_willRespondToIRR ( 0 ), m_preGrantedARQ ( 0 ), m_maintainConnection ( 0 ), m_serviceControl ( 0 ), m_supportsAdditiveRegistration ( 0 ), m_terminalAliasPattern ( 0 ), m_supportedPrefixes ( 0 ), m_usageSpec ( 0 ), m_featureServerAlias ( 0 ), m_capacityReportingSpec ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ), m_assignedGatekeeper ( 0 ), m_rehomingModel ( 0 ), m_transportQOS ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_terminalAlias )
			m_terminalAlias = new ArrayOf_AliasAddress ( * s.m_terminalAlias );
		if ( s.m_gatekeeperIdentifier )
			m_gatekeeperIdentifier = new GatekeeperIdentifier ( * s.m_gatekeeperIdentifier );
		if ( s.m_alternateGatekeeper )
			m_alternateGatekeeper = new ArrayOf_AlternateGK ( * s.m_alternateGatekeeper );
		if ( s.m_timeToLive )
			m_timeToLive = new TimeToLive ( * s.m_timeToLive );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_integrityCheckValue )
			m_integrityCheckValue = new ICV ( * s.m_integrityCheckValue );
		if ( s.m_willRespondToIRR )
			m_willRespondToIRR = new Asn :: Boolean ( * s.m_willRespondToIRR );
		if ( s.m_preGrantedARQ )
			m_preGrantedARQ = new RegistrationConfirm_preGrantedARQ ( * s.m_preGrantedARQ );
		if ( s.m_maintainConnection )
			m_maintainConnection = new Asn :: Boolean ( * s.m_maintainConnection );
		if ( s.m_serviceControl )
			m_serviceControl = new ArrayOf_ServiceControlSession ( * s.m_serviceControl );
		if ( s.m_supportsAdditiveRegistration )
			m_supportsAdditiveRegistration = new Asn :: Null ( * s.m_supportsAdditiveRegistration );
		if ( s.m_terminalAliasPattern )
			m_terminalAliasPattern = new ArrayOf_AddressPattern ( * s.m_terminalAliasPattern );
		if ( s.m_supportedPrefixes )
			m_supportedPrefixes = new ArrayOf_SupportedPrefix ( * s.m_supportedPrefixes );
		if ( s.m_usageSpec )
			m_usageSpec = new ArrayOf_RasUsageSpecification ( * s.m_usageSpec );
		if ( s.m_featureServerAlias )
			m_featureServerAlias = new AliasAddress ( * s.m_featureServerAlias );
		if ( s.m_capacityReportingSpec )
			m_capacityReportingSpec = new CapacityReportingSpecification ( * s.m_capacityReportingSpec );
		if ( s.m_featureSet )
			m_featureSet = new FeatureSet ( * s.m_featureSet );
		if ( s.m_genericData )
			m_genericData = new ArrayOf_GenericData ( * s.m_genericData );
		if ( s.m_assignedGatekeeper )
			m_assignedGatekeeper = new AlternateGK ( * s.m_assignedGatekeeper );
		if ( s.m_rehomingModel )
			m_rehomingModel = new RehomingModel ( * s.m_rehomingModel );
		if ( s.m_transportQOS )
			m_transportQOS = new TransportQOS ( * s.m_transportQOS );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_terminalAlias;
		delete m_gatekeeperIdentifier;
		delete m_alternateGatekeeper;
		delete m_timeToLive;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_willRespondToIRR;
		delete m_preGrantedARQ;
		delete m_maintainConnection;
		delete m_serviceControl;
		delete m_supportsAdditiveRegistration;
		delete m_terminalAliasPattern;
		delete m_supportedPrefixes;
		delete m_usageSpec;
		delete m_featureServerAlias;
		delete m_capacityReportingSpec;
		delete m_featureSet;
		delete m_genericData;
		delete m_assignedGatekeeper;
		delete m_rehomingModel;
		delete m_transportQOS;
		throw;
	}
}


void RegistrationConfirm :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_terminalAlias:
			assignNew ( m_terminalAlias, new ArrayOf_AliasAddress );
			break;
		case e_gatekeeperIdentifier:
			assignNew ( m_gatekeeperIdentifier, new GatekeeperIdentifier );
			break;
		case e_alternateGatekeeper:
			assignNew ( m_alternateGatekeeper, new ArrayOf_AlternateGK );
			break;
		case e_timeToLive:
			assignNew ( m_timeToLive, new TimeToLive );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_integrityCheckValue:
			assignNew ( m_integrityCheckValue, new ICV );
			break;
		case e_willRespondToIRR:
			assignNew ( m_willRespondToIRR, new Asn :: Boolean );
			break;
		case e_preGrantedARQ:
			assignNew ( m_preGrantedARQ, new RegistrationConfirm_preGrantedARQ );
			break;
		case e_maintainConnection:
			assignNew ( m_maintainConnection, new Asn :: Boolean );
			break;
		case e_serviceControl:
			assignNew ( m_serviceControl, new ArrayOf_ServiceControlSession );
			break;
		case e_supportsAdditiveRegistration:
			assignNew ( m_supportsAdditiveRegistration, new Asn :: Null );
			break;
		case e_terminalAliasPattern:
			assignNew ( m_terminalAliasPattern, new ArrayOf_AddressPattern );
			break;
		case e_supportedPrefixes:
			assignNew ( m_supportedPrefixes, new ArrayOf_SupportedPrefix );
			break;
		case e_usageSpec:
			assignNew ( m_usageSpec, new ArrayOf_RasUsageSpecification );
			break;
		case e_featureServerAlias:
			assignNew ( m_featureServerAlias, new AliasAddress );
			break;
		case e_capacityReportingSpec:
			assignNew ( m_capacityReportingSpec, new CapacityReportingSpecification );
			break;
		case e_featureSet:
			assignNew ( m_featureSet, new FeatureSet );
			break;
		case e_genericData:
			assignNew ( m_genericData, new ArrayOf_GenericData );
			break;
		case e_assignedGatekeeper:
			assignNew ( m_assignedGatekeeper, new AlternateGK );
			break;
		case e_rehomingModel:
			assignNew ( m_rehomingModel, new RehomingModel );
			break;
		case e_transportQOS:
			assignNew ( m_transportQOS, new TransportQOS );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void RegistrationConfirm :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_terminalAlias:
			delete m_terminalAlias;
			m_terminalAlias = 0;
			break;
		case e_gatekeeperIdentifier:
			delete m_gatekeeperIdentifier;
			m_gatekeeperIdentifier = 0;
			break;
		case e_alternateGatekeeper:
			delete m_alternateGatekeeper;
			m_alternateGatekeeper = 0;
			break;
		case e_timeToLive:
			delete m_timeToLive;
			m_timeToLive = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_integrityCheckValue:
			delete m_integrityCheckValue;
			m_integrityCheckValue = 0;
			break;
		case e_willRespondToIRR:
			delete m_willRespondToIRR;
			m_willRespondToIRR = 0;
			break;
		case e_preGrantedARQ:
			delete m_preGrantedARQ;
			m_preGrantedARQ = 0;
			break;
		case e_maintainConnection:
			delete m_maintainConnection;
			m_maintainConnection = 0;
			break;
		case e_serviceControl:
			delete m_serviceControl;
			m_serviceControl = 0;
			break;
		case e_supportsAdditiveRegistration:
			delete m_supportsAdditiveRegistration;
			m_supportsAdditiveRegistration = 0;
			break;
		case e_terminalAliasPattern:
			delete m_terminalAliasPattern;
			m_terminalAliasPattern = 0;
			break;
		case e_supportedPrefixes:
			delete m_supportedPrefixes;
			m_supportedPrefixes = 0;
			break;
		case e_usageSpec:
			delete m_usageSpec;
			m_usageSpec = 0;
			break;
		case e_featureServerAlias:
			delete m_featureServerAlias;
			m_featureServerAlias = 0;
			break;
		case e_capacityReportingSpec:
			delete m_capacityReportingSpec;
			m_capacityReportingSpec = 0;
			break;
		case e_featureSet:
			delete m_featureSet;
			m_featureSet = 0;
			break;
		case e_genericData:
			delete m_genericData;
			m_genericData = 0;
			break;
		case e_assignedGatekeeper:
			delete m_assignedGatekeeper;
			m_assignedGatekeeper = 0;
			break;
		case e_rehomingModel:
			delete m_rehomingModel;
			m_rehomingModel = 0;
			break;
		case e_transportQOS:
			delete m_transportQOS;
			m_transportQOS = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void RegistrationConfirm :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_requestSeqNum.encode ( os );
	m_protocolIdentifier.encode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	m_callSignalAddress.encode ( os );
	if ( hasOptionalField ( e_terminalAlias ) )
		m_terminalAlias -> ArrayOf_AliasAddress :: encode ( os );
	if ( hasOptionalField ( e_gatekeeperIdentifier ) )
		m_gatekeeperIdentifier -> GatekeeperIdentifier :: encode ( os );
	m_endpointIdentifier.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_alternateGatekeeper, m_alternateGatekeeper );
		knownExtensionEncode ( os, e_timeToLive, m_timeToLive );
		knownExtensionEncode ( os, e_tokens, m_tokens );
		knownExtensionEncode ( os, e_cryptoTokens, m_cryptoTokens );
		knownExtensionEncode ( os, e_integrityCheckValue, m_integrityCheckValue );
		knownExtensionEncode ( os, e_willRespondToIRR, m_willRespondToIRR );
		knownExtensionEncode ( os, e_preGrantedARQ, m_preGrantedARQ );
		knownExtensionEncode ( os, e_maintainConnection, m_maintainConnection );
		knownExtensionEncode ( os, e_serviceControl, m_serviceControl );
		knownExtensionEncode ( os, e_supportsAdditiveRegistration, m_supportsAdditiveRegistration );
		knownExtensionEncode ( os, e_terminalAliasPattern, m_terminalAliasPattern );
		knownExtensionEncode ( os, e_supportedPrefixes, m_supportedPrefixes );
		knownExtensionEncode ( os, e_usageSpec, m_usageSpec );
		knownExtensionEncode ( os, e_featureServerAlias, m_featureServerAlias );
		knownExtensionEncode ( os, e_capacityReportingSpec, m_capacityReportingSpec );
		knownExtensionEncode ( os, e_featureSet, m_featureSet );
		knownExtensionEncode ( os, e_genericData, m_genericData );
		knownExtensionEncode ( os, e_assignedGatekeeper, m_assignedGatekeeper );
		knownExtensionEncode ( os, e_rehomingModel, m_rehomingModel );
		knownExtensionEncode ( os, e_transportQOS, m_transportQOS );
		unknownExtensionsEncode ( os );
	}
}

RegistrationConfirm :: ~RegistrationConfirm ( ) {
	delete m_nonStandardData;
	delete m_terminalAlias;
	delete m_gatekeeperIdentifier;
	delete m_alternateGatekeeper;
	delete m_timeToLive;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_integrityCheckValue;
	delete m_willRespondToIRR;
	delete m_preGrantedARQ;
	delete m_maintainConnection;
	delete m_serviceControl;
	delete m_supportsAdditiveRegistration;
	delete m_terminalAliasPattern;
	delete m_supportedPrefixes;
	delete m_usageSpec;
	delete m_featureServerAlias;
	delete m_capacityReportingSpec;
	delete m_featureSet;
	delete m_genericData;
	delete m_assignedGatekeeper;
	delete m_rehomingModel;
	delete m_transportQOS;
}

void RegistrationConfirm :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "requestSeqNum = " << std :: setprecision ( indent ) << m_requestSeqNum << '\n';
	os << std :: setw ( indent + 21 ) << "protocolIdentifier = " << std :: setprecision ( indent ) << m_protocolIdentifier << '\n';
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 20 ) << "callSignalAddress = " << std :: setprecision ( indent ) << m_callSignalAddress << '\n';
	if ( hasOptionalField ( e_terminalAlias ) ) {
		os << std :: setw ( indent + 16 ) << "terminalAlias = " << std :: setprecision ( indent );
		m_terminalAlias -> ArrayOf_AliasAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_gatekeeperIdentifier ) ) {
		os << std :: setw ( indent + 23 ) << "gatekeeperIdentifier = " << std :: setprecision ( indent );
		m_gatekeeperIdentifier -> GatekeeperIdentifier :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 21 ) << "endpointIdentifier = " << std :: setprecision ( indent ) << m_endpointIdentifier << '\n';
	if ( hasOptionalField ( e_alternateGatekeeper ) ) {
		os << std :: setw ( indent + 22 ) << "alternateGatekeeper = " << std :: setprecision ( indent );
		m_alternateGatekeeper -> ArrayOf_AlternateGK :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_timeToLive ) ) {
		os << std :: setw ( indent + 13 ) << "timeToLive = " << std :: setprecision ( indent );
		m_timeToLive -> TimeToLive :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_integrityCheckValue ) ) {
		os << std :: setw ( indent + 22 ) << "integrityCheckValue = " << std :: setprecision ( indent );
		m_integrityCheckValue -> ICV :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_willRespondToIRR ) ) {
		os << std :: setw ( indent + 19 ) << "willRespondToIRR = " << std :: setprecision ( indent );
		m_willRespondToIRR -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_preGrantedARQ ) ) {
		os << std :: setw ( indent + 16 ) << "preGrantedARQ = " << std :: setprecision ( indent );
		m_preGrantedARQ -> RegistrationConfirm_preGrantedARQ :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_maintainConnection ) ) {
		os << std :: setw ( indent + 21 ) << "maintainConnection = " << std :: setprecision ( indent );
		m_maintainConnection -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_serviceControl ) ) {
		os << std :: setw ( indent + 17 ) << "serviceControl = " << std :: setprecision ( indent );
		m_serviceControl -> ArrayOf_ServiceControlSession :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_supportsAdditiveRegistration ) ) {
		os << std :: setw ( indent + 31 ) << "supportsAdditiveRegistration = " << std :: setprecision ( indent );
		m_supportsAdditiveRegistration -> Asn :: Null :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_terminalAliasPattern ) ) {
		os << std :: setw ( indent + 23 ) << "terminalAliasPattern = " << std :: setprecision ( indent );
		m_terminalAliasPattern -> ArrayOf_AddressPattern :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_supportedPrefixes ) ) {
		os << std :: setw ( indent + 20 ) << "supportedPrefixes = " << std :: setprecision ( indent );
		m_supportedPrefixes -> ArrayOf_SupportedPrefix :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_usageSpec ) ) {
		os << std :: setw ( indent + 12 ) << "usageSpec = " << std :: setprecision ( indent );
		m_usageSpec -> ArrayOf_RasUsageSpecification :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_featureServerAlias ) ) {
		os << std :: setw ( indent + 21 ) << "featureServerAlias = " << std :: setprecision ( indent );
		m_featureServerAlias -> AliasAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_capacityReportingSpec ) ) {
		os << std :: setw ( indent + 24 ) << "capacityReportingSpec = " << std :: setprecision ( indent );
		m_capacityReportingSpec -> CapacityReportingSpecification :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_featureSet ) ) {
		os << std :: setw ( indent + 13 ) << "featureSet = " << std :: setprecision ( indent );
		m_featureSet -> FeatureSet :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_genericData ) ) {
		os << std :: setw ( indent + 14 ) << "genericData = " << std :: setprecision ( indent );
		m_genericData -> ArrayOf_GenericData :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_assignedGatekeeper ) ) {
		os << std :: setw ( indent + 21 ) << "assignedGatekeeper = " << std :: setprecision ( indent );
		m_assignedGatekeeper -> AlternateGK :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_rehomingModel ) ) {
		os << std :: setw ( indent + 16 ) << "rehomingModel = " << std :: setprecision ( indent );
		m_rehomingModel -> RehomingModel :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_transportQOS ) ) {
		os << std :: setw ( indent + 15 ) << "transportQOS = " << std :: setprecision ( indent );
		m_transportQOS -> TransportQOS :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RegistrationConfirm * RegistrationConfirm :: clone ( ) const {
	return new RegistrationConfirm ( * this );
}

//
// RegistrationRejectReason
//

RegistrationRejectReason :: RegistrationRejectReason ( Asn :: istream & is ) : Asn :: Choice ( is, 8, true ) {
	switch ( tag ) {
		case e_discoveryRequired:
		case e_invalidRevision:
		case e_invalidCallSignalAddress:
		case e_invalidRASAddress:
		case e_invalidTerminalType:
		case e_undefinedReason:
		case e_transportNotSupported:
		case e_transportQOSNotSupported:
		case e_resourceUnavailable:
		case e_invalidAlias:
		case e_securityDenial:
		case e_fullRegistrationRequired:
		case e_additiveRegistrationNotSupported:
		case e_genericDataReason:
		case e_neededFeatureNotSupported:
		case e_registerWithAssignedGK:
			choice = new Asn :: Null ( is );
			break;
		case e_duplicateAlias:
			choice = new ArrayOf_AliasAddress ( is );
			break;
		case e_invalidTerminalAliases:
			choice = new RegistrationRejectReason_invalidTerminalAliases ( is );
			break;
		case e_securityError:
			choice = new SecurityErrors ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

RegistrationRejectReason :: RegistrationRejectReason ( ) : Asn :: Choice ( 8, true ) { }

void RegistrationRejectReason :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_discoveryRequired:
		case e_invalidRevision:
		case e_invalidCallSignalAddress:
		case e_invalidRASAddress:
		case e_invalidTerminalType:
		case e_undefinedReason:
		case e_transportNotSupported:
		case e_transportQOSNotSupported:
		case e_resourceUnavailable:
		case e_invalidAlias:
		case e_securityDenial:
		case e_fullRegistrationRequired:
		case e_additiveRegistrationNotSupported:
		case e_genericDataReason:
		case e_neededFeatureNotSupported:
		case e_registerWithAssignedGK:
			o = new Asn :: Null;
			break;
		case e_duplicateAlias:
			o = new ArrayOf_AliasAddress;
			break;
		case e_invalidTerminalAliases:
			o = new RegistrationRejectReason_invalidTerminalAliases;
			break;
		case e_securityError:
			o = new SecurityErrors;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & RegistrationRejectReason :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_discoveryRequired, "discoveryRequired" },
		{ e_invalidRevision, "invalidRevision" },
		{ e_invalidCallSignalAddress, "invalidCallSignalAddress" },
		{ e_invalidRASAddress, "invalidRASAddress" },
		{ e_duplicateAlias, "duplicateAlias" },
		{ e_invalidTerminalType, "invalidTerminalType" },
		{ e_undefinedReason, "undefinedReason" },
		{ e_transportNotSupported, "transportNotSupported" },
		{ e_transportQOSNotSupported, "transportQOSNotSupported" },
		{ e_resourceUnavailable, "resourceUnavailable" },
		{ e_invalidAlias, "invalidAlias" },
		{ e_securityDenial, "securityDenial" },
		{ e_fullRegistrationRequired, "fullRegistrationRequired" },
		{ e_additiveRegistrationNotSupported, "additiveRegistrationNotSupported" },
		{ e_invalidTerminalAliases, "invalidTerminalAliases" },
		{ e_genericDataReason, "genericDataReason" },
		{ e_neededFeatureNotSupported, "neededFeatureNotSupported" },
		{ e_securityError, "securityError" },
		{ e_registerWithAssignedGK, "registerWithAssignedGK" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

RegistrationRejectReason * RegistrationRejectReason :: clone ( ) const {
	return new RegistrationRejectReason ( * this );
}

//
// UnregistrationRequest
//

UnregistrationRequest :: UnregistrationRequest ( Asn :: istream & is ) : Asn :: Sequence ( is, 3, true, 11 ), m_requestSeqNum ( is ), m_callSignalAddress ( is ), m_endpointAlias ( 0 ), m_nonStandardData ( 0 ), m_endpointIdentifier ( 0 ), m_alternateEndpoints ( 0 ), m_gatekeeperIdentifier ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_reason ( 0 ), m_endpointAliasPattern ( 0 ), m_supportedPrefixes ( 0 ), m_alternateGatekeeper ( 0 ), m_genericData ( 0 ), m_assignedGatekeeper ( 0 ) {
	try {
		if ( hasOptionalField ( e_endpointAlias ) )
			m_endpointAlias = new ArrayOf_AliasAddress ( is );
		if ( hasOptionalField ( e_nonStandardData ) )
			m_nonStandardData = new NonStandardParameter ( is );
		if ( hasOptionalField ( e_endpointIdentifier ) )
			m_endpointIdentifier = new EndpointIdentifier ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_alternateEndpoints ) )
				m_alternateEndpoints = new ArrayOf_Endpoint ( is );
			if ( hasKnownExtensionToDecode ( is, e_gatekeeperIdentifier ) )
				m_gatekeeperIdentifier = new GatekeeperIdentifier ( is );
			if ( hasKnownExtensionToDecode ( is, e_tokens ) )
				m_tokens = new ArrayOf_ClearToken ( is );
			if ( hasKnownExtensionToDecode ( is, e_cryptoTokens ) )
				m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
			if ( hasKnownExtensionToDecode ( is, e_integrityCheckValue ) )
				m_integrityCheckValue = new ICV ( is );
			if ( hasKnownExtensionToDecode ( is, e_reason ) )
				m_reason = new UnregRequestReason ( is );
			if ( hasKnownExtensionToDecode ( is, e_endpointAliasPattern ) )
				m_endpointAliasPattern = new ArrayOf_AddressPattern ( is );
			if ( hasKnownExtensionToDecode ( is, e_supportedPrefixes ) )
				m_supportedPrefixes = new ArrayOf_SupportedPrefix ( is );
			if ( hasKnownExtensionToDecode ( is, e_alternateGatekeeper ) )
				m_alternateGatekeeper = new ArrayOf_AlternateGK ( is );
			if ( hasKnownExtensionToDecode ( is, e_genericData ) )
				m_genericData = new ArrayOf_GenericData ( is );
			if ( hasKnownExtensionToDecode ( is, e_assignedGatekeeper ) )
				m_assignedGatekeeper = new AlternateGK ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_endpointAlias;
		delete m_nonStandardData;
		delete m_endpointIdentifier;
		delete m_alternateEndpoints;
		delete m_gatekeeperIdentifier;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_reason;
		delete m_endpointAliasPattern;
		delete m_supportedPrefixes;
		delete m_alternateGatekeeper;
		delete m_genericData;
		delete m_assignedGatekeeper;
		throw;
	}
}

UnregistrationRequest :: UnregistrationRequest ( ) : Asn :: Sequence ( 3, true, 11 ), m_endpointAlias ( 0 ), m_nonStandardData ( 0 ), m_endpointIdentifier ( 0 ), m_alternateEndpoints ( 0 ), m_gatekeeperIdentifier ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_reason ( 0 ), m_endpointAliasPattern ( 0 ), m_supportedPrefixes ( 0 ), m_alternateGatekeeper ( 0 ), m_genericData ( 0 ), m_assignedGatekeeper ( 0 ) { }

UnregistrationRequest & UnregistrationRequest :: operator= ( const UnregistrationRequest & s ) {
	Asn :: Sequence :: operator= ( s );
	m_requestSeqNum = s.m_requestSeqNum;
	m_callSignalAddress = s.m_callSignalAddress;
	assignCopy ( m_endpointAlias, s.m_endpointAlias );
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	assignCopy ( m_endpointIdentifier, s.m_endpointIdentifier );
	assignCopy ( m_alternateEndpoints, s.m_alternateEndpoints );
	assignCopy ( m_gatekeeperIdentifier, s.m_gatekeeperIdentifier );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_integrityCheckValue, s.m_integrityCheckValue );
	assignCopy ( m_reason, s.m_reason );
	assignCopy ( m_endpointAliasPattern, s.m_endpointAliasPattern );
	assignCopy ( m_supportedPrefixes, s.m_supportedPrefixes );
	assignCopy ( m_alternateGatekeeper, s.m_alternateGatekeeper );
	assignCopy ( m_genericData, s.m_genericData );
	assignCopy ( m_assignedGatekeeper, s.m_assignedGatekeeper );
	return * this;
}

UnregistrationRequest :: UnregistrationRequest ( const UnregistrationRequest & s ) : Asn :: Sequence ( s ), m_requestSeqNum ( s.m_requestSeqNum ), m_callSignalAddress ( s.m_callSignalAddress ), m_endpointAlias ( 0 ), m_nonStandardData ( 0 ), m_endpointIdentifier ( 0 ), m_alternateEndpoints ( 0 ), m_gatekeeperIdentifier ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_reason ( 0 ), m_endpointAliasPattern ( 0 ), m_supportedPrefixes ( 0 ), m_alternateGatekeeper ( 0 ), m_genericData ( 0 ), m_assignedGatekeeper ( 0 ) {
	try {
		if ( s.m_endpointAlias )
			m_endpointAlias = new ArrayOf_AliasAddress ( * s.m_endpointAlias );
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_endpointIdentifier )
			m_endpointIdentifier = new EndpointIdentifier ( * s.m_endpointIdentifier );
		if ( s.m_alternateEndpoints )
			m_alternateEndpoints = new ArrayOf_Endpoint ( * s.m_alternateEndpoints );
		if ( s.m_gatekeeperIdentifier )
			m_gatekeeperIdentifier = new GatekeeperIdentifier ( * s.m_gatekeeperIdentifier );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_integrityCheckValue )
			m_integrityCheckValue = new ICV ( * s.m_integrityCheckValue );
		if ( s.m_reason )
			m_reason = new UnregRequestReason ( * s.m_reason );
		if ( s.m_endpointAliasPattern )
			m_endpointAliasPattern = new ArrayOf_AddressPattern ( * s.m_endpointAliasPattern );
		if ( s.m_supportedPrefixes )
			m_supportedPrefixes = new ArrayOf_SupportedPrefix ( * s.m_supportedPrefixes );
		if ( s.m_alternateGatekeeper )
			m_alternateGatekeeper = new ArrayOf_AlternateGK ( * s.m_alternateGatekeeper );
		if ( s.m_genericData )
			m_genericData = new ArrayOf_GenericData ( * s.m_genericData );
		if ( s.m_assignedGatekeeper )
			m_assignedGatekeeper = new AlternateGK ( * s.m_assignedGatekeeper );
	} catch ( ... ) {
		delete m_endpointAlias;
		delete m_nonStandardData;
		delete m_endpointIdentifier;
		delete m_alternateEndpoints;
		delete m_gatekeeperIdentifier;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_reason;
		delete m_endpointAliasPattern;
		delete m_supportedPrefixes;
		delete m_alternateGatekeeper;
		delete m_genericData;
		delete m_assignedGatekeeper;
		throw;
	}
}


void UnregistrationRequest :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_endpointAlias:
			assignNew ( m_endpointAlias, new ArrayOf_AliasAddress );
			break;
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_endpointIdentifier:
			assignNew ( m_endpointIdentifier, new EndpointIdentifier );
			break;
		case e_alternateEndpoints:
			assignNew ( m_alternateEndpoints, new ArrayOf_Endpoint );
			break;
		case e_gatekeeperIdentifier:
			assignNew ( m_gatekeeperIdentifier, new GatekeeperIdentifier );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_integrityCheckValue:
			assignNew ( m_integrityCheckValue, new ICV );
			break;
		case e_reason:
			assignNew ( m_reason, new UnregRequestReason );
			break;
		case e_endpointAliasPattern:
			assignNew ( m_endpointAliasPattern, new ArrayOf_AddressPattern );
			break;
		case e_supportedPrefixes:
			assignNew ( m_supportedPrefixes, new ArrayOf_SupportedPrefix );
			break;
		case e_alternateGatekeeper:
			assignNew ( m_alternateGatekeeper, new ArrayOf_AlternateGK );
			break;
		case e_genericData:
			assignNew ( m_genericData, new ArrayOf_GenericData );
			break;
		case e_assignedGatekeeper:
			assignNew ( m_assignedGatekeeper, new AlternateGK );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void UnregistrationRequest :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_endpointAlias:
			delete m_endpointAlias;
			m_endpointAlias = 0;
			break;
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_endpointIdentifier:
			delete m_endpointIdentifier;
			m_endpointIdentifier = 0;
			break;
		case e_alternateEndpoints:
			delete m_alternateEndpoints;
			m_alternateEndpoints = 0;
			break;
		case e_gatekeeperIdentifier:
			delete m_gatekeeperIdentifier;
			m_gatekeeperIdentifier = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_integrityCheckValue:
			delete m_integrityCheckValue;
			m_integrityCheckValue = 0;
			break;
		case e_reason:
			delete m_reason;
			m_reason = 0;
			break;
		case e_endpointAliasPattern:
			delete m_endpointAliasPattern;
			m_endpointAliasPattern = 0;
			break;
		case e_supportedPrefixes:
			delete m_supportedPrefixes;
			m_supportedPrefixes = 0;
			break;
		case e_alternateGatekeeper:
			delete m_alternateGatekeeper;
			m_alternateGatekeeper = 0;
			break;
		case e_genericData:
			delete m_genericData;
			m_genericData = 0;
			break;
		case e_assignedGatekeeper:
			delete m_assignedGatekeeper;
			m_assignedGatekeeper = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void UnregistrationRequest :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_requestSeqNum.encode ( os );
	m_callSignalAddress.encode ( os );
	if ( hasOptionalField ( e_endpointAlias ) )
		m_endpointAlias -> ArrayOf_AliasAddress :: encode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( hasOptionalField ( e_endpointIdentifier ) )
		m_endpointIdentifier -> EndpointIdentifier :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_alternateEndpoints, m_alternateEndpoints );
		knownExtensionEncode ( os, e_gatekeeperIdentifier, m_gatekeeperIdentifier );
		knownExtensionEncode ( os, e_tokens, m_tokens );
		knownExtensionEncode ( os, e_cryptoTokens, m_cryptoTokens );
		knownExtensionEncode ( os, e_integrityCheckValue, m_integrityCheckValue );
		knownExtensionEncode ( os, e_reason, m_reason );
		knownExtensionEncode ( os, e_endpointAliasPattern, m_endpointAliasPattern );
		knownExtensionEncode ( os, e_supportedPrefixes, m_supportedPrefixes );
		knownExtensionEncode ( os, e_alternateGatekeeper, m_alternateGatekeeper );
		knownExtensionEncode ( os, e_genericData, m_genericData );
		knownExtensionEncode ( os, e_assignedGatekeeper, m_assignedGatekeeper );
		unknownExtensionsEncode ( os );
	}
}

UnregistrationRequest :: ~UnregistrationRequest ( ) {
	delete m_endpointAlias;
	delete m_nonStandardData;
	delete m_endpointIdentifier;
	delete m_alternateEndpoints;
	delete m_gatekeeperIdentifier;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_integrityCheckValue;
	delete m_reason;
	delete m_endpointAliasPattern;
	delete m_supportedPrefixes;
	delete m_alternateGatekeeper;
	delete m_genericData;
	delete m_assignedGatekeeper;
}

void UnregistrationRequest :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "requestSeqNum = " << std :: setprecision ( indent ) << m_requestSeqNum << '\n';
	os << std :: setw ( indent + 20 ) << "callSignalAddress = " << std :: setprecision ( indent ) << m_callSignalAddress << '\n';
	if ( hasOptionalField ( e_endpointAlias ) ) {
		os << std :: setw ( indent + 16 ) << "endpointAlias = " << std :: setprecision ( indent );
		m_endpointAlias -> ArrayOf_AliasAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_endpointIdentifier ) ) {
		os << std :: setw ( indent + 21 ) << "endpointIdentifier = " << std :: setprecision ( indent );
		m_endpointIdentifier -> EndpointIdentifier :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_alternateEndpoints ) ) {
		os << std :: setw ( indent + 21 ) << "alternateEndpoints = " << std :: setprecision ( indent );
		m_alternateEndpoints -> ArrayOf_Endpoint :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_gatekeeperIdentifier ) ) {
		os << std :: setw ( indent + 23 ) << "gatekeeperIdentifier = " << std :: setprecision ( indent );
		m_gatekeeperIdentifier -> GatekeeperIdentifier :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_integrityCheckValue ) ) {
		os << std :: setw ( indent + 22 ) << "integrityCheckValue = " << std :: setprecision ( indent );
		m_integrityCheckValue -> ICV :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_reason ) ) {
		os << std :: setw ( indent + 9 ) << "reason = " << std :: setprecision ( indent );
		m_reason -> UnregRequestReason :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_endpointAliasPattern ) ) {
		os << std :: setw ( indent + 23 ) << "endpointAliasPattern = " << std :: setprecision ( indent );
		m_endpointAliasPattern -> ArrayOf_AddressPattern :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_supportedPrefixes ) ) {
		os << std :: setw ( indent + 20 ) << "supportedPrefixes = " << std :: setprecision ( indent );
		m_supportedPrefixes -> ArrayOf_SupportedPrefix :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_alternateGatekeeper ) ) {
		os << std :: setw ( indent + 22 ) << "alternateGatekeeper = " << std :: setprecision ( indent );
		m_alternateGatekeeper -> ArrayOf_AlternateGK :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_genericData ) ) {
		os << std :: setw ( indent + 14 ) << "genericData = " << std :: setprecision ( indent );
		m_genericData -> ArrayOf_GenericData :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_assignedGatekeeper ) ) {
		os << std :: setw ( indent + 21 ) << "assignedGatekeeper = " << std :: setprecision ( indent );
		m_assignedGatekeeper -> AlternateGK :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

UnregistrationRequest * UnregistrationRequest :: clone ( ) const {
	return new UnregistrationRequest ( * this );
}

//
// UnregistrationReject
//

UnregistrationReject :: UnregistrationReject ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 5 ), m_requestSeqNum ( is ), m_rejectReason ( is ), m_nonStandardData ( 0 ), m_altGKInfo ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_genericData ( 0 ) {
	try {
		if ( hasOptionalField ( e_nonStandardData ) )
			m_nonStandardData = new NonStandardParameter ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_altGKInfo ) )
				m_altGKInfo = new AltGKInfo ( is );
			if ( hasKnownExtensionToDecode ( is, e_tokens ) )
				m_tokens = new ArrayOf_ClearToken ( is );
			if ( hasKnownExtensionToDecode ( is, e_cryptoTokens ) )
				m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
			if ( hasKnownExtensionToDecode ( is, e_integrityCheckValue ) )
				m_integrityCheckValue = new ICV ( is );
			if ( hasKnownExtensionToDecode ( is, e_genericData ) )
				m_genericData = new ArrayOf_GenericData ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_altGKInfo;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_genericData;
		throw;
	}
}

UnregistrationReject :: UnregistrationReject ( ) : Asn :: Sequence ( 1, true, 5 ), m_nonStandardData ( 0 ), m_altGKInfo ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_genericData ( 0 ) { }

UnregistrationReject & UnregistrationReject :: operator= ( const UnregistrationReject & s ) {
	Asn :: Sequence :: operator= ( s );
	m_requestSeqNum = s.m_requestSeqNum;
	m_rejectReason = s.m_rejectReason;
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	assignCopy ( m_altGKInfo, s.m_altGKInfo );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_integrityCheckValue, s.m_integrityCheckValue );
	assignCopy ( m_genericData, s.m_genericData );
	return * this;
}

UnregistrationReject :: UnregistrationReject ( const UnregistrationReject & s ) : Asn :: Sequence ( s ), m_requestSeqNum ( s.m_requestSeqNum ), m_rejectReason ( s.m_rejectReason ), m_nonStandardData ( 0 ), m_altGKInfo ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_genericData ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_altGKInfo )
			m_altGKInfo = new AltGKInfo ( * s.m_altGKInfo );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_integrityCheckValue )
			m_integrityCheckValue = new ICV ( * s.m_integrityCheckValue );
		if ( s.m_genericData )
			m_genericData = new ArrayOf_GenericData ( * s.m_genericData );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_altGKInfo;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_genericData;
		throw;
	}
}


void UnregistrationReject :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_altGKInfo:
			assignNew ( m_altGKInfo, new AltGKInfo );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_integrityCheckValue:
			assignNew ( m_integrityCheckValue, new ICV );
			break;
		case e_genericData:
			assignNew ( m_genericData, new ArrayOf_GenericData );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void UnregistrationReject :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_altGKInfo:
			delete m_altGKInfo;
			m_altGKInfo = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_integrityCheckValue:
			delete m_integrityCheckValue;
			m_integrityCheckValue = 0;
			break;
		case e_genericData:
			delete m_genericData;
			m_genericData = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void UnregistrationReject :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_requestSeqNum.encode ( os );
	m_rejectReason.encode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_altGKInfo, m_altGKInfo );
		knownExtensionEncode ( os, e_tokens, m_tokens );
		knownExtensionEncode ( os, e_cryptoTokens, m_cryptoTokens );
		knownExtensionEncode ( os, e_integrityCheckValue, m_integrityCheckValue );
		knownExtensionEncode ( os, e_genericData, m_genericData );
		unknownExtensionsEncode ( os );
	}
}

UnregistrationReject :: ~UnregistrationReject ( ) {
	delete m_nonStandardData;
	delete m_altGKInfo;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_integrityCheckValue;
	delete m_genericData;
}

void UnregistrationReject :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "requestSeqNum = " << std :: setprecision ( indent ) << m_requestSeqNum << '\n';
	os << std :: setw ( indent + 15 ) << "rejectReason = " << std :: setprecision ( indent ) << m_rejectReason << '\n';
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_altGKInfo ) ) {
		os << std :: setw ( indent + 12 ) << "altGKInfo = " << std :: setprecision ( indent );
		m_altGKInfo -> AltGKInfo :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_integrityCheckValue ) ) {
		os << std :: setw ( indent + 22 ) << "integrityCheckValue = " << std :: setprecision ( indent );
		m_integrityCheckValue -> ICV :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_genericData ) ) {
		os << std :: setw ( indent + 14 ) << "genericData = " << std :: setprecision ( indent );
		m_genericData -> ArrayOf_GenericData :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

UnregistrationReject * UnregistrationReject :: clone ( ) const {
	return new UnregistrationReject ( * this );
}

//
// AdmissionRequest
//

AdmissionRequest :: AdmissionRequest ( Asn :: istream & is ) : Asn :: Sequence ( is, 7, true, 19 ), m_requestSeqNum ( is ), m_callType ( is ), m_callModel ( hasOptionalField ( e_callModel ) ? pushTemporaryMember ( new CallModel ( is ) ) : 0 ), m_endpointIdentifier ( is ), m_destinationInfo ( hasOptionalField ( e_destinationInfo ) ? pushTemporaryMember ( new ArrayOf_AliasAddress ( is ) ) : 0 ), m_destCallSignalAddress ( hasOptionalField ( e_destCallSignalAddress ) ? pushTemporaryMember ( new TransportAddress ( is ) ) : 0 ), m_destExtraCallInfo ( hasOptionalField ( e_destExtraCallInfo ) ? pushTemporaryMember ( new ArrayOf_AliasAddress ( is ) ) : 0 ), m_srcInfo ( is ), m_srcCallSignalAddress ( hasOptionalField ( e_srcCallSignalAddress ) ? pushTemporaryMember ( new TransportAddress ( is ) ) : 0 ), m_bandWidth ( is ), m_callReferenceValue ( is ), m_nonStandardData ( hasOptionalField ( e_nonStandardData ) ? pushTemporaryMember ( new NonStandardParameter ( is ) ) : 0 ), m_callServices ( hasOptionalField ( e_callServices ) ? pushTemporaryMember ( new QseriesOptions ( is ) ) : 0 ), m_conferenceID ( is ), m_activeMC ( is ), m_answerCall ( is ), m_canMapAlias ( 0 ), m_callIdentifier ( 0 ), m_srcAlternatives ( 0 ), m_destAlternatives ( 0 ), m_gatekeeperIdentifier ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_transportQOS ( 0 ), m_willSupplyUUIEs ( 0 ), m_callLinkage ( 0 ), m_gatewayDataRate ( 0 ), m_capacity ( 0 ), m_circuitInfo ( 0 ), m_desiredProtocols ( 0 ), m_desiredTunnelledProtocol ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ), m_canMapSrcAlias ( 0 ) {
	clearTemporaryMembers ( );
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_canMapAlias ) )
				m_canMapAlias = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_callIdentifier ) )
				m_callIdentifier = new CallIdentifier ( is );
			if ( hasKnownExtensionToDecode ( is, e_srcAlternatives ) )
				m_srcAlternatives = new ArrayOf_Endpoint ( is );
			if ( hasKnownExtensionToDecode ( is, e_destAlternatives ) )
				m_destAlternatives = new ArrayOf_Endpoint ( is );
			if ( hasKnownExtensionToDecode ( is, e_gatekeeperIdentifier ) )
				m_gatekeeperIdentifier = new GatekeeperIdentifier ( is );
			if ( hasKnownExtensionToDecode ( is, e_tokens ) )
				m_tokens = new ArrayOf_ClearToken ( is );
			if ( hasKnownExtensionToDecode ( is, e_cryptoTokens ) )
				m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
			if ( hasKnownExtensionToDecode ( is, e_integrityCheckValue ) )
				m_integrityCheckValue = new ICV ( is );
			if ( hasKnownExtensionToDecode ( is, e_transportQOS ) )
				m_transportQOS = new TransportQOS ( is );
			if ( hasKnownExtensionToDecode ( is, e_willSupplyUUIEs ) )
				m_willSupplyUUIEs = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_callLinkage ) )
				m_callLinkage = new CallLinkage ( is );
			if ( hasKnownExtensionToDecode ( is, e_gatewayDataRate ) )
				m_gatewayDataRate = new DataRate ( is );
			if ( hasKnownExtensionToDecode ( is, e_capacity ) )
				m_capacity = new CallCapacity ( is );
			if ( hasKnownExtensionToDecode ( is, e_circuitInfo ) )
				m_circuitInfo = new CircuitInfo ( is );
			if ( hasKnownExtensionToDecode ( is, e_desiredProtocols ) )
				m_desiredProtocols = new ArrayOf_SupportedProtocols ( is );
			if ( hasKnownExtensionToDecode ( is, e_desiredTunnelledProtocol ) )
				m_desiredTunnelledProtocol = new TunnelledProtocol ( is );
			if ( hasKnownExtensionToDecode ( is, e_featureSet ) )
				m_featureSet = new FeatureSet ( is );
			if ( hasKnownExtensionToDecode ( is, e_genericData ) )
				m_genericData = new ArrayOf_GenericData ( is );
			if ( hasKnownExtensionToDecode ( is, e_canMapSrcAlias ) )
				m_canMapSrcAlias = new Asn :: Boolean ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_callModel;
		delete m_destinationInfo;
		delete m_destCallSignalAddress;
		delete m_destExtraCallInfo;
		delete m_srcCallSignalAddress;
		delete m_nonStandardData;
		delete m_callServices;
		delete m_canMapAlias;
		delete m_callIdentifier;
		delete m_srcAlternatives;
		delete m_destAlternatives;
		delete m_gatekeeperIdentifier;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_transportQOS;
		delete m_willSupplyUUIEs;
		delete m_callLinkage;
		delete m_gatewayDataRate;
		delete m_capacity;
		delete m_circuitInfo;
		delete m_desiredProtocols;
		delete m_desiredTunnelledProtocol;
		delete m_featureSet;
		delete m_genericData;
		delete m_canMapSrcAlias;
		throw;
	}
}

AdmissionRequest :: AdmissionRequest ( ) : Asn :: Sequence ( 7, true, 19 ), m_callModel ( 0 ), m_destinationInfo ( 0 ), m_destCallSignalAddress ( 0 ), m_destExtraCallInfo ( 0 ), m_srcCallSignalAddress ( 0 ), m_nonStandardData ( 0 ), m_callServices ( 0 ), m_canMapAlias ( 0 ), m_callIdentifier ( 0 ), m_srcAlternatives ( 0 ), m_destAlternatives ( 0 ), m_gatekeeperIdentifier ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_transportQOS ( 0 ), m_willSupplyUUIEs ( 0 ), m_callLinkage ( 0 ), m_gatewayDataRate ( 0 ), m_capacity ( 0 ), m_circuitInfo ( 0 ), m_desiredProtocols ( 0 ), m_desiredTunnelledProtocol ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ), m_canMapSrcAlias ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_canMapAlias );
		m_canMapAlias = new Asn :: Boolean;
		Asn :: Sequence :: includeOptionalField ( e_callIdentifier );
		m_callIdentifier = new CallIdentifier;
		Asn :: Sequence :: includeOptionalField ( e_willSupplyUUIEs );
		m_willSupplyUUIEs = new Asn :: Boolean;
		Asn :: Sequence :: includeOptionalField ( e_canMapSrcAlias );
		m_canMapSrcAlias = new Asn :: Boolean;
	} catch ( ... ) {
		delete m_canMapAlias;
		delete m_callIdentifier;
		delete m_willSupplyUUIEs;
		delete m_canMapSrcAlias;
		throw;
	}
}

AdmissionRequest & AdmissionRequest :: operator= ( const AdmissionRequest & s ) {
	Asn :: Sequence :: operator= ( s );
	m_requestSeqNum = s.m_requestSeqNum;
	m_callType = s.m_callType;
	assignCopy ( m_callModel, s.m_callModel );
	m_endpointIdentifier = s.m_endpointIdentifier;
	assignCopy ( m_destinationInfo, s.m_destinationInfo );
	assignCopy ( m_destCallSignalAddress, s.m_destCallSignalAddress );
	assignCopy ( m_destExtraCallInfo, s.m_destExtraCallInfo );
	m_srcInfo = s.m_srcInfo;
	assignCopy ( m_srcCallSignalAddress, s.m_srcCallSignalAddress );
	m_bandWidth = s.m_bandWidth;
	m_callReferenceValue = s.m_callReferenceValue;
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	assignCopy ( m_callServices, s.m_callServices );
	m_conferenceID = s.m_conferenceID;
	m_activeMC = s.m_activeMC;
	m_answerCall = s.m_answerCall;
	assignCopy ( m_canMapAlias, s.m_canMapAlias );
	assignCopy ( m_callIdentifier, s.m_callIdentifier );
	assignCopy ( m_srcAlternatives, s.m_srcAlternatives );
	assignCopy ( m_destAlternatives, s.m_destAlternatives );
	assignCopy ( m_gatekeeperIdentifier, s.m_gatekeeperIdentifier );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_integrityCheckValue, s.m_integrityCheckValue );
	assignCopy ( m_transportQOS, s.m_transportQOS );
	assignCopy ( m_willSupplyUUIEs, s.m_willSupplyUUIEs );
	assignCopy ( m_callLinkage, s.m_callLinkage );
	assignCopy ( m_gatewayDataRate, s.m_gatewayDataRate );
	assignCopy ( m_capacity, s.m_capacity );
	assignCopy ( m_circuitInfo, s.m_circuitInfo );
	assignCopy ( m_desiredProtocols, s.m_desiredProtocols );
	assignCopy ( m_desiredTunnelledProtocol, s.m_desiredTunnelledProtocol );
	assignCopy ( m_featureSet, s.m_featureSet );
	assignCopy ( m_genericData, s.m_genericData );
	assignCopy ( m_canMapSrcAlias, s.m_canMapSrcAlias );
	return * this;
}

AdmissionRequest :: AdmissionRequest ( const AdmissionRequest & s ) : Asn :: Sequence ( s ), m_requestSeqNum ( s.m_requestSeqNum ), m_callType ( s.m_callType ), m_callModel ( 0 ), m_endpointIdentifier ( s.m_endpointIdentifier ), m_destinationInfo ( 0 ), m_destCallSignalAddress ( 0 ), m_destExtraCallInfo ( 0 ), m_srcInfo ( s.m_srcInfo ), m_srcCallSignalAddress ( 0 ), m_bandWidth ( s.m_bandWidth ), m_callReferenceValue ( s.m_callReferenceValue ), m_nonStandardData ( 0 ), m_callServices ( 0 ), m_conferenceID ( s.m_conferenceID ), m_activeMC ( s.m_activeMC ), m_answerCall ( s.m_answerCall ), m_canMapAlias ( 0 ), m_callIdentifier ( 0 ), m_srcAlternatives ( 0 ), m_destAlternatives ( 0 ), m_gatekeeperIdentifier ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_transportQOS ( 0 ), m_willSupplyUUIEs ( 0 ), m_callLinkage ( 0 ), m_gatewayDataRate ( 0 ), m_capacity ( 0 ), m_circuitInfo ( 0 ), m_desiredProtocols ( 0 ), m_desiredTunnelledProtocol ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ), m_canMapSrcAlias ( 0 ) {
	try {
		if ( s.m_callModel )
			m_callModel = new CallModel ( * s.m_callModel );
		if ( s.m_destinationInfo )
			m_destinationInfo = new ArrayOf_AliasAddress ( * s.m_destinationInfo );
		if ( s.m_destCallSignalAddress )
			m_destCallSignalAddress = new TransportAddress ( * s.m_destCallSignalAddress );
		if ( s.m_destExtraCallInfo )
			m_destExtraCallInfo = new ArrayOf_AliasAddress ( * s.m_destExtraCallInfo );
		if ( s.m_srcCallSignalAddress )
			m_srcCallSignalAddress = new TransportAddress ( * s.m_srcCallSignalAddress );
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_callServices )
			m_callServices = new QseriesOptions ( * s.m_callServices );
		if ( s.m_canMapAlias )
			m_canMapAlias = new Asn :: Boolean ( * s.m_canMapAlias );
		if ( s.m_callIdentifier )
			m_callIdentifier = new CallIdentifier ( * s.m_callIdentifier );
		if ( s.m_srcAlternatives )
			m_srcAlternatives = new ArrayOf_Endpoint ( * s.m_srcAlternatives );
		if ( s.m_destAlternatives )
			m_destAlternatives = new ArrayOf_Endpoint ( * s.m_destAlternatives );
		if ( s.m_gatekeeperIdentifier )
			m_gatekeeperIdentifier = new GatekeeperIdentifier ( * s.m_gatekeeperIdentifier );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_integrityCheckValue )
			m_integrityCheckValue = new ICV ( * s.m_integrityCheckValue );
		if ( s.m_transportQOS )
			m_transportQOS = new TransportQOS ( * s.m_transportQOS );
		if ( s.m_willSupplyUUIEs )
			m_willSupplyUUIEs = new Asn :: Boolean ( * s.m_willSupplyUUIEs );
		if ( s.m_callLinkage )
			m_callLinkage = new CallLinkage ( * s.m_callLinkage );
		if ( s.m_gatewayDataRate )
			m_gatewayDataRate = new DataRate ( * s.m_gatewayDataRate );
		if ( s.m_capacity )
			m_capacity = new CallCapacity ( * s.m_capacity );
		if ( s.m_circuitInfo )
			m_circuitInfo = new CircuitInfo ( * s.m_circuitInfo );
		if ( s.m_desiredProtocols )
			m_desiredProtocols = new ArrayOf_SupportedProtocols ( * s.m_desiredProtocols );
		if ( s.m_desiredTunnelledProtocol )
			m_desiredTunnelledProtocol = new TunnelledProtocol ( * s.m_desiredTunnelledProtocol );
		if ( s.m_featureSet )
			m_featureSet = new FeatureSet ( * s.m_featureSet );
		if ( s.m_genericData )
			m_genericData = new ArrayOf_GenericData ( * s.m_genericData );
		if ( s.m_canMapSrcAlias )
			m_canMapSrcAlias = new Asn :: Boolean ( * s.m_canMapSrcAlias );
	} catch ( ... ) {
		delete m_callModel;
		delete m_destinationInfo;
		delete m_destCallSignalAddress;
		delete m_destExtraCallInfo;
		delete m_srcCallSignalAddress;
		delete m_nonStandardData;
		delete m_callServices;
		delete m_canMapAlias;
		delete m_callIdentifier;
		delete m_srcAlternatives;
		delete m_destAlternatives;
		delete m_gatekeeperIdentifier;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_transportQOS;
		delete m_willSupplyUUIEs;
		delete m_callLinkage;
		delete m_gatewayDataRate;
		delete m_capacity;
		delete m_circuitInfo;
		delete m_desiredProtocols;
		delete m_desiredTunnelledProtocol;
		delete m_featureSet;
		delete m_genericData;
		delete m_canMapSrcAlias;
		throw;
	}
}


void AdmissionRequest :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_callModel:
			assignNew ( m_callModel, new CallModel );
			break;
		case e_destinationInfo:
			assignNew ( m_destinationInfo, new ArrayOf_AliasAddress );
			break;
		case e_destCallSignalAddress:
			assignNew ( m_destCallSignalAddress, new TransportAddress );
			break;
		case e_destExtraCallInfo:
			assignNew ( m_destExtraCallInfo, new ArrayOf_AliasAddress );
			break;
		case e_srcCallSignalAddress:
			assignNew ( m_srcCallSignalAddress, new TransportAddress );
			break;
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_callServices:
			assignNew ( m_callServices, new QseriesOptions );
			break;
		case e_canMapAlias:
			assignNew ( m_canMapAlias, new Asn :: Boolean );
			break;
		case e_callIdentifier:
			assignNew ( m_callIdentifier, new CallIdentifier );
			break;
		case e_srcAlternatives:
			assignNew ( m_srcAlternatives, new ArrayOf_Endpoint );
			break;
		case e_destAlternatives:
			assignNew ( m_destAlternatives, new ArrayOf_Endpoint );
			break;
		case e_gatekeeperIdentifier:
			assignNew ( m_gatekeeperIdentifier, new GatekeeperIdentifier );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_integrityCheckValue:
			assignNew ( m_integrityCheckValue, new ICV );
			break;
		case e_transportQOS:
			assignNew ( m_transportQOS, new TransportQOS );
			break;
		case e_willSupplyUUIEs:
			assignNew ( m_willSupplyUUIEs, new Asn :: Boolean );
			break;
		case e_callLinkage:
			assignNew ( m_callLinkage, new CallLinkage );
			break;
		case e_gatewayDataRate:
			assignNew ( m_gatewayDataRate, new DataRate );
			break;
		case e_capacity:
			assignNew ( m_capacity, new CallCapacity );
			break;
		case e_circuitInfo:
			assignNew ( m_circuitInfo, new CircuitInfo );
			break;
		case e_desiredProtocols:
			assignNew ( m_desiredProtocols, new ArrayOf_SupportedProtocols );
			break;
		case e_desiredTunnelledProtocol:
			assignNew ( m_desiredTunnelledProtocol, new TunnelledProtocol );
			break;
		case e_featureSet:
			assignNew ( m_featureSet, new FeatureSet );
			break;
		case e_genericData:
			assignNew ( m_genericData, new ArrayOf_GenericData );
			break;
		case e_canMapSrcAlias:
			assignNew ( m_canMapSrcAlias, new Asn :: Boolean );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void AdmissionRequest :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_callModel:
			delete m_callModel;
			m_callModel = 0;
			break;
		case e_destinationInfo:
			delete m_destinationInfo;
			m_destinationInfo = 0;
			break;
		case e_destCallSignalAddress:
			delete m_destCallSignalAddress;
			m_destCallSignalAddress = 0;
			break;
		case e_destExtraCallInfo:
			delete m_destExtraCallInfo;
			m_destExtraCallInfo = 0;
			break;
		case e_srcCallSignalAddress:
			delete m_srcCallSignalAddress;
			m_srcCallSignalAddress = 0;
			break;
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_callServices:
			delete m_callServices;
			m_callServices = 0;
			break;
		case e_canMapAlias:
			delete m_canMapAlias;
			m_canMapAlias = 0;
			break;
		case e_callIdentifier:
			delete m_callIdentifier;
			m_callIdentifier = 0;
			break;
		case e_srcAlternatives:
			delete m_srcAlternatives;
			m_srcAlternatives = 0;
			break;
		case e_destAlternatives:
			delete m_destAlternatives;
			m_destAlternatives = 0;
			break;
		case e_gatekeeperIdentifier:
			delete m_gatekeeperIdentifier;
			m_gatekeeperIdentifier = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_integrityCheckValue:
			delete m_integrityCheckValue;
			m_integrityCheckValue = 0;
			break;
		case e_transportQOS:
			delete m_transportQOS;
			m_transportQOS = 0;
			break;
		case e_willSupplyUUIEs:
			delete m_willSupplyUUIEs;
			m_willSupplyUUIEs = 0;
			break;
		case e_callLinkage:
			delete m_callLinkage;
			m_callLinkage = 0;
			break;
		case e_gatewayDataRate:
			delete m_gatewayDataRate;
			m_gatewayDataRate = 0;
			break;
		case e_capacity:
			delete m_capacity;
			m_capacity = 0;
			break;
		case e_circuitInfo:
			delete m_circuitInfo;
			m_circuitInfo = 0;
			break;
		case e_desiredProtocols:
			delete m_desiredProtocols;
			m_desiredProtocols = 0;
			break;
		case e_desiredTunnelledProtocol:
			delete m_desiredTunnelledProtocol;
			m_desiredTunnelledProtocol = 0;
			break;
		case e_featureSet:
			delete m_featureSet;
			m_featureSet = 0;
			break;
		case e_genericData:
			delete m_genericData;
			m_genericData = 0;
			break;
		case e_canMapSrcAlias:
			delete m_canMapSrcAlias;
			m_canMapSrcAlias = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void AdmissionRequest :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_requestSeqNum.encode ( os );
	m_callType.encode ( os );
	if ( hasOptionalField ( e_callModel ) )
		m_callModel -> CallModel :: encode ( os );
	m_endpointIdentifier.encode ( os );
	if ( hasOptionalField ( e_destinationInfo ) )
		m_destinationInfo -> ArrayOf_AliasAddress :: encode ( os );
	if ( hasOptionalField ( e_destCallSignalAddress ) )
		m_destCallSignalAddress -> TransportAddress :: encode ( os );
	if ( hasOptionalField ( e_destExtraCallInfo ) )
		m_destExtraCallInfo -> ArrayOf_AliasAddress :: encode ( os );
	m_srcInfo.encode ( os );
	if ( hasOptionalField ( e_srcCallSignalAddress ) )
		m_srcCallSignalAddress -> TransportAddress :: encode ( os );
	m_bandWidth.encode ( os );
	m_callReferenceValue.encode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( hasOptionalField ( e_callServices ) )
		m_callServices -> QseriesOptions :: encode ( os );
	m_conferenceID.encode ( os );
	m_activeMC.encode ( os );
	m_answerCall.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_canMapAlias, m_canMapAlias );
		knownExtensionEncode ( os, e_callIdentifier, m_callIdentifier );
		knownExtensionEncode ( os, e_srcAlternatives, m_srcAlternatives );
		knownExtensionEncode ( os, e_destAlternatives, m_destAlternatives );
		knownExtensionEncode ( os, e_gatekeeperIdentifier, m_gatekeeperIdentifier );
		knownExtensionEncode ( os, e_tokens, m_tokens );
		knownExtensionEncode ( os, e_cryptoTokens, m_cryptoTokens );
		knownExtensionEncode ( os, e_integrityCheckValue, m_integrityCheckValue );
		knownExtensionEncode ( os, e_transportQOS, m_transportQOS );
		knownExtensionEncode ( os, e_willSupplyUUIEs, m_willSupplyUUIEs );
		knownExtensionEncode ( os, e_callLinkage, m_callLinkage );
		knownExtensionEncode ( os, e_gatewayDataRate, m_gatewayDataRate );
		knownExtensionEncode ( os, e_capacity, m_capacity );
		knownExtensionEncode ( os, e_circuitInfo, m_circuitInfo );
		knownExtensionEncode ( os, e_desiredProtocols, m_desiredProtocols );
		knownExtensionEncode ( os, e_desiredTunnelledProtocol, m_desiredTunnelledProtocol );
		knownExtensionEncode ( os, e_featureSet, m_featureSet );
		knownExtensionEncode ( os, e_genericData, m_genericData );
		knownExtensionEncode ( os, e_canMapSrcAlias, m_canMapSrcAlias );
		unknownExtensionsEncode ( os );
	}
}

AdmissionRequest :: ~AdmissionRequest ( ) {
	delete m_callModel;
	delete m_destinationInfo;
	delete m_destCallSignalAddress;
	delete m_destExtraCallInfo;
	delete m_srcCallSignalAddress;
	delete m_nonStandardData;
	delete m_callServices;
	delete m_canMapAlias;
	delete m_callIdentifier;
	delete m_srcAlternatives;
	delete m_destAlternatives;
	delete m_gatekeeperIdentifier;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_integrityCheckValue;
	delete m_transportQOS;
	delete m_willSupplyUUIEs;
	delete m_callLinkage;
	delete m_gatewayDataRate;
	delete m_capacity;
	delete m_circuitInfo;
	delete m_desiredProtocols;
	delete m_desiredTunnelledProtocol;
	delete m_featureSet;
	delete m_genericData;
	delete m_canMapSrcAlias;
}

void AdmissionRequest :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "requestSeqNum = " << std :: setprecision ( indent ) << m_requestSeqNum << '\n';
	os << std :: setw ( indent + 11 ) << "callType = " << std :: setprecision ( indent ) << m_callType << '\n';
	if ( hasOptionalField ( e_callModel ) ) {
		os << std :: setw ( indent + 12 ) << "callModel = " << std :: setprecision ( indent );
		m_callModel -> CallModel :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 21 ) << "endpointIdentifier = " << std :: setprecision ( indent ) << m_endpointIdentifier << '\n';
	if ( hasOptionalField ( e_destinationInfo ) ) {
		os << std :: setw ( indent + 18 ) << "destinationInfo = " << std :: setprecision ( indent );
		m_destinationInfo -> ArrayOf_AliasAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_destCallSignalAddress ) ) {
		os << std :: setw ( indent + 24 ) << "destCallSignalAddress = " << std :: setprecision ( indent );
		m_destCallSignalAddress -> TransportAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_destExtraCallInfo ) ) {
		os << std :: setw ( indent + 20 ) << "destExtraCallInfo = " << std :: setprecision ( indent );
		m_destExtraCallInfo -> ArrayOf_AliasAddress :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 10 ) << "srcInfo = " << std :: setprecision ( indent ) << m_srcInfo << '\n';
	if ( hasOptionalField ( e_srcCallSignalAddress ) ) {
		os << std :: setw ( indent + 23 ) << "srcCallSignalAddress = " << std :: setprecision ( indent );
		m_srcCallSignalAddress -> TransportAddress :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 12 ) << "bandWidth = " << std :: setprecision ( indent ) << m_bandWidth << '\n';
	os << std :: setw ( indent + 21 ) << "callReferenceValue = " << std :: setprecision ( indent ) << m_callReferenceValue << '\n';
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_callServices ) ) {
		os << std :: setw ( indent + 15 ) << "callServices = " << std :: setprecision ( indent );
		m_callServices -> QseriesOptions :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 15 ) << "conferenceID = " << std :: setprecision ( indent ) << m_conferenceID << '\n';
	os << std :: setw ( indent + 11 ) << "activeMC = " << std :: setprecision ( indent ) << m_activeMC << '\n';
	os << std :: setw ( indent + 13 ) << "answerCall = " << std :: setprecision ( indent ) << m_answerCall << '\n';
	if ( hasOptionalField ( e_canMapAlias ) ) {
		os << std :: setw ( indent + 14 ) << "canMapAlias = " << std :: setprecision ( indent );
		m_canMapAlias -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_callIdentifier ) ) {
		os << std :: setw ( indent + 17 ) << "callIdentifier = " << std :: setprecision ( indent );
		m_callIdentifier -> CallIdentifier :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_srcAlternatives ) ) {
		os << std :: setw ( indent + 18 ) << "srcAlternatives = " << std :: setprecision ( indent );
		m_srcAlternatives -> ArrayOf_Endpoint :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_destAlternatives ) ) {
		os << std :: setw ( indent + 19 ) << "destAlternatives = " << std :: setprecision ( indent );
		m_destAlternatives -> ArrayOf_Endpoint :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_gatekeeperIdentifier ) ) {
		os << std :: setw ( indent + 23 ) << "gatekeeperIdentifier = " << std :: setprecision ( indent );
		m_gatekeeperIdentifier -> GatekeeperIdentifier :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_integrityCheckValue ) ) {
		os << std :: setw ( indent + 22 ) << "integrityCheckValue = " << std :: setprecision ( indent );
		m_integrityCheckValue -> ICV :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_transportQOS ) ) {
		os << std :: setw ( indent + 15 ) << "transportQOS = " << std :: setprecision ( indent );
		m_transportQOS -> TransportQOS :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_willSupplyUUIEs ) ) {
		os << std :: setw ( indent + 18 ) << "willSupplyUUIEs = " << std :: setprecision ( indent );
		m_willSupplyUUIEs -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_callLinkage ) ) {
		os << std :: setw ( indent + 14 ) << "callLinkage = " << std :: setprecision ( indent );
		m_callLinkage -> CallLinkage :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_gatewayDataRate ) ) {
		os << std :: setw ( indent + 18 ) << "gatewayDataRate = " << std :: setprecision ( indent );
		m_gatewayDataRate -> DataRate :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_capacity ) ) {
		os << std :: setw ( indent + 11 ) << "capacity = " << std :: setprecision ( indent );
		m_capacity -> CallCapacity :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_circuitInfo ) ) {
		os << std :: setw ( indent + 14 ) << "circuitInfo = " << std :: setprecision ( indent );
		m_circuitInfo -> CircuitInfo :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_desiredProtocols ) ) {
		os << std :: setw ( indent + 19 ) << "desiredProtocols = " << std :: setprecision ( indent );
		m_desiredProtocols -> ArrayOf_SupportedProtocols :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_desiredTunnelledProtocol ) ) {
		os << std :: setw ( indent + 27 ) << "desiredTunnelledProtocol = " << std :: setprecision ( indent );
		m_desiredTunnelledProtocol -> TunnelledProtocol :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_featureSet ) ) {
		os << std :: setw ( indent + 13 ) << "featureSet = " << std :: setprecision ( indent );
		m_featureSet -> FeatureSet :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_genericData ) ) {
		os << std :: setw ( indent + 14 ) << "genericData = " << std :: setprecision ( indent );
		m_genericData -> ArrayOf_GenericData :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_canMapSrcAlias ) ) {
		os << std :: setw ( indent + 17 ) << "canMapSrcAlias = " << std :: setprecision ( indent );
		m_canMapSrcAlias -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

AdmissionRequest * AdmissionRequest :: clone ( ) const {
	return new AdmissionRequest ( * this );
}

//
// TransportQOS
//

TransportQOS :: TransportQOS ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_endpointControlled:
		case e_gatekeeperControlled:
		case e_noControl:
			choice = new Asn :: Null ( is );
			break;
		case e_qOSCapabilities:
			choice = new TransportQOS_qOSCapabilities ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

TransportQOS :: TransportQOS ( ) : Asn :: Choice ( 3, true ) { }

void TransportQOS :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_endpointControlled:
		case e_gatekeeperControlled:
		case e_noControl:
			o = new Asn :: Null;
			break;
		case e_qOSCapabilities:
			o = new TransportQOS_qOSCapabilities;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & TransportQOS :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_endpointControlled, "endpointControlled" },
		{ e_gatekeeperControlled, "gatekeeperControlled" },
		{ e_noControl, "noControl" },
		{ e_qOSCapabilities, "qOSCapabilities" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

TransportQOS * TransportQOS :: clone ( ) const {
	return new TransportQOS ( * this );
}

//
// AdmissionRejectReason
//

AdmissionRejectReason :: AdmissionRejectReason ( Asn :: istream & is ) : Asn :: Choice ( is, 8, true ) {
	switch ( tag ) {
		case e_calledPartyNotRegistered:
		case e_invalidPermission:
		case e_requestDenied:
		case e_undefinedReason:
		case e_callerNotRegistered:
		case e_routeCallToGatekeeper:
		case e_invalidEndpointIdentifier:
		case e_resourceUnavailable:
		case e_securityDenial:
		case e_qosControlNotSupported:
		case e_incompleteAddress:
		case e_aliasesInconsistent:
		case e_exceedsCallCapacity:
		case e_collectDestination:
		case e_collectPIN:
		case e_genericDataReason:
		case e_neededFeatureNotSupported:
		case e_securityDHmismatch:
		case e_noRouteToDestination:
		case e_unallocatedNumber:
		case e_registerWithAssignedGK:
			choice = new Asn :: Null ( is );
			break;
		case e_routeCallToSCN:
			choice = new ArrayOf_PartyNumber ( is );
			break;
		case e_securityErrors:
			choice = new SecurityErrors2 ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

AdmissionRejectReason :: AdmissionRejectReason ( ) : Asn :: Choice ( 8, true ) { }

void AdmissionRejectReason :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_calledPartyNotRegistered:
		case e_invalidPermission:
		case e_requestDenied:
		case e_undefinedReason:
		case e_callerNotRegistered:
		case e_routeCallToGatekeeper:
		case e_invalidEndpointIdentifier:
		case e_resourceUnavailable:
		case e_securityDenial:
		case e_qosControlNotSupported:
		case e_incompleteAddress:
		case e_aliasesInconsistent:
		case e_exceedsCallCapacity:
		case e_collectDestination:
		case e_collectPIN:
		case e_genericDataReason:
		case e_neededFeatureNotSupported:
		case e_securityDHmismatch:
		case e_noRouteToDestination:
		case e_unallocatedNumber:
		case e_registerWithAssignedGK:
			o = new Asn :: Null;
			break;
		case e_routeCallToSCN:
			o = new ArrayOf_PartyNumber;
			break;
		case e_securityErrors:
			o = new SecurityErrors2;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & AdmissionRejectReason :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_calledPartyNotRegistered, "calledPartyNotRegistered" },
		{ e_invalidPermission, "invalidPermission" },
		{ e_requestDenied, "requestDenied" },
		{ e_undefinedReason, "undefinedReason" },
		{ e_callerNotRegistered, "callerNotRegistered" },
		{ e_routeCallToGatekeeper, "routeCallToGatekeeper" },
		{ e_invalidEndpointIdentifier, "invalidEndpointIdentifier" },
		{ e_resourceUnavailable, "resourceUnavailable" },
		{ e_securityDenial, "securityDenial" },
		{ e_qosControlNotSupported, "qosControlNotSupported" },
		{ e_incompleteAddress, "incompleteAddress" },
		{ e_aliasesInconsistent, "aliasesInconsistent" },
		{ e_routeCallToSCN, "routeCallToSCN" },
		{ e_exceedsCallCapacity, "exceedsCallCapacity" },
		{ e_collectDestination, "collectDestination" },
		{ e_collectPIN, "collectPIN" },
		{ e_genericDataReason, "genericDataReason" },
		{ e_neededFeatureNotSupported, "neededFeatureNotSupported" },
		{ e_securityErrors, "securityErrors" },
		{ e_securityDHmismatch, "securityDHmismatch" },
		{ e_noRouteToDestination, "noRouteToDestination" },
		{ e_unallocatedNumber, "unallocatedNumber" },
		{ e_registerWithAssignedGK, "registerWithAssignedGK" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

AdmissionRejectReason * AdmissionRejectReason :: clone ( ) const {
	return new AdmissionRejectReason ( * this );
}

//
// BandwidthReject
//

BandwidthReject :: BandwidthReject ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 5 ), m_requestSeqNum ( is ), m_rejectReason ( is ), m_allowedBandWidth ( is ), m_nonStandardData ( 0 ), m_altGKInfo ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_genericData ( 0 ) {
	try {
		if ( hasOptionalField ( e_nonStandardData ) )
			m_nonStandardData = new NonStandardParameter ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_altGKInfo ) )
				m_altGKInfo = new AltGKInfo ( is );
			if ( hasKnownExtensionToDecode ( is, e_tokens ) )
				m_tokens = new ArrayOf_ClearToken ( is );
			if ( hasKnownExtensionToDecode ( is, e_cryptoTokens ) )
				m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
			if ( hasKnownExtensionToDecode ( is, e_integrityCheckValue ) )
				m_integrityCheckValue = new ICV ( is );
			if ( hasKnownExtensionToDecode ( is, e_genericData ) )
				m_genericData = new ArrayOf_GenericData ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_altGKInfo;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_genericData;
		throw;
	}
}

BandwidthReject :: BandwidthReject ( ) : Asn :: Sequence ( 1, true, 5 ), m_nonStandardData ( 0 ), m_altGKInfo ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_genericData ( 0 ) { }

BandwidthReject & BandwidthReject :: operator= ( const BandwidthReject & s ) {
	Asn :: Sequence :: operator= ( s );
	m_requestSeqNum = s.m_requestSeqNum;
	m_rejectReason = s.m_rejectReason;
	m_allowedBandWidth = s.m_allowedBandWidth;
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	assignCopy ( m_altGKInfo, s.m_altGKInfo );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_integrityCheckValue, s.m_integrityCheckValue );
	assignCopy ( m_genericData, s.m_genericData );
	return * this;
}

BandwidthReject :: BandwidthReject ( const BandwidthReject & s ) : Asn :: Sequence ( s ), m_requestSeqNum ( s.m_requestSeqNum ), m_rejectReason ( s.m_rejectReason ), m_allowedBandWidth ( s.m_allowedBandWidth ), m_nonStandardData ( 0 ), m_altGKInfo ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_genericData ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_altGKInfo )
			m_altGKInfo = new AltGKInfo ( * s.m_altGKInfo );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_integrityCheckValue )
			m_integrityCheckValue = new ICV ( * s.m_integrityCheckValue );
		if ( s.m_genericData )
			m_genericData = new ArrayOf_GenericData ( * s.m_genericData );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_altGKInfo;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_genericData;
		throw;
	}
}


void BandwidthReject :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_altGKInfo:
			assignNew ( m_altGKInfo, new AltGKInfo );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_integrityCheckValue:
			assignNew ( m_integrityCheckValue, new ICV );
			break;
		case e_genericData:
			assignNew ( m_genericData, new ArrayOf_GenericData );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void BandwidthReject :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_altGKInfo:
			delete m_altGKInfo;
			m_altGKInfo = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_integrityCheckValue:
			delete m_integrityCheckValue;
			m_integrityCheckValue = 0;
			break;
		case e_genericData:
			delete m_genericData;
			m_genericData = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void BandwidthReject :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_requestSeqNum.encode ( os );
	m_rejectReason.encode ( os );
	m_allowedBandWidth.encode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_altGKInfo, m_altGKInfo );
		knownExtensionEncode ( os, e_tokens, m_tokens );
		knownExtensionEncode ( os, e_cryptoTokens, m_cryptoTokens );
		knownExtensionEncode ( os, e_integrityCheckValue, m_integrityCheckValue );
		knownExtensionEncode ( os, e_genericData, m_genericData );
		unknownExtensionsEncode ( os );
	}
}

BandwidthReject :: ~BandwidthReject ( ) {
	delete m_nonStandardData;
	delete m_altGKInfo;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_integrityCheckValue;
	delete m_genericData;
}

void BandwidthReject :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "requestSeqNum = " << std :: setprecision ( indent ) << m_requestSeqNum << '\n';
	os << std :: setw ( indent + 15 ) << "rejectReason = " << std :: setprecision ( indent ) << m_rejectReason << '\n';
	os << std :: setw ( indent + 19 ) << "allowedBandWidth = " << std :: setprecision ( indent ) << m_allowedBandWidth << '\n';
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_altGKInfo ) ) {
		os << std :: setw ( indent + 12 ) << "altGKInfo = " << std :: setprecision ( indent );
		m_altGKInfo -> AltGKInfo :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_integrityCheckValue ) ) {
		os << std :: setw ( indent + 22 ) << "integrityCheckValue = " << std :: setprecision ( indent );
		m_integrityCheckValue -> ICV :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_genericData ) ) {
		os << std :: setw ( indent + 14 ) << "genericData = " << std :: setprecision ( indent );
		m_genericData -> ArrayOf_GenericData :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

BandwidthReject * BandwidthReject :: clone ( ) const {
	return new BandwidthReject ( * this );
}

//
// LocationRejectReason
//

LocationRejectReason :: LocationRejectReason ( Asn :: istream & is ) : Asn :: Choice ( is, 4, true ) {
	switch ( tag ) {
		case e_notRegistered:
		case e_invalidPermission:
		case e_requestDenied:
		case e_undefinedReason:
		case e_securityDenial:
		case e_aliasesInconsistent:
		case e_resourceUnavailable:
		case e_genericDataReason:
		case e_neededFeatureNotSupported:
		case e_hopCountExceeded:
		case e_incompleteAddress:
		case e_securityDHmismatch:
		case e_noRouteToDestination:
		case e_unallocatedNumber:
			choice = new Asn :: Null ( is );
			break;
		case e_routeCalltoSCN:
			choice = new ArrayOf_PartyNumber ( is );
			break;
		case e_securityError:
			choice = new SecurityErrors2 ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

LocationRejectReason :: LocationRejectReason ( ) : Asn :: Choice ( 4, true ) { }

void LocationRejectReason :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_notRegistered:
		case e_invalidPermission:
		case e_requestDenied:
		case e_undefinedReason:
		case e_securityDenial:
		case e_aliasesInconsistent:
		case e_resourceUnavailable:
		case e_genericDataReason:
		case e_neededFeatureNotSupported:
		case e_hopCountExceeded:
		case e_incompleteAddress:
		case e_securityDHmismatch:
		case e_noRouteToDestination:
		case e_unallocatedNumber:
			o = new Asn :: Null;
			break;
		case e_routeCalltoSCN:
			o = new ArrayOf_PartyNumber;
			break;
		case e_securityError:
			o = new SecurityErrors2;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & LocationRejectReason :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_notRegistered, "notRegistered" },
		{ e_invalidPermission, "invalidPermission" },
		{ e_requestDenied, "requestDenied" },
		{ e_undefinedReason, "undefinedReason" },
		{ e_securityDenial, "securityDenial" },
		{ e_aliasesInconsistent, "aliasesInconsistent" },
		{ e_routeCalltoSCN, "routeCalltoSCN" },
		{ e_resourceUnavailable, "resourceUnavailable" },
		{ e_genericDataReason, "genericDataReason" },
		{ e_neededFeatureNotSupported, "neededFeatureNotSupported" },
		{ e_hopCountExceeded, "hopCountExceeded" },
		{ e_incompleteAddress, "incompleteAddress" },
		{ e_securityError, "securityError" },
		{ e_securityDHmismatch, "securityDHmismatch" },
		{ e_noRouteToDestination, "noRouteToDestination" },
		{ e_unallocatedNumber, "unallocatedNumber" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

LocationRejectReason * LocationRejectReason :: clone ( ) const {
	return new LocationRejectReason ( * this );
}

//
// DisengageRequest
//

DisengageRequest :: DisengageRequest ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 13 ), m_requestSeqNum ( is ), m_endpointIdentifier ( is ), m_conferenceID ( is ), m_callReferenceValue ( is ), m_disengageReason ( is ), m_nonStandardData ( 0 ), m_callIdentifier ( 0 ), m_gatekeeperIdentifier ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_answeredCall ( 0 ), m_callLinkage ( 0 ), m_capacity ( 0 ), m_circuitInfo ( 0 ), m_usageInformation ( 0 ), m_terminationCause ( 0 ), m_serviceControl ( 0 ), m_genericData ( 0 ) {
	try {
		if ( hasOptionalField ( e_nonStandardData ) )
			m_nonStandardData = new NonStandardParameter ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_callIdentifier ) )
				m_callIdentifier = new CallIdentifier ( is );
			if ( hasKnownExtensionToDecode ( is, e_gatekeeperIdentifier ) )
				m_gatekeeperIdentifier = new GatekeeperIdentifier ( is );
			if ( hasKnownExtensionToDecode ( is, e_tokens ) )
				m_tokens = new ArrayOf_ClearToken ( is );
			if ( hasKnownExtensionToDecode ( is, e_cryptoTokens ) )
				m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
			if ( hasKnownExtensionToDecode ( is, e_integrityCheckValue ) )
				m_integrityCheckValue = new ICV ( is );
			if ( hasKnownExtensionToDecode ( is, e_answeredCall ) )
				m_answeredCall = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_callLinkage ) )
				m_callLinkage = new CallLinkage ( is );
			if ( hasKnownExtensionToDecode ( is, e_capacity ) )
				m_capacity = new CallCapacity ( is );
			if ( hasKnownExtensionToDecode ( is, e_circuitInfo ) )
				m_circuitInfo = new CircuitInfo ( is );
			if ( hasKnownExtensionToDecode ( is, e_usageInformation ) )
				m_usageInformation = new RasUsageInformation ( is );
			if ( hasKnownExtensionToDecode ( is, e_terminationCause ) )
				m_terminationCause = new CallTerminationCause ( is );
			if ( hasKnownExtensionToDecode ( is, e_serviceControl ) )
				m_serviceControl = new ArrayOf_ServiceControlSession ( is );
			if ( hasKnownExtensionToDecode ( is, e_genericData ) )
				m_genericData = new ArrayOf_GenericData ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_callIdentifier;
		delete m_gatekeeperIdentifier;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_answeredCall;
		delete m_callLinkage;
		delete m_capacity;
		delete m_circuitInfo;
		delete m_usageInformation;
		delete m_terminationCause;
		delete m_serviceControl;
		delete m_genericData;
		throw;
	}
}

DisengageRequest :: DisengageRequest ( ) : Asn :: Sequence ( 1, true, 13 ), m_nonStandardData ( 0 ), m_callIdentifier ( 0 ), m_gatekeeperIdentifier ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_answeredCall ( 0 ), m_callLinkage ( 0 ), m_capacity ( 0 ), m_circuitInfo ( 0 ), m_usageInformation ( 0 ), m_terminationCause ( 0 ), m_serviceControl ( 0 ), m_genericData ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_callIdentifier );
		m_callIdentifier = new CallIdentifier;
		Asn :: Sequence :: includeOptionalField ( e_answeredCall );
		m_answeredCall = new Asn :: Boolean;
	} catch ( ... ) {
		delete m_callIdentifier;
		delete m_answeredCall;
		throw;
	}
}

DisengageRequest & DisengageRequest :: operator= ( const DisengageRequest & s ) {
	Asn :: Sequence :: operator= ( s );
	m_requestSeqNum = s.m_requestSeqNum;
	m_endpointIdentifier = s.m_endpointIdentifier;
	m_conferenceID = s.m_conferenceID;
	m_callReferenceValue = s.m_callReferenceValue;
	m_disengageReason = s.m_disengageReason;
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	assignCopy ( m_callIdentifier, s.m_callIdentifier );
	assignCopy ( m_gatekeeperIdentifier, s.m_gatekeeperIdentifier );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_integrityCheckValue, s.m_integrityCheckValue );
	assignCopy ( m_answeredCall, s.m_answeredCall );
	assignCopy ( m_callLinkage, s.m_callLinkage );
	assignCopy ( m_capacity, s.m_capacity );
	assignCopy ( m_circuitInfo, s.m_circuitInfo );
	assignCopy ( m_usageInformation, s.m_usageInformation );
	assignCopy ( m_terminationCause, s.m_terminationCause );
	assignCopy ( m_serviceControl, s.m_serviceControl );
	assignCopy ( m_genericData, s.m_genericData );
	return * this;
}

DisengageRequest :: DisengageRequest ( const DisengageRequest & s ) : Asn :: Sequence ( s ), m_requestSeqNum ( s.m_requestSeqNum ), m_endpointIdentifier ( s.m_endpointIdentifier ), m_conferenceID ( s.m_conferenceID ), m_callReferenceValue ( s.m_callReferenceValue ), m_disengageReason ( s.m_disengageReason ), m_nonStandardData ( 0 ), m_callIdentifier ( 0 ), m_gatekeeperIdentifier ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_answeredCall ( 0 ), m_callLinkage ( 0 ), m_capacity ( 0 ), m_circuitInfo ( 0 ), m_usageInformation ( 0 ), m_terminationCause ( 0 ), m_serviceControl ( 0 ), m_genericData ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_callIdentifier )
			m_callIdentifier = new CallIdentifier ( * s.m_callIdentifier );
		if ( s.m_gatekeeperIdentifier )
			m_gatekeeperIdentifier = new GatekeeperIdentifier ( * s.m_gatekeeperIdentifier );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_integrityCheckValue )
			m_integrityCheckValue = new ICV ( * s.m_integrityCheckValue );
		if ( s.m_answeredCall )
			m_answeredCall = new Asn :: Boolean ( * s.m_answeredCall );
		if ( s.m_callLinkage )
			m_callLinkage = new CallLinkage ( * s.m_callLinkage );
		if ( s.m_capacity )
			m_capacity = new CallCapacity ( * s.m_capacity );
		if ( s.m_circuitInfo )
			m_circuitInfo = new CircuitInfo ( * s.m_circuitInfo );
		if ( s.m_usageInformation )
			m_usageInformation = new RasUsageInformation ( * s.m_usageInformation );
		if ( s.m_terminationCause )
			m_terminationCause = new CallTerminationCause ( * s.m_terminationCause );
		if ( s.m_serviceControl )
			m_serviceControl = new ArrayOf_ServiceControlSession ( * s.m_serviceControl );
		if ( s.m_genericData )
			m_genericData = new ArrayOf_GenericData ( * s.m_genericData );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_callIdentifier;
		delete m_gatekeeperIdentifier;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_answeredCall;
		delete m_callLinkage;
		delete m_capacity;
		delete m_circuitInfo;
		delete m_usageInformation;
		delete m_terminationCause;
		delete m_serviceControl;
		delete m_genericData;
		throw;
	}
}


void DisengageRequest :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_callIdentifier:
			assignNew ( m_callIdentifier, new CallIdentifier );
			break;
		case e_gatekeeperIdentifier:
			assignNew ( m_gatekeeperIdentifier, new GatekeeperIdentifier );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_integrityCheckValue:
			assignNew ( m_integrityCheckValue, new ICV );
			break;
		case e_answeredCall:
			assignNew ( m_answeredCall, new Asn :: Boolean );
			break;
		case e_callLinkage:
			assignNew ( m_callLinkage, new CallLinkage );
			break;
		case e_capacity:
			assignNew ( m_capacity, new CallCapacity );
			break;
		case e_circuitInfo:
			assignNew ( m_circuitInfo, new CircuitInfo );
			break;
		case e_usageInformation:
			assignNew ( m_usageInformation, new RasUsageInformation );
			break;
		case e_terminationCause:
			assignNew ( m_terminationCause, new CallTerminationCause );
			break;
		case e_serviceControl:
			assignNew ( m_serviceControl, new ArrayOf_ServiceControlSession );
			break;
		case e_genericData:
			assignNew ( m_genericData, new ArrayOf_GenericData );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void DisengageRequest :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_callIdentifier:
			delete m_callIdentifier;
			m_callIdentifier = 0;
			break;
		case e_gatekeeperIdentifier:
			delete m_gatekeeperIdentifier;
			m_gatekeeperIdentifier = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_integrityCheckValue:
			delete m_integrityCheckValue;
			m_integrityCheckValue = 0;
			break;
		case e_answeredCall:
			delete m_answeredCall;
			m_answeredCall = 0;
			break;
		case e_callLinkage:
			delete m_callLinkage;
			m_callLinkage = 0;
			break;
		case e_capacity:
			delete m_capacity;
			m_capacity = 0;
			break;
		case e_circuitInfo:
			delete m_circuitInfo;
			m_circuitInfo = 0;
			break;
		case e_usageInformation:
			delete m_usageInformation;
			m_usageInformation = 0;
			break;
		case e_terminationCause:
			delete m_terminationCause;
			m_terminationCause = 0;
			break;
		case e_serviceControl:
			delete m_serviceControl;
			m_serviceControl = 0;
			break;
		case e_genericData:
			delete m_genericData;
			m_genericData = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void DisengageRequest :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_requestSeqNum.encode ( os );
	m_endpointIdentifier.encode ( os );
	m_conferenceID.encode ( os );
	m_callReferenceValue.encode ( os );
	m_disengageReason.encode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_callIdentifier, m_callIdentifier );
		knownExtensionEncode ( os, e_gatekeeperIdentifier, m_gatekeeperIdentifier );
		knownExtensionEncode ( os, e_tokens, m_tokens );
		knownExtensionEncode ( os, e_cryptoTokens, m_cryptoTokens );
		knownExtensionEncode ( os, e_integrityCheckValue, m_integrityCheckValue );
		knownExtensionEncode ( os, e_answeredCall, m_answeredCall );
		knownExtensionEncode ( os, e_callLinkage, m_callLinkage );
		knownExtensionEncode ( os, e_capacity, m_capacity );
		knownExtensionEncode ( os, e_circuitInfo, m_circuitInfo );
		knownExtensionEncode ( os, e_usageInformation, m_usageInformation );
		knownExtensionEncode ( os, e_terminationCause, m_terminationCause );
		knownExtensionEncode ( os, e_serviceControl, m_serviceControl );
		knownExtensionEncode ( os, e_genericData, m_genericData );
		unknownExtensionsEncode ( os );
	}
}

DisengageRequest :: ~DisengageRequest ( ) {
	delete m_nonStandardData;
	delete m_callIdentifier;
	delete m_gatekeeperIdentifier;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_integrityCheckValue;
	delete m_answeredCall;
	delete m_callLinkage;
	delete m_capacity;
	delete m_circuitInfo;
	delete m_usageInformation;
	delete m_terminationCause;
	delete m_serviceControl;
	delete m_genericData;
}

void DisengageRequest :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "requestSeqNum = " << std :: setprecision ( indent ) << m_requestSeqNum << '\n';
	os << std :: setw ( indent + 21 ) << "endpointIdentifier = " << std :: setprecision ( indent ) << m_endpointIdentifier << '\n';
	os << std :: setw ( indent + 15 ) << "conferenceID = " << std :: setprecision ( indent ) << m_conferenceID << '\n';
	os << std :: setw ( indent + 21 ) << "callReferenceValue = " << std :: setprecision ( indent ) << m_callReferenceValue << '\n';
	os << std :: setw ( indent + 18 ) << "disengageReason = " << std :: setprecision ( indent ) << m_disengageReason << '\n';
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_callIdentifier ) ) {
		os << std :: setw ( indent + 17 ) << "callIdentifier = " << std :: setprecision ( indent );
		m_callIdentifier -> CallIdentifier :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_gatekeeperIdentifier ) ) {
		os << std :: setw ( indent + 23 ) << "gatekeeperIdentifier = " << std :: setprecision ( indent );
		m_gatekeeperIdentifier -> GatekeeperIdentifier :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_integrityCheckValue ) ) {
		os << std :: setw ( indent + 22 ) << "integrityCheckValue = " << std :: setprecision ( indent );
		m_integrityCheckValue -> ICV :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_answeredCall ) ) {
		os << std :: setw ( indent + 15 ) << "answeredCall = " << std :: setprecision ( indent );
		m_answeredCall -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_callLinkage ) ) {
		os << std :: setw ( indent + 14 ) << "callLinkage = " << std :: setprecision ( indent );
		m_callLinkage -> CallLinkage :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_capacity ) ) {
		os << std :: setw ( indent + 11 ) << "capacity = " << std :: setprecision ( indent );
		m_capacity -> CallCapacity :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_circuitInfo ) ) {
		os << std :: setw ( indent + 14 ) << "circuitInfo = " << std :: setprecision ( indent );
		m_circuitInfo -> CircuitInfo :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_usageInformation ) ) {
		os << std :: setw ( indent + 19 ) << "usageInformation = " << std :: setprecision ( indent );
		m_usageInformation -> RasUsageInformation :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_terminationCause ) ) {
		os << std :: setw ( indent + 19 ) << "terminationCause = " << std :: setprecision ( indent );
		m_terminationCause -> CallTerminationCause :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_serviceControl ) ) {
		os << std :: setw ( indent + 17 ) << "serviceControl = " << std :: setprecision ( indent );
		m_serviceControl -> ArrayOf_ServiceControlSession :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_genericData ) ) {
		os << std :: setw ( indent + 14 ) << "genericData = " << std :: setprecision ( indent );
		m_genericData -> ArrayOf_GenericData :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

DisengageRequest * DisengageRequest :: clone ( ) const {
	return new DisengageRequest ( * this );
}

//
// DisengageReject
//

DisengageReject :: DisengageReject ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 5 ), m_requestSeqNum ( is ), m_rejectReason ( is ), m_nonStandardData ( 0 ), m_altGKInfo ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_genericData ( 0 ) {
	try {
		if ( hasOptionalField ( e_nonStandardData ) )
			m_nonStandardData = new NonStandardParameter ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_altGKInfo ) )
				m_altGKInfo = new AltGKInfo ( is );
			if ( hasKnownExtensionToDecode ( is, e_tokens ) )
				m_tokens = new ArrayOf_ClearToken ( is );
			if ( hasKnownExtensionToDecode ( is, e_cryptoTokens ) )
				m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
			if ( hasKnownExtensionToDecode ( is, e_integrityCheckValue ) )
				m_integrityCheckValue = new ICV ( is );
			if ( hasKnownExtensionToDecode ( is, e_genericData ) )
				m_genericData = new ArrayOf_GenericData ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_altGKInfo;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_genericData;
		throw;
	}
}

DisengageReject :: DisengageReject ( ) : Asn :: Sequence ( 1, true, 5 ), m_nonStandardData ( 0 ), m_altGKInfo ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_genericData ( 0 ) { }

DisengageReject & DisengageReject :: operator= ( const DisengageReject & s ) {
	Asn :: Sequence :: operator= ( s );
	m_requestSeqNum = s.m_requestSeqNum;
	m_rejectReason = s.m_rejectReason;
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	assignCopy ( m_altGKInfo, s.m_altGKInfo );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_integrityCheckValue, s.m_integrityCheckValue );
	assignCopy ( m_genericData, s.m_genericData );
	return * this;
}

DisengageReject :: DisengageReject ( const DisengageReject & s ) : Asn :: Sequence ( s ), m_requestSeqNum ( s.m_requestSeqNum ), m_rejectReason ( s.m_rejectReason ), m_nonStandardData ( 0 ), m_altGKInfo ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_genericData ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_altGKInfo )
			m_altGKInfo = new AltGKInfo ( * s.m_altGKInfo );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_integrityCheckValue )
			m_integrityCheckValue = new ICV ( * s.m_integrityCheckValue );
		if ( s.m_genericData )
			m_genericData = new ArrayOf_GenericData ( * s.m_genericData );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_altGKInfo;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_genericData;
		throw;
	}
}


void DisengageReject :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_altGKInfo:
			assignNew ( m_altGKInfo, new AltGKInfo );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_integrityCheckValue:
			assignNew ( m_integrityCheckValue, new ICV );
			break;
		case e_genericData:
			assignNew ( m_genericData, new ArrayOf_GenericData );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void DisengageReject :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_altGKInfo:
			delete m_altGKInfo;
			m_altGKInfo = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_integrityCheckValue:
			delete m_integrityCheckValue;
			m_integrityCheckValue = 0;
			break;
		case e_genericData:
			delete m_genericData;
			m_genericData = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void DisengageReject :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_requestSeqNum.encode ( os );
	m_rejectReason.encode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_altGKInfo, m_altGKInfo );
		knownExtensionEncode ( os, e_tokens, m_tokens );
		knownExtensionEncode ( os, e_cryptoTokens, m_cryptoTokens );
		knownExtensionEncode ( os, e_integrityCheckValue, m_integrityCheckValue );
		knownExtensionEncode ( os, e_genericData, m_genericData );
		unknownExtensionsEncode ( os );
	}
}

DisengageReject :: ~DisengageReject ( ) {
	delete m_nonStandardData;
	delete m_altGKInfo;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_integrityCheckValue;
	delete m_genericData;
}

void DisengageReject :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "requestSeqNum = " << std :: setprecision ( indent ) << m_requestSeqNum << '\n';
	os << std :: setw ( indent + 15 ) << "rejectReason = " << std :: setprecision ( indent ) << m_rejectReason << '\n';
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_altGKInfo ) ) {
		os << std :: setw ( indent + 12 ) << "altGKInfo = " << std :: setprecision ( indent );
		m_altGKInfo -> AltGKInfo :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_integrityCheckValue ) ) {
		os << std :: setw ( indent + 22 ) << "integrityCheckValue = " << std :: setprecision ( indent );
		m_integrityCheckValue -> ICV :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_genericData ) ) {
		os << std :: setw ( indent + 14 ) << "genericData = " << std :: setprecision ( indent );
		m_genericData -> ArrayOf_GenericData :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

DisengageReject * DisengageReject :: clone ( ) const {
	return new DisengageReject ( * this );
}

//
// InfoRequestResponseStatus
//

InfoRequestResponseStatus :: InfoRequestResponseStatus ( Asn :: istream & is ) : Asn :: Choice ( is, 4, true ) {
	switch ( tag ) {
		case e_complete:
		case e_incomplete:
		case e_invalidCall:
			choice = new Asn :: Null ( is );
			break;
		case e_segment:
			choice = new InfoRequestResponseStatus_segment ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

InfoRequestResponseStatus :: InfoRequestResponseStatus ( ) : Asn :: Choice ( 4, true ) { }

void InfoRequestResponseStatus :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_complete:
		case e_incomplete:
		case e_invalidCall:
			o = new Asn :: Null;
			break;
		case e_segment:
			o = new InfoRequestResponseStatus_segment;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & InfoRequestResponseStatus :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_complete, "complete" },
		{ e_incomplete, "incomplete" },
		{ e_segment, "segment" },
		{ e_invalidCall, "invalidCall" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

InfoRequestResponseStatus * InfoRequestResponseStatus :: clone ( ) const {
	return new InfoRequestResponseStatus ( * this );
}

//
// InfoRequestNak
//

InfoRequestNak :: InfoRequestNak ( Asn :: istream & is ) : Asn :: Sequence ( is, 5, true, 0 ), m_requestSeqNum ( is ), m_nonStandardData ( hasOptionalField ( e_nonStandardData ) ? pushTemporaryMember ( new NonStandardParameter ( is ) ) : 0 ), m_nakReason ( is ), m_altGKInfo ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ) {
	clearTemporaryMembers ( );
	try {
		if ( hasOptionalField ( e_altGKInfo ) )
			m_altGKInfo = new AltGKInfo ( is );
		if ( hasOptionalField ( e_tokens ) )
			m_tokens = new ArrayOf_ClearToken ( is );
		if ( hasOptionalField ( e_cryptoTokens ) )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
		if ( hasOptionalField ( e_integrityCheckValue ) )
			m_integrityCheckValue = new ICV ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_altGKInfo;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		throw;
	}
}

InfoRequestNak :: InfoRequestNak ( ) : Asn :: Sequence ( 5, true, 0 ), m_nonStandardData ( 0 ), m_altGKInfo ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ) { }

InfoRequestNak & InfoRequestNak :: operator= ( const InfoRequestNak & s ) {
	Asn :: Sequence :: operator= ( s );
	m_requestSeqNum = s.m_requestSeqNum;
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	m_nakReason = s.m_nakReason;
	assignCopy ( m_altGKInfo, s.m_altGKInfo );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_integrityCheckValue, s.m_integrityCheckValue );
	return * this;
}

InfoRequestNak :: InfoRequestNak ( const InfoRequestNak & s ) : Asn :: Sequence ( s ), m_requestSeqNum ( s.m_requestSeqNum ), m_nonStandardData ( 0 ), m_nakReason ( s.m_nakReason ), m_altGKInfo ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_altGKInfo )
			m_altGKInfo = new AltGKInfo ( * s.m_altGKInfo );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_integrityCheckValue )
			m_integrityCheckValue = new ICV ( * s.m_integrityCheckValue );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_altGKInfo;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		throw;
	}
}


void InfoRequestNak :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_altGKInfo:
			assignNew ( m_altGKInfo, new AltGKInfo );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_integrityCheckValue:
			assignNew ( m_integrityCheckValue, new ICV );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void InfoRequestNak :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_altGKInfo:
			delete m_altGKInfo;
			m_altGKInfo = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_integrityCheckValue:
			delete m_integrityCheckValue;
			m_integrityCheckValue = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void InfoRequestNak :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_requestSeqNum.encode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	m_nakReason.encode ( os );
	if ( hasOptionalField ( e_altGKInfo ) )
		m_altGKInfo -> AltGKInfo :: encode ( os );
	if ( hasOptionalField ( e_tokens ) )
		m_tokens -> ArrayOf_ClearToken :: encode ( os );
	if ( hasOptionalField ( e_cryptoTokens ) )
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: encode ( os );
	if ( hasOptionalField ( e_integrityCheckValue ) )
		m_integrityCheckValue -> ICV :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

InfoRequestNak :: ~InfoRequestNak ( ) {
	delete m_nonStandardData;
	delete m_altGKInfo;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_integrityCheckValue;
}

void InfoRequestNak :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "requestSeqNum = " << std :: setprecision ( indent ) << m_requestSeqNum << '\n';
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 12 ) << "nakReason = " << std :: setprecision ( indent ) << m_nakReason << '\n';
	if ( hasOptionalField ( e_altGKInfo ) ) {
		os << std :: setw ( indent + 12 ) << "altGKInfo = " << std :: setprecision ( indent );
		m_altGKInfo -> AltGKInfo :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_integrityCheckValue ) ) {
		os << std :: setw ( indent + 22 ) << "integrityCheckValue = " << std :: setprecision ( indent );
		m_integrityCheckValue -> ICV :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

InfoRequestNak * InfoRequestNak :: clone ( ) const {
	return new InfoRequestNak ( * this );
}

//
// RequestInProgress
//

RequestInProgress :: RequestInProgress ( Asn :: istream & is ) : Asn :: Sequence ( is, 4, true, 0 ), m_requestSeqNum ( is ), m_nonStandardData ( hasOptionalField ( e_nonStandardData ) ? pushTemporaryMember ( new NonStandardParameter ( is ) ) : 0 ), m_tokens ( hasOptionalField ( e_tokens ) ? pushTemporaryMember ( new ArrayOf_ClearToken ( is ) ) : 0 ), m_cryptoTokens ( hasOptionalField ( e_cryptoTokens ) ? pushTemporaryMember ( new ArrayOf_CryptoH323Token ( is ) ) : 0 ), m_integrityCheckValue ( hasOptionalField ( e_integrityCheckValue ) ? pushTemporaryMember ( new ICV ( is ) ) : 0 ), m_delay ( is ) {
	clearTemporaryMembers ( );
	try {
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		throw;
	}
}

RequestInProgress :: RequestInProgress ( ) : Asn :: Sequence ( 4, true, 0 ), m_nonStandardData ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ) { }

RequestInProgress & RequestInProgress :: operator= ( const RequestInProgress & s ) {
	Asn :: Sequence :: operator= ( s );
	m_requestSeqNum = s.m_requestSeqNum;
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_integrityCheckValue, s.m_integrityCheckValue );
	m_delay = s.m_delay;
	return * this;
}

RequestInProgress :: RequestInProgress ( const RequestInProgress & s ) : Asn :: Sequence ( s ), m_requestSeqNum ( s.m_requestSeqNum ), m_nonStandardData ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_delay ( s.m_delay ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_integrityCheckValue )
			m_integrityCheckValue = new ICV ( * s.m_integrityCheckValue );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		throw;
	}
}


void RequestInProgress :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_integrityCheckValue:
			assignNew ( m_integrityCheckValue, new ICV );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void RequestInProgress :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_integrityCheckValue:
			delete m_integrityCheckValue;
			m_integrityCheckValue = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void RequestInProgress :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_requestSeqNum.encode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( hasOptionalField ( e_tokens ) )
		m_tokens -> ArrayOf_ClearToken :: encode ( os );
	if ( hasOptionalField ( e_cryptoTokens ) )
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: encode ( os );
	if ( hasOptionalField ( e_integrityCheckValue ) )
		m_integrityCheckValue -> ICV :: encode ( os );
	m_delay.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

RequestInProgress :: ~RequestInProgress ( ) {
	delete m_nonStandardData;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_integrityCheckValue;
}

void RequestInProgress :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "requestSeqNum = " << std :: setprecision ( indent ) << m_requestSeqNum << '\n';
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_integrityCheckValue ) ) {
		os << std :: setw ( indent + 22 ) << "integrityCheckValue = " << std :: setprecision ( indent );
		m_integrityCheckValue -> ICV :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 8 ) << "delay = " << std :: setprecision ( indent ) << m_delay << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RequestInProgress * RequestInProgress :: clone ( ) const {
	return new RequestInProgress ( * this );
}

//
// ResourcesAvailableIndicate
//

ResourcesAvailableIndicate :: ResourcesAvailableIndicate ( Asn :: istream & is ) : Asn :: Sequence ( is, 4, true, 2 ), m_requestSeqNum ( is ), m_protocolIdentifier ( is ), m_nonStandardData ( hasOptionalField ( e_nonStandardData ) ? pushTemporaryMember ( new NonStandardParameter ( is ) ) : 0 ), m_endpointIdentifier ( is ), m_protocols ( is ), m_almostOutOfResources ( is ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_capacity ( 0 ), m_genericData ( 0 ) {
	clearTemporaryMembers ( );
	try {
		if ( hasOptionalField ( e_tokens ) )
			m_tokens = new ArrayOf_ClearToken ( is );
		if ( hasOptionalField ( e_cryptoTokens ) )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
		if ( hasOptionalField ( e_integrityCheckValue ) )
			m_integrityCheckValue = new ICV ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_capacity ) )
				m_capacity = new CallCapacity ( is );
			if ( hasKnownExtensionToDecode ( is, e_genericData ) )
				m_genericData = new ArrayOf_GenericData ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_capacity;
		delete m_genericData;
		throw;
	}
}

ResourcesAvailableIndicate :: ResourcesAvailableIndicate ( ) : Asn :: Sequence ( 4, true, 2 ), m_nonStandardData ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_capacity ( 0 ), m_genericData ( 0 ) { }

ResourcesAvailableIndicate & ResourcesAvailableIndicate :: operator= ( const ResourcesAvailableIndicate & s ) {
	Asn :: Sequence :: operator= ( s );
	m_requestSeqNum = s.m_requestSeqNum;
	m_protocolIdentifier = s.m_protocolIdentifier;
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	m_endpointIdentifier = s.m_endpointIdentifier;
	m_protocols = s.m_protocols;
	m_almostOutOfResources = s.m_almostOutOfResources;
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_integrityCheckValue, s.m_integrityCheckValue );
	assignCopy ( m_capacity, s.m_capacity );
	assignCopy ( m_genericData, s.m_genericData );
	return * this;
}

ResourcesAvailableIndicate :: ResourcesAvailableIndicate ( const ResourcesAvailableIndicate & s ) : Asn :: Sequence ( s ), m_requestSeqNum ( s.m_requestSeqNum ), m_protocolIdentifier ( s.m_protocolIdentifier ), m_nonStandardData ( 0 ), m_endpointIdentifier ( s.m_endpointIdentifier ), m_protocols ( s.m_protocols ), m_almostOutOfResources ( s.m_almostOutOfResources ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_capacity ( 0 ), m_genericData ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_integrityCheckValue )
			m_integrityCheckValue = new ICV ( * s.m_integrityCheckValue );
		if ( s.m_capacity )
			m_capacity = new CallCapacity ( * s.m_capacity );
		if ( s.m_genericData )
			m_genericData = new ArrayOf_GenericData ( * s.m_genericData );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_capacity;
		delete m_genericData;
		throw;
	}
}


void ResourcesAvailableIndicate :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_integrityCheckValue:
			assignNew ( m_integrityCheckValue, new ICV );
			break;
		case e_capacity:
			assignNew ( m_capacity, new CallCapacity );
			break;
		case e_genericData:
			assignNew ( m_genericData, new ArrayOf_GenericData );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void ResourcesAvailableIndicate :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_integrityCheckValue:
			delete m_integrityCheckValue;
			m_integrityCheckValue = 0;
			break;
		case e_capacity:
			delete m_capacity;
			m_capacity = 0;
			break;
		case e_genericData:
			delete m_genericData;
			m_genericData = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void ResourcesAvailableIndicate :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_requestSeqNum.encode ( os );
	m_protocolIdentifier.encode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	m_endpointIdentifier.encode ( os );
	m_protocols.encode ( os );
	m_almostOutOfResources.encode ( os );
	if ( hasOptionalField ( e_tokens ) )
		m_tokens -> ArrayOf_ClearToken :: encode ( os );
	if ( hasOptionalField ( e_cryptoTokens ) )
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: encode ( os );
	if ( hasOptionalField ( e_integrityCheckValue ) )
		m_integrityCheckValue -> ICV :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_capacity, m_capacity );
		knownExtensionEncode ( os, e_genericData, m_genericData );
		unknownExtensionsEncode ( os );
	}
}

ResourcesAvailableIndicate :: ~ResourcesAvailableIndicate ( ) {
	delete m_nonStandardData;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_integrityCheckValue;
	delete m_capacity;
	delete m_genericData;
}

void ResourcesAvailableIndicate :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "requestSeqNum = " << std :: setprecision ( indent ) << m_requestSeqNum << '\n';
	os << std :: setw ( indent + 21 ) << "protocolIdentifier = " << std :: setprecision ( indent ) << m_protocolIdentifier << '\n';
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 21 ) << "endpointIdentifier = " << std :: setprecision ( indent ) << m_endpointIdentifier << '\n';
	os << std :: setw ( indent + 12 ) << "protocols = " << std :: setprecision ( indent ) << m_protocols << '\n';
	os << std :: setw ( indent + 23 ) << "almostOutOfResources = " << std :: setprecision ( indent ) << m_almostOutOfResources << '\n';
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_integrityCheckValue ) ) {
		os << std :: setw ( indent + 22 ) << "integrityCheckValue = " << std :: setprecision ( indent );
		m_integrityCheckValue -> ICV :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_capacity ) ) {
		os << std :: setw ( indent + 11 ) << "capacity = " << std :: setprecision ( indent );
		m_capacity -> CallCapacity :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_genericData ) ) {
		os << std :: setw ( indent + 14 ) << "genericData = " << std :: setprecision ( indent );
		m_genericData -> ArrayOf_GenericData :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

ResourcesAvailableIndicate * ResourcesAvailableIndicate :: clone ( ) const {
	return new ResourcesAvailableIndicate ( * this );
}

//
// ServiceControlIndication
//

ServiceControlIndication :: ServiceControlIndication ( Asn :: istream & is ) : Asn :: Sequence ( is, 8, true, 0 ), m_requestSeqNum ( is ), m_nonStandardData ( hasOptionalField ( e_nonStandardData ) ? pushTemporaryMember ( new NonStandardParameter ( is ) ) : 0 ), m_serviceControl ( is ), m_endpointIdentifier ( 0 ), m_callSpecific ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ) {
	clearTemporaryMembers ( );
	try {
		if ( hasOptionalField ( e_endpointIdentifier ) )
			m_endpointIdentifier = new EndpointIdentifier ( is );
		if ( hasOptionalField ( e_callSpecific ) )
			m_callSpecific = new ServiceControlIndication_callSpecific ( is );
		if ( hasOptionalField ( e_tokens ) )
			m_tokens = new ArrayOf_ClearToken ( is );
		if ( hasOptionalField ( e_cryptoTokens ) )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
		if ( hasOptionalField ( e_integrityCheckValue ) )
			m_integrityCheckValue = new ICV ( is );
		if ( hasOptionalField ( e_featureSet ) )
			m_featureSet = new FeatureSet ( is );
		if ( hasOptionalField ( e_genericData ) )
			m_genericData = new ArrayOf_GenericData ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_endpointIdentifier;
		delete m_callSpecific;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_featureSet;
		delete m_genericData;
		throw;
	}
}

ServiceControlIndication :: ServiceControlIndication ( ) : Asn :: Sequence ( 8, true, 0 ), m_nonStandardData ( 0 ), m_endpointIdentifier ( 0 ), m_callSpecific ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ) { }

ServiceControlIndication & ServiceControlIndication :: operator= ( const ServiceControlIndication & s ) {
	Asn :: Sequence :: operator= ( s );
	m_requestSeqNum = s.m_requestSeqNum;
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	m_serviceControl = s.m_serviceControl;
	assignCopy ( m_endpointIdentifier, s.m_endpointIdentifier );
	assignCopy ( m_callSpecific, s.m_callSpecific );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_integrityCheckValue, s.m_integrityCheckValue );
	assignCopy ( m_featureSet, s.m_featureSet );
	assignCopy ( m_genericData, s.m_genericData );
	return * this;
}

ServiceControlIndication :: ServiceControlIndication ( const ServiceControlIndication & s ) : Asn :: Sequence ( s ), m_requestSeqNum ( s.m_requestSeqNum ), m_nonStandardData ( 0 ), m_serviceControl ( s.m_serviceControl ), m_endpointIdentifier ( 0 ), m_callSpecific ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_endpointIdentifier )
			m_endpointIdentifier = new EndpointIdentifier ( * s.m_endpointIdentifier );
		if ( s.m_callSpecific )
			m_callSpecific = new ServiceControlIndication_callSpecific ( * s.m_callSpecific );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_integrityCheckValue )
			m_integrityCheckValue = new ICV ( * s.m_integrityCheckValue );
		if ( s.m_featureSet )
			m_featureSet = new FeatureSet ( * s.m_featureSet );
		if ( s.m_genericData )
			m_genericData = new ArrayOf_GenericData ( * s.m_genericData );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_endpointIdentifier;
		delete m_callSpecific;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_featureSet;
		delete m_genericData;
		throw;
	}
}


void ServiceControlIndication :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_endpointIdentifier:
			assignNew ( m_endpointIdentifier, new EndpointIdentifier );
			break;
		case e_callSpecific:
			assignNew ( m_callSpecific, new ServiceControlIndication_callSpecific );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_integrityCheckValue:
			assignNew ( m_integrityCheckValue, new ICV );
			break;
		case e_featureSet:
			assignNew ( m_featureSet, new FeatureSet );
			break;
		case e_genericData:
			assignNew ( m_genericData, new ArrayOf_GenericData );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void ServiceControlIndication :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_endpointIdentifier:
			delete m_endpointIdentifier;
			m_endpointIdentifier = 0;
			break;
		case e_callSpecific:
			delete m_callSpecific;
			m_callSpecific = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_integrityCheckValue:
			delete m_integrityCheckValue;
			m_integrityCheckValue = 0;
			break;
		case e_featureSet:
			delete m_featureSet;
			m_featureSet = 0;
			break;
		case e_genericData:
			delete m_genericData;
			m_genericData = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void ServiceControlIndication :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_requestSeqNum.encode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	m_serviceControl.encode ( os );
	if ( hasOptionalField ( e_endpointIdentifier ) )
		m_endpointIdentifier -> EndpointIdentifier :: encode ( os );
	if ( hasOptionalField ( e_callSpecific ) )
		m_callSpecific -> ServiceControlIndication_callSpecific :: encode ( os );
	if ( hasOptionalField ( e_tokens ) )
		m_tokens -> ArrayOf_ClearToken :: encode ( os );
	if ( hasOptionalField ( e_cryptoTokens ) )
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: encode ( os );
	if ( hasOptionalField ( e_integrityCheckValue ) )
		m_integrityCheckValue -> ICV :: encode ( os );
	if ( hasOptionalField ( e_featureSet ) )
		m_featureSet -> FeatureSet :: encode ( os );
	if ( hasOptionalField ( e_genericData ) )
		m_genericData -> ArrayOf_GenericData :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

ServiceControlIndication :: ~ServiceControlIndication ( ) {
	delete m_nonStandardData;
	delete m_endpointIdentifier;
	delete m_callSpecific;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_integrityCheckValue;
	delete m_featureSet;
	delete m_genericData;
}

void ServiceControlIndication :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "requestSeqNum = " << std :: setprecision ( indent ) << m_requestSeqNum << '\n';
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 17 ) << "serviceControl = " << std :: setprecision ( indent ) << m_serviceControl << '\n';
	if ( hasOptionalField ( e_endpointIdentifier ) ) {
		os << std :: setw ( indent + 21 ) << "endpointIdentifier = " << std :: setprecision ( indent );
		m_endpointIdentifier -> EndpointIdentifier :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_callSpecific ) ) {
		os << std :: setw ( indent + 15 ) << "callSpecific = " << std :: setprecision ( indent );
		m_callSpecific -> ServiceControlIndication_callSpecific :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_integrityCheckValue ) ) {
		os << std :: setw ( indent + 22 ) << "integrityCheckValue = " << std :: setprecision ( indent );
		m_integrityCheckValue -> ICV :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_featureSet ) ) {
		os << std :: setw ( indent + 13 ) << "featureSet = " << std :: setprecision ( indent );
		m_featureSet -> FeatureSet :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_genericData ) ) {
		os << std :: setw ( indent + 14 ) << "genericData = " << std :: setprecision ( indent );
		m_genericData -> ArrayOf_GenericData :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

ServiceControlIndication * ServiceControlIndication :: clone ( ) const {
	return new ServiceControlIndication ( * this );
}

//
// H323-UserInformation_user-data
//

H323_UserInformation_user_data :: H323_UserInformation_user_data ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_protocol_discriminator ( is ), m_user_information ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

H323_UserInformation_user_data :: H323_UserInformation_user_data ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void H323_UserInformation_user_data :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_protocol_discriminator.encode ( os );
	m_user_information.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void H323_UserInformation_user_data :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 25 ) << "protocol_discriminator = " << std :: setprecision ( indent ) << m_protocol_discriminator << '\n';
	os << std :: setw ( indent + 19 ) << "user_information = " << std :: setprecision ( indent ) << m_user_information << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H323_UserInformation_user_data * H323_UserInformation_user_data :: clone ( ) const {
	return new H323_UserInformation_user_data ( * this );
}

//
// H323-UU-PDU_h323-message-body
//

H323_UU_PDU_h323_message_body :: H323_UU_PDU_h323_message_body ( Asn :: istream & is ) : Asn :: Choice ( is, 7, true ) {
	switch ( tag ) {
		case e_setup:
			choice = new Setup_UUIE ( is );
			break;
		case e_callProceeding:
			choice = new CallProceeding_UUIE ( is );
			break;
		case e_connect:
			choice = new Connect_UUIE ( is );
			break;
		case e_alerting:
			choice = new Alerting_UUIE ( is );
			break;
		case e_information:
			choice = new Information_UUIE ( is );
			break;
		case e_releaseComplete:
			choice = new ReleaseComplete_UUIE ( is );
			break;
		case e_facility:
			choice = new Facility_UUIE ( is );
			break;
		case e_progress:
			choice = new Progress_UUIE ( is );
			break;
		case e_empty:
			choice = new Asn :: Null ( is );
			break;
		case e_status:
			choice = new Status_UUIE ( is );
			break;
		case e_statusInquiry:
			choice = new StatusInquiry_UUIE ( is );
			break;
		case e_setupAcknowledge:
			choice = new SetupAcknowledge_UUIE ( is );
			break;
		case e_notify:
			choice = new Notify_UUIE ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

H323_UU_PDU_h323_message_body :: H323_UU_PDU_h323_message_body ( ) : Asn :: Choice ( 7, true ) { }

void H323_UU_PDU_h323_message_body :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_setup:
			o = new Setup_UUIE;
			break;
		case e_callProceeding:
			o = new CallProceeding_UUIE;
			break;
		case e_connect:
			o = new Connect_UUIE;
			break;
		case e_alerting:
			o = new Alerting_UUIE;
			break;
		case e_information:
			o = new Information_UUIE;
			break;
		case e_releaseComplete:
			o = new ReleaseComplete_UUIE;
			break;
		case e_facility:
			o = new Facility_UUIE;
			break;
		case e_progress:
			o = new Progress_UUIE;
			break;
		case e_empty:
			o = new Asn :: Null;
			break;
		case e_status:
			o = new Status_UUIE;
			break;
		case e_statusInquiry:
			o = new StatusInquiry_UUIE;
			break;
		case e_setupAcknowledge:
			o = new SetupAcknowledge_UUIE;
			break;
		case e_notify:
			o = new Notify_UUIE;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & H323_UU_PDU_h323_message_body :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_setup, "setup" },
		{ e_callProceeding, "callProceeding" },
		{ e_connect, "connect" },
		{ e_alerting, "alerting" },
		{ e_information, "information" },
		{ e_releaseComplete, "releaseComplete" },
		{ e_facility, "facility" },
		{ e_progress, "progress" },
		{ e_empty, "empty" },
		{ e_status, "status" },
		{ e_statusInquiry, "statusInquiry" },
		{ e_setupAcknowledge, "setupAcknowledge" },
		{ e_notify, "notify" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

H323_UU_PDU_h323_message_body * H323_UU_PDU_h323_message_body :: clone ( ) const {
	return new H323_UU_PDU_h323_message_body ( * this );
}

//
// Setup-UUIE_connectionParameters
//

Setup_UUIE_connectionParameters :: Setup_UUIE_connectionParameters ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_connectionType ( is ), m_numberOfScnConnections ( is ), m_connectionAggregation ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

Setup_UUIE_connectionParameters :: Setup_UUIE_connectionParameters ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void Setup_UUIE_connectionParameters :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_connectionType.encode ( os );
	m_numberOfScnConnections.encode ( os );
	m_connectionAggregation.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void Setup_UUIE_connectionParameters :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 17 ) << "connectionType = " << std :: setprecision ( indent ) << m_connectionType << '\n';
	os << std :: setw ( indent + 25 ) << "numberOfScnConnections = " << std :: setprecision ( indent ) << m_numberOfScnConnections << '\n';
	os << std :: setw ( indent + 24 ) << "connectionAggregation = " << std :: setprecision ( indent ) << m_connectionAggregation << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

Setup_UUIE_connectionParameters * Setup_UUIE_connectionParameters :: clone ( ) const {
	return new Setup_UUIE_connectionParameters ( * this );
}

//
// TransportAddress_ipAddress
//

TransportAddress_ipAddress :: TransportAddress_ipAddress ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, false, 0 ), m_ip ( is ), m_port ( is ) {
}

TransportAddress_ipAddress :: TransportAddress_ipAddress ( ) : Asn :: Sequence ( 0, false, 0 ) { }

void TransportAddress_ipAddress :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_ip.encode ( os );
	m_port.encode ( os );
}

void TransportAddress_ipAddress :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 5 ) << "ip = " << std :: setprecision ( indent ) << m_ip << '\n';
	os << std :: setw ( indent + 7 ) << "port = " << std :: setprecision ( indent ) << m_port << '\n';
	os << std :: setw ( indent - 1 ) << '}';
}

TransportAddress_ipAddress * TransportAddress_ipAddress :: clone ( ) const {
	return new TransportAddress_ipAddress ( * this );
}

//
// TransportAddress_ipSourceRoute
//

TransportAddress_ipSourceRoute :: TransportAddress_ipSourceRoute ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_ip ( is ), m_port ( is ), m_route ( is ), m_routing ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

TransportAddress_ipSourceRoute :: TransportAddress_ipSourceRoute ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void TransportAddress_ipSourceRoute :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_ip.encode ( os );
	m_port.encode ( os );
	m_route.encode ( os );
	m_routing.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void TransportAddress_ipSourceRoute :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 5 ) << "ip = " << std :: setprecision ( indent ) << m_ip << '\n';
	os << std :: setw ( indent + 7 ) << "port = " << std :: setprecision ( indent ) << m_port << '\n';
	os << std :: setw ( indent + 8 ) << "route = " << std :: setprecision ( indent ) << m_route << '\n';
	os << std :: setw ( indent + 10 ) << "routing = " << std :: setprecision ( indent ) << m_routing << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

TransportAddress_ipSourceRoute * TransportAddress_ipSourceRoute :: clone ( ) const {
	return new TransportAddress_ipSourceRoute ( * this );
}

//
// TransportAddress_ipxAddress
//

TransportAddress_ipxAddress :: TransportAddress_ipxAddress ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, false, 0 ), m_node ( is ), m_netnum ( is ), m_port ( is ) {
}

TransportAddress_ipxAddress :: TransportAddress_ipxAddress ( ) : Asn :: Sequence ( 0, false, 0 ) { }

void TransportAddress_ipxAddress :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_node.encode ( os );
	m_netnum.encode ( os );
	m_port.encode ( os );
}

void TransportAddress_ipxAddress :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 7 ) << "node = " << std :: setprecision ( indent ) << m_node << '\n';
	os << std :: setw ( indent + 9 ) << "netnum = " << std :: setprecision ( indent ) << m_netnum << '\n';
	os << std :: setw ( indent + 7 ) << "port = " << std :: setprecision ( indent ) << m_port << '\n';
	os << std :: setw ( indent - 1 ) << '}';
}

TransportAddress_ipxAddress * TransportAddress_ipxAddress :: clone ( ) const {
	return new TransportAddress_ipxAddress ( * this );
}

//
// TransportAddress_ip6Address
//

TransportAddress_ip6Address :: TransportAddress_ip6Address ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_ip ( is ), m_port ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

TransportAddress_ip6Address :: TransportAddress_ip6Address ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void TransportAddress_ip6Address :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_ip.encode ( os );
	m_port.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void TransportAddress_ip6Address :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 5 ) << "ip = " << std :: setprecision ( indent ) << m_ip << '\n';
	os << std :: setw ( indent + 7 ) << "port = " << std :: setprecision ( indent ) << m_port << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

TransportAddress_ip6Address * TransportAddress_ip6Address :: clone ( ) const {
	return new TransportAddress_ip6Address ( * this );
}

//
// TunnelledProtocol_id
//

TunnelledProtocol_id :: TunnelledProtocol_id ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_tunnelledProtocolObjectID:
			choice = new Asn :: ObjectId ( is );
			break;
		case e_tunnelledProtocolAlternateID:
			choice = new TunnelledProtocolAlternateIdentifier ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

TunnelledProtocol_id :: TunnelledProtocol_id ( ) : Asn :: Choice ( 2, true ) { }

void TunnelledProtocol_id :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_tunnelledProtocolObjectID:
			o = new Asn :: ObjectId;
			break;
		case e_tunnelledProtocolAlternateID:
			o = new TunnelledProtocolAlternateIdentifier;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & TunnelledProtocol_id :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_tunnelledProtocolObjectID, "tunnelledProtocolObjectID" },
		{ e_tunnelledProtocolAlternateID, "tunnelledProtocolAlternateID" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

TunnelledProtocol_id * TunnelledProtocol_id :: clone ( ) const {
	return new TunnelledProtocol_id ( * this );
}

//
// ANSI-41-UIM_system-id
//

ANSI_41_UIM_system_id :: ANSI_41_UIM_system_id ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_sid:
			choice = new ANSI_41_UIM_system_id_sid ( is );
			break;
		case e_mid:
			choice = new ANSI_41_UIM_system_id_mid ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

ANSI_41_UIM_system_id :: ANSI_41_UIM_system_id ( ) : Asn :: Choice ( 2, true ) { }

void ANSI_41_UIM_system_id :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_sid:
			o = new ANSI_41_UIM_system_id_sid;
			break;
		case e_mid:
			o = new ANSI_41_UIM_system_id_mid;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & ANSI_41_UIM_system_id :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_sid, "sid" },
		{ e_mid, "mid" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

ANSI_41_UIM_system_id * ANSI_41_UIM_system_id :: clone ( ) const {
	return new ANSI_41_UIM_system_id ( * this );
}

//
// H323-UU-PDU
//

H323_UU_PDU :: H323_UU_PDU ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 9 ), m_h323_message_body ( is ), m_nonStandardData ( 0 ), m_h4501SupplementaryService ( 0 ), m_h245Tunneling ( 0 ), m_h245Control ( 0 ), m_nonStandardControl ( 0 ), m_callLinkage ( 0 ), m_tunnelledSignallingMessage ( 0 ), m_provisionalRespToH245Tunneling ( 0 ), m_stimulusControl ( 0 ), m_genericData ( 0 ) {
	try {
		if ( hasOptionalField ( e_nonStandardData ) )
			m_nonStandardData = new NonStandardParameter ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_h4501SupplementaryService ) )
				m_h4501SupplementaryService = new ArrayOf_Asn_OctetString ( is );
			if ( hasKnownExtensionToDecode ( is, e_h245Tunneling ) )
				m_h245Tunneling = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_h245Control ) )
				m_h245Control = new ArrayOf_Asn_OctetString ( is );
			if ( hasKnownExtensionToDecode ( is, e_nonStandardControl ) )
				m_nonStandardControl = new ArrayOf_NonStandardParameter ( is );
			if ( hasKnownExtensionToDecode ( is, e_callLinkage ) )
				m_callLinkage = new CallLinkage ( is );
			if ( hasKnownExtensionToDecode ( is, e_tunnelledSignallingMessage ) )
				m_tunnelledSignallingMessage = new H323_UU_PDU_tunnelledSignallingMessage ( is );
			if ( hasKnownExtensionToDecode ( is, e_provisionalRespToH245Tunneling ) )
				m_provisionalRespToH245Tunneling = new Asn :: Null ( is );
			if ( hasKnownExtensionToDecode ( is, e_stimulusControl ) )
				m_stimulusControl = new StimulusControl ( is );
			if ( hasKnownExtensionToDecode ( is, e_genericData ) )
				m_genericData = new ArrayOf_GenericData ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_h4501SupplementaryService;
		delete m_h245Tunneling;
		delete m_h245Control;
		delete m_nonStandardControl;
		delete m_callLinkage;
		delete m_tunnelledSignallingMessage;
		delete m_provisionalRespToH245Tunneling;
		delete m_stimulusControl;
		delete m_genericData;
		throw;
	}
}

H323_UU_PDU :: H323_UU_PDU ( ) : Asn :: Sequence ( 1, true, 9 ), m_nonStandardData ( 0 ), m_h4501SupplementaryService ( 0 ), m_h245Tunneling ( 0 ), m_h245Control ( 0 ), m_nonStandardControl ( 0 ), m_callLinkage ( 0 ), m_tunnelledSignallingMessage ( 0 ), m_provisionalRespToH245Tunneling ( 0 ), m_stimulusControl ( 0 ), m_genericData ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_h245Tunneling );
		m_h245Tunneling = new Asn :: Boolean;
	} catch ( ... ) {
		delete m_h245Tunneling;
		throw;
	}
}

H323_UU_PDU & H323_UU_PDU :: operator= ( const H323_UU_PDU & s ) {
	Asn :: Sequence :: operator= ( s );
	m_h323_message_body = s.m_h323_message_body;
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	assignCopy ( m_h4501SupplementaryService, s.m_h4501SupplementaryService );
	assignCopy ( m_h245Tunneling, s.m_h245Tunneling );
	assignCopy ( m_h245Control, s.m_h245Control );
	assignCopy ( m_nonStandardControl, s.m_nonStandardControl );
	assignCopy ( m_callLinkage, s.m_callLinkage );
	assignCopy ( m_tunnelledSignallingMessage, s.m_tunnelledSignallingMessage );
	assignCopy ( m_provisionalRespToH245Tunneling, s.m_provisionalRespToH245Tunneling );
	assignCopy ( m_stimulusControl, s.m_stimulusControl );
	assignCopy ( m_genericData, s.m_genericData );
	return * this;
}

H323_UU_PDU :: H323_UU_PDU ( const H323_UU_PDU & s ) : Asn :: Sequence ( s ), m_h323_message_body ( s.m_h323_message_body ), m_nonStandardData ( 0 ), m_h4501SupplementaryService ( 0 ), m_h245Tunneling ( 0 ), m_h245Control ( 0 ), m_nonStandardControl ( 0 ), m_callLinkage ( 0 ), m_tunnelledSignallingMessage ( 0 ), m_provisionalRespToH245Tunneling ( 0 ), m_stimulusControl ( 0 ), m_genericData ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_h4501SupplementaryService )
			m_h4501SupplementaryService = new ArrayOf_Asn_OctetString ( * s.m_h4501SupplementaryService );
		if ( s.m_h245Tunneling )
			m_h245Tunneling = new Asn :: Boolean ( * s.m_h245Tunneling );
		if ( s.m_h245Control )
			m_h245Control = new ArrayOf_Asn_OctetString ( * s.m_h245Control );
		if ( s.m_nonStandardControl )
			m_nonStandardControl = new ArrayOf_NonStandardParameter ( * s.m_nonStandardControl );
		if ( s.m_callLinkage )
			m_callLinkage = new CallLinkage ( * s.m_callLinkage );
		if ( s.m_tunnelledSignallingMessage )
			m_tunnelledSignallingMessage = new H323_UU_PDU_tunnelledSignallingMessage ( * s.m_tunnelledSignallingMessage );
		if ( s.m_provisionalRespToH245Tunneling )
			m_provisionalRespToH245Tunneling = new Asn :: Null ( * s.m_provisionalRespToH245Tunneling );
		if ( s.m_stimulusControl )
			m_stimulusControl = new StimulusControl ( * s.m_stimulusControl );
		if ( s.m_genericData )
			m_genericData = new ArrayOf_GenericData ( * s.m_genericData );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_h4501SupplementaryService;
		delete m_h245Tunneling;
		delete m_h245Control;
		delete m_nonStandardControl;
		delete m_callLinkage;
		delete m_tunnelledSignallingMessage;
		delete m_provisionalRespToH245Tunneling;
		delete m_stimulusControl;
		delete m_genericData;
		throw;
	}
}


void H323_UU_PDU :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_h4501SupplementaryService:
			assignNew ( m_h4501SupplementaryService, new ArrayOf_Asn_OctetString );
			break;
		case e_h245Tunneling:
			assignNew ( m_h245Tunneling, new Asn :: Boolean );
			break;
		case e_h245Control:
			assignNew ( m_h245Control, new ArrayOf_Asn_OctetString );
			break;
		case e_nonStandardControl:
			assignNew ( m_nonStandardControl, new ArrayOf_NonStandardParameter );
			break;
		case e_callLinkage:
			assignNew ( m_callLinkage, new CallLinkage );
			break;
		case e_tunnelledSignallingMessage:
			assignNew ( m_tunnelledSignallingMessage, new H323_UU_PDU_tunnelledSignallingMessage );
			break;
		case e_provisionalRespToH245Tunneling:
			assignNew ( m_provisionalRespToH245Tunneling, new Asn :: Null );
			break;
		case e_stimulusControl:
			assignNew ( m_stimulusControl, new StimulusControl );
			break;
		case e_genericData:
			assignNew ( m_genericData, new ArrayOf_GenericData );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void H323_UU_PDU :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_h4501SupplementaryService:
			delete m_h4501SupplementaryService;
			m_h4501SupplementaryService = 0;
			break;
		case e_h245Tunneling:
			delete m_h245Tunneling;
			m_h245Tunneling = 0;
			break;
		case e_h245Control:
			delete m_h245Control;
			m_h245Control = 0;
			break;
		case e_nonStandardControl:
			delete m_nonStandardControl;
			m_nonStandardControl = 0;
			break;
		case e_callLinkage:
			delete m_callLinkage;
			m_callLinkage = 0;
			break;
		case e_tunnelledSignallingMessage:
			delete m_tunnelledSignallingMessage;
			m_tunnelledSignallingMessage = 0;
			break;
		case e_provisionalRespToH245Tunneling:
			delete m_provisionalRespToH245Tunneling;
			m_provisionalRespToH245Tunneling = 0;
			break;
		case e_stimulusControl:
			delete m_stimulusControl;
			m_stimulusControl = 0;
			break;
		case e_genericData:
			delete m_genericData;
			m_genericData = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void H323_UU_PDU :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_h323_message_body.encode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_h4501SupplementaryService, m_h4501SupplementaryService );
		knownExtensionEncode ( os, e_h245Tunneling, m_h245Tunneling );
		knownExtensionEncode ( os, e_h245Control, m_h245Control );
		knownExtensionEncode ( os, e_nonStandardControl, m_nonStandardControl );
		knownExtensionEncode ( os, e_callLinkage, m_callLinkage );
		knownExtensionEncode ( os, e_tunnelledSignallingMessage, m_tunnelledSignallingMessage );
		knownExtensionEncode ( os, e_provisionalRespToH245Tunneling, m_provisionalRespToH245Tunneling );
		knownExtensionEncode ( os, e_stimulusControl, m_stimulusControl );
		knownExtensionEncode ( os, e_genericData, m_genericData );
		unknownExtensionsEncode ( os );
	}
}

H323_UU_PDU :: ~H323_UU_PDU ( ) {
	delete m_nonStandardData;
	delete m_h4501SupplementaryService;
	delete m_h245Tunneling;
	delete m_h245Control;
	delete m_nonStandardControl;
	delete m_callLinkage;
	delete m_tunnelledSignallingMessage;
	delete m_provisionalRespToH245Tunneling;
	delete m_stimulusControl;
	delete m_genericData;
}

void H323_UU_PDU :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 20 ) << "h323_message_body = " << std :: setprecision ( indent ) << m_h323_message_body << '\n';
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_h4501SupplementaryService ) ) {
		os << std :: setw ( indent + 28 ) << "h4501SupplementaryService = " << std :: setprecision ( indent );
		m_h4501SupplementaryService -> ArrayOf_Asn_OctetString :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_h245Tunneling ) ) {
		os << std :: setw ( indent + 16 ) << "h245Tunneling = " << std :: setprecision ( indent );
		m_h245Tunneling -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_h245Control ) ) {
		os << std :: setw ( indent + 14 ) << "h245Control = " << std :: setprecision ( indent );
		m_h245Control -> ArrayOf_Asn_OctetString :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_nonStandardControl ) ) {
		os << std :: setw ( indent + 21 ) << "nonStandardControl = " << std :: setprecision ( indent );
		m_nonStandardControl -> ArrayOf_NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_callLinkage ) ) {
		os << std :: setw ( indent + 14 ) << "callLinkage = " << std :: setprecision ( indent );
		m_callLinkage -> CallLinkage :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tunnelledSignallingMessage ) ) {
		os << std :: setw ( indent + 29 ) << "tunnelledSignallingMessage = " << std :: setprecision ( indent );
		m_tunnelledSignallingMessage -> H323_UU_PDU_tunnelledSignallingMessage :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_provisionalRespToH245Tunneling ) ) {
		os << std :: setw ( indent + 33 ) << "provisionalRespToH245Tunneling = " << std :: setprecision ( indent );
		m_provisionalRespToH245Tunneling -> Asn :: Null :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_stimulusControl ) ) {
		os << std :: setw ( indent + 18 ) << "stimulusControl = " << std :: setprecision ( indent );
		m_stimulusControl -> StimulusControl :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_genericData ) ) {
		os << std :: setw ( indent + 14 ) << "genericData = " << std :: setprecision ( indent );
		m_genericData -> ArrayOf_GenericData :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H323_UU_PDU * H323_UU_PDU :: clone ( ) const {
	return new H323_UU_PDU ( * this );
}

//
// VendorIdentifier
//

VendorIdentifier :: VendorIdentifier ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 1 ), m_vendor ( is ), m_productId ( 0 ), m_versionId ( 0 ), m_enterpriseNumber ( 0 ) {
	try {
		if ( hasOptionalField ( e_productId ) )
			m_productId = new VendorIdentifier_productId ( is );
		if ( hasOptionalField ( e_versionId ) )
			m_versionId = new VendorIdentifier_versionId ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_enterpriseNumber ) )
				m_enterpriseNumber = new Asn :: ObjectId ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_productId;
		delete m_versionId;
		delete m_enterpriseNumber;
		throw;
	}
}

VendorIdentifier :: VendorIdentifier ( ) : Asn :: Sequence ( 2, true, 1 ), m_productId ( 0 ), m_versionId ( 0 ), m_enterpriseNumber ( 0 ) { }

VendorIdentifier & VendorIdentifier :: operator= ( const VendorIdentifier & s ) {
	Asn :: Sequence :: operator= ( s );
	m_vendor = s.m_vendor;
	assignCopy ( m_productId, s.m_productId );
	assignCopy ( m_versionId, s.m_versionId );
	assignCopy ( m_enterpriseNumber, s.m_enterpriseNumber );
	return * this;
}

VendorIdentifier :: VendorIdentifier ( const VendorIdentifier & s ) : Asn :: Sequence ( s ), m_vendor ( s.m_vendor ), m_productId ( 0 ), m_versionId ( 0 ), m_enterpriseNumber ( 0 ) {
	try {
		if ( s.m_productId )
			m_productId = new VendorIdentifier_productId ( * s.m_productId );
		if ( s.m_versionId )
			m_versionId = new VendorIdentifier_versionId ( * s.m_versionId );
		if ( s.m_enterpriseNumber )
			m_enterpriseNumber = new Asn :: ObjectId ( * s.m_enterpriseNumber );
	} catch ( ... ) {
		delete m_productId;
		delete m_versionId;
		delete m_enterpriseNumber;
		throw;
	}
}


void VendorIdentifier :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_productId:
			assignNew ( m_productId, new VendorIdentifier_productId );
			break;
		case e_versionId:
			assignNew ( m_versionId, new VendorIdentifier_versionId );
			break;
		case e_enterpriseNumber:
			assignNew ( m_enterpriseNumber, new Asn :: ObjectId );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void VendorIdentifier :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_productId:
			delete m_productId;
			m_productId = 0;
			break;
		case e_versionId:
			delete m_versionId;
			m_versionId = 0;
			break;
		case e_enterpriseNumber:
			delete m_enterpriseNumber;
			m_enterpriseNumber = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void VendorIdentifier :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_vendor.encode ( os );
	if ( hasOptionalField ( e_productId ) )
		m_productId -> VendorIdentifier_productId :: encode ( os );
	if ( hasOptionalField ( e_versionId ) )
		m_versionId -> VendorIdentifier_versionId :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_enterpriseNumber, m_enterpriseNumber );
		unknownExtensionsEncode ( os );
	}
}

VendorIdentifier :: ~VendorIdentifier ( ) {
	delete m_productId;
	delete m_versionId;
	delete m_enterpriseNumber;
}

void VendorIdentifier :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 9 ) << "vendor = " << std :: setprecision ( indent ) << m_vendor << '\n';
	if ( hasOptionalField ( e_productId ) ) {
		os << std :: setw ( indent + 12 ) << "productId = " << std :: setprecision ( indent );
		m_productId -> VendorIdentifier_productId :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_versionId ) ) {
		os << std :: setw ( indent + 12 ) << "versionId = " << std :: setprecision ( indent );
		m_versionId -> VendorIdentifier_versionId :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_enterpriseNumber ) ) {
		os << std :: setw ( indent + 19 ) << "enterpriseNumber = " << std :: setprecision ( indent );
		m_enterpriseNumber -> Asn :: ObjectId :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

VendorIdentifier * VendorIdentifier :: clone ( ) const {
	return new VendorIdentifier ( * this );
}

//
// TunnelledProtocol
//

TunnelledProtocol :: TunnelledProtocol ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_id ( is ), m_subIdentifier ( 0 ) {
	try {
		if ( hasOptionalField ( e_subIdentifier ) )
			m_subIdentifier = new TunnelledProtocol_subIdentifier ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_subIdentifier;
		throw;
	}
}

TunnelledProtocol :: TunnelledProtocol ( ) : Asn :: Sequence ( 1, true, 0 ), m_subIdentifier ( 0 ) { }

TunnelledProtocol & TunnelledProtocol :: operator= ( const TunnelledProtocol & s ) {
	Asn :: Sequence :: operator= ( s );
	m_id = s.m_id;
	assignCopy ( m_subIdentifier, s.m_subIdentifier );
	return * this;
}

TunnelledProtocol :: TunnelledProtocol ( const TunnelledProtocol & s ) : Asn :: Sequence ( s ), m_id ( s.m_id ), m_subIdentifier ( 0 ) {
	try {
		if ( s.m_subIdentifier )
			m_subIdentifier = new TunnelledProtocol_subIdentifier ( * s.m_subIdentifier );
	} catch ( ... ) {
		delete m_subIdentifier;
		throw;
	}
}


void TunnelledProtocol :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_subIdentifier:
			assignNew ( m_subIdentifier, new TunnelledProtocol_subIdentifier );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void TunnelledProtocol :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_subIdentifier:
			delete m_subIdentifier;
			m_subIdentifier = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void TunnelledProtocol :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_id.encode ( os );
	if ( hasOptionalField ( e_subIdentifier ) )
		m_subIdentifier -> TunnelledProtocol_subIdentifier :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

TunnelledProtocol :: ~TunnelledProtocol ( ) {
	delete m_subIdentifier;
}

void TunnelledProtocol :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 5 ) << "id = " << std :: setprecision ( indent ) << m_id << '\n';
	if ( hasOptionalField ( e_subIdentifier ) ) {
		os << std :: setw ( indent + 16 ) << "subIdentifier = " << std :: setprecision ( indent );
		m_subIdentifier -> TunnelledProtocol_subIdentifier :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

TunnelledProtocol * TunnelledProtocol :: clone ( ) const {
	return new TunnelledProtocol ( * this );
}

//
// NonStandardParameter
//

NonStandardParameter :: NonStandardParameter ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, false, 0 ), m_nonStandardIdentifier ( is ), m_data ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) {
}

NonStandardParameter :: NonStandardParameter ( ) : Asn :: Sequence ( 0, false, 0 ) { }

void NonStandardParameter :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_nonStandardIdentifier.encode ( os );
	m_data.encode ( os );
}

void NonStandardParameter :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 24 ) << "nonStandardIdentifier = " << std :: setprecision ( indent ) << m_nonStandardIdentifier << '\n';
	os << std :: setw ( indent + 7 ) << "data = " << std :: setprecision ( indent ) << m_data << '\n';
	os << std :: setw ( indent - 1 ) << '}';
}

NonStandardParameter * NonStandardParameter :: clone ( ) const {
	return new NonStandardParameter ( * this );
}

//
// PartyNumber
//

PartyNumber :: PartyNumber ( Asn :: istream & is ) : Asn :: Choice ( is, 5, true ) {
	switch ( tag ) {
		case e_e164Number:
			choice = new PublicPartyNumber ( is );
			break;
		case e_dataPartyNumber:
		case e_telexPartyNumber:
		case e_nationalStandardPartyNumber:
			choice = new NumberDigits ( is );
			break;
		case e_privateNumber:
			choice = new PrivatePartyNumber ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

PartyNumber :: PartyNumber ( ) : Asn :: Choice ( 5, true ) { }

void PartyNumber :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_e164Number:
			o = new PublicPartyNumber;
			break;
		case e_dataPartyNumber:
		case e_telexPartyNumber:
		case e_nationalStandardPartyNumber:
			o = new NumberDigits;
			break;
		case e_privateNumber:
			o = new PrivatePartyNumber;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & PartyNumber :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_e164Number, "e164Number" },
		{ e_dataPartyNumber, "dataPartyNumber" },
		{ e_telexPartyNumber, "telexPartyNumber" },
		{ e_privateNumber, "privateNumber" },
		{ e_nationalStandardPartyNumber, "nationalStandardPartyNumber" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

PartyNumber * PartyNumber :: clone ( ) const {
	return new PartyNumber ( * this );
}

//
// ANSI-41-UIM
//

ANSI_41_UIM :: ANSI_41_UIM ( Asn :: istream & is ) : Asn :: Sequence ( is, 3, true, 0 ), m_imsi ( is ), m_min ( is ), m_mdn ( is ), m_msisdn ( is ), m_esn ( is ), m_mscid ( is ), m_system_id ( is ), m_systemMyTypeCode ( hasOptionalField ( e_systemMyTypeCode ) ? pushTemporaryMember ( new ANSI_41_UIM_systemMyTypeCode ( is ) ) : 0 ), m_systemAccessType ( hasOptionalField ( e_systemAccessType ) ? pushTemporaryMember ( new ANSI_41_UIM_systemAccessType ( is ) ) : 0 ), m_qualificationInformationCode ( hasOptionalField ( e_qualificationInformationCode ) ? pushTemporaryMember ( new ANSI_41_UIM_qualificationInformationCode ( is ) ) : 0 ), m_sesn ( is ), m_soc ( is ) {
	clearTemporaryMembers ( );
	try {
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_systemMyTypeCode;
		delete m_systemAccessType;
		delete m_qualificationInformationCode;
		throw;
	}
}

ANSI_41_UIM :: ANSI_41_UIM ( ) : Asn :: Sequence ( 3, true, 0 ), m_systemMyTypeCode ( 0 ), m_systemAccessType ( 0 ), m_qualificationInformationCode ( 0 ) { }

ANSI_41_UIM & ANSI_41_UIM :: operator= ( const ANSI_41_UIM & s ) {
	Asn :: Sequence :: operator= ( s );
	m_imsi = s.m_imsi;
	m_min = s.m_min;
	m_mdn = s.m_mdn;
	m_msisdn = s.m_msisdn;
	m_esn = s.m_esn;
	m_mscid = s.m_mscid;
	m_system_id = s.m_system_id;
	assignCopy ( m_systemMyTypeCode, s.m_systemMyTypeCode );
	assignCopy ( m_systemAccessType, s.m_systemAccessType );
	assignCopy ( m_qualificationInformationCode, s.m_qualificationInformationCode );
	m_sesn = s.m_sesn;
	m_soc = s.m_soc;
	return * this;
}

ANSI_41_UIM :: ANSI_41_UIM ( const ANSI_41_UIM & s ) : Asn :: Sequence ( s ), m_imsi ( s.m_imsi ), m_min ( s.m_min ), m_mdn ( s.m_mdn ), m_msisdn ( s.m_msisdn ), m_esn ( s.m_esn ), m_mscid ( s.m_mscid ), m_system_id ( s.m_system_id ), m_systemMyTypeCode ( 0 ), m_systemAccessType ( 0 ), m_qualificationInformationCode ( 0 ), m_sesn ( s.m_sesn ), m_soc ( s.m_soc ) {
	try {
		if ( s.m_systemMyTypeCode )
			m_systemMyTypeCode = new ANSI_41_UIM_systemMyTypeCode ( * s.m_systemMyTypeCode );
		if ( s.m_systemAccessType )
			m_systemAccessType = new ANSI_41_UIM_systemAccessType ( * s.m_systemAccessType );
		if ( s.m_qualificationInformationCode )
			m_qualificationInformationCode = new ANSI_41_UIM_qualificationInformationCode ( * s.m_qualificationInformationCode );
	} catch ( ... ) {
		delete m_systemMyTypeCode;
		delete m_systemAccessType;
		delete m_qualificationInformationCode;
		throw;
	}
}


void ANSI_41_UIM :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_systemMyTypeCode:
			assignNew ( m_systemMyTypeCode, new ANSI_41_UIM_systemMyTypeCode );
			break;
		case e_systemAccessType:
			assignNew ( m_systemAccessType, new ANSI_41_UIM_systemAccessType );
			break;
		case e_qualificationInformationCode:
			assignNew ( m_qualificationInformationCode, new ANSI_41_UIM_qualificationInformationCode );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void ANSI_41_UIM :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_systemMyTypeCode:
			delete m_systemMyTypeCode;
			m_systemMyTypeCode = 0;
			break;
		case e_systemAccessType:
			delete m_systemAccessType;
			m_systemAccessType = 0;
			break;
		case e_qualificationInformationCode:
			delete m_qualificationInformationCode;
			m_qualificationInformationCode = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void ANSI_41_UIM :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_imsi.encode ( os );
	m_min.encode ( os );
	m_mdn.encode ( os );
	m_msisdn.encode ( os );
	m_esn.encode ( os );
	m_mscid.encode ( os );
	m_system_id.encode ( os );
	if ( hasOptionalField ( e_systemMyTypeCode ) )
		m_systemMyTypeCode -> ANSI_41_UIM_systemMyTypeCode :: encode ( os );
	if ( hasOptionalField ( e_systemAccessType ) )
		m_systemAccessType -> ANSI_41_UIM_systemAccessType :: encode ( os );
	if ( hasOptionalField ( e_qualificationInformationCode ) )
		m_qualificationInformationCode -> ANSI_41_UIM_qualificationInformationCode :: encode ( os );
	m_sesn.encode ( os );
	m_soc.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

ANSI_41_UIM :: ~ANSI_41_UIM ( ) {
	delete m_systemMyTypeCode;
	delete m_systemAccessType;
	delete m_qualificationInformationCode;
}

void ANSI_41_UIM :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 7 ) << "imsi = " << std :: setprecision ( indent ) << m_imsi << '\n';
	os << std :: setw ( indent + 6 ) << "min = " << std :: setprecision ( indent ) << m_min << '\n';
	os << std :: setw ( indent + 6 ) << "mdn = " << std :: setprecision ( indent ) << m_mdn << '\n';
	os << std :: setw ( indent + 9 ) << "msisdn = " << std :: setprecision ( indent ) << m_msisdn << '\n';
	os << std :: setw ( indent + 6 ) << "esn = " << std :: setprecision ( indent ) << m_esn << '\n';
	os << std :: setw ( indent + 8 ) << "mscid = " << std :: setprecision ( indent ) << m_mscid << '\n';
	os << std :: setw ( indent + 12 ) << "system_id = " << std :: setprecision ( indent ) << m_system_id << '\n';
	if ( hasOptionalField ( e_systemMyTypeCode ) ) {
		os << std :: setw ( indent + 19 ) << "systemMyTypeCode = " << std :: setprecision ( indent );
		m_systemMyTypeCode -> ANSI_41_UIM_systemMyTypeCode :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_systemAccessType ) ) {
		os << std :: setw ( indent + 19 ) << "systemAccessType = " << std :: setprecision ( indent );
		m_systemAccessType -> ANSI_41_UIM_systemAccessType :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_qualificationInformationCode ) ) {
		os << std :: setw ( indent + 31 ) << "qualificationInformationCode = " << std :: setprecision ( indent );
		m_qualificationInformationCode -> ANSI_41_UIM_qualificationInformationCode :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 7 ) << "sesn = " << std :: setprecision ( indent ) << m_sesn << '\n';
	os << std :: setw ( indent + 6 ) << "soc = " << std :: setprecision ( indent ) << m_soc << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

ANSI_41_UIM * ANSI_41_UIM :: clone ( ) const {
	return new ANSI_41_UIM ( * this );
}

//
// IsupNumber
//

IsupNumber :: IsupNumber ( Asn :: istream & is ) : Asn :: Choice ( is, 5, true ) {
	switch ( tag ) {
		case e_e164Number:
			choice = new IsupPublicPartyNumber ( is );
			break;
		case e_dataPartyNumber:
		case e_telexPartyNumber:
		case e_nationalStandardPartyNumber:
			choice = new IsupDigits ( is );
			break;
		case e_privateNumber:
			choice = new IsupPrivatePartyNumber ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

IsupNumber :: IsupNumber ( ) : Asn :: Choice ( 5, true ) { }

void IsupNumber :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_e164Number:
			o = new IsupPublicPartyNumber;
			break;
		case e_dataPartyNumber:
		case e_telexPartyNumber:
		case e_nationalStandardPartyNumber:
			o = new IsupDigits;
			break;
		case e_privateNumber:
			o = new IsupPrivatePartyNumber;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & IsupNumber :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_e164Number, "e164Number" },
		{ e_dataPartyNumber, "dataPartyNumber" },
		{ e_telexPartyNumber, "telexPartyNumber" },
		{ e_privateNumber, "privateNumber" },
		{ e_nationalStandardPartyNumber, "nationalStandardPartyNumber" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

IsupNumber * IsupNumber :: clone ( ) const {
	return new IsupNumber ( * this );
}

//
// SecurityServiceMode
//

SecurityServiceMode :: SecurityServiceMode ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_nonStandard:
			choice = new NonStandardParameter ( is );
			break;
		case e_none:
		case e_default:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

SecurityServiceMode :: SecurityServiceMode ( ) : Asn :: Choice ( 3, true ) { }

void SecurityServiceMode :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandard:
			o = new NonStandardParameter;
			break;
		case e_none:
		case e_default:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & SecurityServiceMode :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandard, "nonStandard" },
		{ e_none, "none" },
		{ e_default, "default" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

SecurityServiceMode * SecurityServiceMode :: clone ( ) const {
	return new SecurityServiceMode ( * this );
}

//
// SecurityCapabilities
//

SecurityCapabilities :: SecurityCapabilities ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_nonStandard ( hasOptionalField ( e_nonStandard ) ? pushTemporaryMember ( new NonStandardParameter ( is ) ) : 0 ), m_encryption ( is ), m_authenticaton ( is ), m_integrity ( is ) {
	clearTemporaryMembers ( );
	try {
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_nonStandard;
		throw;
	}
}

SecurityCapabilities :: SecurityCapabilities ( ) : Asn :: Sequence ( 1, true, 0 ), m_nonStandard ( 0 ) { }

SecurityCapabilities & SecurityCapabilities :: operator= ( const SecurityCapabilities & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_nonStandard, s.m_nonStandard );
	m_encryption = s.m_encryption;
	m_authenticaton = s.m_authenticaton;
	m_integrity = s.m_integrity;
	return * this;
}

SecurityCapabilities :: SecurityCapabilities ( const SecurityCapabilities & s ) : Asn :: Sequence ( s ), m_nonStandard ( 0 ), m_encryption ( s.m_encryption ), m_authenticaton ( s.m_authenticaton ), m_integrity ( s.m_integrity ) {
	try {
		if ( s.m_nonStandard )
			m_nonStandard = new NonStandardParameter ( * s.m_nonStandard );
	} catch ( ... ) {
		delete m_nonStandard;
		throw;
	}
}


void SecurityCapabilities :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandard:
			assignNew ( m_nonStandard, new NonStandardParameter );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void SecurityCapabilities :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandard:
			delete m_nonStandard;
			m_nonStandard = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void SecurityCapabilities :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_nonStandard ) )
		m_nonStandard -> NonStandardParameter :: encode ( os );
	m_encryption.encode ( os );
	m_authenticaton.encode ( os );
	m_integrity.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

SecurityCapabilities :: ~SecurityCapabilities ( ) {
	delete m_nonStandard;
}

void SecurityCapabilities :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_nonStandard ) ) {
		os << std :: setw ( indent + 14 ) << "nonStandard = " << std :: setprecision ( indent );
		m_nonStandard -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 13 ) << "encryption = " << std :: setprecision ( indent ) << m_encryption << '\n';
	os << std :: setw ( indent + 16 ) << "authenticaton = " << std :: setprecision ( indent ) << m_authenticaton << '\n';
	os << std :: setw ( indent + 12 ) << "integrity = " << std :: setprecision ( indent ) << m_integrity << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

SecurityCapabilities * SecurityCapabilities :: clone ( ) const {
	return new SecurityCapabilities ( * this );
}

//
// H245Security
//

H245Security :: H245Security ( Asn :: istream & is ) : Asn :: Choice ( is, 4, true ) {
	switch ( tag ) {
		case e_nonStandard:
			choice = new NonStandardParameter ( is );
			break;
		case e_noSecurity:
			choice = new Asn :: Null ( is );
			break;
		case e_tls:
		case e_ipsec:
			choice = new SecurityCapabilities ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

H245Security :: H245Security ( ) : Asn :: Choice ( 4, true ) { }

void H245Security :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandard:
			o = new NonStandardParameter;
			break;
		case e_noSecurity:
			o = new Asn :: Null;
			break;
		case e_tls:
		case e_ipsec:
			o = new SecurityCapabilities;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & H245Security :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandard, "nonStandard" },
		{ e_noSecurity, "noSecurity" },
		{ e_tls, "tls" },
		{ e_ipsec, "ipsec" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

H245Security * H245Security :: clone ( ) const {
	return new H245Security ( * this );
}

//
// EncryptIntAlg
//

EncryptIntAlg :: EncryptIntAlg ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_nonStandard:
			choice = new NonStandardParameter ( is );
			break;
		case e_isoAlgorithm:
			choice = new Asn :: ObjectId ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

EncryptIntAlg :: EncryptIntAlg ( ) : Asn :: Choice ( 2, true ) { }

void EncryptIntAlg :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandard:
			o = new NonStandardParameter;
			break;
		case e_isoAlgorithm:
			o = new Asn :: ObjectId;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & EncryptIntAlg :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandard, "nonStandard" },
		{ e_isoAlgorithm, "isoAlgorithm" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

EncryptIntAlg * EncryptIntAlg :: clone ( ) const {
	return new EncryptIntAlg ( * this );
}

//
// NonIsoIntegrityMechanism
//

NonIsoIntegrityMechanism :: NonIsoIntegrityMechanism ( Asn :: istream & is ) : Asn :: Choice ( is, 4, true ) {
	switch ( tag ) {
		case e_hMAC_MD5:
			choice = new Asn :: Null ( is );
			break;
		case e_hMAC_iso10118_2_s:
		case e_hMAC_iso10118_2_l:
			choice = new EncryptIntAlg ( is );
			break;
		case e_hMAC_iso10118_3:
			choice = new Asn :: ObjectId ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

NonIsoIntegrityMechanism :: NonIsoIntegrityMechanism ( ) : Asn :: Choice ( 4, true ) { }

void NonIsoIntegrityMechanism :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_hMAC_MD5:
			o = new Asn :: Null;
			break;
		case e_hMAC_iso10118_2_s:
		case e_hMAC_iso10118_2_l:
			o = new EncryptIntAlg;
			break;
		case e_hMAC_iso10118_3:
			o = new Asn :: ObjectId;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & NonIsoIntegrityMechanism :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_hMAC_MD5, "hMAC_MD5" },
		{ e_hMAC_iso10118_2_s, "hMAC_iso10118_2_s" },
		{ e_hMAC_iso10118_2_l, "hMAC_iso10118_2_l" },
		{ e_hMAC_iso10118_3, "hMAC_iso10118_3" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

NonIsoIntegrityMechanism * NonIsoIntegrityMechanism :: clone ( ) const {
	return new NonIsoIntegrityMechanism ( * this );
}

//
// IntegrityMechanism
//

IntegrityMechanism :: IntegrityMechanism ( Asn :: istream & is ) : Asn :: Choice ( is, 4, true ) {
	switch ( tag ) {
		case e_nonStandard:
			choice = new NonStandardParameter ( is );
			break;
		case e_digSig:
			choice = new Asn :: Null ( is );
			break;
		case e_iso9797:
			choice = new Asn :: ObjectId ( is );
			break;
		case e_nonIsoIM:
			choice = new NonIsoIntegrityMechanism ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

IntegrityMechanism :: IntegrityMechanism ( ) : Asn :: Choice ( 4, true ) { }

void IntegrityMechanism :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandard:
			o = new NonStandardParameter;
			break;
		case e_digSig:
			o = new Asn :: Null;
			break;
		case e_iso9797:
			o = new Asn :: ObjectId;
			break;
		case e_nonIsoIM:
			o = new NonIsoIntegrityMechanism;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & IntegrityMechanism :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandard, "nonStandard" },
		{ e_digSig, "digSig" },
		{ e_iso9797, "iso9797" },
		{ e_nonIsoIM, "nonIsoIM" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

IntegrityMechanism * IntegrityMechanism :: clone ( ) const {
	return new IntegrityMechanism ( * this );
}

//
// ServiceControlDescriptor
//

ServiceControlDescriptor :: ServiceControlDescriptor ( Asn :: istream & is ) : Asn :: Choice ( is, 4, true ) {
	switch ( tag ) {
		case e_url:
			choice = new ServiceControlDescriptor_url ( is );
			break;
		case e_signal:
			choice = new H248SignalsDescriptor ( is );
			break;
		case e_nonStandard:
			choice = new NonStandardParameter ( is );
			break;
		case e_callCreditServiceControl:
			choice = new CallCreditServiceControl ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

ServiceControlDescriptor :: ServiceControlDescriptor ( ) : Asn :: Choice ( 4, true ) { }

void ServiceControlDescriptor :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_url:
			o = new ServiceControlDescriptor_url;
			break;
		case e_signal:
			o = new H248SignalsDescriptor;
			break;
		case e_nonStandard:
			o = new NonStandardParameter;
			break;
		case e_callCreditServiceControl:
			o = new CallCreditServiceControl;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & ServiceControlDescriptor :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_url, "url" },
		{ e_signal, "signal" },
		{ e_nonStandard, "nonStandard" },
		{ e_callCreditServiceControl, "callCreditServiceControl" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

ServiceControlDescriptor * ServiceControlDescriptor :: clone ( ) const {
	return new ServiceControlDescriptor ( * this );
}

//
// GenericData
//

GenericData :: GenericData ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_id ( is ), m_parameters ( 0 ) {
	try {
		if ( hasOptionalField ( e_parameters ) )
			m_parameters = new GenericData_parameters ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_parameters;
		throw;
	}
}

GenericData :: GenericData ( ) : Asn :: Sequence ( 1, true, 0 ), m_parameters ( 0 ) { }

GenericData & GenericData :: operator= ( const GenericData & s ) {
	Asn :: Sequence :: operator= ( s );
	m_id = s.m_id;
	assignCopy ( m_parameters, s.m_parameters );
	return * this;
}

GenericData :: GenericData ( const GenericData & s ) : Asn :: Sequence ( s ), m_id ( s.m_id ), m_parameters ( 0 ) {
	try {
		if ( s.m_parameters )
			m_parameters = new GenericData_parameters ( * s.m_parameters );
	} catch ( ... ) {
		delete m_parameters;
		throw;
	}
}


void GenericData :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_parameters:
			assignNew ( m_parameters, new GenericData_parameters );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void GenericData :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_parameters:
			delete m_parameters;
			m_parameters = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void GenericData :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_id.encode ( os );
	if ( hasOptionalField ( e_parameters ) )
		m_parameters -> GenericData_parameters :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

GenericData :: ~GenericData ( ) {
	delete m_parameters;
}

void GenericData :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 5 ) << "id = " << std :: setprecision ( indent ) << m_id << '\n';
	if ( hasOptionalField ( e_parameters ) ) {
		os << std :: setw ( indent + 13 ) << "parameters = " << std :: setprecision ( indent );
		m_parameters -> GenericData_parameters :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

GenericData * GenericData :: clone ( ) const {
	return new GenericData ( * this );
}

//
// RegistrationRequest
//

RegistrationRequest :: RegistrationRequest ( Asn :: istream & is ) : Asn :: Sequence ( is, 3, true, 27 ), m_requestSeqNum ( is ), m_protocolIdentifier ( is ), m_nonStandardData ( hasOptionalField ( e_nonStandardData ) ? pushTemporaryMember ( new NonStandardParameter ( is ) ) : 0 ), m_discoveryComplete ( is ), m_callSignalAddress ( is ), m_rasAddress ( is ), m_terminalType ( is ), m_terminalAlias ( hasOptionalField ( e_terminalAlias ) ? pushTemporaryMember ( new ArrayOf_AliasAddress ( is ) ) : 0 ), m_gatekeeperIdentifier ( hasOptionalField ( e_gatekeeperIdentifier ) ? pushTemporaryMember ( new GatekeeperIdentifier ( is ) ) : 0 ), m_endpointVendor ( is ), m_alternateEndpoints ( 0 ), m_timeToLive ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_keepAlive ( 0 ), m_endpointIdentifier ( 0 ), m_willSupplyUUIEs ( 0 ), m_maintainConnection ( 0 ), m_alternateTransportAddresses ( 0 ), m_additiveRegistration ( 0 ), m_terminalAliasPattern ( 0 ), m_supportsAltGK ( 0 ), m_usageReportingCapability ( 0 ), m_multipleCalls ( 0 ), m_supportedH248Packages ( 0 ), m_callCreditCapability ( 0 ), m_capacityReportingCapability ( 0 ), m_capacity ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ), m_restart ( 0 ), m_supportsACFSequences ( 0 ), m_supportsAssignedGK ( 0 ), m_assignedGatekeeper ( 0 ), m_transportQOS ( 0 ), m_language ( 0 ) {
	clearTemporaryMembers ( );
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_alternateEndpoints ) )
				m_alternateEndpoints = new ArrayOf_Endpoint ( is );
			if ( hasKnownExtensionToDecode ( is, e_timeToLive ) )
				m_timeToLive = new TimeToLive ( is );
			if ( hasKnownExtensionToDecode ( is, e_tokens ) )
				m_tokens = new ArrayOf_ClearToken ( is );
			if ( hasKnownExtensionToDecode ( is, e_cryptoTokens ) )
				m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
			if ( hasKnownExtensionToDecode ( is, e_integrityCheckValue ) )
				m_integrityCheckValue = new ICV ( is );
			if ( hasKnownExtensionToDecode ( is, e_keepAlive ) )
				m_keepAlive = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_endpointIdentifier ) )
				m_endpointIdentifier = new EndpointIdentifier ( is );
			if ( hasKnownExtensionToDecode ( is, e_willSupplyUUIEs ) )
				m_willSupplyUUIEs = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_maintainConnection ) )
				m_maintainConnection = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_alternateTransportAddresses ) )
				m_alternateTransportAddresses = new AlternateTransportAddresses ( is );
			if ( hasKnownExtensionToDecode ( is, e_additiveRegistration ) )
				m_additiveRegistration = new Asn :: Null ( is );
			if ( hasKnownExtensionToDecode ( is, e_terminalAliasPattern ) )
				m_terminalAliasPattern = new ArrayOf_AddressPattern ( is );
			if ( hasKnownExtensionToDecode ( is, e_supportsAltGK ) )
				m_supportsAltGK = new Asn :: Null ( is );
			if ( hasKnownExtensionToDecode ( is, e_usageReportingCapability ) )
				m_usageReportingCapability = new RasUsageInfoTypes ( is );
			if ( hasKnownExtensionToDecode ( is, e_multipleCalls ) )
				m_multipleCalls = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_supportedH248Packages ) )
				m_supportedH248Packages = new ArrayOf_H248PackagesDescriptor ( is );
			if ( hasKnownExtensionToDecode ( is, e_callCreditCapability ) )
				m_callCreditCapability = new CallCreditCapability ( is );
			if ( hasKnownExtensionToDecode ( is, e_capacityReportingCapability ) )
				m_capacityReportingCapability = new CapacityReportingCapability ( is );
			if ( hasKnownExtensionToDecode ( is, e_capacity ) )
				m_capacity = new CallCapacity ( is );
			if ( hasKnownExtensionToDecode ( is, e_featureSet ) )
				m_featureSet = new FeatureSet ( is );
			if ( hasKnownExtensionToDecode ( is, e_genericData ) )
				m_genericData = new ArrayOf_GenericData ( is );
			if ( hasKnownExtensionToDecode ( is, e_restart ) )
				m_restart = new Asn :: Null ( is );
			if ( hasKnownExtensionToDecode ( is, e_supportsACFSequences ) )
				m_supportsACFSequences = new Asn :: Null ( is );
			if ( hasKnownExtensionToDecode ( is, e_supportsAssignedGK ) )
				m_supportsAssignedGK = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_assignedGatekeeper ) )
				m_assignedGatekeeper = new AlternateGK ( is );
			if ( hasKnownExtensionToDecode ( is, e_transportQOS ) )
				m_transportQOS = new TransportQOS ( is );
			if ( hasKnownExtensionToDecode ( is, e_language ) )
				m_language = new RegistrationRequest_language ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_terminalAlias;
		delete m_gatekeeperIdentifier;
		delete m_alternateEndpoints;
		delete m_timeToLive;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_keepAlive;
		delete m_endpointIdentifier;
		delete m_willSupplyUUIEs;
		delete m_maintainConnection;
		delete m_alternateTransportAddresses;
		delete m_additiveRegistration;
		delete m_terminalAliasPattern;
		delete m_supportsAltGK;
		delete m_usageReportingCapability;
		delete m_multipleCalls;
		delete m_supportedH248Packages;
		delete m_callCreditCapability;
		delete m_capacityReportingCapability;
		delete m_capacity;
		delete m_featureSet;
		delete m_genericData;
		delete m_restart;
		delete m_supportsACFSequences;
		delete m_supportsAssignedGK;
		delete m_assignedGatekeeper;
		delete m_transportQOS;
		delete m_language;
		throw;
	}
}

RegistrationRequest :: RegistrationRequest ( ) : Asn :: Sequence ( 3, true, 27 ), m_nonStandardData ( 0 ), m_terminalAlias ( 0 ), m_gatekeeperIdentifier ( 0 ), m_alternateEndpoints ( 0 ), m_timeToLive ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_keepAlive ( 0 ), m_endpointIdentifier ( 0 ), m_willSupplyUUIEs ( 0 ), m_maintainConnection ( 0 ), m_alternateTransportAddresses ( 0 ), m_additiveRegistration ( 0 ), m_terminalAliasPattern ( 0 ), m_supportsAltGK ( 0 ), m_usageReportingCapability ( 0 ), m_multipleCalls ( 0 ), m_supportedH248Packages ( 0 ), m_callCreditCapability ( 0 ), m_capacityReportingCapability ( 0 ), m_capacity ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ), m_restart ( 0 ), m_supportsACFSequences ( 0 ), m_supportsAssignedGK ( 0 ), m_assignedGatekeeper ( 0 ), m_transportQOS ( 0 ), m_language ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_keepAlive );
		m_keepAlive = new Asn :: Boolean;
		Asn :: Sequence :: includeOptionalField ( e_willSupplyUUIEs );
		m_willSupplyUUIEs = new Asn :: Boolean;
		Asn :: Sequence :: includeOptionalField ( e_maintainConnection );
		m_maintainConnection = new Asn :: Boolean;
		Asn :: Sequence :: includeOptionalField ( e_supportsAssignedGK );
		m_supportsAssignedGK = new Asn :: Boolean;
	} catch ( ... ) {
		delete m_keepAlive;
		delete m_willSupplyUUIEs;
		delete m_maintainConnection;
		delete m_supportsAssignedGK;
		throw;
	}
}

RegistrationRequest & RegistrationRequest :: operator= ( const RegistrationRequest & s ) {
	Asn :: Sequence :: operator= ( s );
	m_requestSeqNum = s.m_requestSeqNum;
	m_protocolIdentifier = s.m_protocolIdentifier;
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	m_discoveryComplete = s.m_discoveryComplete;
	m_callSignalAddress = s.m_callSignalAddress;
	m_rasAddress = s.m_rasAddress;
	m_terminalType = s.m_terminalType;
	assignCopy ( m_terminalAlias, s.m_terminalAlias );
	assignCopy ( m_gatekeeperIdentifier, s.m_gatekeeperIdentifier );
	m_endpointVendor = s.m_endpointVendor;
	assignCopy ( m_alternateEndpoints, s.m_alternateEndpoints );
	assignCopy ( m_timeToLive, s.m_timeToLive );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_integrityCheckValue, s.m_integrityCheckValue );
	assignCopy ( m_keepAlive, s.m_keepAlive );
	assignCopy ( m_endpointIdentifier, s.m_endpointIdentifier );
	assignCopy ( m_willSupplyUUIEs, s.m_willSupplyUUIEs );
	assignCopy ( m_maintainConnection, s.m_maintainConnection );
	assignCopy ( m_alternateTransportAddresses, s.m_alternateTransportAddresses );
	assignCopy ( m_additiveRegistration, s.m_additiveRegistration );
	assignCopy ( m_terminalAliasPattern, s.m_terminalAliasPattern );
	assignCopy ( m_supportsAltGK, s.m_supportsAltGK );
	assignCopy ( m_usageReportingCapability, s.m_usageReportingCapability );
	assignCopy ( m_multipleCalls, s.m_multipleCalls );
	assignCopy ( m_supportedH248Packages, s.m_supportedH248Packages );
	assignCopy ( m_callCreditCapability, s.m_callCreditCapability );
	assignCopy ( m_capacityReportingCapability, s.m_capacityReportingCapability );
	assignCopy ( m_capacity, s.m_capacity );
	assignCopy ( m_featureSet, s.m_featureSet );
	assignCopy ( m_genericData, s.m_genericData );
	assignCopy ( m_restart, s.m_restart );
	assignCopy ( m_supportsACFSequences, s.m_supportsACFSequences );
	assignCopy ( m_supportsAssignedGK, s.m_supportsAssignedGK );
	assignCopy ( m_assignedGatekeeper, s.m_assignedGatekeeper );
	assignCopy ( m_transportQOS, s.m_transportQOS );
	assignCopy ( m_language, s.m_language );
	return * this;
}

RegistrationRequest :: RegistrationRequest ( const RegistrationRequest & s ) : Asn :: Sequence ( s ), m_requestSeqNum ( s.m_requestSeqNum ), m_protocolIdentifier ( s.m_protocolIdentifier ), m_nonStandardData ( 0 ), m_discoveryComplete ( s.m_discoveryComplete ), m_callSignalAddress ( s.m_callSignalAddress ), m_rasAddress ( s.m_rasAddress ), m_terminalType ( s.m_terminalType ), m_terminalAlias ( 0 ), m_gatekeeperIdentifier ( 0 ), m_endpointVendor ( s.m_endpointVendor ), m_alternateEndpoints ( 0 ), m_timeToLive ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_keepAlive ( 0 ), m_endpointIdentifier ( 0 ), m_willSupplyUUIEs ( 0 ), m_maintainConnection ( 0 ), m_alternateTransportAddresses ( 0 ), m_additiveRegistration ( 0 ), m_terminalAliasPattern ( 0 ), m_supportsAltGK ( 0 ), m_usageReportingCapability ( 0 ), m_multipleCalls ( 0 ), m_supportedH248Packages ( 0 ), m_callCreditCapability ( 0 ), m_capacityReportingCapability ( 0 ), m_capacity ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ), m_restart ( 0 ), m_supportsACFSequences ( 0 ), m_supportsAssignedGK ( 0 ), m_assignedGatekeeper ( 0 ), m_transportQOS ( 0 ), m_language ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_terminalAlias )
			m_terminalAlias = new ArrayOf_AliasAddress ( * s.m_terminalAlias );
		if ( s.m_gatekeeperIdentifier )
			m_gatekeeperIdentifier = new GatekeeperIdentifier ( * s.m_gatekeeperIdentifier );
		if ( s.m_alternateEndpoints )
			m_alternateEndpoints = new ArrayOf_Endpoint ( * s.m_alternateEndpoints );
		if ( s.m_timeToLive )
			m_timeToLive = new TimeToLive ( * s.m_timeToLive );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_integrityCheckValue )
			m_integrityCheckValue = new ICV ( * s.m_integrityCheckValue );
		if ( s.m_keepAlive )
			m_keepAlive = new Asn :: Boolean ( * s.m_keepAlive );
		if ( s.m_endpointIdentifier )
			m_endpointIdentifier = new EndpointIdentifier ( * s.m_endpointIdentifier );
		if ( s.m_willSupplyUUIEs )
			m_willSupplyUUIEs = new Asn :: Boolean ( * s.m_willSupplyUUIEs );
		if ( s.m_maintainConnection )
			m_maintainConnection = new Asn :: Boolean ( * s.m_maintainConnection );
		if ( s.m_alternateTransportAddresses )
			m_alternateTransportAddresses = new AlternateTransportAddresses ( * s.m_alternateTransportAddresses );
		if ( s.m_additiveRegistration )
			m_additiveRegistration = new Asn :: Null ( * s.m_additiveRegistration );
		if ( s.m_terminalAliasPattern )
			m_terminalAliasPattern = new ArrayOf_AddressPattern ( * s.m_terminalAliasPattern );
		if ( s.m_supportsAltGK )
			m_supportsAltGK = new Asn :: Null ( * s.m_supportsAltGK );
		if ( s.m_usageReportingCapability )
			m_usageReportingCapability = new RasUsageInfoTypes ( * s.m_usageReportingCapability );
		if ( s.m_multipleCalls )
			m_multipleCalls = new Asn :: Boolean ( * s.m_multipleCalls );
		if ( s.m_supportedH248Packages )
			m_supportedH248Packages = new ArrayOf_H248PackagesDescriptor ( * s.m_supportedH248Packages );
		if ( s.m_callCreditCapability )
			m_callCreditCapability = new CallCreditCapability ( * s.m_callCreditCapability );
		if ( s.m_capacityReportingCapability )
			m_capacityReportingCapability = new CapacityReportingCapability ( * s.m_capacityReportingCapability );
		if ( s.m_capacity )
			m_capacity = new CallCapacity ( * s.m_capacity );
		if ( s.m_featureSet )
			m_featureSet = new FeatureSet ( * s.m_featureSet );
		if ( s.m_genericData )
			m_genericData = new ArrayOf_GenericData ( * s.m_genericData );
		if ( s.m_restart )
			m_restart = new Asn :: Null ( * s.m_restart );
		if ( s.m_supportsACFSequences )
			m_supportsACFSequences = new Asn :: Null ( * s.m_supportsACFSequences );
		if ( s.m_supportsAssignedGK )
			m_supportsAssignedGK = new Asn :: Boolean ( * s.m_supportsAssignedGK );
		if ( s.m_assignedGatekeeper )
			m_assignedGatekeeper = new AlternateGK ( * s.m_assignedGatekeeper );
		if ( s.m_transportQOS )
			m_transportQOS = new TransportQOS ( * s.m_transportQOS );
		if ( s.m_language )
			m_language = new RegistrationRequest_language ( * s.m_language );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_terminalAlias;
		delete m_gatekeeperIdentifier;
		delete m_alternateEndpoints;
		delete m_timeToLive;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_keepAlive;
		delete m_endpointIdentifier;
		delete m_willSupplyUUIEs;
		delete m_maintainConnection;
		delete m_alternateTransportAddresses;
		delete m_additiveRegistration;
		delete m_terminalAliasPattern;
		delete m_supportsAltGK;
		delete m_usageReportingCapability;
		delete m_multipleCalls;
		delete m_supportedH248Packages;
		delete m_callCreditCapability;
		delete m_capacityReportingCapability;
		delete m_capacity;
		delete m_featureSet;
		delete m_genericData;
		delete m_restart;
		delete m_supportsACFSequences;
		delete m_supportsAssignedGK;
		delete m_assignedGatekeeper;
		delete m_transportQOS;
		delete m_language;
		throw;
	}
}


void RegistrationRequest :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_terminalAlias:
			assignNew ( m_terminalAlias, new ArrayOf_AliasAddress );
			break;
		case e_gatekeeperIdentifier:
			assignNew ( m_gatekeeperIdentifier, new GatekeeperIdentifier );
			break;
		case e_alternateEndpoints:
			assignNew ( m_alternateEndpoints, new ArrayOf_Endpoint );
			break;
		case e_timeToLive:
			assignNew ( m_timeToLive, new TimeToLive );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_integrityCheckValue:
			assignNew ( m_integrityCheckValue, new ICV );
			break;
		case e_keepAlive:
			assignNew ( m_keepAlive, new Asn :: Boolean );
			break;
		case e_endpointIdentifier:
			assignNew ( m_endpointIdentifier, new EndpointIdentifier );
			break;
		case e_willSupplyUUIEs:
			assignNew ( m_willSupplyUUIEs, new Asn :: Boolean );
			break;
		case e_maintainConnection:
			assignNew ( m_maintainConnection, new Asn :: Boolean );
			break;
		case e_alternateTransportAddresses:
			assignNew ( m_alternateTransportAddresses, new AlternateTransportAddresses );
			break;
		case e_additiveRegistration:
			assignNew ( m_additiveRegistration, new Asn :: Null );
			break;
		case e_terminalAliasPattern:
			assignNew ( m_terminalAliasPattern, new ArrayOf_AddressPattern );
			break;
		case e_supportsAltGK:
			assignNew ( m_supportsAltGK, new Asn :: Null );
			break;
		case e_usageReportingCapability:
			assignNew ( m_usageReportingCapability, new RasUsageInfoTypes );
			break;
		case e_multipleCalls:
			assignNew ( m_multipleCalls, new Asn :: Boolean );
			break;
		case e_supportedH248Packages:
			assignNew ( m_supportedH248Packages, new ArrayOf_H248PackagesDescriptor );
			break;
		case e_callCreditCapability:
			assignNew ( m_callCreditCapability, new CallCreditCapability );
			break;
		case e_capacityReportingCapability:
			assignNew ( m_capacityReportingCapability, new CapacityReportingCapability );
			break;
		case e_capacity:
			assignNew ( m_capacity, new CallCapacity );
			break;
		case e_featureSet:
			assignNew ( m_featureSet, new FeatureSet );
			break;
		case e_genericData:
			assignNew ( m_genericData, new ArrayOf_GenericData );
			break;
		case e_restart:
			assignNew ( m_restart, new Asn :: Null );
			break;
		case e_supportsACFSequences:
			assignNew ( m_supportsACFSequences, new Asn :: Null );
			break;
		case e_supportsAssignedGK:
			assignNew ( m_supportsAssignedGK, new Asn :: Boolean );
			break;
		case e_assignedGatekeeper:
			assignNew ( m_assignedGatekeeper, new AlternateGK );
			break;
		case e_transportQOS:
			assignNew ( m_transportQOS, new TransportQOS );
			break;
		case e_language:
			assignNew ( m_language, new RegistrationRequest_language );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void RegistrationRequest :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_terminalAlias:
			delete m_terminalAlias;
			m_terminalAlias = 0;
			break;
		case e_gatekeeperIdentifier:
			delete m_gatekeeperIdentifier;
			m_gatekeeperIdentifier = 0;
			break;
		case e_alternateEndpoints:
			delete m_alternateEndpoints;
			m_alternateEndpoints = 0;
			break;
		case e_timeToLive:
			delete m_timeToLive;
			m_timeToLive = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_integrityCheckValue:
			delete m_integrityCheckValue;
			m_integrityCheckValue = 0;
			break;
		case e_keepAlive:
			delete m_keepAlive;
			m_keepAlive = 0;
			break;
		case e_endpointIdentifier:
			delete m_endpointIdentifier;
			m_endpointIdentifier = 0;
			break;
		case e_willSupplyUUIEs:
			delete m_willSupplyUUIEs;
			m_willSupplyUUIEs = 0;
			break;
		case e_maintainConnection:
			delete m_maintainConnection;
			m_maintainConnection = 0;
			break;
		case e_alternateTransportAddresses:
			delete m_alternateTransportAddresses;
			m_alternateTransportAddresses = 0;
			break;
		case e_additiveRegistration:
			delete m_additiveRegistration;
			m_additiveRegistration = 0;
			break;
		case e_terminalAliasPattern:
			delete m_terminalAliasPattern;
			m_terminalAliasPattern = 0;
			break;
		case e_supportsAltGK:
			delete m_supportsAltGK;
			m_supportsAltGK = 0;
			break;
		case e_usageReportingCapability:
			delete m_usageReportingCapability;
			m_usageReportingCapability = 0;
			break;
		case e_multipleCalls:
			delete m_multipleCalls;
			m_multipleCalls = 0;
			break;
		case e_supportedH248Packages:
			delete m_supportedH248Packages;
			m_supportedH248Packages = 0;
			break;
		case e_callCreditCapability:
			delete m_callCreditCapability;
			m_callCreditCapability = 0;
			break;
		case e_capacityReportingCapability:
			delete m_capacityReportingCapability;
			m_capacityReportingCapability = 0;
			break;
		case e_capacity:
			delete m_capacity;
			m_capacity = 0;
			break;
		case e_featureSet:
			delete m_featureSet;
			m_featureSet = 0;
			break;
		case e_genericData:
			delete m_genericData;
			m_genericData = 0;
			break;
		case e_restart:
			delete m_restart;
			m_restart = 0;
			break;
		case e_supportsACFSequences:
			delete m_supportsACFSequences;
			m_supportsACFSequences = 0;
			break;
		case e_supportsAssignedGK:
			delete m_supportsAssignedGK;
			m_supportsAssignedGK = 0;
			break;
		case e_assignedGatekeeper:
			delete m_assignedGatekeeper;
			m_assignedGatekeeper = 0;
			break;
		case e_transportQOS:
			delete m_transportQOS;
			m_transportQOS = 0;
			break;
		case e_language:
			delete m_language;
			m_language = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void RegistrationRequest :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_requestSeqNum.encode ( os );
	m_protocolIdentifier.encode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	m_discoveryComplete.encode ( os );
	m_callSignalAddress.encode ( os );
	m_rasAddress.encode ( os );
	m_terminalType.encode ( os );
	if ( hasOptionalField ( e_terminalAlias ) )
		m_terminalAlias -> ArrayOf_AliasAddress :: encode ( os );
	if ( hasOptionalField ( e_gatekeeperIdentifier ) )
		m_gatekeeperIdentifier -> GatekeeperIdentifier :: encode ( os );
	m_endpointVendor.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_alternateEndpoints, m_alternateEndpoints );
		knownExtensionEncode ( os, e_timeToLive, m_timeToLive );
		knownExtensionEncode ( os, e_tokens, m_tokens );
		knownExtensionEncode ( os, e_cryptoTokens, m_cryptoTokens );
		knownExtensionEncode ( os, e_integrityCheckValue, m_integrityCheckValue );
		knownExtensionEncode ( os, e_keepAlive, m_keepAlive );
		knownExtensionEncode ( os, e_endpointIdentifier, m_endpointIdentifier );
		knownExtensionEncode ( os, e_willSupplyUUIEs, m_willSupplyUUIEs );
		knownExtensionEncode ( os, e_maintainConnection, m_maintainConnection );
		knownExtensionEncode ( os, e_alternateTransportAddresses, m_alternateTransportAddresses );
		knownExtensionEncode ( os, e_additiveRegistration, m_additiveRegistration );
		knownExtensionEncode ( os, e_terminalAliasPattern, m_terminalAliasPattern );
		knownExtensionEncode ( os, e_supportsAltGK, m_supportsAltGK );
		knownExtensionEncode ( os, e_usageReportingCapability, m_usageReportingCapability );
		knownExtensionEncode ( os, e_multipleCalls, m_multipleCalls );
		knownExtensionEncode ( os, e_supportedH248Packages, m_supportedH248Packages );
		knownExtensionEncode ( os, e_callCreditCapability, m_callCreditCapability );
		knownExtensionEncode ( os, e_capacityReportingCapability, m_capacityReportingCapability );
		knownExtensionEncode ( os, e_capacity, m_capacity );
		knownExtensionEncode ( os, e_featureSet, m_featureSet );
		knownExtensionEncode ( os, e_genericData, m_genericData );
		knownExtensionEncode ( os, e_restart, m_restart );
		knownExtensionEncode ( os, e_supportsACFSequences, m_supportsACFSequences );
		knownExtensionEncode ( os, e_supportsAssignedGK, m_supportsAssignedGK );
		knownExtensionEncode ( os, e_assignedGatekeeper, m_assignedGatekeeper );
		knownExtensionEncode ( os, e_transportQOS, m_transportQOS );
		knownExtensionEncode ( os, e_language, m_language );
		unknownExtensionsEncode ( os );
	}
}

RegistrationRequest :: ~RegistrationRequest ( ) {
	delete m_nonStandardData;
	delete m_terminalAlias;
	delete m_gatekeeperIdentifier;
	delete m_alternateEndpoints;
	delete m_timeToLive;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_integrityCheckValue;
	delete m_keepAlive;
	delete m_endpointIdentifier;
	delete m_willSupplyUUIEs;
	delete m_maintainConnection;
	delete m_alternateTransportAddresses;
	delete m_additiveRegistration;
	delete m_terminalAliasPattern;
	delete m_supportsAltGK;
	delete m_usageReportingCapability;
	delete m_multipleCalls;
	delete m_supportedH248Packages;
	delete m_callCreditCapability;
	delete m_capacityReportingCapability;
	delete m_capacity;
	delete m_featureSet;
	delete m_genericData;
	delete m_restart;
	delete m_supportsACFSequences;
	delete m_supportsAssignedGK;
	delete m_assignedGatekeeper;
	delete m_transportQOS;
	delete m_language;
}

void RegistrationRequest :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "requestSeqNum = " << std :: setprecision ( indent ) << m_requestSeqNum << '\n';
	os << std :: setw ( indent + 21 ) << "protocolIdentifier = " << std :: setprecision ( indent ) << m_protocolIdentifier << '\n';
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 20 ) << "discoveryComplete = " << std :: setprecision ( indent ) << m_discoveryComplete << '\n';
	os << std :: setw ( indent + 20 ) << "callSignalAddress = " << std :: setprecision ( indent ) << m_callSignalAddress << '\n';
	os << std :: setw ( indent + 13 ) << "rasAddress = " << std :: setprecision ( indent ) << m_rasAddress << '\n';
	os << std :: setw ( indent + 15 ) << "terminalType = " << std :: setprecision ( indent ) << m_terminalType << '\n';
	if ( hasOptionalField ( e_terminalAlias ) ) {
		os << std :: setw ( indent + 16 ) << "terminalAlias = " << std :: setprecision ( indent );
		m_terminalAlias -> ArrayOf_AliasAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_gatekeeperIdentifier ) ) {
		os << std :: setw ( indent + 23 ) << "gatekeeperIdentifier = " << std :: setprecision ( indent );
		m_gatekeeperIdentifier -> GatekeeperIdentifier :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 17 ) << "endpointVendor = " << std :: setprecision ( indent ) << m_endpointVendor << '\n';
	if ( hasOptionalField ( e_alternateEndpoints ) ) {
		os << std :: setw ( indent + 21 ) << "alternateEndpoints = " << std :: setprecision ( indent );
		m_alternateEndpoints -> ArrayOf_Endpoint :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_timeToLive ) ) {
		os << std :: setw ( indent + 13 ) << "timeToLive = " << std :: setprecision ( indent );
		m_timeToLive -> TimeToLive :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_integrityCheckValue ) ) {
		os << std :: setw ( indent + 22 ) << "integrityCheckValue = " << std :: setprecision ( indent );
		m_integrityCheckValue -> ICV :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_keepAlive ) ) {
		os << std :: setw ( indent + 12 ) << "keepAlive = " << std :: setprecision ( indent );
		m_keepAlive -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_endpointIdentifier ) ) {
		os << std :: setw ( indent + 21 ) << "endpointIdentifier = " << std :: setprecision ( indent );
		m_endpointIdentifier -> EndpointIdentifier :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_willSupplyUUIEs ) ) {
		os << std :: setw ( indent + 18 ) << "willSupplyUUIEs = " << std :: setprecision ( indent );
		m_willSupplyUUIEs -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_maintainConnection ) ) {
		os << std :: setw ( indent + 21 ) << "maintainConnection = " << std :: setprecision ( indent );
		m_maintainConnection -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_alternateTransportAddresses ) ) {
		os << std :: setw ( indent + 30 ) << "alternateTransportAddresses = " << std :: setprecision ( indent );
		m_alternateTransportAddresses -> AlternateTransportAddresses :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_additiveRegistration ) ) {
		os << std :: setw ( indent + 23 ) << "additiveRegistration = " << std :: setprecision ( indent );
		m_additiveRegistration -> Asn :: Null :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_terminalAliasPattern ) ) {
		os << std :: setw ( indent + 23 ) << "terminalAliasPattern = " << std :: setprecision ( indent );
		m_terminalAliasPattern -> ArrayOf_AddressPattern :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_supportsAltGK ) ) {
		os << std :: setw ( indent + 16 ) << "supportsAltGK = " << std :: setprecision ( indent );
		m_supportsAltGK -> Asn :: Null :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_usageReportingCapability ) ) {
		os << std :: setw ( indent + 27 ) << "usageReportingCapability = " << std :: setprecision ( indent );
		m_usageReportingCapability -> RasUsageInfoTypes :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_multipleCalls ) ) {
		os << std :: setw ( indent + 16 ) << "multipleCalls = " << std :: setprecision ( indent );
		m_multipleCalls -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_supportedH248Packages ) ) {
		os << std :: setw ( indent + 24 ) << "supportedH248Packages = " << std :: setprecision ( indent );
		m_supportedH248Packages -> ArrayOf_H248PackagesDescriptor :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_callCreditCapability ) ) {
		os << std :: setw ( indent + 23 ) << "callCreditCapability = " << std :: setprecision ( indent );
		m_callCreditCapability -> CallCreditCapability :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_capacityReportingCapability ) ) {
		os << std :: setw ( indent + 30 ) << "capacityReportingCapability = " << std :: setprecision ( indent );
		m_capacityReportingCapability -> CapacityReportingCapability :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_capacity ) ) {
		os << std :: setw ( indent + 11 ) << "capacity = " << std :: setprecision ( indent );
		m_capacity -> CallCapacity :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_featureSet ) ) {
		os << std :: setw ( indent + 13 ) << "featureSet = " << std :: setprecision ( indent );
		m_featureSet -> FeatureSet :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_genericData ) ) {
		os << std :: setw ( indent + 14 ) << "genericData = " << std :: setprecision ( indent );
		m_genericData -> ArrayOf_GenericData :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_restart ) ) {
		os << std :: setw ( indent + 10 ) << "restart = " << std :: setprecision ( indent );
		m_restart -> Asn :: Null :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_supportsACFSequences ) ) {
		os << std :: setw ( indent + 23 ) << "supportsACFSequences = " << std :: setprecision ( indent );
		m_supportsACFSequences -> Asn :: Null :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_supportsAssignedGK ) ) {
		os << std :: setw ( indent + 21 ) << "supportsAssignedGK = " << std :: setprecision ( indent );
		m_supportsAssignedGK -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_assignedGatekeeper ) ) {
		os << std :: setw ( indent + 21 ) << "assignedGatekeeper = " << std :: setprecision ( indent );
		m_assignedGatekeeper -> AlternateGK :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_transportQOS ) ) {
		os << std :: setw ( indent + 15 ) << "transportQOS = " << std :: setprecision ( indent );
		m_transportQOS -> TransportQOS :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_language ) ) {
		os << std :: setw ( indent + 11 ) << "language = " << std :: setprecision ( indent );
		m_language -> RegistrationRequest_language :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RegistrationRequest * RegistrationRequest :: clone ( ) const {
	return new RegistrationRequest ( * this );
}

//
// RegistrationReject
//

RegistrationReject :: RegistrationReject ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 7 ), m_requestSeqNum ( is ), m_protocolIdentifier ( is ), m_nonStandardData ( hasOptionalField ( e_nonStandardData ) ? pushTemporaryMember ( new NonStandardParameter ( is ) ) : 0 ), m_rejectReason ( is ), m_gatekeeperIdentifier ( 0 ), m_altGKInfo ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ), m_assignedGatekeeper ( 0 ) {
	clearTemporaryMembers ( );
	try {
		if ( hasOptionalField ( e_gatekeeperIdentifier ) )
			m_gatekeeperIdentifier = new GatekeeperIdentifier ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_altGKInfo ) )
				m_altGKInfo = new AltGKInfo ( is );
			if ( hasKnownExtensionToDecode ( is, e_tokens ) )
				m_tokens = new ArrayOf_ClearToken ( is );
			if ( hasKnownExtensionToDecode ( is, e_cryptoTokens ) )
				m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
			if ( hasKnownExtensionToDecode ( is, e_integrityCheckValue ) )
				m_integrityCheckValue = new ICV ( is );
			if ( hasKnownExtensionToDecode ( is, e_featureSet ) )
				m_featureSet = new FeatureSet ( is );
			if ( hasKnownExtensionToDecode ( is, e_genericData ) )
				m_genericData = new ArrayOf_GenericData ( is );
			if ( hasKnownExtensionToDecode ( is, e_assignedGatekeeper ) )
				m_assignedGatekeeper = new AlternateGK ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_gatekeeperIdentifier;
		delete m_altGKInfo;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_featureSet;
		delete m_genericData;
		delete m_assignedGatekeeper;
		throw;
	}
}

RegistrationReject :: RegistrationReject ( ) : Asn :: Sequence ( 2, true, 7 ), m_nonStandardData ( 0 ), m_gatekeeperIdentifier ( 0 ), m_altGKInfo ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ), m_assignedGatekeeper ( 0 ) { }

RegistrationReject & RegistrationReject :: operator= ( const RegistrationReject & s ) {
	Asn :: Sequence :: operator= ( s );
	m_requestSeqNum = s.m_requestSeqNum;
	m_protocolIdentifier = s.m_protocolIdentifier;
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	m_rejectReason = s.m_rejectReason;
	assignCopy ( m_gatekeeperIdentifier, s.m_gatekeeperIdentifier );
	assignCopy ( m_altGKInfo, s.m_altGKInfo );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_integrityCheckValue, s.m_integrityCheckValue );
	assignCopy ( m_featureSet, s.m_featureSet );
	assignCopy ( m_genericData, s.m_genericData );
	assignCopy ( m_assignedGatekeeper, s.m_assignedGatekeeper );
	return * this;
}

RegistrationReject :: RegistrationReject ( const RegistrationReject & s ) : Asn :: Sequence ( s ), m_requestSeqNum ( s.m_requestSeqNum ), m_protocolIdentifier ( s.m_protocolIdentifier ), m_nonStandardData ( 0 ), m_rejectReason ( s.m_rejectReason ), m_gatekeeperIdentifier ( 0 ), m_altGKInfo ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ), m_assignedGatekeeper ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_gatekeeperIdentifier )
			m_gatekeeperIdentifier = new GatekeeperIdentifier ( * s.m_gatekeeperIdentifier );
		if ( s.m_altGKInfo )
			m_altGKInfo = new AltGKInfo ( * s.m_altGKInfo );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_integrityCheckValue )
			m_integrityCheckValue = new ICV ( * s.m_integrityCheckValue );
		if ( s.m_featureSet )
			m_featureSet = new FeatureSet ( * s.m_featureSet );
		if ( s.m_genericData )
			m_genericData = new ArrayOf_GenericData ( * s.m_genericData );
		if ( s.m_assignedGatekeeper )
			m_assignedGatekeeper = new AlternateGK ( * s.m_assignedGatekeeper );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_gatekeeperIdentifier;
		delete m_altGKInfo;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_featureSet;
		delete m_genericData;
		delete m_assignedGatekeeper;
		throw;
	}
}


void RegistrationReject :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_gatekeeperIdentifier:
			assignNew ( m_gatekeeperIdentifier, new GatekeeperIdentifier );
			break;
		case e_altGKInfo:
			assignNew ( m_altGKInfo, new AltGKInfo );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_integrityCheckValue:
			assignNew ( m_integrityCheckValue, new ICV );
			break;
		case e_featureSet:
			assignNew ( m_featureSet, new FeatureSet );
			break;
		case e_genericData:
			assignNew ( m_genericData, new ArrayOf_GenericData );
			break;
		case e_assignedGatekeeper:
			assignNew ( m_assignedGatekeeper, new AlternateGK );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void RegistrationReject :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_gatekeeperIdentifier:
			delete m_gatekeeperIdentifier;
			m_gatekeeperIdentifier = 0;
			break;
		case e_altGKInfo:
			delete m_altGKInfo;
			m_altGKInfo = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_integrityCheckValue:
			delete m_integrityCheckValue;
			m_integrityCheckValue = 0;
			break;
		case e_featureSet:
			delete m_featureSet;
			m_featureSet = 0;
			break;
		case e_genericData:
			delete m_genericData;
			m_genericData = 0;
			break;
		case e_assignedGatekeeper:
			delete m_assignedGatekeeper;
			m_assignedGatekeeper = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void RegistrationReject :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_requestSeqNum.encode ( os );
	m_protocolIdentifier.encode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	m_rejectReason.encode ( os );
	if ( hasOptionalField ( e_gatekeeperIdentifier ) )
		m_gatekeeperIdentifier -> GatekeeperIdentifier :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_altGKInfo, m_altGKInfo );
		knownExtensionEncode ( os, e_tokens, m_tokens );
		knownExtensionEncode ( os, e_cryptoTokens, m_cryptoTokens );
		knownExtensionEncode ( os, e_integrityCheckValue, m_integrityCheckValue );
		knownExtensionEncode ( os, e_featureSet, m_featureSet );
		knownExtensionEncode ( os, e_genericData, m_genericData );
		knownExtensionEncode ( os, e_assignedGatekeeper, m_assignedGatekeeper );
		unknownExtensionsEncode ( os );
	}
}

RegistrationReject :: ~RegistrationReject ( ) {
	delete m_nonStandardData;
	delete m_gatekeeperIdentifier;
	delete m_altGKInfo;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_integrityCheckValue;
	delete m_featureSet;
	delete m_genericData;
	delete m_assignedGatekeeper;
}

void RegistrationReject :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "requestSeqNum = " << std :: setprecision ( indent ) << m_requestSeqNum << '\n';
	os << std :: setw ( indent + 21 ) << "protocolIdentifier = " << std :: setprecision ( indent ) << m_protocolIdentifier << '\n';
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 15 ) << "rejectReason = " << std :: setprecision ( indent ) << m_rejectReason << '\n';
	if ( hasOptionalField ( e_gatekeeperIdentifier ) ) {
		os << std :: setw ( indent + 23 ) << "gatekeeperIdentifier = " << std :: setprecision ( indent );
		m_gatekeeperIdentifier -> GatekeeperIdentifier :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_altGKInfo ) ) {
		os << std :: setw ( indent + 12 ) << "altGKInfo = " << std :: setprecision ( indent );
		m_altGKInfo -> AltGKInfo :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_integrityCheckValue ) ) {
		os << std :: setw ( indent + 22 ) << "integrityCheckValue = " << std :: setprecision ( indent );
		m_integrityCheckValue -> ICV :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_featureSet ) ) {
		os << std :: setw ( indent + 13 ) << "featureSet = " << std :: setprecision ( indent );
		m_featureSet -> FeatureSet :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_genericData ) ) {
		os << std :: setw ( indent + 14 ) << "genericData = " << std :: setprecision ( indent );
		m_genericData -> ArrayOf_GenericData :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_assignedGatekeeper ) ) {
		os << std :: setw ( indent + 21 ) << "assignedGatekeeper = " << std :: setprecision ( indent );
		m_assignedGatekeeper -> AlternateGK :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RegistrationReject * RegistrationReject :: clone ( ) const {
	return new RegistrationReject ( * this );
}

//
// AdmissionReject
//

AdmissionReject :: AdmissionReject ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 9 ), m_requestSeqNum ( is ), m_rejectReason ( is ), m_nonStandardData ( 0 ), m_altGKInfo ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_callSignalAddress ( 0 ), m_integrityCheckValue ( 0 ), m_serviceControl ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ), m_assignedGatekeeper ( 0 ) {
	try {
		if ( hasOptionalField ( e_nonStandardData ) )
			m_nonStandardData = new NonStandardParameter ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_altGKInfo ) )
				m_altGKInfo = new AltGKInfo ( is );
			if ( hasKnownExtensionToDecode ( is, e_tokens ) )
				m_tokens = new ArrayOf_ClearToken ( is );
			if ( hasKnownExtensionToDecode ( is, e_cryptoTokens ) )
				m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
			if ( hasKnownExtensionToDecode ( is, e_callSignalAddress ) )
				m_callSignalAddress = new ArrayOf_TransportAddress ( is );
			if ( hasKnownExtensionToDecode ( is, e_integrityCheckValue ) )
				m_integrityCheckValue = new ICV ( is );
			if ( hasKnownExtensionToDecode ( is, e_serviceControl ) )
				m_serviceControl = new ArrayOf_ServiceControlSession ( is );
			if ( hasKnownExtensionToDecode ( is, e_featureSet ) )
				m_featureSet = new FeatureSet ( is );
			if ( hasKnownExtensionToDecode ( is, e_genericData ) )
				m_genericData = new ArrayOf_GenericData ( is );
			if ( hasKnownExtensionToDecode ( is, e_assignedGatekeeper ) )
				m_assignedGatekeeper = new AlternateGK ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_altGKInfo;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_callSignalAddress;
		delete m_integrityCheckValue;
		delete m_serviceControl;
		delete m_featureSet;
		delete m_genericData;
		delete m_assignedGatekeeper;
		throw;
	}
}

AdmissionReject :: AdmissionReject ( ) : Asn :: Sequence ( 1, true, 9 ), m_nonStandardData ( 0 ), m_altGKInfo ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_callSignalAddress ( 0 ), m_integrityCheckValue ( 0 ), m_serviceControl ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ), m_assignedGatekeeper ( 0 ) { }

AdmissionReject & AdmissionReject :: operator= ( const AdmissionReject & s ) {
	Asn :: Sequence :: operator= ( s );
	m_requestSeqNum = s.m_requestSeqNum;
	m_rejectReason = s.m_rejectReason;
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	assignCopy ( m_altGKInfo, s.m_altGKInfo );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_callSignalAddress, s.m_callSignalAddress );
	assignCopy ( m_integrityCheckValue, s.m_integrityCheckValue );
	assignCopy ( m_serviceControl, s.m_serviceControl );
	assignCopy ( m_featureSet, s.m_featureSet );
	assignCopy ( m_genericData, s.m_genericData );
	assignCopy ( m_assignedGatekeeper, s.m_assignedGatekeeper );
	return * this;
}

AdmissionReject :: AdmissionReject ( const AdmissionReject & s ) : Asn :: Sequence ( s ), m_requestSeqNum ( s.m_requestSeqNum ), m_rejectReason ( s.m_rejectReason ), m_nonStandardData ( 0 ), m_altGKInfo ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_callSignalAddress ( 0 ), m_integrityCheckValue ( 0 ), m_serviceControl ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ), m_assignedGatekeeper ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_altGKInfo )
			m_altGKInfo = new AltGKInfo ( * s.m_altGKInfo );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_callSignalAddress )
			m_callSignalAddress = new ArrayOf_TransportAddress ( * s.m_callSignalAddress );
		if ( s.m_integrityCheckValue )
			m_integrityCheckValue = new ICV ( * s.m_integrityCheckValue );
		if ( s.m_serviceControl )
			m_serviceControl = new ArrayOf_ServiceControlSession ( * s.m_serviceControl );
		if ( s.m_featureSet )
			m_featureSet = new FeatureSet ( * s.m_featureSet );
		if ( s.m_genericData )
			m_genericData = new ArrayOf_GenericData ( * s.m_genericData );
		if ( s.m_assignedGatekeeper )
			m_assignedGatekeeper = new AlternateGK ( * s.m_assignedGatekeeper );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_altGKInfo;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_callSignalAddress;
		delete m_integrityCheckValue;
		delete m_serviceControl;
		delete m_featureSet;
		delete m_genericData;
		delete m_assignedGatekeeper;
		throw;
	}
}


void AdmissionReject :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_altGKInfo:
			assignNew ( m_altGKInfo, new AltGKInfo );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_callSignalAddress:
			assignNew ( m_callSignalAddress, new ArrayOf_TransportAddress );
			break;
		case e_integrityCheckValue:
			assignNew ( m_integrityCheckValue, new ICV );
			break;
		case e_serviceControl:
			assignNew ( m_serviceControl, new ArrayOf_ServiceControlSession );
			break;
		case e_featureSet:
			assignNew ( m_featureSet, new FeatureSet );
			break;
		case e_genericData:
			assignNew ( m_genericData, new ArrayOf_GenericData );
			break;
		case e_assignedGatekeeper:
			assignNew ( m_assignedGatekeeper, new AlternateGK );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void AdmissionReject :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_altGKInfo:
			delete m_altGKInfo;
			m_altGKInfo = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_callSignalAddress:
			delete m_callSignalAddress;
			m_callSignalAddress = 0;
			break;
		case e_integrityCheckValue:
			delete m_integrityCheckValue;
			m_integrityCheckValue = 0;
			break;
		case e_serviceControl:
			delete m_serviceControl;
			m_serviceControl = 0;
			break;
		case e_featureSet:
			delete m_featureSet;
			m_featureSet = 0;
			break;
		case e_genericData:
			delete m_genericData;
			m_genericData = 0;
			break;
		case e_assignedGatekeeper:
			delete m_assignedGatekeeper;
			m_assignedGatekeeper = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void AdmissionReject :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_requestSeqNum.encode ( os );
	m_rejectReason.encode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_altGKInfo, m_altGKInfo );
		knownExtensionEncode ( os, e_tokens, m_tokens );
		knownExtensionEncode ( os, e_cryptoTokens, m_cryptoTokens );
		knownExtensionEncode ( os, e_callSignalAddress, m_callSignalAddress );
		knownExtensionEncode ( os, e_integrityCheckValue, m_integrityCheckValue );
		knownExtensionEncode ( os, e_serviceControl, m_serviceControl );
		knownExtensionEncode ( os, e_featureSet, m_featureSet );
		knownExtensionEncode ( os, e_genericData, m_genericData );
		knownExtensionEncode ( os, e_assignedGatekeeper, m_assignedGatekeeper );
		unknownExtensionsEncode ( os );
	}
}

AdmissionReject :: ~AdmissionReject ( ) {
	delete m_nonStandardData;
	delete m_altGKInfo;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_callSignalAddress;
	delete m_integrityCheckValue;
	delete m_serviceControl;
	delete m_featureSet;
	delete m_genericData;
	delete m_assignedGatekeeper;
}

void AdmissionReject :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "requestSeqNum = " << std :: setprecision ( indent ) << m_requestSeqNum << '\n';
	os << std :: setw ( indent + 15 ) << "rejectReason = " << std :: setprecision ( indent ) << m_rejectReason << '\n';
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_altGKInfo ) ) {
		os << std :: setw ( indent + 12 ) << "altGKInfo = " << std :: setprecision ( indent );
		m_altGKInfo -> AltGKInfo :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_callSignalAddress ) ) {
		os << std :: setw ( indent + 20 ) << "callSignalAddress = " << std :: setprecision ( indent );
		m_callSignalAddress -> ArrayOf_TransportAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_integrityCheckValue ) ) {
		os << std :: setw ( indent + 22 ) << "integrityCheckValue = " << std :: setprecision ( indent );
		m_integrityCheckValue -> ICV :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_serviceControl ) ) {
		os << std :: setw ( indent + 17 ) << "serviceControl = " << std :: setprecision ( indent );
		m_serviceControl -> ArrayOf_ServiceControlSession :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_featureSet ) ) {
		os << std :: setw ( indent + 13 ) << "featureSet = " << std :: setprecision ( indent );
		m_featureSet -> FeatureSet :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_genericData ) ) {
		os << std :: setw ( indent + 14 ) << "genericData = " << std :: setprecision ( indent );
		m_genericData -> ArrayOf_GenericData :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_assignedGatekeeper ) ) {
		os << std :: setw ( indent + 21 ) << "assignedGatekeeper = " << std :: setprecision ( indent );
		m_assignedGatekeeper -> AlternateGK :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

AdmissionReject * AdmissionReject :: clone ( ) const {
	return new AdmissionReject ( * this );
}

//
// LocationReject
//

LocationReject :: LocationReject ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 7 ), m_requestSeqNum ( is ), m_rejectReason ( is ), m_nonStandardData ( 0 ), m_altGKInfo ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ), m_serviceControl ( 0 ) {
	try {
		if ( hasOptionalField ( e_nonStandardData ) )
			m_nonStandardData = new NonStandardParameter ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_altGKInfo ) )
				m_altGKInfo = new AltGKInfo ( is );
			if ( hasKnownExtensionToDecode ( is, e_tokens ) )
				m_tokens = new ArrayOf_ClearToken ( is );
			if ( hasKnownExtensionToDecode ( is, e_cryptoTokens ) )
				m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
			if ( hasKnownExtensionToDecode ( is, e_integrityCheckValue ) )
				m_integrityCheckValue = new ICV ( is );
			if ( hasKnownExtensionToDecode ( is, e_featureSet ) )
				m_featureSet = new FeatureSet ( is );
			if ( hasKnownExtensionToDecode ( is, e_genericData ) )
				m_genericData = new ArrayOf_GenericData ( is );
			if ( hasKnownExtensionToDecode ( is, e_serviceControl ) )
				m_serviceControl = new ArrayOf_ServiceControlSession ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_altGKInfo;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_featureSet;
		delete m_genericData;
		delete m_serviceControl;
		throw;
	}
}

LocationReject :: LocationReject ( ) : Asn :: Sequence ( 1, true, 7 ), m_nonStandardData ( 0 ), m_altGKInfo ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ), m_serviceControl ( 0 ) { }

LocationReject & LocationReject :: operator= ( const LocationReject & s ) {
	Asn :: Sequence :: operator= ( s );
	m_requestSeqNum = s.m_requestSeqNum;
	m_rejectReason = s.m_rejectReason;
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	assignCopy ( m_altGKInfo, s.m_altGKInfo );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_integrityCheckValue, s.m_integrityCheckValue );
	assignCopy ( m_featureSet, s.m_featureSet );
	assignCopy ( m_genericData, s.m_genericData );
	assignCopy ( m_serviceControl, s.m_serviceControl );
	return * this;
}

LocationReject :: LocationReject ( const LocationReject & s ) : Asn :: Sequence ( s ), m_requestSeqNum ( s.m_requestSeqNum ), m_rejectReason ( s.m_rejectReason ), m_nonStandardData ( 0 ), m_altGKInfo ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ), m_serviceControl ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_altGKInfo )
			m_altGKInfo = new AltGKInfo ( * s.m_altGKInfo );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_integrityCheckValue )
			m_integrityCheckValue = new ICV ( * s.m_integrityCheckValue );
		if ( s.m_featureSet )
			m_featureSet = new FeatureSet ( * s.m_featureSet );
		if ( s.m_genericData )
			m_genericData = new ArrayOf_GenericData ( * s.m_genericData );
		if ( s.m_serviceControl )
			m_serviceControl = new ArrayOf_ServiceControlSession ( * s.m_serviceControl );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_altGKInfo;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_featureSet;
		delete m_genericData;
		delete m_serviceControl;
		throw;
	}
}


void LocationReject :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_altGKInfo:
			assignNew ( m_altGKInfo, new AltGKInfo );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_integrityCheckValue:
			assignNew ( m_integrityCheckValue, new ICV );
			break;
		case e_featureSet:
			assignNew ( m_featureSet, new FeatureSet );
			break;
		case e_genericData:
			assignNew ( m_genericData, new ArrayOf_GenericData );
			break;
		case e_serviceControl:
			assignNew ( m_serviceControl, new ArrayOf_ServiceControlSession );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void LocationReject :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_altGKInfo:
			delete m_altGKInfo;
			m_altGKInfo = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_integrityCheckValue:
			delete m_integrityCheckValue;
			m_integrityCheckValue = 0;
			break;
		case e_featureSet:
			delete m_featureSet;
			m_featureSet = 0;
			break;
		case e_genericData:
			delete m_genericData;
			m_genericData = 0;
			break;
		case e_serviceControl:
			delete m_serviceControl;
			m_serviceControl = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void LocationReject :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_requestSeqNum.encode ( os );
	m_rejectReason.encode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_altGKInfo, m_altGKInfo );
		knownExtensionEncode ( os, e_tokens, m_tokens );
		knownExtensionEncode ( os, e_cryptoTokens, m_cryptoTokens );
		knownExtensionEncode ( os, e_integrityCheckValue, m_integrityCheckValue );
		knownExtensionEncode ( os, e_featureSet, m_featureSet );
		knownExtensionEncode ( os, e_genericData, m_genericData );
		knownExtensionEncode ( os, e_serviceControl, m_serviceControl );
		unknownExtensionsEncode ( os );
	}
}

LocationReject :: ~LocationReject ( ) {
	delete m_nonStandardData;
	delete m_altGKInfo;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_integrityCheckValue;
	delete m_featureSet;
	delete m_genericData;
	delete m_serviceControl;
}

void LocationReject :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "requestSeqNum = " << std :: setprecision ( indent ) << m_requestSeqNum << '\n';
	os << std :: setw ( indent + 15 ) << "rejectReason = " << std :: setprecision ( indent ) << m_rejectReason << '\n';
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_altGKInfo ) ) {
		os << std :: setw ( indent + 12 ) << "altGKInfo = " << std :: setprecision ( indent );
		m_altGKInfo -> AltGKInfo :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_integrityCheckValue ) ) {
		os << std :: setw ( indent + 22 ) << "integrityCheckValue = " << std :: setprecision ( indent );
		m_integrityCheckValue -> ICV :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_featureSet ) ) {
		os << std :: setw ( indent + 13 ) << "featureSet = " << std :: setprecision ( indent );
		m_featureSet -> FeatureSet :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_genericData ) ) {
		os << std :: setw ( indent + 14 ) << "genericData = " << std :: setprecision ( indent );
		m_genericData -> ArrayOf_GenericData :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_serviceControl ) ) {
		os << std :: setw ( indent + 17 ) << "serviceControl = " << std :: setprecision ( indent );
		m_serviceControl -> ArrayOf_ServiceControlSession :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

LocationReject * LocationReject :: clone ( ) const {
	return new LocationReject ( * this );
}

//
// NonStandardMessage
//

NonStandardMessage :: NonStandardMessage ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 5 ), m_requestSeqNum ( is ), m_nonStandardData ( is ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ) {
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_tokens ) )
				m_tokens = new ArrayOf_ClearToken ( is );
			if ( hasKnownExtensionToDecode ( is, e_cryptoTokens ) )
				m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
			if ( hasKnownExtensionToDecode ( is, e_integrityCheckValue ) )
				m_integrityCheckValue = new ICV ( is );
			if ( hasKnownExtensionToDecode ( is, e_featureSet ) )
				m_featureSet = new FeatureSet ( is );
			if ( hasKnownExtensionToDecode ( is, e_genericData ) )
				m_genericData = new ArrayOf_GenericData ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_featureSet;
		delete m_genericData;
		throw;
	}
}

NonStandardMessage :: NonStandardMessage ( ) : Asn :: Sequence ( 0, true, 5 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ) { }

NonStandardMessage & NonStandardMessage :: operator= ( const NonStandardMessage & s ) {
	Asn :: Sequence :: operator= ( s );
	m_requestSeqNum = s.m_requestSeqNum;
	m_nonStandardData = s.m_nonStandardData;
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_integrityCheckValue, s.m_integrityCheckValue );
	assignCopy ( m_featureSet, s.m_featureSet );
	assignCopy ( m_genericData, s.m_genericData );
	return * this;
}

NonStandardMessage :: NonStandardMessage ( const NonStandardMessage & s ) : Asn :: Sequence ( s ), m_requestSeqNum ( s.m_requestSeqNum ), m_nonStandardData ( s.m_nonStandardData ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ) {
	try {
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_integrityCheckValue )
			m_integrityCheckValue = new ICV ( * s.m_integrityCheckValue );
		if ( s.m_featureSet )
			m_featureSet = new FeatureSet ( * s.m_featureSet );
		if ( s.m_genericData )
			m_genericData = new ArrayOf_GenericData ( * s.m_genericData );
	} catch ( ... ) {
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_featureSet;
		delete m_genericData;
		throw;
	}
}


void NonStandardMessage :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_integrityCheckValue:
			assignNew ( m_integrityCheckValue, new ICV );
			break;
		case e_featureSet:
			assignNew ( m_featureSet, new FeatureSet );
			break;
		case e_genericData:
			assignNew ( m_genericData, new ArrayOf_GenericData );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void NonStandardMessage :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_integrityCheckValue:
			delete m_integrityCheckValue;
			m_integrityCheckValue = 0;
			break;
		case e_featureSet:
			delete m_featureSet;
			m_featureSet = 0;
			break;
		case e_genericData:
			delete m_genericData;
			m_genericData = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void NonStandardMessage :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_requestSeqNum.encode ( os );
	m_nonStandardData.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_tokens, m_tokens );
		knownExtensionEncode ( os, e_cryptoTokens, m_cryptoTokens );
		knownExtensionEncode ( os, e_integrityCheckValue, m_integrityCheckValue );
		knownExtensionEncode ( os, e_featureSet, m_featureSet );
		knownExtensionEncode ( os, e_genericData, m_genericData );
		unknownExtensionsEncode ( os );
	}
}

NonStandardMessage :: ~NonStandardMessage ( ) {
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_integrityCheckValue;
	delete m_featureSet;
	delete m_genericData;
}

void NonStandardMessage :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "requestSeqNum = " << std :: setprecision ( indent ) << m_requestSeqNum << '\n';
	os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent ) << m_nonStandardData << '\n';
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_integrityCheckValue ) ) {
		os << std :: setw ( indent + 22 ) << "integrityCheckValue = " << std :: setprecision ( indent );
		m_integrityCheckValue -> ICV :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_featureSet ) ) {
		os << std :: setw ( indent + 13 ) << "featureSet = " << std :: setprecision ( indent );
		m_featureSet -> FeatureSet :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_genericData ) ) {
		os << std :: setw ( indent + 14 ) << "genericData = " << std :: setprecision ( indent );
		m_genericData -> ArrayOf_GenericData :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

NonStandardMessage * NonStandardMessage :: clone ( ) const {
	return new NonStandardMessage ( * this );
}

//
// H323-UU-PDU_tunnelledSignallingMessage
//

H323_UU_PDU_tunnelledSignallingMessage :: H323_UU_PDU_tunnelledSignallingMessage ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 0 ), m_tunnelledProtocolID ( is ), m_messageContent ( is ), m_tunnellingRequired ( 0 ), m_nonStandardData ( 0 ) {
	try {
		if ( hasOptionalField ( e_tunnellingRequired ) )
			m_tunnellingRequired = new Asn :: Null ( is );
		if ( hasOptionalField ( e_nonStandardData ) )
			m_nonStandardData = new NonStandardParameter ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_tunnellingRequired;
		delete m_nonStandardData;
		throw;
	}
}

H323_UU_PDU_tunnelledSignallingMessage :: H323_UU_PDU_tunnelledSignallingMessage ( ) : Asn :: Sequence ( 2, true, 0 ), m_tunnellingRequired ( 0 ), m_nonStandardData ( 0 ) { }

H323_UU_PDU_tunnelledSignallingMessage & H323_UU_PDU_tunnelledSignallingMessage :: operator= ( const H323_UU_PDU_tunnelledSignallingMessage & s ) {
	Asn :: Sequence :: operator= ( s );
	m_tunnelledProtocolID = s.m_tunnelledProtocolID;
	m_messageContent = s.m_messageContent;
	assignCopy ( m_tunnellingRequired, s.m_tunnellingRequired );
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	return * this;
}

H323_UU_PDU_tunnelledSignallingMessage :: H323_UU_PDU_tunnelledSignallingMessage ( const H323_UU_PDU_tunnelledSignallingMessage & s ) : Asn :: Sequence ( s ), m_tunnelledProtocolID ( s.m_tunnelledProtocolID ), m_messageContent ( s.m_messageContent ), m_tunnellingRequired ( 0 ), m_nonStandardData ( 0 ) {
	try {
		if ( s.m_tunnellingRequired )
			m_tunnellingRequired = new Asn :: Null ( * s.m_tunnellingRequired );
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
	} catch ( ... ) {
		delete m_tunnellingRequired;
		delete m_nonStandardData;
		throw;
	}
}


void H323_UU_PDU_tunnelledSignallingMessage :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_tunnellingRequired:
			assignNew ( m_tunnellingRequired, new Asn :: Null );
			break;
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void H323_UU_PDU_tunnelledSignallingMessage :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_tunnellingRequired:
			delete m_tunnellingRequired;
			m_tunnellingRequired = 0;
			break;
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void H323_UU_PDU_tunnelledSignallingMessage :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_tunnelledProtocolID.encode ( os );
	m_messageContent.encode ( os );
	if ( hasOptionalField ( e_tunnellingRequired ) )
		m_tunnellingRequired -> Asn :: Null :: encode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

H323_UU_PDU_tunnelledSignallingMessage :: ~H323_UU_PDU_tunnelledSignallingMessage ( ) {
	delete m_tunnellingRequired;
	delete m_nonStandardData;
}

void H323_UU_PDU_tunnelledSignallingMessage :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 22 ) << "tunnelledProtocolID = " << std :: setprecision ( indent ) << m_tunnelledProtocolID << '\n';
	os << std :: setw ( indent + 17 ) << "messageContent = " << std :: setprecision ( indent ) << m_messageContent << '\n';
	if ( hasOptionalField ( e_tunnellingRequired ) ) {
		os << std :: setw ( indent + 21 ) << "tunnellingRequired = " << std :: setprecision ( indent );
		m_tunnellingRequired -> Asn :: Null :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H323_UU_PDU_tunnelledSignallingMessage * H323_UU_PDU_tunnelledSignallingMessage :: clone ( ) const {
	return new H323_UU_PDU_tunnelledSignallingMessage ( * this );
}

//
// AddressPattern_range
//

AddressPattern_range :: AddressPattern_range ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, false, 0 ), m_startOfRange ( is ), m_endOfRange ( is ) {
}

AddressPattern_range :: AddressPattern_range ( ) : Asn :: Sequence ( 0, false, 0 ) { }

void AddressPattern_range :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_startOfRange.encode ( os );
	m_endOfRange.encode ( os );
}

void AddressPattern_range :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 15 ) << "startOfRange = " << std :: setprecision ( indent ) << m_startOfRange << '\n';
	os << std :: setw ( indent + 13 ) << "endOfRange = " << std :: setprecision ( indent ) << m_endOfRange << '\n';
	os << std :: setw ( indent - 1 ) << '}';
}

AddressPattern_range * AddressPattern_range :: clone ( ) const {
	return new AddressPattern_range ( * this );
}

//
// InfoRequestResponse_perCallInfo_subtype_pdu_subtype
//

InfoRequestResponse_perCallInfo_subtype_pdu_subtype :: InfoRequestResponse_perCallInfo_subtype_pdu_subtype ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, false, 0 ), m_h323pdu ( is ), m_sent ( is ) {
}

InfoRequestResponse_perCallInfo_subtype_pdu_subtype :: InfoRequestResponse_perCallInfo_subtype_pdu_subtype ( ) : Asn :: Sequence ( 0, false, 0 ) { }

void InfoRequestResponse_perCallInfo_subtype_pdu_subtype :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_h323pdu.encode ( os );
	m_sent.encode ( os );
}

void InfoRequestResponse_perCallInfo_subtype_pdu_subtype :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 10 ) << "h323pdu = " << std :: setprecision ( indent ) << m_h323pdu << '\n';
	os << std :: setw ( indent + 7 ) << "sent = " << std :: setprecision ( indent ) << m_sent << '\n';
	os << std :: setw ( indent - 1 ) << '}';
}

InfoRequestResponse_perCallInfo_subtype_pdu_subtype * InfoRequestResponse_perCallInfo_subtype_pdu_subtype :: clone ( ) const {
	return new InfoRequestResponse_perCallInfo_subtype_pdu_subtype ( * this );
}

//
// H323-UserInformation
//

H323_UserInformation :: H323_UserInformation ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_h323_uu_pdu ( is ), m_user_data ( 0 ) {
	try {
		if ( hasOptionalField ( e_user_data ) )
			m_user_data = new H323_UserInformation_user_data ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_user_data;
		throw;
	}
}

H323_UserInformation :: H323_UserInformation ( ) : Asn :: Sequence ( 1, true, 0 ), m_user_data ( 0 ) { }

H323_UserInformation & H323_UserInformation :: operator= ( const H323_UserInformation & s ) {
	Asn :: Sequence :: operator= ( s );
	m_h323_uu_pdu = s.m_h323_uu_pdu;
	assignCopy ( m_user_data, s.m_user_data );
	return * this;
}

H323_UserInformation :: H323_UserInformation ( const H323_UserInformation & s ) : Asn :: Sequence ( s ), m_h323_uu_pdu ( s.m_h323_uu_pdu ), m_user_data ( 0 ) {
	try {
		if ( s.m_user_data )
			m_user_data = new H323_UserInformation_user_data ( * s.m_user_data );
	} catch ( ... ) {
		delete m_user_data;
		throw;
	}
}


void H323_UserInformation :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_user_data:
			assignNew ( m_user_data, new H323_UserInformation_user_data );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void H323_UserInformation :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_user_data:
			delete m_user_data;
			m_user_data = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void H323_UserInformation :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_h323_uu_pdu.encode ( os );
	if ( hasOptionalField ( e_user_data ) )
		m_user_data -> H323_UserInformation_user_data :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

H323_UserInformation :: ~H323_UserInformation ( ) {
	delete m_user_data;
}

void H323_UserInformation :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 14 ) << "h323_uu_pdu = " << std :: setprecision ( indent ) << m_h323_uu_pdu << '\n';
	if ( hasOptionalField ( e_user_data ) ) {
		os << std :: setw ( indent + 12 ) << "user_data = " << std :: setprecision ( indent );
		m_user_data -> H323_UserInformation_user_data :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H323_UserInformation * H323_UserInformation :: clone ( ) const {
	return new H323_UserInformation ( * this );
}

//
// ReleaseCompleteReason
//

ReleaseCompleteReason :: ReleaseCompleteReason ( Asn :: istream & is ) : Asn :: Choice ( is, 12, true ) {
	switch ( tag ) {
		case e_noBandwidth:
		case e_gatekeeperResources:
		case e_unreachableDestination:
		case e_destinationRejection:
		case e_invalidRevision:
		case e_noPermission:
		case e_unreachableGatekeeper:
		case e_gatewayResources:
		case e_badFormatAddress:
		case e_adaptiveBusy:
		case e_inConf:
		case e_undefinedReason:
		case e_facilityCallDeflection:
		case e_securityDenied:
		case e_calledPartyNotRegistered:
		case e_callerNotRegistered:
		case e_newConnectionNeeded:
		case e_genericDataReason:
		case e_neededFeatureNotSupported:
		case e_tunnelledSignallingRejected:
		case e_invalidCID:
		case e_hopCountExceeded:
			choice = new Asn :: Null ( is );
			break;
		case e_nonStandardReason:
			choice = new NonStandardParameter ( is );
			break;
		case e_replaceWithConferenceInvite:
			choice = new ConferenceIdentifier ( is );
			break;
		case e_securityError:
			choice = new SecurityErrors ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

ReleaseCompleteReason :: ReleaseCompleteReason ( ) : Asn :: Choice ( 12, true ) { }

void ReleaseCompleteReason :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_noBandwidth:
		case e_gatekeeperResources:
		case e_unreachableDestination:
		case e_destinationRejection:
		case e_invalidRevision:
		case e_noPermission:
		case e_unreachableGatekeeper:
		case e_gatewayResources:
		case e_badFormatAddress:
		case e_adaptiveBusy:
		case e_inConf:
		case e_undefinedReason:
		case e_facilityCallDeflection:
		case e_securityDenied:
		case e_calledPartyNotRegistered:
		case e_callerNotRegistered:
		case e_newConnectionNeeded:
		case e_genericDataReason:
		case e_neededFeatureNotSupported:
		case e_tunnelledSignallingRejected:
		case e_invalidCID:
		case e_hopCountExceeded:
			o = new Asn :: Null;
			break;
		case e_nonStandardReason:
			o = new NonStandardParameter;
			break;
		case e_replaceWithConferenceInvite:
			o = new ConferenceIdentifier;
			break;
		case e_securityError:
			o = new SecurityErrors;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & ReleaseCompleteReason :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_noBandwidth, "noBandwidth" },
		{ e_gatekeeperResources, "gatekeeperResources" },
		{ e_unreachableDestination, "unreachableDestination" },
		{ e_destinationRejection, "destinationRejection" },
		{ e_invalidRevision, "invalidRevision" },
		{ e_noPermission, "noPermission" },
		{ e_unreachableGatekeeper, "unreachableGatekeeper" },
		{ e_gatewayResources, "gatewayResources" },
		{ e_badFormatAddress, "badFormatAddress" },
		{ e_adaptiveBusy, "adaptiveBusy" },
		{ e_inConf, "inConf" },
		{ e_undefinedReason, "undefinedReason" },
		{ e_facilityCallDeflection, "facilityCallDeflection" },
		{ e_securityDenied, "securityDenied" },
		{ e_calledPartyNotRegistered, "calledPartyNotRegistered" },
		{ e_callerNotRegistered, "callerNotRegistered" },
		{ e_newConnectionNeeded, "newConnectionNeeded" },
		{ e_nonStandardReason, "nonStandardReason" },
		{ e_replaceWithConferenceInvite, "replaceWithConferenceInvite" },
		{ e_genericDataReason, "genericDataReason" },
		{ e_neededFeatureNotSupported, "neededFeatureNotSupported" },
		{ e_tunnelledSignallingRejected, "tunnelledSignallingRejected" },
		{ e_invalidCID, "invalidCID" },
		{ e_securityError, "securityError" },
		{ e_hopCountExceeded, "hopCountExceeded" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

ReleaseCompleteReason * ReleaseCompleteReason :: clone ( ) const {
	return new ReleaseCompleteReason ( * this );
}

//
// TransportAddress
//

TransportAddress :: TransportAddress ( Asn :: istream & is ) : Asn :: Choice ( is, 7, true ) {
	switch ( tag ) {
		case e_ipAddress:
			choice = new TransportAddress_ipAddress ( is );
			break;
		case e_ipSourceRoute:
			choice = new TransportAddress_ipSourceRoute ( is );
			break;
		case e_ipxAddress:
			choice = new TransportAddress_ipxAddress ( is );
			break;
		case e_ip6Address:
			choice = new TransportAddress_ip6Address ( is );
			break;
		case e_netBios:
			choice = new TransportAddress_netBios ( is );
			break;
		case e_nsap:
			choice = new TransportAddress_nsap ( is );
			break;
		case e_nonStandardAddress:
			choice = new NonStandardParameter ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

TransportAddress :: TransportAddress ( ) : Asn :: Choice ( 7, true ) { }

void TransportAddress :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_ipAddress:
			o = new TransportAddress_ipAddress;
			break;
		case e_ipSourceRoute:
			o = new TransportAddress_ipSourceRoute;
			break;
		case e_ipxAddress:
			o = new TransportAddress_ipxAddress;
			break;
		case e_ip6Address:
			o = new TransportAddress_ip6Address;
			break;
		case e_netBios:
			o = new TransportAddress_netBios;
			break;
		case e_nsap:
			o = new TransportAddress_nsap;
			break;
		case e_nonStandardAddress:
			o = new NonStandardParameter;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & TransportAddress :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_ipAddress, "ipAddress" },
		{ e_ipSourceRoute, "ipSourceRoute" },
		{ e_ipxAddress, "ipxAddress" },
		{ e_ip6Address, "ip6Address" },
		{ e_netBios, "netBios" },
		{ e_nsap, "nsap" },
		{ e_nonStandardAddress, "nonStandardAddress" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

TransportAddress * TransportAddress :: clone ( ) const {
	return new TransportAddress ( * this );
}

//
// SupportedProtocols
//

SupportedProtocols :: SupportedProtocols ( Asn :: istream & is ) : Asn :: Choice ( is, 9, true ) {
	switch ( tag ) {
		case e_nonStandardData:
			choice = new NonStandardParameter ( is );
			break;
		case e_h310:
			choice = new H310Caps ( is );
			break;
		case e_h320:
			choice = new H320Caps ( is );
			break;
		case e_h321:
			choice = new H321Caps ( is );
			break;
		case e_h322:
			choice = new H322Caps ( is );
			break;
		case e_h323:
			choice = new H323Caps ( is );
			break;
		case e_h324:
			choice = new H324Caps ( is );
			break;
		case e_voice:
			choice = new VoiceCaps ( is );
			break;
		case e_t120_only:
			choice = new T120OnlyCaps ( is );
			break;
		case e_nonStandardProtocol:
			choice = new NonStandardProtocol ( is );
			break;
		case e_t38FaxAnnexbOnly:
			choice = new T38FaxAnnexbOnlyCaps ( is );
			break;
		case e_sip:
			choice = new SIPCaps ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

SupportedProtocols :: SupportedProtocols ( ) : Asn :: Choice ( 9, true ) { }

void SupportedProtocols :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandardData:
			o = new NonStandardParameter;
			break;
		case e_h310:
			o = new H310Caps;
			break;
		case e_h320:
			o = new H320Caps;
			break;
		case e_h321:
			o = new H321Caps;
			break;
		case e_h322:
			o = new H322Caps;
			break;
		case e_h323:
			o = new H323Caps;
			break;
		case e_h324:
			o = new H324Caps;
			break;
		case e_voice:
			o = new VoiceCaps;
			break;
		case e_t120_only:
			o = new T120OnlyCaps;
			break;
		case e_nonStandardProtocol:
			o = new NonStandardProtocol;
			break;
		case e_t38FaxAnnexbOnly:
			o = new T38FaxAnnexbOnlyCaps;
			break;
		case e_sip:
			o = new SIPCaps;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & SupportedProtocols :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandardData, "nonStandardData" },
		{ e_h310, "h310" },
		{ e_h320, "h320" },
		{ e_h321, "h321" },
		{ e_h322, "h322" },
		{ e_h323, "h323" },
		{ e_h324, "h324" },
		{ e_voice, "voice" },
		{ e_t120_only, "t120_only" },
		{ e_nonStandardProtocol, "nonStandardProtocol" },
		{ e_t38FaxAnnexbOnly, "t38FaxAnnexbOnly" },
		{ e_sip, "sip" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

SupportedProtocols * SupportedProtocols :: clone ( ) const {
	return new SupportedProtocols ( * this );
}

//
// MobileUIM
//

MobileUIM :: MobileUIM ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_ansi_41_uim:
			choice = new ANSI_41_UIM ( is );
			break;
		case e_gsm_uim:
			choice = new GSM_UIM ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

MobileUIM :: MobileUIM ( ) : Asn :: Choice ( 2, true ) { }

void MobileUIM :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_ansi_41_uim:
			o = new ANSI_41_UIM;
			break;
		case e_gsm_uim:
			o = new GSM_UIM;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & MobileUIM :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_ansi_41_uim, "ansi_41_uim" },
		{ e_gsm_uim, "gsm_uim" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

MobileUIM * MobileUIM :: clone ( ) const {
	return new MobileUIM ( * this );
}

//
// AlternateGK
//

AlternateGK :: AlternateGK ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_rasAddress ( is ), m_gatekeeperIdentifier ( hasOptionalField ( e_gatekeeperIdentifier ) ? pushTemporaryMember ( new GatekeeperIdentifier ( is ) ) : 0 ), m_needToRegister ( is ), m_priority ( is ) {
	clearTemporaryMembers ( );
	try {
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_gatekeeperIdentifier;
		throw;
	}
}

AlternateGK :: AlternateGK ( ) : Asn :: Sequence ( 1, true, 0 ), m_gatekeeperIdentifier ( 0 ) { }

AlternateGK & AlternateGK :: operator= ( const AlternateGK & s ) {
	Asn :: Sequence :: operator= ( s );
	m_rasAddress = s.m_rasAddress;
	assignCopy ( m_gatekeeperIdentifier, s.m_gatekeeperIdentifier );
	m_needToRegister = s.m_needToRegister;
	m_priority = s.m_priority;
	return * this;
}

AlternateGK :: AlternateGK ( const AlternateGK & s ) : Asn :: Sequence ( s ), m_rasAddress ( s.m_rasAddress ), m_gatekeeperIdentifier ( 0 ), m_needToRegister ( s.m_needToRegister ), m_priority ( s.m_priority ) {
	try {
		if ( s.m_gatekeeperIdentifier )
			m_gatekeeperIdentifier = new GatekeeperIdentifier ( * s.m_gatekeeperIdentifier );
	} catch ( ... ) {
		delete m_gatekeeperIdentifier;
		throw;
	}
}


void AlternateGK :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_gatekeeperIdentifier:
			assignNew ( m_gatekeeperIdentifier, new GatekeeperIdentifier );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void AlternateGK :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_gatekeeperIdentifier:
			delete m_gatekeeperIdentifier;
			m_gatekeeperIdentifier = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void AlternateGK :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_rasAddress.encode ( os );
	if ( hasOptionalField ( e_gatekeeperIdentifier ) )
		m_gatekeeperIdentifier -> GatekeeperIdentifier :: encode ( os );
	m_needToRegister.encode ( os );
	m_priority.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

AlternateGK :: ~AlternateGK ( ) {
	delete m_gatekeeperIdentifier;
}

void AlternateGK :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 13 ) << "rasAddress = " << std :: setprecision ( indent ) << m_rasAddress << '\n';
	if ( hasOptionalField ( e_gatekeeperIdentifier ) ) {
		os << std :: setw ( indent + 23 ) << "gatekeeperIdentifier = " << std :: setprecision ( indent );
		m_gatekeeperIdentifier -> GatekeeperIdentifier :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 17 ) << "needToRegister = " << std :: setprecision ( indent ) << m_needToRegister << '\n';
	os << std :: setw ( indent + 11 ) << "priority = " << std :: setprecision ( indent ) << m_priority << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

AlternateGK * AlternateGK :: clone ( ) const {
	return new AlternateGK ( * this );
}

//
// FeatureDescriptor
//

FeatureDescriptor :: FeatureDescriptor ( Asn :: istream & is ) : GenericData ( is ) { }

FeatureDescriptor :: FeatureDescriptor ( ) : GenericData ( ) { }

FeatureDescriptor * FeatureDescriptor :: clone ( ) const {
	return new FeatureDescriptor ( * this );
}

//
// CallTerminationCause
//

CallTerminationCause :: CallTerminationCause ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_releaseCompleteReason:
			choice = new ReleaseCompleteReason ( is );
			break;
		case e_releaseCompleteCauseIE:
			choice = new CallTerminationCause_releaseCompleteCauseIE ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

CallTerminationCause :: CallTerminationCause ( ) : Asn :: Choice ( 2, true ) { }

void CallTerminationCause :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_releaseCompleteReason:
			o = new ReleaseCompleteReason;
			break;
		case e_releaseCompleteCauseIE:
			o = new CallTerminationCause_releaseCompleteCauseIE;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & CallTerminationCause :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_releaseCompleteReason, "releaseCompleteReason" },
		{ e_releaseCompleteCauseIE, "releaseCompleteCauseIE" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

CallTerminationCause * CallTerminationCause :: clone ( ) const {
	return new CallTerminationCause ( * this );
}

//
// GatekeeperRequest
//

GatekeeperRequest :: GatekeeperRequest ( Asn :: istream & is ) : Asn :: Sequence ( is, 4, true, 12 ), m_requestSeqNum ( is ), m_protocolIdentifier ( is ), m_nonStandardData ( hasOptionalField ( e_nonStandardData ) ? pushTemporaryMember ( new NonStandardParameter ( is ) ) : 0 ), m_rasAddress ( is ), m_endpointType ( is ), m_gatekeeperIdentifier ( 0 ), m_callServices ( 0 ), m_endpointAlias ( 0 ), m_alternateEndpoints ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_authenticationCapability ( 0 ), m_algorithmOIDs ( 0 ), m_integrity ( 0 ), m_integrityCheckValue ( 0 ), m_supportsAltGK ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ), m_supportsAssignedGK ( 0 ), m_assignedGatekeeper ( 0 ) {
	clearTemporaryMembers ( );
	try {
		if ( hasOptionalField ( e_gatekeeperIdentifier ) )
			m_gatekeeperIdentifier = new GatekeeperIdentifier ( is );
		if ( hasOptionalField ( e_callServices ) )
			m_callServices = new QseriesOptions ( is );
		if ( hasOptionalField ( e_endpointAlias ) )
			m_endpointAlias = new ArrayOf_AliasAddress ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_alternateEndpoints ) )
				m_alternateEndpoints = new ArrayOf_Endpoint ( is );
			if ( hasKnownExtensionToDecode ( is, e_tokens ) )
				m_tokens = new ArrayOf_ClearToken ( is );
			if ( hasKnownExtensionToDecode ( is, e_cryptoTokens ) )
				m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
			if ( hasKnownExtensionToDecode ( is, e_authenticationCapability ) )
				m_authenticationCapability = new ArrayOf_AuthenticationMechanism ( is );
			if ( hasKnownExtensionToDecode ( is, e_algorithmOIDs ) )
				m_algorithmOIDs = new ArrayOf_Asn_ObjectId ( is );
			if ( hasKnownExtensionToDecode ( is, e_integrity ) )
				m_integrity = new ArrayOf_IntegrityMechanism ( is );
			if ( hasKnownExtensionToDecode ( is, e_integrityCheckValue ) )
				m_integrityCheckValue = new ICV ( is );
			if ( hasKnownExtensionToDecode ( is, e_supportsAltGK ) )
				m_supportsAltGK = new Asn :: Null ( is );
			if ( hasKnownExtensionToDecode ( is, e_featureSet ) )
				m_featureSet = new FeatureSet ( is );
			if ( hasKnownExtensionToDecode ( is, e_genericData ) )
				m_genericData = new ArrayOf_GenericData ( is );
			if ( hasKnownExtensionToDecode ( is, e_supportsAssignedGK ) )
				m_supportsAssignedGK = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_assignedGatekeeper ) )
				m_assignedGatekeeper = new AlternateGK ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_gatekeeperIdentifier;
		delete m_callServices;
		delete m_endpointAlias;
		delete m_alternateEndpoints;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_authenticationCapability;
		delete m_algorithmOIDs;
		delete m_integrity;
		delete m_integrityCheckValue;
		delete m_supportsAltGK;
		delete m_featureSet;
		delete m_genericData;
		delete m_supportsAssignedGK;
		delete m_assignedGatekeeper;
		throw;
	}
}

GatekeeperRequest :: GatekeeperRequest ( ) : Asn :: Sequence ( 4, true, 12 ), m_nonStandardData ( 0 ), m_gatekeeperIdentifier ( 0 ), m_callServices ( 0 ), m_endpointAlias ( 0 ), m_alternateEndpoints ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_authenticationCapability ( 0 ), m_algorithmOIDs ( 0 ), m_integrity ( 0 ), m_integrityCheckValue ( 0 ), m_supportsAltGK ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ), m_supportsAssignedGK ( 0 ), m_assignedGatekeeper ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_supportsAssignedGK );
		m_supportsAssignedGK = new Asn :: Boolean;
	} catch ( ... ) {
		delete m_supportsAssignedGK;
		throw;
	}
}

GatekeeperRequest & GatekeeperRequest :: operator= ( const GatekeeperRequest & s ) {
	Asn :: Sequence :: operator= ( s );
	m_requestSeqNum = s.m_requestSeqNum;
	m_protocolIdentifier = s.m_protocolIdentifier;
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	m_rasAddress = s.m_rasAddress;
	m_endpointType = s.m_endpointType;
	assignCopy ( m_gatekeeperIdentifier, s.m_gatekeeperIdentifier );
	assignCopy ( m_callServices, s.m_callServices );
	assignCopy ( m_endpointAlias, s.m_endpointAlias );
	assignCopy ( m_alternateEndpoints, s.m_alternateEndpoints );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_authenticationCapability, s.m_authenticationCapability );
	assignCopy ( m_algorithmOIDs, s.m_algorithmOIDs );
	assignCopy ( m_integrity, s.m_integrity );
	assignCopy ( m_integrityCheckValue, s.m_integrityCheckValue );
	assignCopy ( m_supportsAltGK, s.m_supportsAltGK );
	assignCopy ( m_featureSet, s.m_featureSet );
	assignCopy ( m_genericData, s.m_genericData );
	assignCopy ( m_supportsAssignedGK, s.m_supportsAssignedGK );
	assignCopy ( m_assignedGatekeeper, s.m_assignedGatekeeper );
	return * this;
}

GatekeeperRequest :: GatekeeperRequest ( const GatekeeperRequest & s ) : Asn :: Sequence ( s ), m_requestSeqNum ( s.m_requestSeqNum ), m_protocolIdentifier ( s.m_protocolIdentifier ), m_nonStandardData ( 0 ), m_rasAddress ( s.m_rasAddress ), m_endpointType ( s.m_endpointType ), m_gatekeeperIdentifier ( 0 ), m_callServices ( 0 ), m_endpointAlias ( 0 ), m_alternateEndpoints ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_authenticationCapability ( 0 ), m_algorithmOIDs ( 0 ), m_integrity ( 0 ), m_integrityCheckValue ( 0 ), m_supportsAltGK ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ), m_supportsAssignedGK ( 0 ), m_assignedGatekeeper ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_gatekeeperIdentifier )
			m_gatekeeperIdentifier = new GatekeeperIdentifier ( * s.m_gatekeeperIdentifier );
		if ( s.m_callServices )
			m_callServices = new QseriesOptions ( * s.m_callServices );
		if ( s.m_endpointAlias )
			m_endpointAlias = new ArrayOf_AliasAddress ( * s.m_endpointAlias );
		if ( s.m_alternateEndpoints )
			m_alternateEndpoints = new ArrayOf_Endpoint ( * s.m_alternateEndpoints );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_authenticationCapability )
			m_authenticationCapability = new ArrayOf_AuthenticationMechanism ( * s.m_authenticationCapability );
		if ( s.m_algorithmOIDs )
			m_algorithmOIDs = new ArrayOf_Asn_ObjectId ( * s.m_algorithmOIDs );
		if ( s.m_integrity )
			m_integrity = new ArrayOf_IntegrityMechanism ( * s.m_integrity );
		if ( s.m_integrityCheckValue )
			m_integrityCheckValue = new ICV ( * s.m_integrityCheckValue );
		if ( s.m_supportsAltGK )
			m_supportsAltGK = new Asn :: Null ( * s.m_supportsAltGK );
		if ( s.m_featureSet )
			m_featureSet = new FeatureSet ( * s.m_featureSet );
		if ( s.m_genericData )
			m_genericData = new ArrayOf_GenericData ( * s.m_genericData );
		if ( s.m_supportsAssignedGK )
			m_supportsAssignedGK = new Asn :: Boolean ( * s.m_supportsAssignedGK );
		if ( s.m_assignedGatekeeper )
			m_assignedGatekeeper = new AlternateGK ( * s.m_assignedGatekeeper );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_gatekeeperIdentifier;
		delete m_callServices;
		delete m_endpointAlias;
		delete m_alternateEndpoints;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_authenticationCapability;
		delete m_algorithmOIDs;
		delete m_integrity;
		delete m_integrityCheckValue;
		delete m_supportsAltGK;
		delete m_featureSet;
		delete m_genericData;
		delete m_supportsAssignedGK;
		delete m_assignedGatekeeper;
		throw;
	}
}


void GatekeeperRequest :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_gatekeeperIdentifier:
			assignNew ( m_gatekeeperIdentifier, new GatekeeperIdentifier );
			break;
		case e_callServices:
			assignNew ( m_callServices, new QseriesOptions );
			break;
		case e_endpointAlias:
			assignNew ( m_endpointAlias, new ArrayOf_AliasAddress );
			break;
		case e_alternateEndpoints:
			assignNew ( m_alternateEndpoints, new ArrayOf_Endpoint );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_authenticationCapability:
			assignNew ( m_authenticationCapability, new ArrayOf_AuthenticationMechanism );
			break;
		case e_algorithmOIDs:
			assignNew ( m_algorithmOIDs, new ArrayOf_Asn_ObjectId );
			break;
		case e_integrity:
			assignNew ( m_integrity, new ArrayOf_IntegrityMechanism );
			break;
		case e_integrityCheckValue:
			assignNew ( m_integrityCheckValue, new ICV );
			break;
		case e_supportsAltGK:
			assignNew ( m_supportsAltGK, new Asn :: Null );
			break;
		case e_featureSet:
			assignNew ( m_featureSet, new FeatureSet );
			break;
		case e_genericData:
			assignNew ( m_genericData, new ArrayOf_GenericData );
			break;
		case e_supportsAssignedGK:
			assignNew ( m_supportsAssignedGK, new Asn :: Boolean );
			break;
		case e_assignedGatekeeper:
			assignNew ( m_assignedGatekeeper, new AlternateGK );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void GatekeeperRequest :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_gatekeeperIdentifier:
			delete m_gatekeeperIdentifier;
			m_gatekeeperIdentifier = 0;
			break;
		case e_callServices:
			delete m_callServices;
			m_callServices = 0;
			break;
		case e_endpointAlias:
			delete m_endpointAlias;
			m_endpointAlias = 0;
			break;
		case e_alternateEndpoints:
			delete m_alternateEndpoints;
			m_alternateEndpoints = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_authenticationCapability:
			delete m_authenticationCapability;
			m_authenticationCapability = 0;
			break;
		case e_algorithmOIDs:
			delete m_algorithmOIDs;
			m_algorithmOIDs = 0;
			break;
		case e_integrity:
			delete m_integrity;
			m_integrity = 0;
			break;
		case e_integrityCheckValue:
			delete m_integrityCheckValue;
			m_integrityCheckValue = 0;
			break;
		case e_supportsAltGK:
			delete m_supportsAltGK;
			m_supportsAltGK = 0;
			break;
		case e_featureSet:
			delete m_featureSet;
			m_featureSet = 0;
			break;
		case e_genericData:
			delete m_genericData;
			m_genericData = 0;
			break;
		case e_supportsAssignedGK:
			delete m_supportsAssignedGK;
			m_supportsAssignedGK = 0;
			break;
		case e_assignedGatekeeper:
			delete m_assignedGatekeeper;
			m_assignedGatekeeper = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void GatekeeperRequest :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_requestSeqNum.encode ( os );
	m_protocolIdentifier.encode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	m_rasAddress.encode ( os );
	m_endpointType.encode ( os );
	if ( hasOptionalField ( e_gatekeeperIdentifier ) )
		m_gatekeeperIdentifier -> GatekeeperIdentifier :: encode ( os );
	if ( hasOptionalField ( e_callServices ) )
		m_callServices -> QseriesOptions :: encode ( os );
	if ( hasOptionalField ( e_endpointAlias ) )
		m_endpointAlias -> ArrayOf_AliasAddress :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_alternateEndpoints, m_alternateEndpoints );
		knownExtensionEncode ( os, e_tokens, m_tokens );
		knownExtensionEncode ( os, e_cryptoTokens, m_cryptoTokens );
		knownExtensionEncode ( os, e_authenticationCapability, m_authenticationCapability );
		knownExtensionEncode ( os, e_algorithmOIDs, m_algorithmOIDs );
		knownExtensionEncode ( os, e_integrity, m_integrity );
		knownExtensionEncode ( os, e_integrityCheckValue, m_integrityCheckValue );
		knownExtensionEncode ( os, e_supportsAltGK, m_supportsAltGK );
		knownExtensionEncode ( os, e_featureSet, m_featureSet );
		knownExtensionEncode ( os, e_genericData, m_genericData );
		knownExtensionEncode ( os, e_supportsAssignedGK, m_supportsAssignedGK );
		knownExtensionEncode ( os, e_assignedGatekeeper, m_assignedGatekeeper );
		unknownExtensionsEncode ( os );
	}
}

GatekeeperRequest :: ~GatekeeperRequest ( ) {
	delete m_nonStandardData;
	delete m_gatekeeperIdentifier;
	delete m_callServices;
	delete m_endpointAlias;
	delete m_alternateEndpoints;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_authenticationCapability;
	delete m_algorithmOIDs;
	delete m_integrity;
	delete m_integrityCheckValue;
	delete m_supportsAltGK;
	delete m_featureSet;
	delete m_genericData;
	delete m_supportsAssignedGK;
	delete m_assignedGatekeeper;
}

void GatekeeperRequest :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "requestSeqNum = " << std :: setprecision ( indent ) << m_requestSeqNum << '\n';
	os << std :: setw ( indent + 21 ) << "protocolIdentifier = " << std :: setprecision ( indent ) << m_protocolIdentifier << '\n';
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 13 ) << "rasAddress = " << std :: setprecision ( indent ) << m_rasAddress << '\n';
	os << std :: setw ( indent + 15 ) << "endpointType = " << std :: setprecision ( indent ) << m_endpointType << '\n';
	if ( hasOptionalField ( e_gatekeeperIdentifier ) ) {
		os << std :: setw ( indent + 23 ) << "gatekeeperIdentifier = " << std :: setprecision ( indent );
		m_gatekeeperIdentifier -> GatekeeperIdentifier :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_callServices ) ) {
		os << std :: setw ( indent + 15 ) << "callServices = " << std :: setprecision ( indent );
		m_callServices -> QseriesOptions :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_endpointAlias ) ) {
		os << std :: setw ( indent + 16 ) << "endpointAlias = " << std :: setprecision ( indent );
		m_endpointAlias -> ArrayOf_AliasAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_alternateEndpoints ) ) {
		os << std :: setw ( indent + 21 ) << "alternateEndpoints = " << std :: setprecision ( indent );
		m_alternateEndpoints -> ArrayOf_Endpoint :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_authenticationCapability ) ) {
		os << std :: setw ( indent + 27 ) << "authenticationCapability = " << std :: setprecision ( indent );
		m_authenticationCapability -> ArrayOf_AuthenticationMechanism :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_algorithmOIDs ) ) {
		os << std :: setw ( indent + 16 ) << "algorithmOIDs = " << std :: setprecision ( indent );
		m_algorithmOIDs -> ArrayOf_Asn_ObjectId :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_integrity ) ) {
		os << std :: setw ( indent + 12 ) << "integrity = " << std :: setprecision ( indent );
		m_integrity -> ArrayOf_IntegrityMechanism :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_integrityCheckValue ) ) {
		os << std :: setw ( indent + 22 ) << "integrityCheckValue = " << std :: setprecision ( indent );
		m_integrityCheckValue -> ICV :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_supportsAltGK ) ) {
		os << std :: setw ( indent + 16 ) << "supportsAltGK = " << std :: setprecision ( indent );
		m_supportsAltGK -> Asn :: Null :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_featureSet ) ) {
		os << std :: setw ( indent + 13 ) << "featureSet = " << std :: setprecision ( indent );
		m_featureSet -> FeatureSet :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_genericData ) ) {
		os << std :: setw ( indent + 14 ) << "genericData = " << std :: setprecision ( indent );
		m_genericData -> ArrayOf_GenericData :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_supportsAssignedGK ) ) {
		os << std :: setw ( indent + 21 ) << "supportsAssignedGK = " << std :: setprecision ( indent );
		m_supportsAssignedGK -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_assignedGatekeeper ) ) {
		os << std :: setw ( indent + 21 ) << "assignedGatekeeper = " << std :: setprecision ( indent );
		m_assignedGatekeeper -> AlternateGK :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

GatekeeperRequest * GatekeeperRequest :: clone ( ) const {
	return new GatekeeperRequest ( * this );
}

//
// GatekeeperConfirm
//

GatekeeperConfirm :: GatekeeperConfirm ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 11 ), m_requestSeqNum ( is ), m_protocolIdentifier ( is ), m_nonStandardData ( hasOptionalField ( e_nonStandardData ) ? pushTemporaryMember ( new NonStandardParameter ( is ) ) : 0 ), m_gatekeeperIdentifier ( hasOptionalField ( e_gatekeeperIdentifier ) ? pushTemporaryMember ( new GatekeeperIdentifier ( is ) ) : 0 ), m_rasAddress ( is ), m_alternateGatekeeper ( 0 ), m_authenticationMode ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_algorithmOID ( 0 ), m_integrity ( 0 ), m_integrityCheckValue ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ), m_assignedGatekeeper ( 0 ), m_rehomingModel ( 0 ) {
	clearTemporaryMembers ( );
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_alternateGatekeeper ) )
				m_alternateGatekeeper = new ArrayOf_AlternateGK ( is );
			if ( hasKnownExtensionToDecode ( is, e_authenticationMode ) )
				m_authenticationMode = new H235 :: AuthenticationMechanism ( is );
			if ( hasKnownExtensionToDecode ( is, e_tokens ) )
				m_tokens = new ArrayOf_ClearToken ( is );
			if ( hasKnownExtensionToDecode ( is, e_cryptoTokens ) )
				m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
			if ( hasKnownExtensionToDecode ( is, e_algorithmOID ) )
				m_algorithmOID = new Asn :: ObjectId ( is );
			if ( hasKnownExtensionToDecode ( is, e_integrity ) )
				m_integrity = new ArrayOf_IntegrityMechanism ( is );
			if ( hasKnownExtensionToDecode ( is, e_integrityCheckValue ) )
				m_integrityCheckValue = new ICV ( is );
			if ( hasKnownExtensionToDecode ( is, e_featureSet ) )
				m_featureSet = new FeatureSet ( is );
			if ( hasKnownExtensionToDecode ( is, e_genericData ) )
				m_genericData = new ArrayOf_GenericData ( is );
			if ( hasKnownExtensionToDecode ( is, e_assignedGatekeeper ) )
				m_assignedGatekeeper = new AlternateGK ( is );
			if ( hasKnownExtensionToDecode ( is, e_rehomingModel ) )
				m_rehomingModel = new RehomingModel ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_gatekeeperIdentifier;
		delete m_alternateGatekeeper;
		delete m_authenticationMode;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_algorithmOID;
		delete m_integrity;
		delete m_integrityCheckValue;
		delete m_featureSet;
		delete m_genericData;
		delete m_assignedGatekeeper;
		delete m_rehomingModel;
		throw;
	}
}

GatekeeperConfirm :: GatekeeperConfirm ( ) : Asn :: Sequence ( 2, true, 11 ), m_nonStandardData ( 0 ), m_gatekeeperIdentifier ( 0 ), m_alternateGatekeeper ( 0 ), m_authenticationMode ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_algorithmOID ( 0 ), m_integrity ( 0 ), m_integrityCheckValue ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ), m_assignedGatekeeper ( 0 ), m_rehomingModel ( 0 ) { }

GatekeeperConfirm & GatekeeperConfirm :: operator= ( const GatekeeperConfirm & s ) {
	Asn :: Sequence :: operator= ( s );
	m_requestSeqNum = s.m_requestSeqNum;
	m_protocolIdentifier = s.m_protocolIdentifier;
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	assignCopy ( m_gatekeeperIdentifier, s.m_gatekeeperIdentifier );
	m_rasAddress = s.m_rasAddress;
	assignCopy ( m_alternateGatekeeper, s.m_alternateGatekeeper );
	assignCopy ( m_authenticationMode, s.m_authenticationMode );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_algorithmOID, s.m_algorithmOID );
	assignCopy ( m_integrity, s.m_integrity );
	assignCopy ( m_integrityCheckValue, s.m_integrityCheckValue );
	assignCopy ( m_featureSet, s.m_featureSet );
	assignCopy ( m_genericData, s.m_genericData );
	assignCopy ( m_assignedGatekeeper, s.m_assignedGatekeeper );
	assignCopy ( m_rehomingModel, s.m_rehomingModel );
	return * this;
}

GatekeeperConfirm :: GatekeeperConfirm ( const GatekeeperConfirm & s ) : Asn :: Sequence ( s ), m_requestSeqNum ( s.m_requestSeqNum ), m_protocolIdentifier ( s.m_protocolIdentifier ), m_nonStandardData ( 0 ), m_gatekeeperIdentifier ( 0 ), m_rasAddress ( s.m_rasAddress ), m_alternateGatekeeper ( 0 ), m_authenticationMode ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_algorithmOID ( 0 ), m_integrity ( 0 ), m_integrityCheckValue ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ), m_assignedGatekeeper ( 0 ), m_rehomingModel ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_gatekeeperIdentifier )
			m_gatekeeperIdentifier = new GatekeeperIdentifier ( * s.m_gatekeeperIdentifier );
		if ( s.m_alternateGatekeeper )
			m_alternateGatekeeper = new ArrayOf_AlternateGK ( * s.m_alternateGatekeeper );
		if ( s.m_authenticationMode )
			m_authenticationMode = new H235 :: AuthenticationMechanism ( * s.m_authenticationMode );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_algorithmOID )
			m_algorithmOID = new Asn :: ObjectId ( * s.m_algorithmOID );
		if ( s.m_integrity )
			m_integrity = new ArrayOf_IntegrityMechanism ( * s.m_integrity );
		if ( s.m_integrityCheckValue )
			m_integrityCheckValue = new ICV ( * s.m_integrityCheckValue );
		if ( s.m_featureSet )
			m_featureSet = new FeatureSet ( * s.m_featureSet );
		if ( s.m_genericData )
			m_genericData = new ArrayOf_GenericData ( * s.m_genericData );
		if ( s.m_assignedGatekeeper )
			m_assignedGatekeeper = new AlternateGK ( * s.m_assignedGatekeeper );
		if ( s.m_rehomingModel )
			m_rehomingModel = new RehomingModel ( * s.m_rehomingModel );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_gatekeeperIdentifier;
		delete m_alternateGatekeeper;
		delete m_authenticationMode;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_algorithmOID;
		delete m_integrity;
		delete m_integrityCheckValue;
		delete m_featureSet;
		delete m_genericData;
		delete m_assignedGatekeeper;
		delete m_rehomingModel;
		throw;
	}
}


void GatekeeperConfirm :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_gatekeeperIdentifier:
			assignNew ( m_gatekeeperIdentifier, new GatekeeperIdentifier );
			break;
		case e_alternateGatekeeper:
			assignNew ( m_alternateGatekeeper, new ArrayOf_AlternateGK );
			break;
		case e_authenticationMode:
			assignNew ( m_authenticationMode, new H235 :: AuthenticationMechanism );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_algorithmOID:
			assignNew ( m_algorithmOID, new Asn :: ObjectId );
			break;
		case e_integrity:
			assignNew ( m_integrity, new ArrayOf_IntegrityMechanism );
			break;
		case e_integrityCheckValue:
			assignNew ( m_integrityCheckValue, new ICV );
			break;
		case e_featureSet:
			assignNew ( m_featureSet, new FeatureSet );
			break;
		case e_genericData:
			assignNew ( m_genericData, new ArrayOf_GenericData );
			break;
		case e_assignedGatekeeper:
			assignNew ( m_assignedGatekeeper, new AlternateGK );
			break;
		case e_rehomingModel:
			assignNew ( m_rehomingModel, new RehomingModel );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void GatekeeperConfirm :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_gatekeeperIdentifier:
			delete m_gatekeeperIdentifier;
			m_gatekeeperIdentifier = 0;
			break;
		case e_alternateGatekeeper:
			delete m_alternateGatekeeper;
			m_alternateGatekeeper = 0;
			break;
		case e_authenticationMode:
			delete m_authenticationMode;
			m_authenticationMode = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_algorithmOID:
			delete m_algorithmOID;
			m_algorithmOID = 0;
			break;
		case e_integrity:
			delete m_integrity;
			m_integrity = 0;
			break;
		case e_integrityCheckValue:
			delete m_integrityCheckValue;
			m_integrityCheckValue = 0;
			break;
		case e_featureSet:
			delete m_featureSet;
			m_featureSet = 0;
			break;
		case e_genericData:
			delete m_genericData;
			m_genericData = 0;
			break;
		case e_assignedGatekeeper:
			delete m_assignedGatekeeper;
			m_assignedGatekeeper = 0;
			break;
		case e_rehomingModel:
			delete m_rehomingModel;
			m_rehomingModel = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void GatekeeperConfirm :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_requestSeqNum.encode ( os );
	m_protocolIdentifier.encode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( hasOptionalField ( e_gatekeeperIdentifier ) )
		m_gatekeeperIdentifier -> GatekeeperIdentifier :: encode ( os );
	m_rasAddress.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_alternateGatekeeper, m_alternateGatekeeper );
		knownExtensionEncode ( os, e_authenticationMode, m_authenticationMode );
		knownExtensionEncode ( os, e_tokens, m_tokens );
		knownExtensionEncode ( os, e_cryptoTokens, m_cryptoTokens );
		knownExtensionEncode ( os, e_algorithmOID, m_algorithmOID );
		knownExtensionEncode ( os, e_integrity, m_integrity );
		knownExtensionEncode ( os, e_integrityCheckValue, m_integrityCheckValue );
		knownExtensionEncode ( os, e_featureSet, m_featureSet );
		knownExtensionEncode ( os, e_genericData, m_genericData );
		knownExtensionEncode ( os, e_assignedGatekeeper, m_assignedGatekeeper );
		knownExtensionEncode ( os, e_rehomingModel, m_rehomingModel );
		unknownExtensionsEncode ( os );
	}
}

GatekeeperConfirm :: ~GatekeeperConfirm ( ) {
	delete m_nonStandardData;
	delete m_gatekeeperIdentifier;
	delete m_alternateGatekeeper;
	delete m_authenticationMode;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_algorithmOID;
	delete m_integrity;
	delete m_integrityCheckValue;
	delete m_featureSet;
	delete m_genericData;
	delete m_assignedGatekeeper;
	delete m_rehomingModel;
}

void GatekeeperConfirm :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "requestSeqNum = " << std :: setprecision ( indent ) << m_requestSeqNum << '\n';
	os << std :: setw ( indent + 21 ) << "protocolIdentifier = " << std :: setprecision ( indent ) << m_protocolIdentifier << '\n';
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_gatekeeperIdentifier ) ) {
		os << std :: setw ( indent + 23 ) << "gatekeeperIdentifier = " << std :: setprecision ( indent );
		m_gatekeeperIdentifier -> GatekeeperIdentifier :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 13 ) << "rasAddress = " << std :: setprecision ( indent ) << m_rasAddress << '\n';
	if ( hasOptionalField ( e_alternateGatekeeper ) ) {
		os << std :: setw ( indent + 22 ) << "alternateGatekeeper = " << std :: setprecision ( indent );
		m_alternateGatekeeper -> ArrayOf_AlternateGK :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_authenticationMode ) ) {
		os << std :: setw ( indent + 21 ) << "authenticationMode = " << std :: setprecision ( indent );
		m_authenticationMode -> H235 :: AuthenticationMechanism :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_algorithmOID ) ) {
		os << std :: setw ( indent + 15 ) << "algorithmOID = " << std :: setprecision ( indent );
		m_algorithmOID -> Asn :: ObjectId :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_integrity ) ) {
		os << std :: setw ( indent + 12 ) << "integrity = " << std :: setprecision ( indent );
		m_integrity -> ArrayOf_IntegrityMechanism :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_integrityCheckValue ) ) {
		os << std :: setw ( indent + 22 ) << "integrityCheckValue = " << std :: setprecision ( indent );
		m_integrityCheckValue -> ICV :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_featureSet ) ) {
		os << std :: setw ( indent + 13 ) << "featureSet = " << std :: setprecision ( indent );
		m_featureSet -> FeatureSet :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_genericData ) ) {
		os << std :: setw ( indent + 14 ) << "genericData = " << std :: setprecision ( indent );
		m_genericData -> ArrayOf_GenericData :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_assignedGatekeeper ) ) {
		os << std :: setw ( indent + 21 ) << "assignedGatekeeper = " << std :: setprecision ( indent );
		m_assignedGatekeeper -> AlternateGK :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_rehomingModel ) ) {
		os << std :: setw ( indent + 16 ) << "rehomingModel = " << std :: setprecision ( indent );
		m_rehomingModel -> RehomingModel :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

GatekeeperConfirm * GatekeeperConfirm :: clone ( ) const {
	return new GatekeeperConfirm ( * this );
}

//
// AdmissionConfirm
//

AdmissionConfirm :: AdmissionConfirm ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 23 ), m_requestSeqNum ( is ), m_bandWidth ( is ), m_callModel ( is ), m_destCallSignalAddress ( is ), m_irrFrequency ( 0 ), m_nonStandardData ( 0 ), m_destinationInfo ( 0 ), m_destExtraCallInfo ( 0 ), m_destinationType ( 0 ), m_remoteExtensionAddress ( 0 ), m_alternateEndpoints ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_transportQOS ( 0 ), m_willRespondToIRR ( 0 ), m_uuiesRequested ( 0 ), m_language ( 0 ), m_alternateTransportAddresses ( 0 ), m_useSpecifiedTransport ( 0 ), m_circuitInfo ( 0 ), m_usageSpec ( 0 ), m_supportedProtocols ( 0 ), m_serviceControl ( 0 ), m_multipleCalls ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ), m_modifiedSrcInfo ( 0 ), m_assignedGatekeeper ( 0 ) {
	try {
		if ( hasOptionalField ( e_irrFrequency ) )
			m_irrFrequency = new AdmissionConfirm_irrFrequency ( is );
		if ( hasOptionalField ( e_nonStandardData ) )
			m_nonStandardData = new NonStandardParameter ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_destinationInfo ) )
				m_destinationInfo = new ArrayOf_AliasAddress ( is );
			if ( hasKnownExtensionToDecode ( is, e_destExtraCallInfo ) )
				m_destExtraCallInfo = new ArrayOf_AliasAddress ( is );
			if ( hasKnownExtensionToDecode ( is, e_destinationType ) )
				m_destinationType = new EndpointType ( is );
			if ( hasKnownExtensionToDecode ( is, e_remoteExtensionAddress ) )
				m_remoteExtensionAddress = new ArrayOf_AliasAddress ( is );
			if ( hasKnownExtensionToDecode ( is, e_alternateEndpoints ) )
				m_alternateEndpoints = new ArrayOf_Endpoint ( is );
			if ( hasKnownExtensionToDecode ( is, e_tokens ) )
				m_tokens = new ArrayOf_ClearToken ( is );
			if ( hasKnownExtensionToDecode ( is, e_cryptoTokens ) )
				m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
			if ( hasKnownExtensionToDecode ( is, e_integrityCheckValue ) )
				m_integrityCheckValue = new ICV ( is );
			if ( hasKnownExtensionToDecode ( is, e_transportQOS ) )
				m_transportQOS = new TransportQOS ( is );
			if ( hasKnownExtensionToDecode ( is, e_willRespondToIRR ) )
				m_willRespondToIRR = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_uuiesRequested ) )
				m_uuiesRequested = new UUIEsRequested ( is );
			if ( hasKnownExtensionToDecode ( is, e_language ) )
				m_language = new AdmissionConfirm_language ( is );
			if ( hasKnownExtensionToDecode ( is, e_alternateTransportAddresses ) )
				m_alternateTransportAddresses = new AlternateTransportAddresses ( is );
			if ( hasKnownExtensionToDecode ( is, e_useSpecifiedTransport ) )
				m_useSpecifiedTransport = new UseSpecifiedTransport ( is );
			if ( hasKnownExtensionToDecode ( is, e_circuitInfo ) )
				m_circuitInfo = new CircuitInfo ( is );
			if ( hasKnownExtensionToDecode ( is, e_usageSpec ) )
				m_usageSpec = new ArrayOf_RasUsageSpecification ( is );
			if ( hasKnownExtensionToDecode ( is, e_supportedProtocols ) )
				m_supportedProtocols = new ArrayOf_SupportedProtocols ( is );
			if ( hasKnownExtensionToDecode ( is, e_serviceControl ) )
				m_serviceControl = new ArrayOf_ServiceControlSession ( is );
			if ( hasKnownExtensionToDecode ( is, e_multipleCalls ) )
				m_multipleCalls = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_featureSet ) )
				m_featureSet = new FeatureSet ( is );
			if ( hasKnownExtensionToDecode ( is, e_genericData ) )
				m_genericData = new ArrayOf_GenericData ( is );
			if ( hasKnownExtensionToDecode ( is, e_modifiedSrcInfo ) )
				m_modifiedSrcInfo = new ArrayOf_AliasAddress ( is );
			if ( hasKnownExtensionToDecode ( is, e_assignedGatekeeper ) )
				m_assignedGatekeeper = new AlternateGK ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_irrFrequency;
		delete m_nonStandardData;
		delete m_destinationInfo;
		delete m_destExtraCallInfo;
		delete m_destinationType;
		delete m_remoteExtensionAddress;
		delete m_alternateEndpoints;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_transportQOS;
		delete m_willRespondToIRR;
		delete m_uuiesRequested;
		delete m_language;
		delete m_alternateTransportAddresses;
		delete m_useSpecifiedTransport;
		delete m_circuitInfo;
		delete m_usageSpec;
		delete m_supportedProtocols;
		delete m_serviceControl;
		delete m_multipleCalls;
		delete m_featureSet;
		delete m_genericData;
		delete m_modifiedSrcInfo;
		delete m_assignedGatekeeper;
		throw;
	}
}

AdmissionConfirm :: AdmissionConfirm ( ) : Asn :: Sequence ( 2, true, 23 ), m_irrFrequency ( 0 ), m_nonStandardData ( 0 ), m_destinationInfo ( 0 ), m_destExtraCallInfo ( 0 ), m_destinationType ( 0 ), m_remoteExtensionAddress ( 0 ), m_alternateEndpoints ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_transportQOS ( 0 ), m_willRespondToIRR ( 0 ), m_uuiesRequested ( 0 ), m_language ( 0 ), m_alternateTransportAddresses ( 0 ), m_useSpecifiedTransport ( 0 ), m_circuitInfo ( 0 ), m_usageSpec ( 0 ), m_supportedProtocols ( 0 ), m_serviceControl ( 0 ), m_multipleCalls ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ), m_modifiedSrcInfo ( 0 ), m_assignedGatekeeper ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_willRespondToIRR );
		m_willRespondToIRR = new Asn :: Boolean;
		Asn :: Sequence :: includeOptionalField ( e_uuiesRequested );
		m_uuiesRequested = new UUIEsRequested;
	} catch ( ... ) {
		delete m_willRespondToIRR;
		delete m_uuiesRequested;
		throw;
	}
}

AdmissionConfirm & AdmissionConfirm :: operator= ( const AdmissionConfirm & s ) {
	Asn :: Sequence :: operator= ( s );
	m_requestSeqNum = s.m_requestSeqNum;
	m_bandWidth = s.m_bandWidth;
	m_callModel = s.m_callModel;
	m_destCallSignalAddress = s.m_destCallSignalAddress;
	assignCopy ( m_irrFrequency, s.m_irrFrequency );
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	assignCopy ( m_destinationInfo, s.m_destinationInfo );
	assignCopy ( m_destExtraCallInfo, s.m_destExtraCallInfo );
	assignCopy ( m_destinationType, s.m_destinationType );
	assignCopy ( m_remoteExtensionAddress, s.m_remoteExtensionAddress );
	assignCopy ( m_alternateEndpoints, s.m_alternateEndpoints );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_integrityCheckValue, s.m_integrityCheckValue );
	assignCopy ( m_transportQOS, s.m_transportQOS );
	assignCopy ( m_willRespondToIRR, s.m_willRespondToIRR );
	assignCopy ( m_uuiesRequested, s.m_uuiesRequested );
	assignCopy ( m_language, s.m_language );
	assignCopy ( m_alternateTransportAddresses, s.m_alternateTransportAddresses );
	assignCopy ( m_useSpecifiedTransport, s.m_useSpecifiedTransport );
	assignCopy ( m_circuitInfo, s.m_circuitInfo );
	assignCopy ( m_usageSpec, s.m_usageSpec );
	assignCopy ( m_supportedProtocols, s.m_supportedProtocols );
	assignCopy ( m_serviceControl, s.m_serviceControl );
	assignCopy ( m_multipleCalls, s.m_multipleCalls );
	assignCopy ( m_featureSet, s.m_featureSet );
	assignCopy ( m_genericData, s.m_genericData );
	assignCopy ( m_modifiedSrcInfo, s.m_modifiedSrcInfo );
	assignCopy ( m_assignedGatekeeper, s.m_assignedGatekeeper );
	return * this;
}

AdmissionConfirm :: AdmissionConfirm ( const AdmissionConfirm & s ) : Asn :: Sequence ( s ), m_requestSeqNum ( s.m_requestSeqNum ), m_bandWidth ( s.m_bandWidth ), m_callModel ( s.m_callModel ), m_destCallSignalAddress ( s.m_destCallSignalAddress ), m_irrFrequency ( 0 ), m_nonStandardData ( 0 ), m_destinationInfo ( 0 ), m_destExtraCallInfo ( 0 ), m_destinationType ( 0 ), m_remoteExtensionAddress ( 0 ), m_alternateEndpoints ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_transportQOS ( 0 ), m_willRespondToIRR ( 0 ), m_uuiesRequested ( 0 ), m_language ( 0 ), m_alternateTransportAddresses ( 0 ), m_useSpecifiedTransport ( 0 ), m_circuitInfo ( 0 ), m_usageSpec ( 0 ), m_supportedProtocols ( 0 ), m_serviceControl ( 0 ), m_multipleCalls ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ), m_modifiedSrcInfo ( 0 ), m_assignedGatekeeper ( 0 ) {
	try {
		if ( s.m_irrFrequency )
			m_irrFrequency = new AdmissionConfirm_irrFrequency ( * s.m_irrFrequency );
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_destinationInfo )
			m_destinationInfo = new ArrayOf_AliasAddress ( * s.m_destinationInfo );
		if ( s.m_destExtraCallInfo )
			m_destExtraCallInfo = new ArrayOf_AliasAddress ( * s.m_destExtraCallInfo );
		if ( s.m_destinationType )
			m_destinationType = new EndpointType ( * s.m_destinationType );
		if ( s.m_remoteExtensionAddress )
			m_remoteExtensionAddress = new ArrayOf_AliasAddress ( * s.m_remoteExtensionAddress );
		if ( s.m_alternateEndpoints )
			m_alternateEndpoints = new ArrayOf_Endpoint ( * s.m_alternateEndpoints );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_integrityCheckValue )
			m_integrityCheckValue = new ICV ( * s.m_integrityCheckValue );
		if ( s.m_transportQOS )
			m_transportQOS = new TransportQOS ( * s.m_transportQOS );
		if ( s.m_willRespondToIRR )
			m_willRespondToIRR = new Asn :: Boolean ( * s.m_willRespondToIRR );
		if ( s.m_uuiesRequested )
			m_uuiesRequested = new UUIEsRequested ( * s.m_uuiesRequested );
		if ( s.m_language )
			m_language = new AdmissionConfirm_language ( * s.m_language );
		if ( s.m_alternateTransportAddresses )
			m_alternateTransportAddresses = new AlternateTransportAddresses ( * s.m_alternateTransportAddresses );
		if ( s.m_useSpecifiedTransport )
			m_useSpecifiedTransport = new UseSpecifiedTransport ( * s.m_useSpecifiedTransport );
		if ( s.m_circuitInfo )
			m_circuitInfo = new CircuitInfo ( * s.m_circuitInfo );
		if ( s.m_usageSpec )
			m_usageSpec = new ArrayOf_RasUsageSpecification ( * s.m_usageSpec );
		if ( s.m_supportedProtocols )
			m_supportedProtocols = new ArrayOf_SupportedProtocols ( * s.m_supportedProtocols );
		if ( s.m_serviceControl )
			m_serviceControl = new ArrayOf_ServiceControlSession ( * s.m_serviceControl );
		if ( s.m_multipleCalls )
			m_multipleCalls = new Asn :: Boolean ( * s.m_multipleCalls );
		if ( s.m_featureSet )
			m_featureSet = new FeatureSet ( * s.m_featureSet );
		if ( s.m_genericData )
			m_genericData = new ArrayOf_GenericData ( * s.m_genericData );
		if ( s.m_modifiedSrcInfo )
			m_modifiedSrcInfo = new ArrayOf_AliasAddress ( * s.m_modifiedSrcInfo );
		if ( s.m_assignedGatekeeper )
			m_assignedGatekeeper = new AlternateGK ( * s.m_assignedGatekeeper );
	} catch ( ... ) {
		delete m_irrFrequency;
		delete m_nonStandardData;
		delete m_destinationInfo;
		delete m_destExtraCallInfo;
		delete m_destinationType;
		delete m_remoteExtensionAddress;
		delete m_alternateEndpoints;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_transportQOS;
		delete m_willRespondToIRR;
		delete m_uuiesRequested;
		delete m_language;
		delete m_alternateTransportAddresses;
		delete m_useSpecifiedTransport;
		delete m_circuitInfo;
		delete m_usageSpec;
		delete m_supportedProtocols;
		delete m_serviceControl;
		delete m_multipleCalls;
		delete m_featureSet;
		delete m_genericData;
		delete m_modifiedSrcInfo;
		delete m_assignedGatekeeper;
		throw;
	}
}


void AdmissionConfirm :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_irrFrequency:
			assignNew ( m_irrFrequency, new AdmissionConfirm_irrFrequency );
			break;
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_destinationInfo:
			assignNew ( m_destinationInfo, new ArrayOf_AliasAddress );
			break;
		case e_destExtraCallInfo:
			assignNew ( m_destExtraCallInfo, new ArrayOf_AliasAddress );
			break;
		case e_destinationType:
			assignNew ( m_destinationType, new EndpointType );
			break;
		case e_remoteExtensionAddress:
			assignNew ( m_remoteExtensionAddress, new ArrayOf_AliasAddress );
			break;
		case e_alternateEndpoints:
			assignNew ( m_alternateEndpoints, new ArrayOf_Endpoint );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_integrityCheckValue:
			assignNew ( m_integrityCheckValue, new ICV );
			break;
		case e_transportQOS:
			assignNew ( m_transportQOS, new TransportQOS );
			break;
		case e_willRespondToIRR:
			assignNew ( m_willRespondToIRR, new Asn :: Boolean );
			break;
		case e_uuiesRequested:
			assignNew ( m_uuiesRequested, new UUIEsRequested );
			break;
		case e_language:
			assignNew ( m_language, new AdmissionConfirm_language );
			break;
		case e_alternateTransportAddresses:
			assignNew ( m_alternateTransportAddresses, new AlternateTransportAddresses );
			break;
		case e_useSpecifiedTransport:
			assignNew ( m_useSpecifiedTransport, new UseSpecifiedTransport );
			break;
		case e_circuitInfo:
			assignNew ( m_circuitInfo, new CircuitInfo );
			break;
		case e_usageSpec:
			assignNew ( m_usageSpec, new ArrayOf_RasUsageSpecification );
			break;
		case e_supportedProtocols:
			assignNew ( m_supportedProtocols, new ArrayOf_SupportedProtocols );
			break;
		case e_serviceControl:
			assignNew ( m_serviceControl, new ArrayOf_ServiceControlSession );
			break;
		case e_multipleCalls:
			assignNew ( m_multipleCalls, new Asn :: Boolean );
			break;
		case e_featureSet:
			assignNew ( m_featureSet, new FeatureSet );
			break;
		case e_genericData:
			assignNew ( m_genericData, new ArrayOf_GenericData );
			break;
		case e_modifiedSrcInfo:
			assignNew ( m_modifiedSrcInfo, new ArrayOf_AliasAddress );
			break;
		case e_assignedGatekeeper:
			assignNew ( m_assignedGatekeeper, new AlternateGK );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void AdmissionConfirm :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_irrFrequency:
			delete m_irrFrequency;
			m_irrFrequency = 0;
			break;
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_destinationInfo:
			delete m_destinationInfo;
			m_destinationInfo = 0;
			break;
		case e_destExtraCallInfo:
			delete m_destExtraCallInfo;
			m_destExtraCallInfo = 0;
			break;
		case e_destinationType:
			delete m_destinationType;
			m_destinationType = 0;
			break;
		case e_remoteExtensionAddress:
			delete m_remoteExtensionAddress;
			m_remoteExtensionAddress = 0;
			break;
		case e_alternateEndpoints:
			delete m_alternateEndpoints;
			m_alternateEndpoints = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_integrityCheckValue:
			delete m_integrityCheckValue;
			m_integrityCheckValue = 0;
			break;
		case e_transportQOS:
			delete m_transportQOS;
			m_transportQOS = 0;
			break;
		case e_willRespondToIRR:
			delete m_willRespondToIRR;
			m_willRespondToIRR = 0;
			break;
		case e_uuiesRequested:
			delete m_uuiesRequested;
			m_uuiesRequested = 0;
			break;
		case e_language:
			delete m_language;
			m_language = 0;
			break;
		case e_alternateTransportAddresses:
			delete m_alternateTransportAddresses;
			m_alternateTransportAddresses = 0;
			break;
		case e_useSpecifiedTransport:
			delete m_useSpecifiedTransport;
			m_useSpecifiedTransport = 0;
			break;
		case e_circuitInfo:
			delete m_circuitInfo;
			m_circuitInfo = 0;
			break;
		case e_usageSpec:
			delete m_usageSpec;
			m_usageSpec = 0;
			break;
		case e_supportedProtocols:
			delete m_supportedProtocols;
			m_supportedProtocols = 0;
			break;
		case e_serviceControl:
			delete m_serviceControl;
			m_serviceControl = 0;
			break;
		case e_multipleCalls:
			delete m_multipleCalls;
			m_multipleCalls = 0;
			break;
		case e_featureSet:
			delete m_featureSet;
			m_featureSet = 0;
			break;
		case e_genericData:
			delete m_genericData;
			m_genericData = 0;
			break;
		case e_modifiedSrcInfo:
			delete m_modifiedSrcInfo;
			m_modifiedSrcInfo = 0;
			break;
		case e_assignedGatekeeper:
			delete m_assignedGatekeeper;
			m_assignedGatekeeper = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void AdmissionConfirm :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_requestSeqNum.encode ( os );
	m_bandWidth.encode ( os );
	m_callModel.encode ( os );
	m_destCallSignalAddress.encode ( os );
	if ( hasOptionalField ( e_irrFrequency ) )
		m_irrFrequency -> AdmissionConfirm_irrFrequency :: encode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_destinationInfo, m_destinationInfo );
		knownExtensionEncode ( os, e_destExtraCallInfo, m_destExtraCallInfo );
		knownExtensionEncode ( os, e_destinationType, m_destinationType );
		knownExtensionEncode ( os, e_remoteExtensionAddress, m_remoteExtensionAddress );
		knownExtensionEncode ( os, e_alternateEndpoints, m_alternateEndpoints );
		knownExtensionEncode ( os, e_tokens, m_tokens );
		knownExtensionEncode ( os, e_cryptoTokens, m_cryptoTokens );
		knownExtensionEncode ( os, e_integrityCheckValue, m_integrityCheckValue );
		knownExtensionEncode ( os, e_transportQOS, m_transportQOS );
		knownExtensionEncode ( os, e_willRespondToIRR, m_willRespondToIRR );
		knownExtensionEncode ( os, e_uuiesRequested, m_uuiesRequested );
		knownExtensionEncode ( os, e_language, m_language );
		knownExtensionEncode ( os, e_alternateTransportAddresses, m_alternateTransportAddresses );
		knownExtensionEncode ( os, e_useSpecifiedTransport, m_useSpecifiedTransport );
		knownExtensionEncode ( os, e_circuitInfo, m_circuitInfo );
		knownExtensionEncode ( os, e_usageSpec, m_usageSpec );
		knownExtensionEncode ( os, e_supportedProtocols, m_supportedProtocols );
		knownExtensionEncode ( os, e_serviceControl, m_serviceControl );
		knownExtensionEncode ( os, e_multipleCalls, m_multipleCalls );
		knownExtensionEncode ( os, e_featureSet, m_featureSet );
		knownExtensionEncode ( os, e_genericData, m_genericData );
		knownExtensionEncode ( os, e_modifiedSrcInfo, m_modifiedSrcInfo );
		knownExtensionEncode ( os, e_assignedGatekeeper, m_assignedGatekeeper );
		unknownExtensionsEncode ( os );
	}
}

AdmissionConfirm :: ~AdmissionConfirm ( ) {
	delete m_irrFrequency;
	delete m_nonStandardData;
	delete m_destinationInfo;
	delete m_destExtraCallInfo;
	delete m_destinationType;
	delete m_remoteExtensionAddress;
	delete m_alternateEndpoints;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_integrityCheckValue;
	delete m_transportQOS;
	delete m_willRespondToIRR;
	delete m_uuiesRequested;
	delete m_language;
	delete m_alternateTransportAddresses;
	delete m_useSpecifiedTransport;
	delete m_circuitInfo;
	delete m_usageSpec;
	delete m_supportedProtocols;
	delete m_serviceControl;
	delete m_multipleCalls;
	delete m_featureSet;
	delete m_genericData;
	delete m_modifiedSrcInfo;
	delete m_assignedGatekeeper;
}

void AdmissionConfirm :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "requestSeqNum = " << std :: setprecision ( indent ) << m_requestSeqNum << '\n';
	os << std :: setw ( indent + 12 ) << "bandWidth = " << std :: setprecision ( indent ) << m_bandWidth << '\n';
	os << std :: setw ( indent + 12 ) << "callModel = " << std :: setprecision ( indent ) << m_callModel << '\n';
	os << std :: setw ( indent + 24 ) << "destCallSignalAddress = " << std :: setprecision ( indent ) << m_destCallSignalAddress << '\n';
	if ( hasOptionalField ( e_irrFrequency ) ) {
		os << std :: setw ( indent + 15 ) << "irrFrequency = " << std :: setprecision ( indent );
		m_irrFrequency -> AdmissionConfirm_irrFrequency :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_destinationInfo ) ) {
		os << std :: setw ( indent + 18 ) << "destinationInfo = " << std :: setprecision ( indent );
		m_destinationInfo -> ArrayOf_AliasAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_destExtraCallInfo ) ) {
		os << std :: setw ( indent + 20 ) << "destExtraCallInfo = " << std :: setprecision ( indent );
		m_destExtraCallInfo -> ArrayOf_AliasAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_destinationType ) ) {
		os << std :: setw ( indent + 18 ) << "destinationType = " << std :: setprecision ( indent );
		m_destinationType -> EndpointType :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_remoteExtensionAddress ) ) {
		os << std :: setw ( indent + 25 ) << "remoteExtensionAddress = " << std :: setprecision ( indent );
		m_remoteExtensionAddress -> ArrayOf_AliasAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_alternateEndpoints ) ) {
		os << std :: setw ( indent + 21 ) << "alternateEndpoints = " << std :: setprecision ( indent );
		m_alternateEndpoints -> ArrayOf_Endpoint :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_integrityCheckValue ) ) {
		os << std :: setw ( indent + 22 ) << "integrityCheckValue = " << std :: setprecision ( indent );
		m_integrityCheckValue -> ICV :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_transportQOS ) ) {
		os << std :: setw ( indent + 15 ) << "transportQOS = " << std :: setprecision ( indent );
		m_transportQOS -> TransportQOS :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_willRespondToIRR ) ) {
		os << std :: setw ( indent + 19 ) << "willRespondToIRR = " << std :: setprecision ( indent );
		m_willRespondToIRR -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_uuiesRequested ) ) {
		os << std :: setw ( indent + 17 ) << "uuiesRequested = " << std :: setprecision ( indent );
		m_uuiesRequested -> UUIEsRequested :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_language ) ) {
		os << std :: setw ( indent + 11 ) << "language = " << std :: setprecision ( indent );
		m_language -> AdmissionConfirm_language :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_alternateTransportAddresses ) ) {
		os << std :: setw ( indent + 30 ) << "alternateTransportAddresses = " << std :: setprecision ( indent );
		m_alternateTransportAddresses -> AlternateTransportAddresses :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_useSpecifiedTransport ) ) {
		os << std :: setw ( indent + 24 ) << "useSpecifiedTransport = " << std :: setprecision ( indent );
		m_useSpecifiedTransport -> UseSpecifiedTransport :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_circuitInfo ) ) {
		os << std :: setw ( indent + 14 ) << "circuitInfo = " << std :: setprecision ( indent );
		m_circuitInfo -> CircuitInfo :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_usageSpec ) ) {
		os << std :: setw ( indent + 12 ) << "usageSpec = " << std :: setprecision ( indent );
		m_usageSpec -> ArrayOf_RasUsageSpecification :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_supportedProtocols ) ) {
		os << std :: setw ( indent + 21 ) << "supportedProtocols = " << std :: setprecision ( indent );
		m_supportedProtocols -> ArrayOf_SupportedProtocols :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_serviceControl ) ) {
		os << std :: setw ( indent + 17 ) << "serviceControl = " << std :: setprecision ( indent );
		m_serviceControl -> ArrayOf_ServiceControlSession :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_multipleCalls ) ) {
		os << std :: setw ( indent + 16 ) << "multipleCalls = " << std :: setprecision ( indent );
		m_multipleCalls -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_featureSet ) ) {
		os << std :: setw ( indent + 13 ) << "featureSet = " << std :: setprecision ( indent );
		m_featureSet -> FeatureSet :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_genericData ) ) {
		os << std :: setw ( indent + 14 ) << "genericData = " << std :: setprecision ( indent );
		m_genericData -> ArrayOf_GenericData :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_modifiedSrcInfo ) ) {
		os << std :: setw ( indent + 18 ) << "modifiedSrcInfo = " << std :: setprecision ( indent );
		m_modifiedSrcInfo -> ArrayOf_AliasAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_assignedGatekeeper ) ) {
		os << std :: setw ( indent + 21 ) << "assignedGatekeeper = " << std :: setprecision ( indent );
		m_assignedGatekeeper -> AlternateGK :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

AdmissionConfirm * AdmissionConfirm :: clone ( ) const {
	return new AdmissionConfirm ( * this );
}

//
// LocationRequest
//

LocationRequest :: LocationRequest ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 17 ), m_requestSeqNum ( is ), m_endpointIdentifier ( hasOptionalField ( e_endpointIdentifier ) ? pushTemporaryMember ( new EndpointIdentifier ( is ) ) : 0 ), m_destinationInfo ( is ), m_nonStandardData ( hasOptionalField ( e_nonStandardData ) ? pushTemporaryMember ( new NonStandardParameter ( is ) ) : 0 ), m_replyAddress ( is ), m_sourceInfo ( 0 ), m_canMapAlias ( 0 ), m_gatekeeperIdentifier ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_desiredProtocols ( 0 ), m_desiredTunnelledProtocol ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ), m_hopCount ( 0 ), m_circuitInfo ( 0 ), m_callIdentifier ( 0 ), m_bandWidth ( 0 ), m_sourceEndpointInfo ( 0 ), m_canMapSrcAlias ( 0 ), m_language ( 0 ) {
	clearTemporaryMembers ( );
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_sourceInfo ) )
				m_sourceInfo = new ArrayOf_AliasAddress ( is );
			if ( hasKnownExtensionToDecode ( is, e_canMapAlias ) )
				m_canMapAlias = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_gatekeeperIdentifier ) )
				m_gatekeeperIdentifier = new GatekeeperIdentifier ( is );
			if ( hasKnownExtensionToDecode ( is, e_tokens ) )
				m_tokens = new ArrayOf_ClearToken ( is );
			if ( hasKnownExtensionToDecode ( is, e_cryptoTokens ) )
				m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
			if ( hasKnownExtensionToDecode ( is, e_integrityCheckValue ) )
				m_integrityCheckValue = new ICV ( is );
			if ( hasKnownExtensionToDecode ( is, e_desiredProtocols ) )
				m_desiredProtocols = new ArrayOf_SupportedProtocols ( is );
			if ( hasKnownExtensionToDecode ( is, e_desiredTunnelledProtocol ) )
				m_desiredTunnelledProtocol = new TunnelledProtocol ( is );
			if ( hasKnownExtensionToDecode ( is, e_featureSet ) )
				m_featureSet = new FeatureSet ( is );
			if ( hasKnownExtensionToDecode ( is, e_genericData ) )
				m_genericData = new ArrayOf_GenericData ( is );
			if ( hasKnownExtensionToDecode ( is, e_hopCount ) )
				m_hopCount = new LocationRequest_hopCount ( is );
			if ( hasKnownExtensionToDecode ( is, e_circuitInfo ) )
				m_circuitInfo = new CircuitInfo ( is );
			if ( hasKnownExtensionToDecode ( is, e_callIdentifier ) )
				m_callIdentifier = new CallIdentifier ( is );
			if ( hasKnownExtensionToDecode ( is, e_bandWidth ) )
				m_bandWidth = new BandWidth ( is );
			if ( hasKnownExtensionToDecode ( is, e_sourceEndpointInfo ) )
				m_sourceEndpointInfo = new ArrayOf_AliasAddress ( is );
			if ( hasKnownExtensionToDecode ( is, e_canMapSrcAlias ) )
				m_canMapSrcAlias = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_language ) )
				m_language = new LocationRequest_language ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_endpointIdentifier;
		delete m_nonStandardData;
		delete m_sourceInfo;
		delete m_canMapAlias;
		delete m_gatekeeperIdentifier;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_desiredProtocols;
		delete m_desiredTunnelledProtocol;
		delete m_featureSet;
		delete m_genericData;
		delete m_hopCount;
		delete m_circuitInfo;
		delete m_callIdentifier;
		delete m_bandWidth;
		delete m_sourceEndpointInfo;
		delete m_canMapSrcAlias;
		delete m_language;
		throw;
	}
}

LocationRequest :: LocationRequest ( ) : Asn :: Sequence ( 2, true, 17 ), m_endpointIdentifier ( 0 ), m_nonStandardData ( 0 ), m_sourceInfo ( 0 ), m_canMapAlias ( 0 ), m_gatekeeperIdentifier ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_desiredProtocols ( 0 ), m_desiredTunnelledProtocol ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ), m_hopCount ( 0 ), m_circuitInfo ( 0 ), m_callIdentifier ( 0 ), m_bandWidth ( 0 ), m_sourceEndpointInfo ( 0 ), m_canMapSrcAlias ( 0 ), m_language ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_canMapAlias );
		m_canMapAlias = new Asn :: Boolean;
		Asn :: Sequence :: includeOptionalField ( e_canMapSrcAlias );
		m_canMapSrcAlias = new Asn :: Boolean;
	} catch ( ... ) {
		delete m_canMapAlias;
		delete m_canMapSrcAlias;
		throw;
	}
}

LocationRequest & LocationRequest :: operator= ( const LocationRequest & s ) {
	Asn :: Sequence :: operator= ( s );
	m_requestSeqNum = s.m_requestSeqNum;
	assignCopy ( m_endpointIdentifier, s.m_endpointIdentifier );
	m_destinationInfo = s.m_destinationInfo;
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	m_replyAddress = s.m_replyAddress;
	assignCopy ( m_sourceInfo, s.m_sourceInfo );
	assignCopy ( m_canMapAlias, s.m_canMapAlias );
	assignCopy ( m_gatekeeperIdentifier, s.m_gatekeeperIdentifier );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_integrityCheckValue, s.m_integrityCheckValue );
	assignCopy ( m_desiredProtocols, s.m_desiredProtocols );
	assignCopy ( m_desiredTunnelledProtocol, s.m_desiredTunnelledProtocol );
	assignCopy ( m_featureSet, s.m_featureSet );
	assignCopy ( m_genericData, s.m_genericData );
	assignCopy ( m_hopCount, s.m_hopCount );
	assignCopy ( m_circuitInfo, s.m_circuitInfo );
	assignCopy ( m_callIdentifier, s.m_callIdentifier );
	assignCopy ( m_bandWidth, s.m_bandWidth );
	assignCopy ( m_sourceEndpointInfo, s.m_sourceEndpointInfo );
	assignCopy ( m_canMapSrcAlias, s.m_canMapSrcAlias );
	assignCopy ( m_language, s.m_language );
	return * this;
}

LocationRequest :: LocationRequest ( const LocationRequest & s ) : Asn :: Sequence ( s ), m_requestSeqNum ( s.m_requestSeqNum ), m_endpointIdentifier ( 0 ), m_destinationInfo ( s.m_destinationInfo ), m_nonStandardData ( 0 ), m_replyAddress ( s.m_replyAddress ), m_sourceInfo ( 0 ), m_canMapAlias ( 0 ), m_gatekeeperIdentifier ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_desiredProtocols ( 0 ), m_desiredTunnelledProtocol ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ), m_hopCount ( 0 ), m_circuitInfo ( 0 ), m_callIdentifier ( 0 ), m_bandWidth ( 0 ), m_sourceEndpointInfo ( 0 ), m_canMapSrcAlias ( 0 ), m_language ( 0 ) {
	try {
		if ( s.m_endpointIdentifier )
			m_endpointIdentifier = new EndpointIdentifier ( * s.m_endpointIdentifier );
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_sourceInfo )
			m_sourceInfo = new ArrayOf_AliasAddress ( * s.m_sourceInfo );
		if ( s.m_canMapAlias )
			m_canMapAlias = new Asn :: Boolean ( * s.m_canMapAlias );
		if ( s.m_gatekeeperIdentifier )
			m_gatekeeperIdentifier = new GatekeeperIdentifier ( * s.m_gatekeeperIdentifier );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_integrityCheckValue )
			m_integrityCheckValue = new ICV ( * s.m_integrityCheckValue );
		if ( s.m_desiredProtocols )
			m_desiredProtocols = new ArrayOf_SupportedProtocols ( * s.m_desiredProtocols );
		if ( s.m_desiredTunnelledProtocol )
			m_desiredTunnelledProtocol = new TunnelledProtocol ( * s.m_desiredTunnelledProtocol );
		if ( s.m_featureSet )
			m_featureSet = new FeatureSet ( * s.m_featureSet );
		if ( s.m_genericData )
			m_genericData = new ArrayOf_GenericData ( * s.m_genericData );
		if ( s.m_hopCount )
			m_hopCount = new LocationRequest_hopCount ( * s.m_hopCount );
		if ( s.m_circuitInfo )
			m_circuitInfo = new CircuitInfo ( * s.m_circuitInfo );
		if ( s.m_callIdentifier )
			m_callIdentifier = new CallIdentifier ( * s.m_callIdentifier );
		if ( s.m_bandWidth )
			m_bandWidth = new BandWidth ( * s.m_bandWidth );
		if ( s.m_sourceEndpointInfo )
			m_sourceEndpointInfo = new ArrayOf_AliasAddress ( * s.m_sourceEndpointInfo );
		if ( s.m_canMapSrcAlias )
			m_canMapSrcAlias = new Asn :: Boolean ( * s.m_canMapSrcAlias );
		if ( s.m_language )
			m_language = new LocationRequest_language ( * s.m_language );
	} catch ( ... ) {
		delete m_endpointIdentifier;
		delete m_nonStandardData;
		delete m_sourceInfo;
		delete m_canMapAlias;
		delete m_gatekeeperIdentifier;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_desiredProtocols;
		delete m_desiredTunnelledProtocol;
		delete m_featureSet;
		delete m_genericData;
		delete m_hopCount;
		delete m_circuitInfo;
		delete m_callIdentifier;
		delete m_bandWidth;
		delete m_sourceEndpointInfo;
		delete m_canMapSrcAlias;
		delete m_language;
		throw;
	}
}


void LocationRequest :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_endpointIdentifier:
			assignNew ( m_endpointIdentifier, new EndpointIdentifier );
			break;
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_sourceInfo:
			assignNew ( m_sourceInfo, new ArrayOf_AliasAddress );
			break;
		case e_canMapAlias:
			assignNew ( m_canMapAlias, new Asn :: Boolean );
			break;
		case e_gatekeeperIdentifier:
			assignNew ( m_gatekeeperIdentifier, new GatekeeperIdentifier );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_integrityCheckValue:
			assignNew ( m_integrityCheckValue, new ICV );
			break;
		case e_desiredProtocols:
			assignNew ( m_desiredProtocols, new ArrayOf_SupportedProtocols );
			break;
		case e_desiredTunnelledProtocol:
			assignNew ( m_desiredTunnelledProtocol, new TunnelledProtocol );
			break;
		case e_featureSet:
			assignNew ( m_featureSet, new FeatureSet );
			break;
		case e_genericData:
			assignNew ( m_genericData, new ArrayOf_GenericData );
			break;
		case e_hopCount:
			assignNew ( m_hopCount, new LocationRequest_hopCount );
			break;
		case e_circuitInfo:
			assignNew ( m_circuitInfo, new CircuitInfo );
			break;
		case e_callIdentifier:
			assignNew ( m_callIdentifier, new CallIdentifier );
			break;
		case e_bandWidth:
			assignNew ( m_bandWidth, new BandWidth );
			break;
		case e_sourceEndpointInfo:
			assignNew ( m_sourceEndpointInfo, new ArrayOf_AliasAddress );
			break;
		case e_canMapSrcAlias:
			assignNew ( m_canMapSrcAlias, new Asn :: Boolean );
			break;
		case e_language:
			assignNew ( m_language, new LocationRequest_language );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void LocationRequest :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_endpointIdentifier:
			delete m_endpointIdentifier;
			m_endpointIdentifier = 0;
			break;
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_sourceInfo:
			delete m_sourceInfo;
			m_sourceInfo = 0;
			break;
		case e_canMapAlias:
			delete m_canMapAlias;
			m_canMapAlias = 0;
			break;
		case e_gatekeeperIdentifier:
			delete m_gatekeeperIdentifier;
			m_gatekeeperIdentifier = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_integrityCheckValue:
			delete m_integrityCheckValue;
			m_integrityCheckValue = 0;
			break;
		case e_desiredProtocols:
			delete m_desiredProtocols;
			m_desiredProtocols = 0;
			break;
		case e_desiredTunnelledProtocol:
			delete m_desiredTunnelledProtocol;
			m_desiredTunnelledProtocol = 0;
			break;
		case e_featureSet:
			delete m_featureSet;
			m_featureSet = 0;
			break;
		case e_genericData:
			delete m_genericData;
			m_genericData = 0;
			break;
		case e_hopCount:
			delete m_hopCount;
			m_hopCount = 0;
			break;
		case e_circuitInfo:
			delete m_circuitInfo;
			m_circuitInfo = 0;
			break;
		case e_callIdentifier:
			delete m_callIdentifier;
			m_callIdentifier = 0;
			break;
		case e_bandWidth:
			delete m_bandWidth;
			m_bandWidth = 0;
			break;
		case e_sourceEndpointInfo:
			delete m_sourceEndpointInfo;
			m_sourceEndpointInfo = 0;
			break;
		case e_canMapSrcAlias:
			delete m_canMapSrcAlias;
			m_canMapSrcAlias = 0;
			break;
		case e_language:
			delete m_language;
			m_language = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void LocationRequest :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_requestSeqNum.encode ( os );
	if ( hasOptionalField ( e_endpointIdentifier ) )
		m_endpointIdentifier -> EndpointIdentifier :: encode ( os );
	m_destinationInfo.encode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	m_replyAddress.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_sourceInfo, m_sourceInfo );
		knownExtensionEncode ( os, e_canMapAlias, m_canMapAlias );
		knownExtensionEncode ( os, e_gatekeeperIdentifier, m_gatekeeperIdentifier );
		knownExtensionEncode ( os, e_tokens, m_tokens );
		knownExtensionEncode ( os, e_cryptoTokens, m_cryptoTokens );
		knownExtensionEncode ( os, e_integrityCheckValue, m_integrityCheckValue );
		knownExtensionEncode ( os, e_desiredProtocols, m_desiredProtocols );
		knownExtensionEncode ( os, e_desiredTunnelledProtocol, m_desiredTunnelledProtocol );
		knownExtensionEncode ( os, e_featureSet, m_featureSet );
		knownExtensionEncode ( os, e_genericData, m_genericData );
		knownExtensionEncode ( os, e_hopCount, m_hopCount );
		knownExtensionEncode ( os, e_circuitInfo, m_circuitInfo );
		knownExtensionEncode ( os, e_callIdentifier, m_callIdentifier );
		knownExtensionEncode ( os, e_bandWidth, m_bandWidth );
		knownExtensionEncode ( os, e_sourceEndpointInfo, m_sourceEndpointInfo );
		knownExtensionEncode ( os, e_canMapSrcAlias, m_canMapSrcAlias );
		knownExtensionEncode ( os, e_language, m_language );
		unknownExtensionsEncode ( os );
	}
}

LocationRequest :: ~LocationRequest ( ) {
	delete m_endpointIdentifier;
	delete m_nonStandardData;
	delete m_sourceInfo;
	delete m_canMapAlias;
	delete m_gatekeeperIdentifier;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_integrityCheckValue;
	delete m_desiredProtocols;
	delete m_desiredTunnelledProtocol;
	delete m_featureSet;
	delete m_genericData;
	delete m_hopCount;
	delete m_circuitInfo;
	delete m_callIdentifier;
	delete m_bandWidth;
	delete m_sourceEndpointInfo;
	delete m_canMapSrcAlias;
	delete m_language;
}

void LocationRequest :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "requestSeqNum = " << std :: setprecision ( indent ) << m_requestSeqNum << '\n';
	if ( hasOptionalField ( e_endpointIdentifier ) ) {
		os << std :: setw ( indent + 21 ) << "endpointIdentifier = " << std :: setprecision ( indent );
		m_endpointIdentifier -> EndpointIdentifier :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 18 ) << "destinationInfo = " << std :: setprecision ( indent ) << m_destinationInfo << '\n';
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 15 ) << "replyAddress = " << std :: setprecision ( indent ) << m_replyAddress << '\n';
	if ( hasOptionalField ( e_sourceInfo ) ) {
		os << std :: setw ( indent + 13 ) << "sourceInfo = " << std :: setprecision ( indent );
		m_sourceInfo -> ArrayOf_AliasAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_canMapAlias ) ) {
		os << std :: setw ( indent + 14 ) << "canMapAlias = " << std :: setprecision ( indent );
		m_canMapAlias -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_gatekeeperIdentifier ) ) {
		os << std :: setw ( indent + 23 ) << "gatekeeperIdentifier = " << std :: setprecision ( indent );
		m_gatekeeperIdentifier -> GatekeeperIdentifier :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_integrityCheckValue ) ) {
		os << std :: setw ( indent + 22 ) << "integrityCheckValue = " << std :: setprecision ( indent );
		m_integrityCheckValue -> ICV :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_desiredProtocols ) ) {
		os << std :: setw ( indent + 19 ) << "desiredProtocols = " << std :: setprecision ( indent );
		m_desiredProtocols -> ArrayOf_SupportedProtocols :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_desiredTunnelledProtocol ) ) {
		os << std :: setw ( indent + 27 ) << "desiredTunnelledProtocol = " << std :: setprecision ( indent );
		m_desiredTunnelledProtocol -> TunnelledProtocol :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_featureSet ) ) {
		os << std :: setw ( indent + 13 ) << "featureSet = " << std :: setprecision ( indent );
		m_featureSet -> FeatureSet :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_genericData ) ) {
		os << std :: setw ( indent + 14 ) << "genericData = " << std :: setprecision ( indent );
		m_genericData -> ArrayOf_GenericData :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_hopCount ) ) {
		os << std :: setw ( indent + 11 ) << "hopCount = " << std :: setprecision ( indent );
		m_hopCount -> LocationRequest_hopCount :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_circuitInfo ) ) {
		os << std :: setw ( indent + 14 ) << "circuitInfo = " << std :: setprecision ( indent );
		m_circuitInfo -> CircuitInfo :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_callIdentifier ) ) {
		os << std :: setw ( indent + 17 ) << "callIdentifier = " << std :: setprecision ( indent );
		m_callIdentifier -> CallIdentifier :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_bandWidth ) ) {
		os << std :: setw ( indent + 12 ) << "bandWidth = " << std :: setprecision ( indent );
		m_bandWidth -> BandWidth :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_sourceEndpointInfo ) ) {
		os << std :: setw ( indent + 21 ) << "sourceEndpointInfo = " << std :: setprecision ( indent );
		m_sourceEndpointInfo -> ArrayOf_AliasAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_canMapSrcAlias ) ) {
		os << std :: setw ( indent + 17 ) << "canMapSrcAlias = " << std :: setprecision ( indent );
		m_canMapSrcAlias -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_language ) ) {
		os << std :: setw ( indent + 11 ) << "language = " << std :: setprecision ( indent );
		m_language -> LocationRequest_language :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

LocationRequest * LocationRequest :: clone ( ) const {
	return new LocationRequest ( * this );
}

//
// LocationConfirm
//

LocationConfirm :: LocationConfirm ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 17 ), m_requestSeqNum ( is ), m_callSignalAddress ( is ), m_rasAddress ( is ), m_nonStandardData ( 0 ), m_destinationInfo ( 0 ), m_destExtraCallInfo ( 0 ), m_destinationType ( 0 ), m_remoteExtensionAddress ( 0 ), m_alternateEndpoints ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_alternateTransportAddresses ( 0 ), m_supportedProtocols ( 0 ), m_multipleCalls ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ), m_circuitInfo ( 0 ), m_serviceControl ( 0 ), m_modifiedSrcInfo ( 0 ), m_bandWidth ( 0 ) {
	try {
		if ( hasOptionalField ( e_nonStandardData ) )
			m_nonStandardData = new NonStandardParameter ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_destinationInfo ) )
				m_destinationInfo = new ArrayOf_AliasAddress ( is );
			if ( hasKnownExtensionToDecode ( is, e_destExtraCallInfo ) )
				m_destExtraCallInfo = new ArrayOf_AliasAddress ( is );
			if ( hasKnownExtensionToDecode ( is, e_destinationType ) )
				m_destinationType = new EndpointType ( is );
			if ( hasKnownExtensionToDecode ( is, e_remoteExtensionAddress ) )
				m_remoteExtensionAddress = new ArrayOf_AliasAddress ( is );
			if ( hasKnownExtensionToDecode ( is, e_alternateEndpoints ) )
				m_alternateEndpoints = new ArrayOf_Endpoint ( is );
			if ( hasKnownExtensionToDecode ( is, e_tokens ) )
				m_tokens = new ArrayOf_ClearToken ( is );
			if ( hasKnownExtensionToDecode ( is, e_cryptoTokens ) )
				m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
			if ( hasKnownExtensionToDecode ( is, e_integrityCheckValue ) )
				m_integrityCheckValue = new ICV ( is );
			if ( hasKnownExtensionToDecode ( is, e_alternateTransportAddresses ) )
				m_alternateTransportAddresses = new AlternateTransportAddresses ( is );
			if ( hasKnownExtensionToDecode ( is, e_supportedProtocols ) )
				m_supportedProtocols = new ArrayOf_SupportedProtocols ( is );
			if ( hasKnownExtensionToDecode ( is, e_multipleCalls ) )
				m_multipleCalls = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_featureSet ) )
				m_featureSet = new FeatureSet ( is );
			if ( hasKnownExtensionToDecode ( is, e_genericData ) )
				m_genericData = new ArrayOf_GenericData ( is );
			if ( hasKnownExtensionToDecode ( is, e_circuitInfo ) )
				m_circuitInfo = new CircuitInfo ( is );
			if ( hasKnownExtensionToDecode ( is, e_serviceControl ) )
				m_serviceControl = new ArrayOf_ServiceControlSession ( is );
			if ( hasKnownExtensionToDecode ( is, e_modifiedSrcInfo ) )
				m_modifiedSrcInfo = new ArrayOf_AliasAddress ( is );
			if ( hasKnownExtensionToDecode ( is, e_bandWidth ) )
				m_bandWidth = new BandWidth ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_destinationInfo;
		delete m_destExtraCallInfo;
		delete m_destinationType;
		delete m_remoteExtensionAddress;
		delete m_alternateEndpoints;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_alternateTransportAddresses;
		delete m_supportedProtocols;
		delete m_multipleCalls;
		delete m_featureSet;
		delete m_genericData;
		delete m_circuitInfo;
		delete m_serviceControl;
		delete m_modifiedSrcInfo;
		delete m_bandWidth;
		throw;
	}
}

LocationConfirm :: LocationConfirm ( ) : Asn :: Sequence ( 1, true, 17 ), m_nonStandardData ( 0 ), m_destinationInfo ( 0 ), m_destExtraCallInfo ( 0 ), m_destinationType ( 0 ), m_remoteExtensionAddress ( 0 ), m_alternateEndpoints ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_alternateTransportAddresses ( 0 ), m_supportedProtocols ( 0 ), m_multipleCalls ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ), m_circuitInfo ( 0 ), m_serviceControl ( 0 ), m_modifiedSrcInfo ( 0 ), m_bandWidth ( 0 ) { }

LocationConfirm & LocationConfirm :: operator= ( const LocationConfirm & s ) {
	Asn :: Sequence :: operator= ( s );
	m_requestSeqNum = s.m_requestSeqNum;
	m_callSignalAddress = s.m_callSignalAddress;
	m_rasAddress = s.m_rasAddress;
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	assignCopy ( m_destinationInfo, s.m_destinationInfo );
	assignCopy ( m_destExtraCallInfo, s.m_destExtraCallInfo );
	assignCopy ( m_destinationType, s.m_destinationType );
	assignCopy ( m_remoteExtensionAddress, s.m_remoteExtensionAddress );
	assignCopy ( m_alternateEndpoints, s.m_alternateEndpoints );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_integrityCheckValue, s.m_integrityCheckValue );
	assignCopy ( m_alternateTransportAddresses, s.m_alternateTransportAddresses );
	assignCopy ( m_supportedProtocols, s.m_supportedProtocols );
	assignCopy ( m_multipleCalls, s.m_multipleCalls );
	assignCopy ( m_featureSet, s.m_featureSet );
	assignCopy ( m_genericData, s.m_genericData );
	assignCopy ( m_circuitInfo, s.m_circuitInfo );
	assignCopy ( m_serviceControl, s.m_serviceControl );
	assignCopy ( m_modifiedSrcInfo, s.m_modifiedSrcInfo );
	assignCopy ( m_bandWidth, s.m_bandWidth );
	return * this;
}

LocationConfirm :: LocationConfirm ( const LocationConfirm & s ) : Asn :: Sequence ( s ), m_requestSeqNum ( s.m_requestSeqNum ), m_callSignalAddress ( s.m_callSignalAddress ), m_rasAddress ( s.m_rasAddress ), m_nonStandardData ( 0 ), m_destinationInfo ( 0 ), m_destExtraCallInfo ( 0 ), m_destinationType ( 0 ), m_remoteExtensionAddress ( 0 ), m_alternateEndpoints ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_alternateTransportAddresses ( 0 ), m_supportedProtocols ( 0 ), m_multipleCalls ( 0 ), m_featureSet ( 0 ), m_genericData ( 0 ), m_circuitInfo ( 0 ), m_serviceControl ( 0 ), m_modifiedSrcInfo ( 0 ), m_bandWidth ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_destinationInfo )
			m_destinationInfo = new ArrayOf_AliasAddress ( * s.m_destinationInfo );
		if ( s.m_destExtraCallInfo )
			m_destExtraCallInfo = new ArrayOf_AliasAddress ( * s.m_destExtraCallInfo );
		if ( s.m_destinationType )
			m_destinationType = new EndpointType ( * s.m_destinationType );
		if ( s.m_remoteExtensionAddress )
			m_remoteExtensionAddress = new ArrayOf_AliasAddress ( * s.m_remoteExtensionAddress );
		if ( s.m_alternateEndpoints )
			m_alternateEndpoints = new ArrayOf_Endpoint ( * s.m_alternateEndpoints );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_integrityCheckValue )
			m_integrityCheckValue = new ICV ( * s.m_integrityCheckValue );
		if ( s.m_alternateTransportAddresses )
			m_alternateTransportAddresses = new AlternateTransportAddresses ( * s.m_alternateTransportAddresses );
		if ( s.m_supportedProtocols )
			m_supportedProtocols = new ArrayOf_SupportedProtocols ( * s.m_supportedProtocols );
		if ( s.m_multipleCalls )
			m_multipleCalls = new Asn :: Boolean ( * s.m_multipleCalls );
		if ( s.m_featureSet )
			m_featureSet = new FeatureSet ( * s.m_featureSet );
		if ( s.m_genericData )
			m_genericData = new ArrayOf_GenericData ( * s.m_genericData );
		if ( s.m_circuitInfo )
			m_circuitInfo = new CircuitInfo ( * s.m_circuitInfo );
		if ( s.m_serviceControl )
			m_serviceControl = new ArrayOf_ServiceControlSession ( * s.m_serviceControl );
		if ( s.m_modifiedSrcInfo )
			m_modifiedSrcInfo = new ArrayOf_AliasAddress ( * s.m_modifiedSrcInfo );
		if ( s.m_bandWidth )
			m_bandWidth = new BandWidth ( * s.m_bandWidth );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_destinationInfo;
		delete m_destExtraCallInfo;
		delete m_destinationType;
		delete m_remoteExtensionAddress;
		delete m_alternateEndpoints;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_alternateTransportAddresses;
		delete m_supportedProtocols;
		delete m_multipleCalls;
		delete m_featureSet;
		delete m_genericData;
		delete m_circuitInfo;
		delete m_serviceControl;
		delete m_modifiedSrcInfo;
		delete m_bandWidth;
		throw;
	}
}


void LocationConfirm :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_destinationInfo:
			assignNew ( m_destinationInfo, new ArrayOf_AliasAddress );
			break;
		case e_destExtraCallInfo:
			assignNew ( m_destExtraCallInfo, new ArrayOf_AliasAddress );
			break;
		case e_destinationType:
			assignNew ( m_destinationType, new EndpointType );
			break;
		case e_remoteExtensionAddress:
			assignNew ( m_remoteExtensionAddress, new ArrayOf_AliasAddress );
			break;
		case e_alternateEndpoints:
			assignNew ( m_alternateEndpoints, new ArrayOf_Endpoint );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_integrityCheckValue:
			assignNew ( m_integrityCheckValue, new ICV );
			break;
		case e_alternateTransportAddresses:
			assignNew ( m_alternateTransportAddresses, new AlternateTransportAddresses );
			break;
		case e_supportedProtocols:
			assignNew ( m_supportedProtocols, new ArrayOf_SupportedProtocols );
			break;
		case e_multipleCalls:
			assignNew ( m_multipleCalls, new Asn :: Boolean );
			break;
		case e_featureSet:
			assignNew ( m_featureSet, new FeatureSet );
			break;
		case e_genericData:
			assignNew ( m_genericData, new ArrayOf_GenericData );
			break;
		case e_circuitInfo:
			assignNew ( m_circuitInfo, new CircuitInfo );
			break;
		case e_serviceControl:
			assignNew ( m_serviceControl, new ArrayOf_ServiceControlSession );
			break;
		case e_modifiedSrcInfo:
			assignNew ( m_modifiedSrcInfo, new ArrayOf_AliasAddress );
			break;
		case e_bandWidth:
			assignNew ( m_bandWidth, new BandWidth );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void LocationConfirm :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_destinationInfo:
			delete m_destinationInfo;
			m_destinationInfo = 0;
			break;
		case e_destExtraCallInfo:
			delete m_destExtraCallInfo;
			m_destExtraCallInfo = 0;
			break;
		case e_destinationType:
			delete m_destinationType;
			m_destinationType = 0;
			break;
		case e_remoteExtensionAddress:
			delete m_remoteExtensionAddress;
			m_remoteExtensionAddress = 0;
			break;
		case e_alternateEndpoints:
			delete m_alternateEndpoints;
			m_alternateEndpoints = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_integrityCheckValue:
			delete m_integrityCheckValue;
			m_integrityCheckValue = 0;
			break;
		case e_alternateTransportAddresses:
			delete m_alternateTransportAddresses;
			m_alternateTransportAddresses = 0;
			break;
		case e_supportedProtocols:
			delete m_supportedProtocols;
			m_supportedProtocols = 0;
			break;
		case e_multipleCalls:
			delete m_multipleCalls;
			m_multipleCalls = 0;
			break;
		case e_featureSet:
			delete m_featureSet;
			m_featureSet = 0;
			break;
		case e_genericData:
			delete m_genericData;
			m_genericData = 0;
			break;
		case e_circuitInfo:
			delete m_circuitInfo;
			m_circuitInfo = 0;
			break;
		case e_serviceControl:
			delete m_serviceControl;
			m_serviceControl = 0;
			break;
		case e_modifiedSrcInfo:
			delete m_modifiedSrcInfo;
			m_modifiedSrcInfo = 0;
			break;
		case e_bandWidth:
			delete m_bandWidth;
			m_bandWidth = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void LocationConfirm :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_requestSeqNum.encode ( os );
	m_callSignalAddress.encode ( os );
	m_rasAddress.encode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_destinationInfo, m_destinationInfo );
		knownExtensionEncode ( os, e_destExtraCallInfo, m_destExtraCallInfo );
		knownExtensionEncode ( os, e_destinationType, m_destinationType );
		knownExtensionEncode ( os, e_remoteExtensionAddress, m_remoteExtensionAddress );
		knownExtensionEncode ( os, e_alternateEndpoints, m_alternateEndpoints );
		knownExtensionEncode ( os, e_tokens, m_tokens );
		knownExtensionEncode ( os, e_cryptoTokens, m_cryptoTokens );
		knownExtensionEncode ( os, e_integrityCheckValue, m_integrityCheckValue );
		knownExtensionEncode ( os, e_alternateTransportAddresses, m_alternateTransportAddresses );
		knownExtensionEncode ( os, e_supportedProtocols, m_supportedProtocols );
		knownExtensionEncode ( os, e_multipleCalls, m_multipleCalls );
		knownExtensionEncode ( os, e_featureSet, m_featureSet );
		knownExtensionEncode ( os, e_genericData, m_genericData );
		knownExtensionEncode ( os, e_circuitInfo, m_circuitInfo );
		knownExtensionEncode ( os, e_serviceControl, m_serviceControl );
		knownExtensionEncode ( os, e_modifiedSrcInfo, m_modifiedSrcInfo );
		knownExtensionEncode ( os, e_bandWidth, m_bandWidth );
		unknownExtensionsEncode ( os );
	}
}

LocationConfirm :: ~LocationConfirm ( ) {
	delete m_nonStandardData;
	delete m_destinationInfo;
	delete m_destExtraCallInfo;
	delete m_destinationType;
	delete m_remoteExtensionAddress;
	delete m_alternateEndpoints;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_integrityCheckValue;
	delete m_alternateTransportAddresses;
	delete m_supportedProtocols;
	delete m_multipleCalls;
	delete m_featureSet;
	delete m_genericData;
	delete m_circuitInfo;
	delete m_serviceControl;
	delete m_modifiedSrcInfo;
	delete m_bandWidth;
}

void LocationConfirm :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "requestSeqNum = " << std :: setprecision ( indent ) << m_requestSeqNum << '\n';
	os << std :: setw ( indent + 20 ) << "callSignalAddress = " << std :: setprecision ( indent ) << m_callSignalAddress << '\n';
	os << std :: setw ( indent + 13 ) << "rasAddress = " << std :: setprecision ( indent ) << m_rasAddress << '\n';
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_destinationInfo ) ) {
		os << std :: setw ( indent + 18 ) << "destinationInfo = " << std :: setprecision ( indent );
		m_destinationInfo -> ArrayOf_AliasAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_destExtraCallInfo ) ) {
		os << std :: setw ( indent + 20 ) << "destExtraCallInfo = " << std :: setprecision ( indent );
		m_destExtraCallInfo -> ArrayOf_AliasAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_destinationType ) ) {
		os << std :: setw ( indent + 18 ) << "destinationType = " << std :: setprecision ( indent );
		m_destinationType -> EndpointType :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_remoteExtensionAddress ) ) {
		os << std :: setw ( indent + 25 ) << "remoteExtensionAddress = " << std :: setprecision ( indent );
		m_remoteExtensionAddress -> ArrayOf_AliasAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_alternateEndpoints ) ) {
		os << std :: setw ( indent + 21 ) << "alternateEndpoints = " << std :: setprecision ( indent );
		m_alternateEndpoints -> ArrayOf_Endpoint :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_integrityCheckValue ) ) {
		os << std :: setw ( indent + 22 ) << "integrityCheckValue = " << std :: setprecision ( indent );
		m_integrityCheckValue -> ICV :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_alternateTransportAddresses ) ) {
		os << std :: setw ( indent + 30 ) << "alternateTransportAddresses = " << std :: setprecision ( indent );
		m_alternateTransportAddresses -> AlternateTransportAddresses :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_supportedProtocols ) ) {
		os << std :: setw ( indent + 21 ) << "supportedProtocols = " << std :: setprecision ( indent );
		m_supportedProtocols -> ArrayOf_SupportedProtocols :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_multipleCalls ) ) {
		os << std :: setw ( indent + 16 ) << "multipleCalls = " << std :: setprecision ( indent );
		m_multipleCalls -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_featureSet ) ) {
		os << std :: setw ( indent + 13 ) << "featureSet = " << std :: setprecision ( indent );
		m_featureSet -> FeatureSet :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_genericData ) ) {
		os << std :: setw ( indent + 14 ) << "genericData = " << std :: setprecision ( indent );
		m_genericData -> ArrayOf_GenericData :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_circuitInfo ) ) {
		os << std :: setw ( indent + 14 ) << "circuitInfo = " << std :: setprecision ( indent );
		m_circuitInfo -> CircuitInfo :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_serviceControl ) ) {
		os << std :: setw ( indent + 17 ) << "serviceControl = " << std :: setprecision ( indent );
		m_serviceControl -> ArrayOf_ServiceControlSession :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_modifiedSrcInfo ) ) {
		os << std :: setw ( indent + 18 ) << "modifiedSrcInfo = " << std :: setprecision ( indent );
		m_modifiedSrcInfo -> ArrayOf_AliasAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_bandWidth ) ) {
		os << std :: setw ( indent + 12 ) << "bandWidth = " << std :: setprecision ( indent );
		m_bandWidth -> BandWidth :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

LocationConfirm * LocationConfirm :: clone ( ) const {
	return new LocationConfirm ( * this );
}

//
// InfoRequestResponse
//

InfoRequestResponse :: InfoRequestResponse ( Asn :: istream & is ) : Asn :: Sequence ( is, 3, true, 8 ), m_nonStandardData ( hasOptionalField ( e_nonStandardData ) ? pushTemporaryMember ( new NonStandardParameter ( is ) ) : 0 ), m_requestSeqNum ( is ), m_endpointType ( is ), m_endpointIdentifier ( is ), m_rasAddress ( is ), m_callSignalAddress ( is ), m_endpointAlias ( 0 ), m_perCallInfo ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_needResponse ( 0 ), m_capacity ( 0 ), m_irrStatus ( 0 ), m_unsolicited ( 0 ), m_genericData ( 0 ) {
	clearTemporaryMembers ( );
	try {
		if ( hasOptionalField ( e_endpointAlias ) )
			m_endpointAlias = new ArrayOf_AliasAddress ( is );
		if ( hasOptionalField ( e_perCallInfo ) )
			m_perCallInfo = new InfoRequestResponse_perCallInfo ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_tokens ) )
				m_tokens = new ArrayOf_ClearToken ( is );
			if ( hasKnownExtensionToDecode ( is, e_cryptoTokens ) )
				m_cryptoTokens = new ArrayOf_CryptoH323Token ( is );
			if ( hasKnownExtensionToDecode ( is, e_integrityCheckValue ) )
				m_integrityCheckValue = new ICV ( is );
			if ( hasKnownExtensionToDecode ( is, e_needResponse ) )
				m_needResponse = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_capacity ) )
				m_capacity = new CallCapacity ( is );
			if ( hasKnownExtensionToDecode ( is, e_irrStatus ) )
				m_irrStatus = new InfoRequestResponseStatus ( is );
			if ( hasKnownExtensionToDecode ( is, e_unsolicited ) )
				m_unsolicited = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_genericData ) )
				m_genericData = new ArrayOf_GenericData ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_endpointAlias;
		delete m_perCallInfo;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_needResponse;
		delete m_capacity;
		delete m_irrStatus;
		delete m_unsolicited;
		delete m_genericData;
		throw;
	}
}

InfoRequestResponse :: InfoRequestResponse ( ) : Asn :: Sequence ( 3, true, 8 ), m_nonStandardData ( 0 ), m_endpointAlias ( 0 ), m_perCallInfo ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_needResponse ( 0 ), m_capacity ( 0 ), m_irrStatus ( 0 ), m_unsolicited ( 0 ), m_genericData ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_needResponse );
		m_needResponse = new Asn :: Boolean;
		Asn :: Sequence :: includeOptionalField ( e_unsolicited );
		m_unsolicited = new Asn :: Boolean;
	} catch ( ... ) {
		delete m_needResponse;
		delete m_unsolicited;
		throw;
	}
}

InfoRequestResponse & InfoRequestResponse :: operator= ( const InfoRequestResponse & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	m_requestSeqNum = s.m_requestSeqNum;
	m_endpointType = s.m_endpointType;
	m_endpointIdentifier = s.m_endpointIdentifier;
	m_rasAddress = s.m_rasAddress;
	m_callSignalAddress = s.m_callSignalAddress;
	assignCopy ( m_endpointAlias, s.m_endpointAlias );
	assignCopy ( m_perCallInfo, s.m_perCallInfo );
	assignCopy ( m_tokens, s.m_tokens );
	assignCopy ( m_cryptoTokens, s.m_cryptoTokens );
	assignCopy ( m_integrityCheckValue, s.m_integrityCheckValue );
	assignCopy ( m_needResponse, s.m_needResponse );
	assignCopy ( m_capacity, s.m_capacity );
	assignCopy ( m_irrStatus, s.m_irrStatus );
	assignCopy ( m_unsolicited, s.m_unsolicited );
	assignCopy ( m_genericData, s.m_genericData );
	return * this;
}

InfoRequestResponse :: InfoRequestResponse ( const InfoRequestResponse & s ) : Asn :: Sequence ( s ), m_nonStandardData ( 0 ), m_requestSeqNum ( s.m_requestSeqNum ), m_endpointType ( s.m_endpointType ), m_endpointIdentifier ( s.m_endpointIdentifier ), m_rasAddress ( s.m_rasAddress ), m_callSignalAddress ( s.m_callSignalAddress ), m_endpointAlias ( 0 ), m_perCallInfo ( 0 ), m_tokens ( 0 ), m_cryptoTokens ( 0 ), m_integrityCheckValue ( 0 ), m_needResponse ( 0 ), m_capacity ( 0 ), m_irrStatus ( 0 ), m_unsolicited ( 0 ), m_genericData ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_endpointAlias )
			m_endpointAlias = new ArrayOf_AliasAddress ( * s.m_endpointAlias );
		if ( s.m_perCallInfo )
			m_perCallInfo = new InfoRequestResponse_perCallInfo ( * s.m_perCallInfo );
		if ( s.m_tokens )
			m_tokens = new ArrayOf_ClearToken ( * s.m_tokens );
		if ( s.m_cryptoTokens )
			m_cryptoTokens = new ArrayOf_CryptoH323Token ( * s.m_cryptoTokens );
		if ( s.m_integrityCheckValue )
			m_integrityCheckValue = new ICV ( * s.m_integrityCheckValue );
		if ( s.m_needResponse )
			m_needResponse = new Asn :: Boolean ( * s.m_needResponse );
		if ( s.m_capacity )
			m_capacity = new CallCapacity ( * s.m_capacity );
		if ( s.m_irrStatus )
			m_irrStatus = new InfoRequestResponseStatus ( * s.m_irrStatus );
		if ( s.m_unsolicited )
			m_unsolicited = new Asn :: Boolean ( * s.m_unsolicited );
		if ( s.m_genericData )
			m_genericData = new ArrayOf_GenericData ( * s.m_genericData );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_endpointAlias;
		delete m_perCallInfo;
		delete m_tokens;
		delete m_cryptoTokens;
		delete m_integrityCheckValue;
		delete m_needResponse;
		delete m_capacity;
		delete m_irrStatus;
		delete m_unsolicited;
		delete m_genericData;
		throw;
	}
}


void InfoRequestResponse :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_endpointAlias:
			assignNew ( m_endpointAlias, new ArrayOf_AliasAddress );
			break;
		case e_perCallInfo:
			assignNew ( m_perCallInfo, new InfoRequestResponse_perCallInfo );
			break;
		case e_tokens:
			assignNew ( m_tokens, new ArrayOf_ClearToken );
			break;
		case e_cryptoTokens:
			assignNew ( m_cryptoTokens, new ArrayOf_CryptoH323Token );
			break;
		case e_integrityCheckValue:
			assignNew ( m_integrityCheckValue, new ICV );
			break;
		case e_needResponse:
			assignNew ( m_needResponse, new Asn :: Boolean );
			break;
		case e_capacity:
			assignNew ( m_capacity, new CallCapacity );
			break;
		case e_irrStatus:
			assignNew ( m_irrStatus, new InfoRequestResponseStatus );
			break;
		case e_unsolicited:
			assignNew ( m_unsolicited, new Asn :: Boolean );
			break;
		case e_genericData:
			assignNew ( m_genericData, new ArrayOf_GenericData );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void InfoRequestResponse :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_endpointAlias:
			delete m_endpointAlias;
			m_endpointAlias = 0;
			break;
		case e_perCallInfo:
			delete m_perCallInfo;
			m_perCallInfo = 0;
			break;
		case e_tokens:
			delete m_tokens;
			m_tokens = 0;
			break;
		case e_cryptoTokens:
			delete m_cryptoTokens;
			m_cryptoTokens = 0;
			break;
		case e_integrityCheckValue:
			delete m_integrityCheckValue;
			m_integrityCheckValue = 0;
			break;
		case e_needResponse:
			delete m_needResponse;
			m_needResponse = 0;
			break;
		case e_capacity:
			delete m_capacity;
			m_capacity = 0;
			break;
		case e_irrStatus:
			delete m_irrStatus;
			m_irrStatus = 0;
			break;
		case e_unsolicited:
			delete m_unsolicited;
			m_unsolicited = 0;
			break;
		case e_genericData:
			delete m_genericData;
			m_genericData = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void InfoRequestResponse :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	m_requestSeqNum.encode ( os );
	m_endpointType.encode ( os );
	m_endpointIdentifier.encode ( os );
	m_rasAddress.encode ( os );
	m_callSignalAddress.encode ( os );
	if ( hasOptionalField ( e_endpointAlias ) )
		m_endpointAlias -> ArrayOf_AliasAddress :: encode ( os );
	if ( hasOptionalField ( e_perCallInfo ) )
		m_perCallInfo -> InfoRequestResponse_perCallInfo :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_tokens, m_tokens );
		knownExtensionEncode ( os, e_cryptoTokens, m_cryptoTokens );
		knownExtensionEncode ( os, e_integrityCheckValue, m_integrityCheckValue );
		knownExtensionEncode ( os, e_needResponse, m_needResponse );
		knownExtensionEncode ( os, e_capacity, m_capacity );
		knownExtensionEncode ( os, e_irrStatus, m_irrStatus );
		knownExtensionEncode ( os, e_unsolicited, m_unsolicited );
		knownExtensionEncode ( os, e_genericData, m_genericData );
		unknownExtensionsEncode ( os );
	}
}

InfoRequestResponse :: ~InfoRequestResponse ( ) {
	delete m_nonStandardData;
	delete m_endpointAlias;
	delete m_perCallInfo;
	delete m_tokens;
	delete m_cryptoTokens;
	delete m_integrityCheckValue;
	delete m_needResponse;
	delete m_capacity;
	delete m_irrStatus;
	delete m_unsolicited;
	delete m_genericData;
}

void InfoRequestResponse :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 16 ) << "requestSeqNum = " << std :: setprecision ( indent ) << m_requestSeqNum << '\n';
	os << std :: setw ( indent + 15 ) << "endpointType = " << std :: setprecision ( indent ) << m_endpointType << '\n';
	os << std :: setw ( indent + 21 ) << "endpointIdentifier = " << std :: setprecision ( indent ) << m_endpointIdentifier << '\n';
	os << std :: setw ( indent + 13 ) << "rasAddress = " << std :: setprecision ( indent ) << m_rasAddress << '\n';
	os << std :: setw ( indent + 20 ) << "callSignalAddress = " << std :: setprecision ( indent ) << m_callSignalAddress << '\n';
	if ( hasOptionalField ( e_endpointAlias ) ) {
		os << std :: setw ( indent + 16 ) << "endpointAlias = " << std :: setprecision ( indent );
		m_endpointAlias -> ArrayOf_AliasAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_perCallInfo ) ) {
		os << std :: setw ( indent + 14 ) << "perCallInfo = " << std :: setprecision ( indent );
		m_perCallInfo -> InfoRequestResponse_perCallInfo :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokens ) ) {
		os << std :: setw ( indent + 9 ) << "tokens = " << std :: setprecision ( indent );
		m_tokens -> ArrayOf_ClearToken :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cryptoTokens ) ) {
		os << std :: setw ( indent + 15 ) << "cryptoTokens = " << std :: setprecision ( indent );
		m_cryptoTokens -> ArrayOf_CryptoH323Token :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_integrityCheckValue ) ) {
		os << std :: setw ( indent + 22 ) << "integrityCheckValue = " << std :: setprecision ( indent );
		m_integrityCheckValue -> ICV :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_needResponse ) ) {
		os << std :: setw ( indent + 15 ) << "needResponse = " << std :: setprecision ( indent );
		m_needResponse -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_capacity ) ) {
		os << std :: setw ( indent + 11 ) << "capacity = " << std :: setprecision ( indent );
		m_capacity -> CallCapacity :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_irrStatus ) ) {
		os << std :: setw ( indent + 12 ) << "irrStatus = " << std :: setprecision ( indent );
		m_irrStatus -> InfoRequestResponseStatus :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_unsolicited ) ) {
		os << std :: setw ( indent + 14 ) << "unsolicited = " << std :: setprecision ( indent );
		m_unsolicited -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_genericData ) ) {
		os << std :: setw ( indent + 14 ) << "genericData = " << std :: setprecision ( indent );
		m_genericData -> ArrayOf_GenericData :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

InfoRequestResponse * InfoRequestResponse :: clone ( ) const {
	return new InfoRequestResponse ( * this );
}

//
// AliasAddress
//

AliasAddress :: AliasAddress ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_dialedDigits:
			choice = new AliasAddress_dialedDigits ( is );
			break;
		case e_h323_ID:
			choice = new AliasAddress_h323_ID ( is );
			break;
		case e_url_ID:
			choice = new AliasAddress_url_ID ( is );
			break;
		case e_transportID:
			choice = new TransportAddress ( is );
			break;
		case e_email_ID:
			choice = new AliasAddress_email_ID ( is );
			break;
		case e_partyNumber:
			choice = new PartyNumber ( is );
			break;
		case e_mobileUIM:
			choice = new MobileUIM ( is );
			break;
		case e_isupNumber:
			choice = new IsupNumber ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

AliasAddress :: AliasAddress ( ) : Asn :: Choice ( 2, true ) { }

void AliasAddress :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_dialedDigits:
			o = new AliasAddress_dialedDigits;
			break;
		case e_h323_ID:
			o = new AliasAddress_h323_ID;
			break;
		case e_url_ID:
			o = new AliasAddress_url_ID;
			break;
		case e_transportID:
			o = new TransportAddress;
			break;
		case e_email_ID:
			o = new AliasAddress_email_ID;
			break;
		case e_partyNumber:
			o = new PartyNumber;
			break;
		case e_mobileUIM:
			o = new MobileUIM;
			break;
		case e_isupNumber:
			o = new IsupNumber;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & AliasAddress :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_dialedDigits, "dialedDigits" },
		{ e_h323_ID, "h323_ID" },
		{ e_url_ID, "url_ID" },
		{ e_transportID, "transportID" },
		{ e_email_ID, "email_ID" },
		{ e_partyNumber, "partyNumber" },
		{ e_mobileUIM, "mobileUIM" },
		{ e_isupNumber, "isupNumber" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

AliasAddress * AliasAddress :: clone ( ) const {
	return new AliasAddress ( * this );
}

//
// AddressPattern
//

AddressPattern :: AddressPattern ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_wildcard:
			choice = new AliasAddress ( is );
			break;
		case e_range:
			choice = new AddressPattern_range ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

AddressPattern :: AddressPattern ( ) : Asn :: Choice ( 2, true ) { }

void AddressPattern :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_wildcard:
			o = new AliasAddress;
			break;
		case e_range:
			o = new AddressPattern_range;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & AddressPattern :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_wildcard, "wildcard" },
		{ e_range, "range" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

AddressPattern * AddressPattern :: clone ( ) const {
	return new AddressPattern ( * this );
}

//
// ExtendedAliasAddress
//

ExtendedAliasAddress :: ExtendedAliasAddress ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 0 ), m_address ( is ), m_presentationIndicator ( 0 ), m_screeningIndicator ( 0 ) {
	try {
		if ( hasOptionalField ( e_presentationIndicator ) )
			m_presentationIndicator = new PresentationIndicator ( is );
		if ( hasOptionalField ( e_screeningIndicator ) )
			m_screeningIndicator = new ScreeningIndicator ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_presentationIndicator;
		delete m_screeningIndicator;
		throw;
	}
}

ExtendedAliasAddress :: ExtendedAliasAddress ( ) : Asn :: Sequence ( 2, true, 0 ), m_presentationIndicator ( 0 ), m_screeningIndicator ( 0 ) { }

ExtendedAliasAddress & ExtendedAliasAddress :: operator= ( const ExtendedAliasAddress & s ) {
	Asn :: Sequence :: operator= ( s );
	m_address = s.m_address;
	assignCopy ( m_presentationIndicator, s.m_presentationIndicator );
	assignCopy ( m_screeningIndicator, s.m_screeningIndicator );
	return * this;
}

ExtendedAliasAddress :: ExtendedAliasAddress ( const ExtendedAliasAddress & s ) : Asn :: Sequence ( s ), m_address ( s.m_address ), m_presentationIndicator ( 0 ), m_screeningIndicator ( 0 ) {
	try {
		if ( s.m_presentationIndicator )
			m_presentationIndicator = new PresentationIndicator ( * s.m_presentationIndicator );
		if ( s.m_screeningIndicator )
			m_screeningIndicator = new ScreeningIndicator ( * s.m_screeningIndicator );
	} catch ( ... ) {
		delete m_presentationIndicator;
		delete m_screeningIndicator;
		throw;
	}
}


void ExtendedAliasAddress :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_presentationIndicator:
			assignNew ( m_presentationIndicator, new PresentationIndicator );
			break;
		case e_screeningIndicator:
			assignNew ( m_screeningIndicator, new ScreeningIndicator );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void ExtendedAliasAddress :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_presentationIndicator:
			delete m_presentationIndicator;
			m_presentationIndicator = 0;
			break;
		case e_screeningIndicator:
			delete m_screeningIndicator;
			m_screeningIndicator = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void ExtendedAliasAddress :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_address.encode ( os );
	if ( hasOptionalField ( e_presentationIndicator ) )
		m_presentationIndicator -> PresentationIndicator :: encode ( os );
	if ( hasOptionalField ( e_screeningIndicator ) )
		m_screeningIndicator -> ScreeningIndicator :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

ExtendedAliasAddress :: ~ExtendedAliasAddress ( ) {
	delete m_presentationIndicator;
	delete m_screeningIndicator;
}

void ExtendedAliasAddress :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 10 ) << "address = " << std :: setprecision ( indent ) << m_address << '\n';
	if ( hasOptionalField ( e_presentationIndicator ) ) {
		os << std :: setw ( indent + 24 ) << "presentationIndicator = " << std :: setprecision ( indent );
		m_presentationIndicator -> PresentationIndicator :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_screeningIndicator ) ) {
		os << std :: setw ( indent + 21 ) << "screeningIndicator = " << std :: setprecision ( indent );
		m_screeningIndicator -> ScreeningIndicator :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

ExtendedAliasAddress * ExtendedAliasAddress :: clone ( ) const {
	return new ExtendedAliasAddress ( * this );
}

//
// SupportedPrefix
//

SupportedPrefix :: SupportedPrefix ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_nonStandardData ( hasOptionalField ( e_nonStandardData ) ? pushTemporaryMember ( new NonStandardParameter ( is ) ) : 0 ), m_prefix ( is ) {
	clearTemporaryMembers ( );
	try {
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_nonStandardData;
		throw;
	}
}

SupportedPrefix :: SupportedPrefix ( ) : Asn :: Sequence ( 1, true, 0 ), m_nonStandardData ( 0 ) { }

SupportedPrefix & SupportedPrefix :: operator= ( const SupportedPrefix & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	m_prefix = s.m_prefix;
	return * this;
}

SupportedPrefix :: SupportedPrefix ( const SupportedPrefix & s ) : Asn :: Sequence ( s ), m_nonStandardData ( 0 ), m_prefix ( s.m_prefix ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
	} catch ( ... ) {
		delete m_nonStandardData;
		throw;
	}
}


void SupportedPrefix :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void SupportedPrefix :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void SupportedPrefix :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	m_prefix.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

SupportedPrefix :: ~SupportedPrefix ( ) {
	delete m_nonStandardData;
}

void SupportedPrefix :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 9 ) << "prefix = " << std :: setprecision ( indent ) << m_prefix << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

SupportedPrefix * SupportedPrefix :: clone ( ) const {
	return new SupportedPrefix ( * this );
}

//
// Content
//

Content :: Content ( Asn :: istream & is ) : Asn :: Choice ( is, 12, true ) {
	switch ( tag ) {
		case e_raw:
			choice = new Asn :: OctetString ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) );
			break;
		case e_text:
			choice = new Asn :: IA5String ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) );
			break;
		case e_unicode:
			choice = new Asn :: BMPString ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) );
			break;
		case e_bool:
			choice = new Asn :: Boolean ( is );
			break;
		case e_number8:
			choice = new Content_number8 ( is );
			break;
		case e_number16:
			choice = new Content_number16 ( is );
			break;
		case e_number32:
			choice = new Content_number32 ( is );
			break;
		case e_id:
			choice = new GenericIdentifier ( is );
			break;
		case e_alias:
			choice = new AliasAddress ( is );
			break;
		case e_transport:
			choice = new TransportAddress ( is );
			break;
		case e_compound:
			choice = new Content_compound ( is );
			break;
		case e_nested:
			choice = new Content_nested ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

Content :: Content ( ) : Asn :: Choice ( 12, true ) { }

void Content :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_raw:
			o = new Asn :: OctetString;
			break;
		case e_text:
			o = new Asn :: IA5String;
			break;
		case e_unicode:
			o = new Asn :: BMPString;
			break;
		case e_bool:
			o = new Asn :: Boolean;
			break;
		case e_number8:
			o = new Content_number8;
			break;
		case e_number16:
			o = new Content_number16;
			break;
		case e_number32:
			o = new Content_number32;
			break;
		case e_id:
			o = new GenericIdentifier;
			break;
		case e_alias:
			o = new AliasAddress;
			break;
		case e_transport:
			o = new TransportAddress;
			break;
		case e_compound:
			o = new Content_compound;
			break;
		case e_nested:
			o = new Content_nested;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & Content :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_raw, "raw" },
		{ e_text, "text" },
		{ e_unicode, "unicode" },
		{ e_bool, "bool" },
		{ e_number8, "number8" },
		{ e_number16, "number16" },
		{ e_number32, "number32" },
		{ e_id, "id" },
		{ e_alias, "alias" },
		{ e_transport, "transport" },
		{ e_compound, "compound" },
		{ e_nested, "nested" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

Content * Content :: clone ( ) const {
	return new Content ( * this );
}

//
// RasMessage
//

RasMessage :: RasMessage ( Asn :: istream & is ) : Asn :: Choice ( is, 25, true ) {
	switch ( tag ) {
		case e_gatekeeperRequest:
			choice = new GatekeeperRequest ( is );
			break;
		case e_gatekeeperConfirm:
			choice = new GatekeeperConfirm ( is );
			break;
		case e_gatekeeperReject:
			choice = new GatekeeperReject ( is );
			break;
		case e_registrationRequest:
			choice = new RegistrationRequest ( is );
			break;
		case e_registrationConfirm:
			choice = new RegistrationConfirm ( is );
			break;
		case e_registrationReject:
			choice = new RegistrationReject ( is );
			break;
		case e_unregistrationRequest:
			choice = new UnregistrationRequest ( is );
			break;
		case e_unregistrationConfirm:
			choice = new UnregistrationConfirm ( is );
			break;
		case e_unregistrationReject:
			choice = new UnregistrationReject ( is );
			break;
		case e_admissionRequest:
			choice = new AdmissionRequest ( is );
			break;
		case e_admissionConfirm:
			choice = new AdmissionConfirm ( is );
			break;
		case e_admissionReject:
			choice = new AdmissionReject ( is );
			break;
		case e_bandwidthRequest:
			choice = new BandwidthRequest ( is );
			break;
		case e_bandwidthConfirm:
			choice = new BandwidthConfirm ( is );
			break;
		case e_bandwidthReject:
			choice = new BandwidthReject ( is );
			break;
		case e_disengageRequest:
			choice = new DisengageRequest ( is );
			break;
		case e_disengageConfirm:
			choice = new DisengageConfirm ( is );
			break;
		case e_disengageReject:
			choice = new DisengageReject ( is );
			break;
		case e_locationRequest:
			choice = new LocationRequest ( is );
			break;
		case e_locationConfirm:
			choice = new LocationConfirm ( is );
			break;
		case e_locationReject:
			choice = new LocationReject ( is );
			break;
		case e_infoRequest:
			choice = new InfoRequest ( is );
			break;
		case e_infoRequestResponse:
			choice = new InfoRequestResponse ( is );
			break;
		case e_nonStandardMessage:
			choice = new NonStandardMessage ( is );
			break;
		case e_unknownMessageResponse:
			choice = new UnknownMessageResponse ( is );
			break;
		case e_requestInProgress:
			choice = new RequestInProgress ( is );
			break;
		case e_resourcesAvailableIndicate:
			choice = new ResourcesAvailableIndicate ( is );
			break;
		case e_resourcesAvailableConfirm:
			choice = new ResourcesAvailableConfirm ( is );
			break;
		case e_infoRequestAck:
			choice = new InfoRequestAck ( is );
			break;
		case e_infoRequestNak:
			choice = new InfoRequestNak ( is );
			break;
		case e_serviceControlIndication:
			choice = new ServiceControlIndication ( is );
			break;
		case e_serviceControlResponse:
			choice = new ServiceControlResponse ( is );
			break;
		case e_admissionConfirmSequence:
			choice = new ArrayOf_AdmissionConfirm ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

RasMessage :: RasMessage ( ) : Asn :: Choice ( 25, true ) { }

void RasMessage :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_gatekeeperRequest:
			o = new GatekeeperRequest;
			break;
		case e_gatekeeperConfirm:
			o = new GatekeeperConfirm;
			break;
		case e_gatekeeperReject:
			o = new GatekeeperReject;
			break;
		case e_registrationRequest:
			o = new RegistrationRequest;
			break;
		case e_registrationConfirm:
			o = new RegistrationConfirm;
			break;
		case e_registrationReject:
			o = new RegistrationReject;
			break;
		case e_unregistrationRequest:
			o = new UnregistrationRequest;
			break;
		case e_unregistrationConfirm:
			o = new UnregistrationConfirm;
			break;
		case e_unregistrationReject:
			o = new UnregistrationReject;
			break;
		case e_admissionRequest:
			o = new AdmissionRequest;
			break;
		case e_admissionConfirm:
			o = new AdmissionConfirm;
			break;
		case e_admissionReject:
			o = new AdmissionReject;
			break;
		case e_bandwidthRequest:
			o = new BandwidthRequest;
			break;
		case e_bandwidthConfirm:
			o = new BandwidthConfirm;
			break;
		case e_bandwidthReject:
			o = new BandwidthReject;
			break;
		case e_disengageRequest:
			o = new DisengageRequest;
			break;
		case e_disengageConfirm:
			o = new DisengageConfirm;
			break;
		case e_disengageReject:
			o = new DisengageReject;
			break;
		case e_locationRequest:
			o = new LocationRequest;
			break;
		case e_locationConfirm:
			o = new LocationConfirm;
			break;
		case e_locationReject:
			o = new LocationReject;
			break;
		case e_infoRequest:
			o = new InfoRequest;
			break;
		case e_infoRequestResponse:
			o = new InfoRequestResponse;
			break;
		case e_nonStandardMessage:
			o = new NonStandardMessage;
			break;
		case e_unknownMessageResponse:
			o = new UnknownMessageResponse;
			break;
		case e_requestInProgress:
			o = new RequestInProgress;
			break;
		case e_resourcesAvailableIndicate:
			o = new ResourcesAvailableIndicate;
			break;
		case e_resourcesAvailableConfirm:
			o = new ResourcesAvailableConfirm;
			break;
		case e_infoRequestAck:
			o = new InfoRequestAck;
			break;
		case e_infoRequestNak:
			o = new InfoRequestNak;
			break;
		case e_serviceControlIndication:
			o = new ServiceControlIndication;
			break;
		case e_serviceControlResponse:
			o = new ServiceControlResponse;
			break;
		case e_admissionConfirmSequence:
			o = new ArrayOf_AdmissionConfirm;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & RasMessage :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_gatekeeperRequest, "gatekeeperRequest" },
		{ e_gatekeeperConfirm, "gatekeeperConfirm" },
		{ e_gatekeeperReject, "gatekeeperReject" },
		{ e_registrationRequest, "registrationRequest" },
		{ e_registrationConfirm, "registrationConfirm" },
		{ e_registrationReject, "registrationReject" },
		{ e_unregistrationRequest, "unregistrationRequest" },
		{ e_unregistrationConfirm, "unregistrationConfirm" },
		{ e_unregistrationReject, "unregistrationReject" },
		{ e_admissionRequest, "admissionRequest" },
		{ e_admissionConfirm, "admissionConfirm" },
		{ e_admissionReject, "admissionReject" },
		{ e_bandwidthRequest, "bandwidthRequest" },
		{ e_bandwidthConfirm, "bandwidthConfirm" },
		{ e_bandwidthReject, "bandwidthReject" },
		{ e_disengageRequest, "disengageRequest" },
		{ e_disengageConfirm, "disengageConfirm" },
		{ e_disengageReject, "disengageReject" },
		{ e_locationRequest, "locationRequest" },
		{ e_locationConfirm, "locationConfirm" },
		{ e_locationReject, "locationReject" },
		{ e_infoRequest, "infoRequest" },
		{ e_infoRequestResponse, "infoRequestResponse" },
		{ e_nonStandardMessage, "nonStandardMessage" },
		{ e_unknownMessageResponse, "unknownMessageResponse" },
		{ e_requestInProgress, "requestInProgress" },
		{ e_resourcesAvailableIndicate, "resourcesAvailableIndicate" },
		{ e_resourcesAvailableConfirm, "resourcesAvailableConfirm" },
		{ e_infoRequestAck, "infoRequestAck" },
		{ e_infoRequestNak, "infoRequestNak" },
		{ e_serviceControlIndication, "serviceControlIndication" },
		{ e_serviceControlResponse, "serviceControlResponse" },
		{ e_admissionConfirmSequence, "admissionConfirmSequence" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

RasMessage * RasMessage :: clone ( ) const {
	return new RasMessage ( * this );
}

//
// CryptoH323Token_cryptoEPPwdHash
//

CryptoH323Token_cryptoEPPwdHash :: CryptoH323Token_cryptoEPPwdHash ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, false, 0 ), m_alias ( is ), m_timeStamp ( is ), m_token ( is ) {
}

CryptoH323Token_cryptoEPPwdHash :: CryptoH323Token_cryptoEPPwdHash ( ) : Asn :: Sequence ( 0, false, 0 ) { }

void CryptoH323Token_cryptoEPPwdHash :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_alias.encode ( os );
	m_timeStamp.encode ( os );
	m_token.encode ( os );
}

void CryptoH323Token_cryptoEPPwdHash :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 8 ) << "alias = " << std :: setprecision ( indent ) << m_alias << '\n';
	os << std :: setw ( indent + 12 ) << "timeStamp = " << std :: setprecision ( indent ) << m_timeStamp << '\n';
	os << std :: setw ( indent + 8 ) << "token = " << std :: setprecision ( indent ) << m_token << '\n';
	os << std :: setw ( indent - 1 ) << '}';
}

CryptoH323Token_cryptoEPPwdHash * CryptoH323Token_cryptoEPPwdHash :: clone ( ) const {
	return new CryptoH323Token_cryptoEPPwdHash ( * this );
}

//
// CryptoH323Token
//

CryptoH323Token :: CryptoH323Token ( Asn :: istream & is ) : Asn :: Choice ( is, 8, true ) {
	switch ( tag ) {
		case e_cryptoEPPwdHash:
			choice = new CryptoH323Token_cryptoEPPwdHash ( is );
			break;
		case e_cryptoGKPwdHash:
			choice = new CryptoH323Token_cryptoGKPwdHash ( is );
			break;
		case e_cryptoEPPwdEncr:
		case e_cryptoGKPwdEncr:
			choice = new H235 :: ENCRYPTED < H235 :: EncodedPwdCertToken > ( is );
			break;
		case e_cryptoEPCert:
		case e_cryptoGKCert:
			choice = new H235 :: SIGNED < H235 :: EncodedPwdCertToken > ( is );
			break;
		case e_cryptoFastStart:
			choice = new H235 :: SIGNED < EncodedFastStartToken > ( is );
			break;
		case e_nestedcryptoToken:
			choice = new H235 :: CryptoToken ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

CryptoH323Token :: CryptoH323Token ( ) : Asn :: Choice ( 8, true ) { }

void CryptoH323Token :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_cryptoEPPwdHash:
			o = new CryptoH323Token_cryptoEPPwdHash;
			break;
		case e_cryptoGKPwdHash:
			o = new CryptoH323Token_cryptoGKPwdHash;
			break;
		case e_cryptoEPPwdEncr:
		case e_cryptoGKPwdEncr:
			o = new H235 :: ENCRYPTED < H235 :: EncodedPwdCertToken >;
			break;
		case e_cryptoEPCert:
		case e_cryptoGKCert:
			o = new H235 :: SIGNED < H235 :: EncodedPwdCertToken >;
			break;
		case e_cryptoFastStart:
			o = new H235 :: SIGNED < EncodedFastStartToken >;
			break;
		case e_nestedcryptoToken:
			o = new H235 :: CryptoToken;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & CryptoH323Token :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_cryptoEPPwdHash, "cryptoEPPwdHash" },
		{ e_cryptoGKPwdHash, "cryptoGKPwdHash" },
		{ e_cryptoEPPwdEncr, "cryptoEPPwdEncr" },
		{ e_cryptoGKPwdEncr, "cryptoGKPwdEncr" },
		{ e_cryptoEPCert, "cryptoEPCert" },
		{ e_cryptoGKCert, "cryptoGKCert" },
		{ e_cryptoFastStart, "cryptoFastStart" },
		{ e_nestedcryptoToken, "nestedcryptoToken" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

CryptoH323Token * CryptoH323Token :: clone ( ) const {
	return new CryptoH323Token ( * this );
}


// End of h225.cxx
