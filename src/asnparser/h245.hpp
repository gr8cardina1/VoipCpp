//
// h245.hpp
//
// Code automatically generated by asnparse.
//

#ifndef __H245_HPP
#define __H245_HPP

#ifdef __GNUC__
#pragma interface
#endif

namespace H245 {

//
// SequenceNumber
//

// from 0 size 0 type 0 simple 1
class SequenceNumber : public Asn :: Integer {
	public:
	explicit SequenceNumber ( Asn :: istream & is );
	SequenceNumber ( unsigned v = 0 );
	SequenceNumber & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	SequenceNumber & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	SequenceNumber * clone ( ) const;
};

//
// MasterSlaveDeterminationRelease
//

// from 0 size 0 type 0 simple 0
class MasterSlaveDeterminationRelease : public Asn :: Sequence {
	public:
	explicit MasterSlaveDeterminationRelease ( Asn :: istream & is );
	MasterSlaveDeterminationRelease ( );
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MasterSlaveDeterminationRelease * clone ( ) const;
};

//
// TerminalCapabilitySet
//

// from 0 size 0 type 0 simple 0
class MultiplexCapability;
class TerminalCapabilitySet_capabilityTable;
class TerminalCapabilitySet_capabilityDescriptors;
class ArrayOf_GenericInformation;

class TerminalCapabilitySet : public Asn :: Sequence {
	public:
	explicit TerminalCapabilitySet ( Asn :: istream & is );
	TerminalCapabilitySet ( );
	enum OptionalFields {
		e_multiplexCapability,
		e_capabilityTable,
		e_capabilityDescriptors,
		e_genericInformation
	};

	TerminalCapabilitySet ( const TerminalCapabilitySet & s );
	TerminalCapabilitySet & operator= ( const TerminalCapabilitySet & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	SequenceNumber m_sequenceNumber;
	Asn :: ObjectId m_protocolIdentifier;
	protected:
	MultiplexCapability * m_multiplexCapability;
	TerminalCapabilitySet_capabilityTable * m_capabilityTable;
	TerminalCapabilitySet_capabilityDescriptors * m_capabilityDescriptors;
	ArrayOf_GenericInformation * m_genericInformation;
	public:
	void encode ( Asn :: ostream & os ) const;
	~TerminalCapabilitySet ( );
	void printOn ( std :: ostream & os ) const;
	const MultiplexCapability & get_multiplexCapability ( ) const {
		return * m_multiplexCapability;
	}
	MultiplexCapability & get_multiplexCapability ( ) {
		return * m_multiplexCapability;
	}
	const TerminalCapabilitySet_capabilityTable & get_capabilityTable ( ) const {
		return * m_capabilityTable;
	}
	TerminalCapabilitySet_capabilityTable & get_capabilityTable ( ) {
		return * m_capabilityTable;
	}
	const TerminalCapabilitySet_capabilityDescriptors & get_capabilityDescriptors ( ) const {
		return * m_capabilityDescriptors;
	}
	TerminalCapabilitySet_capabilityDescriptors & get_capabilityDescriptors ( ) {
		return * m_capabilityDescriptors;
	}
	const ArrayOf_GenericInformation & get_genericInformation ( ) const {
		return * m_genericInformation;
	}
	ArrayOf_GenericInformation & get_genericInformation ( ) {
		return * m_genericInformation;
	}
	TerminalCapabilitySet * clone ( ) const;
};

//
// AlternativeCapabilitySet
//

// from 0 size 1 type 0 simple 0
class CapabilityTableEntryNumber;

class AlternativeCapabilitySet : public Asn :: Array {
	public:
	explicit AlternativeCapabilitySet ( Asn :: istream & is );
	AlternativeCapabilitySet ( );
	explicit AlternativeCapabilitySet ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const CapabilityTableEntryNumber & o );
	const CapabilityTableEntryNumber & operator[] ( std :: size_t i ) const;
	CapabilityTableEntryNumber & operator[] ( std :: size_t i );
	AlternativeCapabilitySet * clone ( ) const;
};

//
// CapabilityTableEntryNumber
//

// from 0 size 0 type 0 simple 1
class CapabilityTableEntryNumber : public Asn :: Integer {
	public:
	explicit CapabilityTableEntryNumber ( Asn :: istream & is );
	CapabilityTableEntryNumber ( unsigned v = 0 );
	CapabilityTableEntryNumber & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CapabilityTableEntryNumber & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CapabilityTableEntryNumber * clone ( ) const;
};

//
// CapabilityDescriptorNumber
//

// from 0 size 0 type 0 simple 1
class CapabilityDescriptorNumber : public Asn :: Integer {
	public:
	explicit CapabilityDescriptorNumber ( Asn :: istream & is );
	CapabilityDescriptorNumber ( unsigned v = 0 );
	CapabilityDescriptorNumber & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CapabilityDescriptorNumber & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CapabilityDescriptorNumber * clone ( ) const;
};

//
// TerminalCapabilitySetAck
//

// from 0 size 0 type 0 simple 0
class TerminalCapabilitySetAck : public Asn :: Sequence {
	public:
	explicit TerminalCapabilitySetAck ( Asn :: istream & is );
	TerminalCapabilitySetAck ( );
	enum OptionalFields {
		e_genericInformation
	};

	TerminalCapabilitySetAck ( const TerminalCapabilitySetAck & s );
	TerminalCapabilitySetAck & operator= ( const TerminalCapabilitySetAck & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	SequenceNumber m_sequenceNumber;
	protected:
	ArrayOf_GenericInformation * m_genericInformation;
	public:
	void encode ( Asn :: ostream & os ) const;
	~TerminalCapabilitySetAck ( );
	void printOn ( std :: ostream & os ) const;
	const ArrayOf_GenericInformation & get_genericInformation ( ) const {
		return * m_genericInformation;
	}
	ArrayOf_GenericInformation & get_genericInformation ( ) {
		return * m_genericInformation;
	}
	TerminalCapabilitySetAck * clone ( ) const;
};

//
// TerminalCapabilitySetRelease
//

// from 0 size 0 type 0 simple 0
class TerminalCapabilitySetRelease : public Asn :: Sequence {
	public:
	explicit TerminalCapabilitySetRelease ( Asn :: istream & is );
	TerminalCapabilitySetRelease ( );
	enum OptionalFields {
		e_genericInformation
	};

	TerminalCapabilitySetRelease ( const TerminalCapabilitySetRelease & s );
	TerminalCapabilitySetRelease & operator= ( const TerminalCapabilitySetRelease & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	ArrayOf_GenericInformation * m_genericInformation;
	public:
	void encode ( Asn :: ostream & os ) const;
	~TerminalCapabilitySetRelease ( );
	void printOn ( std :: ostream & os ) const;
	const ArrayOf_GenericInformation & get_genericInformation ( ) const {
		return * m_genericInformation;
	}
	ArrayOf_GenericInformation & get_genericInformation ( ) {
		return * m_genericInformation;
	}
	TerminalCapabilitySetRelease * clone ( ) const;
};

//
// V75Capability
//

// from 0 size 0 type 0 simple 0
class V75Capability : public Asn :: Sequence {
	public:
	explicit V75Capability ( Asn :: istream & is );
	V75Capability ( );
	Asn :: Boolean m_audioHeader;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	V75Capability * clone ( ) const;
};

//
// MediaPacketizationCapability
//

// from 0 size 0 type 0 simple 0
class MediaPacketizationCapability_rtpPayloadType;

class MediaPacketizationCapability : public Asn :: Sequence {
	public:
	explicit MediaPacketizationCapability ( Asn :: istream & is );
	MediaPacketizationCapability ( );
	enum OptionalFields {
		e_rtpPayloadType
	};

	MediaPacketizationCapability ( const MediaPacketizationCapability & s );
	MediaPacketizationCapability & operator= ( const MediaPacketizationCapability & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	Asn :: Boolean m_h261aVideoPacketization;
	protected:
	MediaPacketizationCapability_rtpPayloadType * m_rtpPayloadType;
	public:
	void encode ( Asn :: ostream & os ) const;
	~MediaPacketizationCapability ( );
	void printOn ( std :: ostream & os ) const;
	const MediaPacketizationCapability_rtpPayloadType & get_rtpPayloadType ( ) const {
		return * m_rtpPayloadType;
	}
	MediaPacketizationCapability_rtpPayloadType & get_rtpPayloadType ( ) {
		return * m_rtpPayloadType;
	}
	MediaPacketizationCapability * clone ( ) const;
};

//
// RSVPParameters
//

// from 0 size 0 type 0 simple 0
class QOSMode;
class RSVPParameters_tokenRate;
class RSVPParameters_bucketSize;
class RSVPParameters_peakRate;
class RSVPParameters_minPoliced;
class RSVPParameters_maxPktSize;

class RSVPParameters : public Asn :: Sequence {
	public:
	explicit RSVPParameters ( Asn :: istream & is );
	RSVPParameters ( );
	enum OptionalFields {
		e_qosMode,
		e_tokenRate,
		e_bucketSize,
		e_peakRate,
		e_minPoliced,
		e_maxPktSize
	};

	RSVPParameters ( const RSVPParameters & s );
	RSVPParameters & operator= ( const RSVPParameters & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	QOSMode * m_qosMode;
	RSVPParameters_tokenRate * m_tokenRate;
	RSVPParameters_bucketSize * m_bucketSize;
	RSVPParameters_peakRate * m_peakRate;
	RSVPParameters_minPoliced * m_minPoliced;
	RSVPParameters_maxPktSize * m_maxPktSize;
	public:
	void encode ( Asn :: ostream & os ) const;
	~RSVPParameters ( );
	void printOn ( std :: ostream & os ) const;
	const QOSMode & get_qosMode ( ) const {
		return * m_qosMode;
	}
	QOSMode & get_qosMode ( ) {
		return * m_qosMode;
	}
	const RSVPParameters_tokenRate & get_tokenRate ( ) const {
		return * m_tokenRate;
	}
	RSVPParameters_tokenRate & get_tokenRate ( ) {
		return * m_tokenRate;
	}
	const RSVPParameters_bucketSize & get_bucketSize ( ) const {
		return * m_bucketSize;
	}
	RSVPParameters_bucketSize & get_bucketSize ( ) {
		return * m_bucketSize;
	}
	const RSVPParameters_peakRate & get_peakRate ( ) const {
		return * m_peakRate;
	}
	RSVPParameters_peakRate & get_peakRate ( ) {
		return * m_peakRate;
	}
	const RSVPParameters_minPoliced & get_minPoliced ( ) const {
		return * m_minPoliced;
	}
	RSVPParameters_minPoliced & get_minPoliced ( ) {
		return * m_minPoliced;
	}
	const RSVPParameters_maxPktSize & get_maxPktSize ( ) const {
		return * m_maxPktSize;
	}
	RSVPParameters_maxPktSize & get_maxPktSize ( ) {
		return * m_maxPktSize;
	}
	RSVPParameters * clone ( ) const;
};

//
// QOSMode
//

// from 0 size 0 type 0 simple 0
class QOSMode : public Asn :: Choice {
	public:
	explicit QOSMode ( Asn :: istream & is );
	QOSMode ( );
	enum Choices {
		e_guaranteedQOS,
		e_controlledLoad
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	QOSMode * clone ( ) const;
};

//
// ServicePriorityValue
//

// from 0 size 0 type 0 simple 0
class NonStandardParameter;

class ServicePriorityValue : public Asn :: Sequence {
	public:
	explicit ServicePriorityValue ( Asn :: istream & is );
	ServicePriorityValue ( );
	enum OptionalFields {
		e_nonStandardParameter
	};

	ServicePriorityValue ( const ServicePriorityValue & s );
	ServicePriorityValue & operator= ( const ServicePriorityValue & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	NonStandardParameter * m_nonStandardParameter;
	public:
	void encode ( Asn :: ostream & os ) const;
	~ServicePriorityValue ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardParameter ( ) const {
		return * m_nonStandardParameter;
	}
	NonStandardParameter & get_nonStandardParameter ( ) {
		return * m_nonStandardParameter;
	}
	ServicePriorityValue * clone ( ) const;
};

//
// ServicePriority
//

// from 0 size 0 type 0 simple 0
class ServicePriority : public Asn :: Sequence {
	public:
	explicit ServicePriority ( Asn :: istream & is );
	ServicePriority ( );
	enum OptionalFields {
		e_nonStandardData,
		e_servicePriorityValue
	};

	ServicePriority ( const ServicePriority & s );
	ServicePriority & operator= ( const ServicePriority & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	NonStandardParameter * m_nonStandardData;
	public:
	Asn :: Boolean m_servicePrioritySignalled;
	protected:
	ServicePriorityValue * m_servicePriorityValue;
	public:
	void encode ( Asn :: ostream & os ) const;
	~ServicePriority ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const ServicePriorityValue & get_servicePriorityValue ( ) const {
		return * m_servicePriorityValue;
	}
	ServicePriorityValue & get_servicePriorityValue ( ) {
		return * m_servicePriorityValue;
	}
	ServicePriority * clone ( ) const;
};

//
// AuthorizationParameters
//

// from 0 size 0 type 0 simple 0
class AuthorizationParameters : public Asn :: Sequence {
	public:
	explicit AuthorizationParameters ( Asn :: istream & is );
	AuthorizationParameters ( );
	enum OptionalFields {
		e_nonStandardData
	};

	AuthorizationParameters ( const AuthorizationParameters & s );
	AuthorizationParameters & operator= ( const AuthorizationParameters & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	NonStandardParameter * m_nonStandardData;
	public:
	void encode ( Asn :: ostream & os ) const;
	~AuthorizationParameters ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	AuthorizationParameters * clone ( ) const;
};

//
// QOSType
//

// from 0 size 0 type 0 simple 0
class QOSType : public Asn :: Choice {
	public:
	explicit QOSType ( Asn :: istream & is );
	QOSType ( );
	enum Choices {
		e_desired,
		e_required
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	QOSType * clone ( ) const;
};

//
// QOSClass
//

// from 0 size 0 type 0 simple 0
class QOSClass : public Asn :: Choice {
	public:
	explicit QOSClass ( Asn :: istream & is );
	QOSClass ( );
	enum Choices {
		e_class0,
		e_class1,
		e_class2,
		e_class3,
		e_class4,
		e_class5
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	QOSClass * clone ( ) const;
};

//
// QOSDescriptor
//

// from 0 size 0 type 0 simple 0
class QOSDescriptor : public Asn :: Sequence {
	public:
	explicit QOSDescriptor ( Asn :: istream & is );
	QOSDescriptor ( );
	enum OptionalFields {
		e_nonStandardData
	};

	QOSDescriptor ( const QOSDescriptor & s );
	QOSDescriptor & operator= ( const QOSDescriptor & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	NonStandardParameter * m_nonStandardData;
	public:
	QOSType m_qosType;
	QOSClass m_qosClass;
	void encode ( Asn :: ostream & os ) const;
	~QOSDescriptor ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	QOSDescriptor * clone ( ) const;
};

//
// GenericTransportParameters
//

// from 0 size 0 type 0 simple 0
class GenericTransportParameters_averageRate;
class GenericTransportParameters_burst;
class GenericTransportParameters_peakRate;
class GenericTransportParameters_maxPktSize;

class GenericTransportParameters : public Asn :: Sequence {
	public:
	explicit GenericTransportParameters ( Asn :: istream & is );
	GenericTransportParameters ( );
	enum OptionalFields {
		e_nonStandardData,
		e_averageRate,
		e_burst,
		e_peakRate,
		e_maxPktSize
	};

	GenericTransportParameters ( const GenericTransportParameters & s );
	GenericTransportParameters & operator= ( const GenericTransportParameters & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	NonStandardParameter * m_nonStandardData;
	GenericTransportParameters_averageRate * m_averageRate;
	GenericTransportParameters_burst * m_burst;
	GenericTransportParameters_peakRate * m_peakRate;
	GenericTransportParameters_maxPktSize * m_maxPktSize;
	public:
	void encode ( Asn :: ostream & os ) const;
	~GenericTransportParameters ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const GenericTransportParameters_averageRate & get_averageRate ( ) const {
		return * m_averageRate;
	}
	GenericTransportParameters_averageRate & get_averageRate ( ) {
		return * m_averageRate;
	}
	const GenericTransportParameters_burst & get_burst ( ) const {
		return * m_burst;
	}
	GenericTransportParameters_burst & get_burst ( ) {
		return * m_burst;
	}
	const GenericTransportParameters_peakRate & get_peakRate ( ) const {
		return * m_peakRate;
	}
	GenericTransportParameters_peakRate & get_peakRate ( ) {
		return * m_peakRate;
	}
	const GenericTransportParameters_maxPktSize & get_maxPktSize ( ) const {
		return * m_maxPktSize;
	}
	GenericTransportParameters_maxPktSize & get_maxPktSize ( ) {
		return * m_maxPktSize;
	}
	GenericTransportParameters * clone ( ) const;
};

//
// QOSCapability
//

// from 0 size 0 type 0 simple 0
class ATMParameters;
class QOSCapability_dscpValue;

class QOSCapability : public Asn :: Sequence {
	public:
	explicit QOSCapability ( Asn :: istream & is );
	QOSCapability ( );
	enum OptionalFields {
		e_nonStandardData,
		e_rsvpParameters,
		e_atmParameters,
		e_localQoS,
		e_genericTransportParameters,
		e_servicePriority,
		e_authorizationParameter,
		e_qosDescriptor,
		e_dscpValue
	};

	QOSCapability ( const QOSCapability & s );
	QOSCapability & operator= ( const QOSCapability & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	NonStandardParameter * m_nonStandardData;
	RSVPParameters * m_rsvpParameters;
	ATMParameters * m_atmParameters;
	Asn :: Boolean * m_localQoS;
	GenericTransportParameters * m_genericTransportParameters;
	ServicePriority * m_servicePriority;
	AuthorizationParameters * m_authorizationParameter;
	QOSDescriptor * m_qosDescriptor;
	QOSCapability_dscpValue * m_dscpValue;
	public:
	void encode ( Asn :: ostream & os ) const;
	~QOSCapability ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const RSVPParameters & get_rsvpParameters ( ) const {
		return * m_rsvpParameters;
	}
	RSVPParameters & get_rsvpParameters ( ) {
		return * m_rsvpParameters;
	}
	const ATMParameters & get_atmParameters ( ) const {
		return * m_atmParameters;
	}
	ATMParameters & get_atmParameters ( ) {
		return * m_atmParameters;
	}
	const Asn :: Boolean & get_localQoS ( ) const {
		return * m_localQoS;
	}
	Asn :: Boolean & get_localQoS ( ) {
		return * m_localQoS;
	}
	const GenericTransportParameters & get_genericTransportParameters ( ) const {
		return * m_genericTransportParameters;
	}
	GenericTransportParameters & get_genericTransportParameters ( ) {
		return * m_genericTransportParameters;
	}
	const ServicePriority & get_servicePriority ( ) const {
		return * m_servicePriority;
	}
	ServicePriority & get_servicePriority ( ) {
		return * m_servicePriority;
	}
	const AuthorizationParameters & get_authorizationParameter ( ) const {
		return * m_authorizationParameter;
	}
	AuthorizationParameters & get_authorizationParameter ( ) {
		return * m_authorizationParameter;
	}
	const QOSDescriptor & get_qosDescriptor ( ) const {
		return * m_qosDescriptor;
	}
	QOSDescriptor & get_qosDescriptor ( ) {
		return * m_qosDescriptor;
	}
	const QOSCapability_dscpValue & get_dscpValue ( ) const {
		return * m_dscpValue;
	}
	QOSCapability_dscpValue & get_dscpValue ( ) {
		return * m_dscpValue;
	}
	QOSCapability * clone ( ) const;
};

//
// MediaChannelCapability
//

// from 0 size 0 type 0 simple 0
class MediaTransportType;

class MediaChannelCapability : public Asn :: Sequence {
	public:
	explicit MediaChannelCapability ( Asn :: istream & is );
	MediaChannelCapability ( );
	enum OptionalFields {
		e_mediaTransport
	};

	MediaChannelCapability ( const MediaChannelCapability & s );
	MediaChannelCapability & operator= ( const MediaChannelCapability & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	MediaTransportType * m_mediaTransport;
	public:
	void encode ( Asn :: ostream & os ) const;
	~MediaChannelCapability ( );
	void printOn ( std :: ostream & os ) const;
	const MediaTransportType & get_mediaTransport ( ) const {
		return * m_mediaTransport;
	}
	MediaTransportType & get_mediaTransport ( ) {
		return * m_mediaTransport;
	}
	MediaChannelCapability * clone ( ) const;
};

//
// TransportCapability
//

// from 0 size 0 type 0 simple 0
class TransportCapability_qOSCapabilities;
class TransportCapability_mediaChannelCapabilities;

class TransportCapability : public Asn :: Sequence {
	public:
	explicit TransportCapability ( Asn :: istream & is );
	TransportCapability ( );
	enum OptionalFields {
		e_nonStandard,
		e_qOSCapabilities,
		e_mediaChannelCapabilities
	};

	TransportCapability ( const TransportCapability & s );
	TransportCapability & operator= ( const TransportCapability & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	NonStandardParameter * m_nonStandard;
	TransportCapability_qOSCapabilities * m_qOSCapabilities;
	TransportCapability_mediaChannelCapabilities * m_mediaChannelCapabilities;
	public:
	void encode ( Asn :: ostream & os ) const;
	~TransportCapability ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandard ( ) const {
		return * m_nonStandard;
	}
	NonStandardParameter & get_nonStandard ( ) {
		return * m_nonStandard;
	}
	const TransportCapability_qOSCapabilities & get_qOSCapabilities ( ) const {
		return * m_qOSCapabilities;
	}
	TransportCapability_qOSCapabilities & get_qOSCapabilities ( ) {
		return * m_qOSCapabilities;
	}
	const TransportCapability_mediaChannelCapabilities & get_mediaChannelCapabilities ( ) const {
		return * m_mediaChannelCapabilities;
	}
	TransportCapability_mediaChannelCapabilities & get_mediaChannelCapabilities ( ) {
		return * m_mediaChannelCapabilities;
	}
	TransportCapability * clone ( ) const;
};

//
// MediaDistributionCapability
//

// from 0 size 0 type 0 simple 0
class ArrayOf_DataApplicationCapability;

class MediaDistributionCapability : public Asn :: Sequence {
	public:
	explicit MediaDistributionCapability ( Asn :: istream & is );
	MediaDistributionCapability ( );
	enum OptionalFields {
		e_centralizedData,
		e_distributedData
	};

	MediaDistributionCapability ( const MediaDistributionCapability & s );
	MediaDistributionCapability & operator= ( const MediaDistributionCapability & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	Asn :: Boolean m_centralizedControl;
	Asn :: Boolean m_distributedControl;
	Asn :: Boolean m_centralizedAudio;
	Asn :: Boolean m_distributedAudio;
	Asn :: Boolean m_centralizedVideo;
	Asn :: Boolean m_distributedVideo;
	protected:
	ArrayOf_DataApplicationCapability * m_centralizedData;
	ArrayOf_DataApplicationCapability * m_distributedData;
	public:
	void encode ( Asn :: ostream & os ) const;
	~MediaDistributionCapability ( );
	void printOn ( std :: ostream & os ) const;
	const ArrayOf_DataApplicationCapability & get_centralizedData ( ) const {
		return * m_centralizedData;
	}
	ArrayOf_DataApplicationCapability & get_centralizedData ( ) {
		return * m_centralizedData;
	}
	const ArrayOf_DataApplicationCapability & get_distributedData ( ) const {
		return * m_distributedData;
	}
	ArrayOf_DataApplicationCapability & get_distributedData ( ) {
		return * m_distributedData;
	}
	MediaDistributionCapability * clone ( ) const;
};

//
// H262VideoCapability
//

// from 0 size 0 type 0 simple 0
class H262VideoCapability_videoBitRate;
class H262VideoCapability_vbvBufferSize;
class H262VideoCapability_samplesPerLine;
class H262VideoCapability_linesPerFrame;
class H262VideoCapability_framesPerSecond;
class H262VideoCapability_luminanceSampleRate;

class H262VideoCapability : public Asn :: Sequence {
	public:
	explicit H262VideoCapability ( Asn :: istream & is );
	H262VideoCapability ( );
	enum OptionalFields {
		e_videoBitRate,
		e_vbvBufferSize,
		e_samplesPerLine,
		e_linesPerFrame,
		e_framesPerSecond,
		e_luminanceSampleRate
	};

	H262VideoCapability ( const H262VideoCapability & s );
	H262VideoCapability & operator= ( const H262VideoCapability & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	Asn :: Boolean m_profileAndLevel_SPatML;
	Asn :: Boolean m_profileAndLevel_MPatLL;
	Asn :: Boolean m_profileAndLevel_MPatML;
	Asn :: Boolean m_profileAndLevel_MPatH_14;
	Asn :: Boolean m_profileAndLevel_MPatHL;
	Asn :: Boolean m_profileAndLevel_SNRatLL;
	Asn :: Boolean m_profileAndLevel_SNRatML;
	Asn :: Boolean m_profileAndLevel_SpatialatH_14;
	Asn :: Boolean m_profileAndLevel_HPatML;
	Asn :: Boolean m_profileAndLevel_HPatH_14;
	Asn :: Boolean m_profileAndLevel_HPatHL;
	protected:
	H262VideoCapability_videoBitRate * m_videoBitRate;
	H262VideoCapability_vbvBufferSize * m_vbvBufferSize;
	H262VideoCapability_samplesPerLine * m_samplesPerLine;
	H262VideoCapability_linesPerFrame * m_linesPerFrame;
	H262VideoCapability_framesPerSecond * m_framesPerSecond;
	H262VideoCapability_luminanceSampleRate * m_luminanceSampleRate;
	public:
	Asn :: Boolean m_videoBadMBsCap;
	void encode ( Asn :: ostream & os ) const;
	~H262VideoCapability ( );
	void printOn ( std :: ostream & os ) const;
	const H262VideoCapability_videoBitRate & get_videoBitRate ( ) const {
		return * m_videoBitRate;
	}
	H262VideoCapability_videoBitRate & get_videoBitRate ( ) {
		return * m_videoBitRate;
	}
	const H262VideoCapability_vbvBufferSize & get_vbvBufferSize ( ) const {
		return * m_vbvBufferSize;
	}
	H262VideoCapability_vbvBufferSize & get_vbvBufferSize ( ) {
		return * m_vbvBufferSize;
	}
	const H262VideoCapability_samplesPerLine & get_samplesPerLine ( ) const {
		return * m_samplesPerLine;
	}
	H262VideoCapability_samplesPerLine & get_samplesPerLine ( ) {
		return * m_samplesPerLine;
	}
	const H262VideoCapability_linesPerFrame & get_linesPerFrame ( ) const {
		return * m_linesPerFrame;
	}
	H262VideoCapability_linesPerFrame & get_linesPerFrame ( ) {
		return * m_linesPerFrame;
	}
	const H262VideoCapability_framesPerSecond & get_framesPerSecond ( ) const {
		return * m_framesPerSecond;
	}
	H262VideoCapability_framesPerSecond & get_framesPerSecond ( ) {
		return * m_framesPerSecond;
	}
	const H262VideoCapability_luminanceSampleRate & get_luminanceSampleRate ( ) const {
		return * m_luminanceSampleRate;
	}
	H262VideoCapability_luminanceSampleRate & get_luminanceSampleRate ( ) {
		return * m_luminanceSampleRate;
	}
	H262VideoCapability * clone ( ) const;
};

//
// EnhancementLayerInfo
//

// from 0 size 0 type 0 simple 0
class EnhancementLayerInfo_snrEnhancement;
class EnhancementLayerInfo_spatialEnhancement;
class EnhancementLayerInfo_bPictureEnhancement;

class EnhancementLayerInfo : public Asn :: Sequence {
	public:
	explicit EnhancementLayerInfo ( Asn :: istream & is );
	EnhancementLayerInfo ( );
	enum OptionalFields {
		e_snrEnhancement,
		e_spatialEnhancement,
		e_bPictureEnhancement
	};

	EnhancementLayerInfo ( const EnhancementLayerInfo & s );
	EnhancementLayerInfo & operator= ( const EnhancementLayerInfo & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	Asn :: Boolean m_baseBitRateConstrained;
	protected:
	EnhancementLayerInfo_snrEnhancement * m_snrEnhancement;
	EnhancementLayerInfo_spatialEnhancement * m_spatialEnhancement;
	EnhancementLayerInfo_bPictureEnhancement * m_bPictureEnhancement;
	public:
	void encode ( Asn :: ostream & os ) const;
	~EnhancementLayerInfo ( );
	void printOn ( std :: ostream & os ) const;
	const EnhancementLayerInfo_snrEnhancement & get_snrEnhancement ( ) const {
		return * m_snrEnhancement;
	}
	EnhancementLayerInfo_snrEnhancement & get_snrEnhancement ( ) {
		return * m_snrEnhancement;
	}
	const EnhancementLayerInfo_spatialEnhancement & get_spatialEnhancement ( ) const {
		return * m_spatialEnhancement;
	}
	EnhancementLayerInfo_spatialEnhancement & get_spatialEnhancement ( ) {
		return * m_spatialEnhancement;
	}
	const EnhancementLayerInfo_bPictureEnhancement & get_bPictureEnhancement ( ) const {
		return * m_bPictureEnhancement;
	}
	EnhancementLayerInfo_bPictureEnhancement & get_bPictureEnhancement ( ) {
		return * m_bPictureEnhancement;
	}
	EnhancementLayerInfo * clone ( ) const;
};

//
// H263Options
//

// from 0 size 0 type 0 simple 0
class TransparencyParameters;
class RefPictureSelection;
class H263Options_customPictureClockFrequency;
class H263Options_customPictureFormat;
class H263Options_modeCombos;
class H263Version3Options;

class H263Options : public Asn :: Sequence {
	public:
	explicit H263Options ( Asn :: istream & is );
	H263Options ( );
	enum OptionalFields {
		e_transparencyParameters,
		e_refPictureSelection,
		e_customPictureClockFrequency,
		e_customPictureFormat,
		e_modeCombos,
		e_videoBadMBsCap,
		e_h263Version3Options
	};

	H263Options ( const H263Options & s );
	H263Options & operator= ( const H263Options & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	Asn :: Boolean m_advancedIntraCodingMode;
	Asn :: Boolean m_deblockingFilterMode;
	Asn :: Boolean m_improvedPBFramesMode;
	Asn :: Boolean m_unlimitedMotionVectors;
	Asn :: Boolean m_fullPictureFreeze;
	Asn :: Boolean m_partialPictureFreezeAndRelease;
	Asn :: Boolean m_resizingPartPicFreezeAndRelease;
	Asn :: Boolean m_fullPictureSnapshot;
	Asn :: Boolean m_partialPictureSnapshot;
	Asn :: Boolean m_videoSegmentTagging;
	Asn :: Boolean m_progressiveRefinement;
	Asn :: Boolean m_dynamicPictureResizingByFour;
	Asn :: Boolean m_dynamicPictureResizingSixteenthPel;
	Asn :: Boolean m_dynamicWarpingHalfPel;
	Asn :: Boolean m_dynamicWarpingSixteenthPel;
	Asn :: Boolean m_independentSegmentDecoding;
	Asn :: Boolean m_slicesInOrder_NonRect;
	Asn :: Boolean m_slicesInOrder_Rect;
	Asn :: Boolean m_slicesNoOrder_NonRect;
	Asn :: Boolean m_slicesNoOrder_Rect;
	Asn :: Boolean m_alternateInterVLCMode;
	Asn :: Boolean m_modifiedQuantizationMode;
	Asn :: Boolean m_reducedResolutionUpdate;
	protected:
	TransparencyParameters * m_transparencyParameters;
	public:
	Asn :: Boolean m_separateVideoBackChannel;
	protected:
	RefPictureSelection * m_refPictureSelection;
	H263Options_customPictureClockFrequency * m_customPictureClockFrequency;
	H263Options_customPictureFormat * m_customPictureFormat;
	H263Options_modeCombos * m_modeCombos;
	Asn :: Boolean * m_videoBadMBsCap;
	H263Version3Options * m_h263Version3Options;
	public:
	void encode ( Asn :: ostream & os ) const;
	~H263Options ( );
	void printOn ( std :: ostream & os ) const;
	const TransparencyParameters & get_transparencyParameters ( ) const {
		return * m_transparencyParameters;
	}
	TransparencyParameters & get_transparencyParameters ( ) {
		return * m_transparencyParameters;
	}
	const RefPictureSelection & get_refPictureSelection ( ) const {
		return * m_refPictureSelection;
	}
	RefPictureSelection & get_refPictureSelection ( ) {
		return * m_refPictureSelection;
	}
	const H263Options_customPictureClockFrequency & get_customPictureClockFrequency ( ) const {
		return * m_customPictureClockFrequency;
	}
	H263Options_customPictureClockFrequency & get_customPictureClockFrequency ( ) {
		return * m_customPictureClockFrequency;
	}
	const H263Options_customPictureFormat & get_customPictureFormat ( ) const {
		return * m_customPictureFormat;
	}
	H263Options_customPictureFormat & get_customPictureFormat ( ) {
		return * m_customPictureFormat;
	}
	const H263Options_modeCombos & get_modeCombos ( ) const {
		return * m_modeCombos;
	}
	H263Options_modeCombos & get_modeCombos ( ) {
		return * m_modeCombos;
	}
	const Asn :: Boolean & get_videoBadMBsCap ( ) const {
		return * m_videoBadMBsCap;
	}
	Asn :: Boolean & get_videoBadMBsCap ( ) {
		return * m_videoBadMBsCap;
	}
	const H263Version3Options & get_h263Version3Options ( ) const {
		return * m_h263Version3Options;
	}
	H263Version3Options & get_h263Version3Options ( ) {
		return * m_h263Version3Options;
	}
	H263Options * clone ( ) const;
};

//
// H263ModeComboFlags
//

// from 0 size 0 type 0 simple 0
class H263ModeComboFlags : public Asn :: Sequence {
	public:
	explicit H263ModeComboFlags ( Asn :: istream & is );
	H263ModeComboFlags ( );
	enum OptionalFields {
		e_enhancedReferencePicSelect,
		e_h263Version3Options
	};

	H263ModeComboFlags ( const H263ModeComboFlags & s );
	H263ModeComboFlags & operator= ( const H263ModeComboFlags & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	Asn :: Boolean m_unrestrictedVector;
	Asn :: Boolean m_arithmeticCoding;
	Asn :: Boolean m_advancedPrediction;
	Asn :: Boolean m_pbFrames;
	Asn :: Boolean m_advancedIntraCodingMode;
	Asn :: Boolean m_deblockingFilterMode;
	Asn :: Boolean m_unlimitedMotionVectors;
	Asn :: Boolean m_slicesInOrder_NonRect;
	Asn :: Boolean m_slicesInOrder_Rect;
	Asn :: Boolean m_slicesNoOrder_NonRect;
	Asn :: Boolean m_slicesNoOrder_Rect;
	Asn :: Boolean m_improvedPBFramesMode;
	Asn :: Boolean m_referencePicSelect;
	Asn :: Boolean m_dynamicPictureResizingByFour;
	Asn :: Boolean m_dynamicPictureResizingSixteenthPel;
	Asn :: Boolean m_dynamicWarpingHalfPel;
	Asn :: Boolean m_dynamicWarpingSixteenthPel;
	Asn :: Boolean m_reducedResolutionUpdate;
	Asn :: Boolean m_independentSegmentDecoding;
	Asn :: Boolean m_alternateInterVLCMode;
	Asn :: Boolean m_modifiedQuantizationMode;
	protected:
	Asn :: Boolean * m_enhancedReferencePicSelect;
	H263Version3Options * m_h263Version3Options;
	public:
	void encode ( Asn :: ostream & os ) const;
	~H263ModeComboFlags ( );
	void printOn ( std :: ostream & os ) const;
	const Asn :: Boolean & get_enhancedReferencePicSelect ( ) const {
		return * m_enhancedReferencePicSelect;
	}
	Asn :: Boolean & get_enhancedReferencePicSelect ( ) {
		return * m_enhancedReferencePicSelect;
	}
	const H263Version3Options & get_h263Version3Options ( ) const {
		return * m_h263Version3Options;
	}
	H263Version3Options & get_h263Version3Options ( ) {
		return * m_h263Version3Options;
	}
	H263ModeComboFlags * clone ( ) const;
};

//
// H263Version3Options
//

// from 0 size 0 type 0 simple 0
class H263Version3Options : public Asn :: Sequence {
	public:
	explicit H263Version3Options ( Asn :: istream & is );
	H263Version3Options ( );
	Asn :: Boolean m_dataPartitionedSlices;
	Asn :: Boolean m_fixedPointIDCT0;
	Asn :: Boolean m_interlacedFields;
	Asn :: Boolean m_currentPictureHeaderRepetition;
	Asn :: Boolean m_previousPictureHeaderRepetition;
	Asn :: Boolean m_nextPictureHeaderRepetition;
	Asn :: Boolean m_pictureNumber;
	Asn :: Boolean m_spareReferencePictures;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	H263Version3Options * clone ( ) const;
};

//
// IS11172VideoCapability
//

// from 0 size 0 type 0 simple 0
class IS11172VideoCapability_videoBitRate;
class IS11172VideoCapability_vbvBufferSize;
class IS11172VideoCapability_samplesPerLine;
class IS11172VideoCapability_linesPerFrame;
class IS11172VideoCapability_pictureRate;
class IS11172VideoCapability_luminanceSampleRate;

class IS11172VideoCapability : public Asn :: Sequence {
	public:
	explicit IS11172VideoCapability ( Asn :: istream & is );
	IS11172VideoCapability ( );
	enum OptionalFields {
		e_videoBitRate,
		e_vbvBufferSize,
		e_samplesPerLine,
		e_linesPerFrame,
		e_pictureRate,
		e_luminanceSampleRate,
		e_videoBadMBsCap
	};

	IS11172VideoCapability ( const IS11172VideoCapability & s );
	IS11172VideoCapability & operator= ( const IS11172VideoCapability & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	Asn :: Boolean m_constrainedBitstream;
	protected:
	IS11172VideoCapability_videoBitRate * m_videoBitRate;
	IS11172VideoCapability_vbvBufferSize * m_vbvBufferSize;
	IS11172VideoCapability_samplesPerLine * m_samplesPerLine;
	IS11172VideoCapability_linesPerFrame * m_linesPerFrame;
	IS11172VideoCapability_pictureRate * m_pictureRate;
	IS11172VideoCapability_luminanceSampleRate * m_luminanceSampleRate;
	Asn :: Boolean * m_videoBadMBsCap;
	public:
	void encode ( Asn :: ostream & os ) const;
	~IS11172VideoCapability ( );
	void printOn ( std :: ostream & os ) const;
	const IS11172VideoCapability_videoBitRate & get_videoBitRate ( ) const {
		return * m_videoBitRate;
	}
	IS11172VideoCapability_videoBitRate & get_videoBitRate ( ) {
		return * m_videoBitRate;
	}
	const IS11172VideoCapability_vbvBufferSize & get_vbvBufferSize ( ) const {
		return * m_vbvBufferSize;
	}
	IS11172VideoCapability_vbvBufferSize & get_vbvBufferSize ( ) {
		return * m_vbvBufferSize;
	}
	const IS11172VideoCapability_samplesPerLine & get_samplesPerLine ( ) const {
		return * m_samplesPerLine;
	}
	IS11172VideoCapability_samplesPerLine & get_samplesPerLine ( ) {
		return * m_samplesPerLine;
	}
	const IS11172VideoCapability_linesPerFrame & get_linesPerFrame ( ) const {
		return * m_linesPerFrame;
	}
	IS11172VideoCapability_linesPerFrame & get_linesPerFrame ( ) {
		return * m_linesPerFrame;
	}
	const IS11172VideoCapability_pictureRate & get_pictureRate ( ) const {
		return * m_pictureRate;
	}
	IS11172VideoCapability_pictureRate & get_pictureRate ( ) {
		return * m_pictureRate;
	}
	const IS11172VideoCapability_luminanceSampleRate & get_luminanceSampleRate ( ) const {
		return * m_luminanceSampleRate;
	}
	IS11172VideoCapability_luminanceSampleRate & get_luminanceSampleRate ( ) {
		return * m_luminanceSampleRate;
	}
	const Asn :: Boolean & get_videoBadMBsCap ( ) const {
		return * m_videoBadMBsCap;
	}
	Asn :: Boolean & get_videoBadMBsCap ( ) {
		return * m_videoBadMBsCap;
	}
	IS11172VideoCapability * clone ( ) const;
};

//
// G729Extensions
//

// from 0 size 0 type 0 simple 0
class G729Extensions_audioUnit;

class G729Extensions : public Asn :: Sequence {
	public:
	explicit G729Extensions ( Asn :: istream & is );
	G729Extensions ( );
	enum OptionalFields {
		e_audioUnit
	};

	G729Extensions ( const G729Extensions & s );
	G729Extensions & operator= ( const G729Extensions & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	G729Extensions_audioUnit * m_audioUnit;
	public:
	Asn :: Boolean m_annexA;
	Asn :: Boolean m_annexB;
	Asn :: Boolean m_annexD;
	Asn :: Boolean m_annexE;
	Asn :: Boolean m_annexF;
	Asn :: Boolean m_annexG;
	Asn :: Boolean m_annexH;
	void encode ( Asn :: ostream & os ) const;
	~G729Extensions ( );
	void printOn ( std :: ostream & os ) const;
	const G729Extensions_audioUnit & get_audioUnit ( ) const {
		return * m_audioUnit;
	}
	G729Extensions_audioUnit & get_audioUnit ( ) {
		return * m_audioUnit;
	}
	G729Extensions * clone ( ) const;
};

//
// T38FaxProfile
//

// from 0 size 0 type 0 simple 0
class T38FaxProfile_version;
class T38FaxRateManagement;
class T38FaxUdpOptions;
class T38FaxTcpOptions;

class T38FaxProfile : public Asn :: Sequence {
	public:
	explicit T38FaxProfile ( Asn :: istream & is );
	T38FaxProfile ( );
	enum OptionalFields {
		e_version,
		e_t38FaxRateManagement,
		e_t38FaxUdpOptions,
		e_t38FaxTcpOptions
	};

	T38FaxProfile ( const T38FaxProfile & s );
	T38FaxProfile & operator= ( const T38FaxProfile & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	Asn :: Boolean m_fillBitRemoval;
	Asn :: Boolean m_transcodingJBIG;
	Asn :: Boolean m_transcodingMMR;
	protected:
	T38FaxProfile_version * m_version;
	T38FaxRateManagement * m_t38FaxRateManagement;
	T38FaxUdpOptions * m_t38FaxUdpOptions;
	T38FaxTcpOptions * m_t38FaxTcpOptions;
	public:
	void encode ( Asn :: ostream & os ) const;
	~T38FaxProfile ( );
	void printOn ( std :: ostream & os ) const;
	const T38FaxProfile_version & get_version ( ) const {
		return * m_version;
	}
	T38FaxProfile_version & get_version ( ) {
		return * m_version;
	}
	const T38FaxRateManagement & get_t38FaxRateManagement ( ) const {
		return * m_t38FaxRateManagement;
	}
	T38FaxRateManagement & get_t38FaxRateManagement ( ) {
		return * m_t38FaxRateManagement;
	}
	const T38FaxUdpOptions & get_t38FaxUdpOptions ( ) const {
		return * m_t38FaxUdpOptions;
	}
	T38FaxUdpOptions & get_t38FaxUdpOptions ( ) {
		return * m_t38FaxUdpOptions;
	}
	const T38FaxTcpOptions & get_t38FaxTcpOptions ( ) const {
		return * m_t38FaxTcpOptions;
	}
	T38FaxTcpOptions & get_t38FaxTcpOptions ( ) {
		return * m_t38FaxTcpOptions;
	}
	T38FaxProfile * clone ( ) const;
};

//
// T38FaxRateManagement
//

// from 0 size 0 type 0 simple 0
class T38FaxRateManagement : public Asn :: Choice {
	public:
	explicit T38FaxRateManagement ( Asn :: istream & is );
	T38FaxRateManagement ( );
	enum Choices {
		e_localTCF,
		e_transferredTCF
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	T38FaxRateManagement * clone ( ) const;
};

//
// T38FaxTcpOptions
//

// from 0 size 0 type 0 simple 0
class T38FaxTcpOptions : public Asn :: Sequence {
	public:
	explicit T38FaxTcpOptions ( Asn :: istream & is );
	T38FaxTcpOptions ( );
	Asn :: Boolean m_t38TCPBidirectionalMode;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	T38FaxTcpOptions * clone ( ) const;
};

//
// EncryptionAuthenticationAndIntegrity
//

// from 0 size 0 type 0 simple 0
class EncryptionCapability;
class AuthenticationCapability;
class IntegrityCapability;
class GenericCapability;

class EncryptionAuthenticationAndIntegrity : public Asn :: Sequence {
	public:
	explicit EncryptionAuthenticationAndIntegrity ( Asn :: istream & is );
	EncryptionAuthenticationAndIntegrity ( );
	enum OptionalFields {
		e_encryptionCapability,
		e_authenticationCapability,
		e_integrityCapability,
		e_genericH235SecurityCapability
	};

	EncryptionAuthenticationAndIntegrity ( const EncryptionAuthenticationAndIntegrity & s );
	EncryptionAuthenticationAndIntegrity & operator= ( const EncryptionAuthenticationAndIntegrity & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	EncryptionCapability * m_encryptionCapability;
	AuthenticationCapability * m_authenticationCapability;
	IntegrityCapability * m_integrityCapability;
	GenericCapability * m_genericH235SecurityCapability;
	public:
	void encode ( Asn :: ostream & os ) const;
	~EncryptionAuthenticationAndIntegrity ( );
	void printOn ( std :: ostream & os ) const;
	const EncryptionCapability & get_encryptionCapability ( ) const {
		return * m_encryptionCapability;
	}
	EncryptionCapability & get_encryptionCapability ( ) {
		return * m_encryptionCapability;
	}
	const AuthenticationCapability & get_authenticationCapability ( ) const {
		return * m_authenticationCapability;
	}
	AuthenticationCapability & get_authenticationCapability ( ) {
		return * m_authenticationCapability;
	}
	const IntegrityCapability & get_integrityCapability ( ) const {
		return * m_integrityCapability;
	}
	IntegrityCapability & get_integrityCapability ( ) {
		return * m_integrityCapability;
	}
	const GenericCapability & get_genericH235SecurityCapability ( ) const {
		return * m_genericH235SecurityCapability;
	}
	GenericCapability & get_genericH235SecurityCapability ( ) {
		return * m_genericH235SecurityCapability;
	}
	EncryptionAuthenticationAndIntegrity * clone ( ) const;
};

//
// EncryptionCapability
//

// from 0 size 1 type 0 simple 0
class MediaEncryptionAlgorithm;

class EncryptionCapability : public Asn :: Array {
	public:
	explicit EncryptionCapability ( Asn :: istream & is );
	EncryptionCapability ( );
	explicit EncryptionCapability ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const MediaEncryptionAlgorithm & o );
	const MediaEncryptionAlgorithm & operator[] ( std :: size_t i ) const;
	MediaEncryptionAlgorithm & operator[] ( std :: size_t i );
	EncryptionCapability * clone ( ) const;
};

//
// AuthenticationCapability
//

// from 0 size 0 type 0 simple 0
class AuthenticationCapability : public Asn :: Sequence {
	public:
	explicit AuthenticationCapability ( Asn :: istream & is );
	AuthenticationCapability ( );
	enum OptionalFields {
		e_nonStandard,
		e_antiSpamAlgorithm
	};

	AuthenticationCapability ( const AuthenticationCapability & s );
	AuthenticationCapability & operator= ( const AuthenticationCapability & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	NonStandardParameter * m_nonStandard;
	Asn :: ObjectId * m_antiSpamAlgorithm;
	public:
	void encode ( Asn :: ostream & os ) const;
	~AuthenticationCapability ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandard ( ) const {
		return * m_nonStandard;
	}
	NonStandardParameter & get_nonStandard ( ) {
		return * m_nonStandard;
	}
	const Asn :: ObjectId & get_antiSpamAlgorithm ( ) const {
		return * m_antiSpamAlgorithm;
	}
	Asn :: ObjectId & get_antiSpamAlgorithm ( ) {
		return * m_antiSpamAlgorithm;
	}
	AuthenticationCapability * clone ( ) const;
};

//
// IntegrityCapability
//

// from 0 size 0 type 0 simple 0
class IntegrityCapability : public Asn :: Sequence {
	public:
	explicit IntegrityCapability ( Asn :: istream & is );
	IntegrityCapability ( );
	enum OptionalFields {
		e_nonStandard
	};

	IntegrityCapability ( const IntegrityCapability & s );
	IntegrityCapability & operator= ( const IntegrityCapability & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	NonStandardParameter * m_nonStandard;
	public:
	void encode ( Asn :: ostream & os ) const;
	~IntegrityCapability ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandard ( ) const {
		return * m_nonStandard;
	}
	NonStandardParameter & get_nonStandard ( ) {
		return * m_nonStandard;
	}
	IntegrityCapability * clone ( ) const;
};

//
// ConferenceCapability
//

// from 0 size 0 type 0 simple 0
class ArrayOf_NonStandardParameter;

class ConferenceCapability : public Asn :: Sequence {
	public:
	explicit ConferenceCapability ( Asn :: istream & is );
	ConferenceCapability ( );
	enum OptionalFields {
		e_nonStandardData,
		e_videoIndicateMixingCapability,
		e_multipointVisualizationCapability
	};

	ConferenceCapability ( const ConferenceCapability & s );
	ConferenceCapability & operator= ( const ConferenceCapability & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	ArrayOf_NonStandardParameter * m_nonStandardData;
	public:
	Asn :: Boolean m_chairControlCapability;
	protected:
	Asn :: Boolean * m_videoIndicateMixingCapability;
	Asn :: Boolean * m_multipointVisualizationCapability;
	public:
	void encode ( Asn :: ostream & os ) const;
	~ConferenceCapability ( );
	void printOn ( std :: ostream & os ) const;
	const ArrayOf_NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	ArrayOf_NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const Asn :: Boolean & get_videoIndicateMixingCapability ( ) const {
		return * m_videoIndicateMixingCapability;
	}
	Asn :: Boolean & get_videoIndicateMixingCapability ( ) {
		return * m_videoIndicateMixingCapability;
	}
	const Asn :: Boolean & get_multipointVisualizationCapability ( ) const {
		return * m_multipointVisualizationCapability;
	}
	Asn :: Boolean & get_multipointVisualizationCapability ( ) {
		return * m_multipointVisualizationCapability;
	}
	ConferenceCapability * clone ( ) const;
};

//
// NoPTAudioTelephonyEventCapability
//

// from 0 size 0 type 0 simple 0
class NoPTAudioTelephonyEventCapability : public Asn :: Sequence {
	public:
	explicit NoPTAudioTelephonyEventCapability ( Asn :: istream & is );
	NoPTAudioTelephonyEventCapability ( );
	Asn :: GeneralString m_audioTelephoneEvent;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	NoPTAudioTelephonyEventCapability * clone ( ) const;
};

//
// NoPTAudioToneCapability
//

// from 0 size 0 type 0 simple 0
class NoPTAudioToneCapability : public Asn :: Sequence {
	public:
	explicit NoPTAudioToneCapability ( Asn :: istream & is );
	NoPTAudioToneCapability ( );
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	NoPTAudioToneCapability * clone ( ) const;
};

//
// FECCapability
//

// from 0 size 0 type 0 simple 0
class FECCapability_rfc2733Format;

class FECCapability : public Asn :: Sequence {
	public:
	explicit FECCapability ( Asn :: istream & is );
	FECCapability ( );
	enum OptionalFields {
		e_fecScheme,
		e_rfc2733Format
	};

	FECCapability ( const FECCapability & s );
	FECCapability & operator= ( const FECCapability & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	CapabilityTableEntryNumber m_protectedCapability;
	protected:
	Asn :: ObjectId * m_fecScheme;
	FECCapability_rfc2733Format * m_rfc2733Format;
	public:
	void encode ( Asn :: ostream & os ) const;
	~FECCapability ( );
	void printOn ( std :: ostream & os ) const;
	const Asn :: ObjectId & get_fecScheme ( ) const {
		return * m_fecScheme;
	}
	Asn :: ObjectId & get_fecScheme ( ) {
		return * m_fecScheme;
	}
	const FECCapability_rfc2733Format & get_rfc2733Format ( ) const {
		return * m_rfc2733Format;
	}
	FECCapability_rfc2733Format & get_rfc2733Format ( ) {
		return * m_rfc2733Format;
	}
	FECCapability * clone ( ) const;
};

//
// MaxRedundancy
//

// from 0 size 0 type 0 simple 1
class MaxRedundancy : public Asn :: Integer {
	public:
	explicit MaxRedundancy ( Asn :: istream & is );
	MaxRedundancy ( unsigned v = 0 );
	MaxRedundancy & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MaxRedundancy & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MaxRedundancy * clone ( ) const;
};

//
// LogicalChannelNumber
//

// from 0 size 0 type 0 simple 1
class LogicalChannelNumber : public Asn :: Integer {
	public:
	explicit LogicalChannelNumber ( Asn :: istream & is );
	LogicalChannelNumber ( unsigned v = 0 );
	LogicalChannelNumber & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	LogicalChannelNumber & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	LogicalChannelNumber * clone ( ) const;
};

//
// V75Parameters
//

// from 0 size 0 type 0 simple 0
class V75Parameters : public Asn :: Sequence {
	public:
	explicit V75Parameters ( Asn :: istream & is );
	V75Parameters ( );
	Asn :: Boolean m_audioHeaderPresent;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	V75Parameters * clone ( ) const;
};

//
// CRCLength
//

// from 0 size 0 type 0 simple 0
class CRCLength : public Asn :: Choice {
	public:
	explicit CRCLength ( Asn :: istream & is );
	CRCLength ( );
	enum Choices {
		e_crc8bit,
		e_crc16bit,
		e_crc32bit
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	CRCLength * clone ( ) const;
};

//
// OpenLogicalChannelAck
//

// from 0 size 0 type 0 simple 0
class OpenLogicalChannelAck_reverseLogicalChannelParameters;
class NetworkAccessParameters;
class OpenLogicalChannelAck_forwardMultiplexAckParameters;
class EncryptionSync;

class OpenLogicalChannelAck : public Asn :: Sequence {
	public:
	explicit OpenLogicalChannelAck ( Asn :: istream & is );
	OpenLogicalChannelAck ( );
	enum OptionalFields {
		e_reverseLogicalChannelParameters,
		e_separateStack,
		e_forwardMultiplexAckParameters,
		e_encryptionSync,
		e_genericInformation
	};

	OpenLogicalChannelAck ( const OpenLogicalChannelAck & s );
	OpenLogicalChannelAck & operator= ( const OpenLogicalChannelAck & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	LogicalChannelNumber m_forwardLogicalChannelNumber;
	protected:
	OpenLogicalChannelAck_reverseLogicalChannelParameters * m_reverseLogicalChannelParameters;
	NetworkAccessParameters * m_separateStack;
	OpenLogicalChannelAck_forwardMultiplexAckParameters * m_forwardMultiplexAckParameters;
	EncryptionSync * m_encryptionSync;
	ArrayOf_GenericInformation * m_genericInformation;
	public:
	void encode ( Asn :: ostream & os ) const;
	~OpenLogicalChannelAck ( );
	void printOn ( std :: ostream & os ) const;
	const OpenLogicalChannelAck_reverseLogicalChannelParameters & get_reverseLogicalChannelParameters ( ) const {
		return * m_reverseLogicalChannelParameters;
	}
	OpenLogicalChannelAck_reverseLogicalChannelParameters & get_reverseLogicalChannelParameters ( ) {
		return * m_reverseLogicalChannelParameters;
	}
	const NetworkAccessParameters & get_separateStack ( ) const {
		return * m_separateStack;
	}
	NetworkAccessParameters & get_separateStack ( ) {
		return * m_separateStack;
	}
	const OpenLogicalChannelAck_forwardMultiplexAckParameters & get_forwardMultiplexAckParameters ( ) const {
		return * m_forwardMultiplexAckParameters;
	}
	OpenLogicalChannelAck_forwardMultiplexAckParameters & get_forwardMultiplexAckParameters ( ) {
		return * m_forwardMultiplexAckParameters;
	}
	const EncryptionSync & get_encryptionSync ( ) const {
		return * m_encryptionSync;
	}
	EncryptionSync & get_encryptionSync ( ) {
		return * m_encryptionSync;
	}
	const ArrayOf_GenericInformation & get_genericInformation ( ) const {
		return * m_genericInformation;
	}
	ArrayOf_GenericInformation & get_genericInformation ( ) {
		return * m_genericInformation;
	}
	OpenLogicalChannelAck * clone ( ) const;
};

//
// OpenLogicalChannelConfirm
//

// from 0 size 0 type 0 simple 0
class OpenLogicalChannelConfirm : public Asn :: Sequence {
	public:
	explicit OpenLogicalChannelConfirm ( Asn :: istream & is );
	OpenLogicalChannelConfirm ( );
	enum OptionalFields {
		e_genericInformation
	};

	OpenLogicalChannelConfirm ( const OpenLogicalChannelConfirm & s );
	OpenLogicalChannelConfirm & operator= ( const OpenLogicalChannelConfirm & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	LogicalChannelNumber m_forwardLogicalChannelNumber;
	protected:
	ArrayOf_GenericInformation * m_genericInformation;
	public:
	void encode ( Asn :: ostream & os ) const;
	~OpenLogicalChannelConfirm ( );
	void printOn ( std :: ostream & os ) const;
	const ArrayOf_GenericInformation & get_genericInformation ( ) const {
		return * m_genericInformation;
	}
	ArrayOf_GenericInformation & get_genericInformation ( ) {
		return * m_genericInformation;
	}
	OpenLogicalChannelConfirm * clone ( ) const;
};

//
// H2250LogicalChannelAckParameters
//

// from 0 size 0 type 0 simple 0
class H2250LogicalChannelAckParameters_sessionID;
class TransportAddress;
class H2250LogicalChannelAckParameters_dynamicRTPPayloadType;
class H2250LogicalChannelAckParameters_portNumber;

class H2250LogicalChannelAckParameters : public Asn :: Sequence {
	public:
	explicit H2250LogicalChannelAckParameters ( Asn :: istream & is );
	H2250LogicalChannelAckParameters ( );
	enum OptionalFields {
		e_nonStandard,
		e_sessionID,
		e_mediaChannel,
		e_mediaControlChannel,
		e_dynamicRTPPayloadType,
		e_flowControlToZero,
		e_portNumber
	};

	H2250LogicalChannelAckParameters ( const H2250LogicalChannelAckParameters & s );
	H2250LogicalChannelAckParameters & operator= ( const H2250LogicalChannelAckParameters & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	ArrayOf_NonStandardParameter * m_nonStandard;
	H2250LogicalChannelAckParameters_sessionID * m_sessionID;
	TransportAddress * m_mediaChannel;
	TransportAddress * m_mediaControlChannel;
	H2250LogicalChannelAckParameters_dynamicRTPPayloadType * m_dynamicRTPPayloadType;
	Asn :: Boolean * m_flowControlToZero;
	H2250LogicalChannelAckParameters_portNumber * m_portNumber;
	public:
	void encode ( Asn :: ostream & os ) const;
	~H2250LogicalChannelAckParameters ( );
	void printOn ( std :: ostream & os ) const;
	const ArrayOf_NonStandardParameter & get_nonStandard ( ) const {
		return * m_nonStandard;
	}
	ArrayOf_NonStandardParameter & get_nonStandard ( ) {
		return * m_nonStandard;
	}
	const H2250LogicalChannelAckParameters_sessionID & get_sessionID ( ) const {
		return * m_sessionID;
	}
	H2250LogicalChannelAckParameters_sessionID & get_sessionID ( ) {
		return * m_sessionID;
	}
	const TransportAddress & get_mediaChannel ( ) const {
		return * m_mediaChannel;
	}
	TransportAddress & get_mediaChannel ( ) {
		return * m_mediaChannel;
	}
	const TransportAddress & get_mediaControlChannel ( ) const {
		return * m_mediaControlChannel;
	}
	TransportAddress & get_mediaControlChannel ( ) {
		return * m_mediaControlChannel;
	}
	const H2250LogicalChannelAckParameters_dynamicRTPPayloadType & get_dynamicRTPPayloadType ( ) const {
		return * m_dynamicRTPPayloadType;
	}
	H2250LogicalChannelAckParameters_dynamicRTPPayloadType & get_dynamicRTPPayloadType ( ) {
		return * m_dynamicRTPPayloadType;
	}
	const Asn :: Boolean & get_flowControlToZero ( ) const {
		return * m_flowControlToZero;
	}
	Asn :: Boolean & get_flowControlToZero ( ) {
		return * m_flowControlToZero;
	}
	const H2250LogicalChannelAckParameters_portNumber & get_portNumber ( ) const {
		return * m_portNumber;
	}
	H2250LogicalChannelAckParameters_portNumber & get_portNumber ( ) {
		return * m_portNumber;
	}
	H2250LogicalChannelAckParameters * clone ( ) const;
};

//
// CloseLogicalChannelAck
//

// from 0 size 0 type 0 simple 0
class CloseLogicalChannelAck : public Asn :: Sequence {
	public:
	explicit CloseLogicalChannelAck ( Asn :: istream & is );
	CloseLogicalChannelAck ( );
	LogicalChannelNumber m_forwardLogicalChannelNumber;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	CloseLogicalChannelAck * clone ( ) const;
};

//
// RequestChannelClose
//

// from 0 size 0 type 0 simple 0
class RequestChannelClose_reason;

class RequestChannelClose : public Asn :: Sequence {
	public:
	explicit RequestChannelClose ( Asn :: istream & is );
	RequestChannelClose ( );
	enum OptionalFields {
		e_qosCapability,
		e_reason
	};

	RequestChannelClose ( const RequestChannelClose & s );
	RequestChannelClose & operator= ( const RequestChannelClose & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	LogicalChannelNumber m_forwardLogicalChannelNumber;
	protected:
	QOSCapability * m_qosCapability;
	RequestChannelClose_reason * m_reason;
	public:
	void encode ( Asn :: ostream & os ) const;
	~RequestChannelClose ( );
	void printOn ( std :: ostream & os ) const;
	const QOSCapability & get_qosCapability ( ) const {
		return * m_qosCapability;
	}
	QOSCapability & get_qosCapability ( ) {
		return * m_qosCapability;
	}
	const RequestChannelClose_reason & get_reason ( ) const {
		return * m_reason;
	}
	RequestChannelClose_reason & get_reason ( ) {
		return * m_reason;
	}
	RequestChannelClose * clone ( ) const;
};

//
// RequestChannelCloseAck
//

// from 0 size 0 type 0 simple 0
class RequestChannelCloseAck : public Asn :: Sequence {
	public:
	explicit RequestChannelCloseAck ( Asn :: istream & is );
	RequestChannelCloseAck ( );
	LogicalChannelNumber m_forwardLogicalChannelNumber;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	RequestChannelCloseAck * clone ( ) const;
};

//
// RequestChannelCloseRelease
//

// from 0 size 0 type 0 simple 0
class RequestChannelCloseRelease : public Asn :: Sequence {
	public:
	explicit RequestChannelCloseRelease ( Asn :: istream & is );
	RequestChannelCloseRelease ( );
	LogicalChannelNumber m_forwardLogicalChannelNumber;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	RequestChannelCloseRelease * clone ( ) const;
};

//
// MultiplexTableEntryNumber
//

// from 0 size 0 type 0 simple 1
class MultiplexTableEntryNumber : public Asn :: Integer {
	public:
	explicit MultiplexTableEntryNumber ( Asn :: istream & is );
	MultiplexTableEntryNumber ( unsigned v = 0 );
	MultiplexTableEntryNumber & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MultiplexTableEntryNumber & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MultiplexTableEntryNumber * clone ( ) const;
};

//
// RequestModeRelease
//

// from 0 size 0 type 0 simple 0
class RequestModeRelease : public Asn :: Sequence {
	public:
	explicit RequestModeRelease ( Asn :: istream & is );
	RequestModeRelease ( );
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	RequestModeRelease * clone ( ) const;
};

//
// ModeDescription
//

// from 0 size 1 type 0 simple 0
class ModeElement;

class ModeDescription : public Asn :: Array {
	public:
	explicit ModeDescription ( Asn :: istream & is );
	ModeDescription ( );
	explicit ModeDescription ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const ModeElement & o );
	const ModeElement & operator[] ( std :: size_t i ) const;
	ModeElement & operator[] ( std :: size_t i );
	ModeDescription * clone ( ) const;
};

//
// MultiplexedStreamModeParameters
//

// from 0 size 0 type 0 simple 0
class MultiplexedStreamModeParameters : public Asn :: Sequence {
	public:
	explicit MultiplexedStreamModeParameters ( Asn :: istream & is );
	MultiplexedStreamModeParameters ( );
	LogicalChannelNumber m_logicalChannelNumber;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MultiplexedStreamModeParameters * clone ( ) const;
};

//
// V76ModeParameters
//

// from 0 size 0 type 0 simple 0
class V76ModeParameters : public Asn :: Choice {
	public:
	explicit V76ModeParameters ( Asn :: istream & is );
	V76ModeParameters ( );
	enum Choices {
		e_suspendResumewAddress,
		e_suspendResumewoAddress
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	V76ModeParameters * clone ( ) const;
};

//
// H2250ModeParameters
//

// from 0 size 0 type 0 simple 0
class RedundancyEncodingMode;

class H2250ModeParameters : public Asn :: Sequence {
	public:
	explicit H2250ModeParameters ( Asn :: istream & is );
	H2250ModeParameters ( );
	enum OptionalFields {
		e_redundancyEncodingMode
	};

	H2250ModeParameters ( const H2250ModeParameters & s );
	H2250ModeParameters & operator= ( const H2250ModeParameters & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	RedundancyEncodingMode * m_redundancyEncodingMode;
	public:
	void encode ( Asn :: ostream & os ) const;
	~H2250ModeParameters ( );
	void printOn ( std :: ostream & os ) const;
	const RedundancyEncodingMode & get_redundancyEncodingMode ( ) const {
		return * m_redundancyEncodingMode;
	}
	RedundancyEncodingMode & get_redundancyEncodingMode ( ) {
		return * m_redundancyEncodingMode;
	}
	H2250ModeParameters * clone ( ) const;
};

//
// IS11172VideoMode
//

// from 0 size 0 type 0 simple 0
class IS11172VideoMode_videoBitRate;
class IS11172VideoMode_vbvBufferSize;
class IS11172VideoMode_samplesPerLine;
class IS11172VideoMode_linesPerFrame;
class IS11172VideoMode_pictureRate;
class IS11172VideoMode_luminanceSampleRate;

class IS11172VideoMode : public Asn :: Sequence {
	public:
	explicit IS11172VideoMode ( Asn :: istream & is );
	IS11172VideoMode ( );
	enum OptionalFields {
		e_videoBitRate,
		e_vbvBufferSize,
		e_samplesPerLine,
		e_linesPerFrame,
		e_pictureRate,
		e_luminanceSampleRate
	};

	IS11172VideoMode ( const IS11172VideoMode & s );
	IS11172VideoMode & operator= ( const IS11172VideoMode & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	Asn :: Boolean m_constrainedBitstream;
	protected:
	IS11172VideoMode_videoBitRate * m_videoBitRate;
	IS11172VideoMode_vbvBufferSize * m_vbvBufferSize;
	IS11172VideoMode_samplesPerLine * m_samplesPerLine;
	IS11172VideoMode_linesPerFrame * m_linesPerFrame;
	IS11172VideoMode_pictureRate * m_pictureRate;
	IS11172VideoMode_luminanceSampleRate * m_luminanceSampleRate;
	public:
	void encode ( Asn :: ostream & os ) const;
	~IS11172VideoMode ( );
	void printOn ( std :: ostream & os ) const;
	const IS11172VideoMode_videoBitRate & get_videoBitRate ( ) const {
		return * m_videoBitRate;
	}
	IS11172VideoMode_videoBitRate & get_videoBitRate ( ) {
		return * m_videoBitRate;
	}
	const IS11172VideoMode_vbvBufferSize & get_vbvBufferSize ( ) const {
		return * m_vbvBufferSize;
	}
	IS11172VideoMode_vbvBufferSize & get_vbvBufferSize ( ) {
		return * m_vbvBufferSize;
	}
	const IS11172VideoMode_samplesPerLine & get_samplesPerLine ( ) const {
		return * m_samplesPerLine;
	}
	IS11172VideoMode_samplesPerLine & get_samplesPerLine ( ) {
		return * m_samplesPerLine;
	}
	const IS11172VideoMode_linesPerFrame & get_linesPerFrame ( ) const {
		return * m_linesPerFrame;
	}
	IS11172VideoMode_linesPerFrame & get_linesPerFrame ( ) {
		return * m_linesPerFrame;
	}
	const IS11172VideoMode_pictureRate & get_pictureRate ( ) const {
		return * m_pictureRate;
	}
	IS11172VideoMode_pictureRate & get_pictureRate ( ) {
		return * m_pictureRate;
	}
	const IS11172VideoMode_luminanceSampleRate & get_luminanceSampleRate ( ) const {
		return * m_luminanceSampleRate;
	}
	IS11172VideoMode_luminanceSampleRate & get_luminanceSampleRate ( ) {
		return * m_luminanceSampleRate;
	}
	IS11172VideoMode * clone ( ) const;
};

//
// RoundTripDelayRequest
//

// from 0 size 0 type 0 simple 0
class RoundTripDelayRequest : public Asn :: Sequence {
	public:
	explicit RoundTripDelayRequest ( Asn :: istream & is );
	RoundTripDelayRequest ( );
	SequenceNumber m_sequenceNumber;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	RoundTripDelayRequest * clone ( ) const;
};

//
// RoundTripDelayResponse
//

// from 0 size 0 type 0 simple 0
class RoundTripDelayResponse : public Asn :: Sequence {
	public:
	explicit RoundTripDelayResponse ( Asn :: istream & is );
	RoundTripDelayResponse ( );
	SequenceNumber m_sequenceNumber;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	RoundTripDelayResponse * clone ( ) const;
};

//
// MaintenanceLoopOffCommand
//

// from 0 size 0 type 0 simple 0
class MaintenanceLoopOffCommand : public Asn :: Sequence {
	public:
	explicit MaintenanceLoopOffCommand ( Asn :: istream & is );
	MaintenanceLoopOffCommand ( );
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MaintenanceLoopOffCommand * clone ( ) const;
};

//
// CommunicationModeRequest
//

// from 0 size 0 type 0 simple 0
class CommunicationModeRequest : public Asn :: Sequence {
	public:
	explicit CommunicationModeRequest ( Asn :: istream & is );
	CommunicationModeRequest ( );
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	CommunicationModeRequest * clone ( ) const;
};

//
// CertSelectionCriteria
//

// from 0 size 1 type 0 simple 0
class Criteria;

class CertSelectionCriteria : public Asn :: Array {
	public:
	explicit CertSelectionCriteria ( Asn :: istream & is );
	CertSelectionCriteria ( );
	explicit CertSelectionCriteria ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const Criteria & o );
	const Criteria & operator[] ( std :: size_t i ) const;
	Criteria & operator[] ( std :: size_t i );
	CertSelectionCriteria * clone ( ) const;
};

//
// McuNumber
//

// from 0 size 0 type 0 simple 1
class McuNumber : public Asn :: Integer {
	public:
	explicit McuNumber ( Asn :: istream & is );
	McuNumber ( unsigned v = 0 );
	McuNumber & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	McuNumber & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	McuNumber * clone ( ) const;
};

//
// TerminalNumber
//

// from 0 size 0 type 0 simple 1
class TerminalNumber : public Asn :: Integer {
	public:
	explicit TerminalNumber ( Asn :: istream & is );
	TerminalNumber ( unsigned v = 0 );
	TerminalNumber & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	TerminalNumber & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	TerminalNumber * clone ( ) const;
};

//
// TerminalID
//

// from 0 size 1 type 0 simple 0
class TerminalID : public Asn :: OctetString {
	public:
	explicit TerminalID ( Asn :: istream & is );
	TerminalID ( const Asn :: string & v = Asn :: string ( ) );
	TerminalID & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	TerminalID * clone ( ) const;
};

//
// ConferenceID
//

// from 0 size 1 type 0 simple 0
class ConferenceID : public Asn :: OctetString {
	public:
	explicit ConferenceID ( Asn :: istream & is );
	ConferenceID ( const Asn :: string & v = Asn :: string ( ) );
	ConferenceID & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	ConferenceID * clone ( ) const;
};

//
// Password
//

// from 0 size 1 type 0 simple 0
class Password : public Asn :: OctetString {
	public:
	explicit Password ( Asn :: istream & is );
	Password ( const Asn :: string & v = Asn :: string ( ) );
	Password & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	Password * clone ( ) const;
};

//
// RemoteMCRequest
//

// from 0 size 0 type 0 simple 0
class RemoteMCRequest : public Asn :: Choice {
	public:
	explicit RemoteMCRequest ( Asn :: istream & is );
	RemoteMCRequest ( );
	enum Choices {
		e_masterActivate,
		e_slaveActivate,
		e_deActivate
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	RemoteMCRequest * clone ( ) const;
};

//
// MaximumBitRate
//

// from 0 size 0 type 0 simple 1
class MaximumBitRate : public Asn :: Integer {
	public:
	explicit MaximumBitRate ( Asn :: istream & is );
	MaximumBitRate ( unsigned v = 0 );
	MaximumBitRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MaximumBitRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MaximumBitRate * clone ( ) const;
};

//
// LogicalChannelRateRequest
//

// from 0 size 0 type 0 simple 0
class LogicalChannelRateRequest : public Asn :: Sequence {
	public:
	explicit LogicalChannelRateRequest ( Asn :: istream & is );
	LogicalChannelRateRequest ( );
	SequenceNumber m_sequenceNumber;
	LogicalChannelNumber m_logicalChannelNumber;
	MaximumBitRate m_maximumBitRate;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	LogicalChannelRateRequest * clone ( ) const;
};

//
// LogicalChannelRateAcknowledge
//

// from 0 size 0 type 0 simple 0
class LogicalChannelRateAcknowledge : public Asn :: Sequence {
	public:
	explicit LogicalChannelRateAcknowledge ( Asn :: istream & is );
	LogicalChannelRateAcknowledge ( );
	SequenceNumber m_sequenceNumber;
	LogicalChannelNumber m_logicalChannelNumber;
	MaximumBitRate m_maximumBitRate;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	LogicalChannelRateAcknowledge * clone ( ) const;
};

//
// LogicalChannelRateRejectReason
//

// from 0 size 0 type 0 simple 0
class LogicalChannelRateRejectReason : public Asn :: Choice {
	public:
	explicit LogicalChannelRateRejectReason ( Asn :: istream & is );
	LogicalChannelRateRejectReason ( );
	enum Choices {
		e_undefinedReason,
		e_insufficientResources
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	LogicalChannelRateRejectReason * clone ( ) const;
};

//
// LogicalChannelRateRelease
//

// from 0 size 0 type 0 simple 0
class LogicalChannelRateRelease : public Asn :: Sequence {
	public:
	explicit LogicalChannelRateRelease ( Asn :: istream & is );
	LogicalChannelRateRelease ( );
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	LogicalChannelRateRelease * clone ( ) const;
};

//
// EncryptionUpdateDirection
//

// from 0 size 0 type 0 simple 0
class EncryptionUpdateDirection : public Asn :: Choice {
	public:
	explicit EncryptionUpdateDirection ( Asn :: istream & is );
	EncryptionUpdateDirection ( );
	enum Choices {
		e_masterToSlave,
		e_slaveToMaster
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	EncryptionUpdateDirection * clone ( ) const;
};

//
// KeyProtectionMethod
//

// from 0 size 0 type 0 simple 0
class KeyProtectionMethod : public Asn :: Sequence {
	public:
	explicit KeyProtectionMethod ( Asn :: istream & is );
	KeyProtectionMethod ( );
	Asn :: Boolean m_secureChannel;
	Asn :: Boolean m_sharedSecret;
	Asn :: Boolean m_certProtectedKey;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	KeyProtectionMethod * clone ( ) const;
};

//
// EncryptionUpdateRequest
//

// from 0 size 0 type 0 simple 0
class EncryptionUpdateRequest_synchFlag;

class EncryptionUpdateRequest : public Asn :: Sequence {
	public:
	explicit EncryptionUpdateRequest ( Asn :: istream & is );
	EncryptionUpdateRequest ( );
	enum OptionalFields {
		e_keyProtectionMethod,
		e_synchFlag
	};

	EncryptionUpdateRequest ( const EncryptionUpdateRequest & s );
	EncryptionUpdateRequest & operator= ( const EncryptionUpdateRequest & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	KeyProtectionMethod * m_keyProtectionMethod;
	EncryptionUpdateRequest_synchFlag * m_synchFlag;
	public:
	void encode ( Asn :: ostream & os ) const;
	~EncryptionUpdateRequest ( );
	void printOn ( std :: ostream & os ) const;
	const KeyProtectionMethod & get_keyProtectionMethod ( ) const {
		return * m_keyProtectionMethod;
	}
	KeyProtectionMethod & get_keyProtectionMethod ( ) {
		return * m_keyProtectionMethod;
	}
	const EncryptionUpdateRequest_synchFlag & get_synchFlag ( ) const {
		return * m_synchFlag;
	}
	EncryptionUpdateRequest_synchFlag & get_synchFlag ( ) {
		return * m_synchFlag;
	}
	EncryptionUpdateRequest * clone ( ) const;
};

//
// IV8
//

// from 0 size 1 type 0 simple 0
class IV8 : public Asn :: OctetString {
	public:
	explicit IV8 ( Asn :: istream & is );
	IV8 ( const Asn :: string & v = Asn :: string ( ) );
	IV8 & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	IV8 * clone ( ) const;
};

//
// IV16
//

// from 0 size 1 type 0 simple 0
class IV16 : public Asn :: OctetString {
	public:
	explicit IV16 ( Asn :: istream & is );
	IV16 ( const Asn :: string & v = Asn :: string ( ) );
	IV16 & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	IV16 * clone ( ) const;
};

//
// Params
//

// from 0 size 0 type 0 simple 0
class Params : public Asn :: Sequence {
	public:
	explicit Params ( Asn :: istream & is );
	Params ( );
	enum OptionalFields {
		e_iv8,
		e_iv16,
		e_iv
	};

	Params ( const Params & s );
	Params & operator= ( const Params & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	IV8 * m_iv8;
	IV16 * m_iv16;
	Asn :: OctetString * m_iv;
	public:
	void encode ( Asn :: ostream & os ) const;
	~Params ( );
	void printOn ( std :: ostream & os ) const;
	const IV8 & get_iv8 ( ) const {
		return * m_iv8;
	}
	IV8 & get_iv8 ( ) {
		return * m_iv8;
	}
	const IV16 & get_iv16 ( ) const {
		return * m_iv16;
	}
	IV16 & get_iv16 ( ) {
		return * m_iv16;
	}
	const Asn :: OctetString & get_iv ( ) const {
		return * m_iv;
	}
	Asn :: OctetString & get_iv ( ) {
		return * m_iv;
	}
	Params * clone ( ) const;
};

//
// GenericMessage_subMessageIdentifier
//

// from 0 size 0 type 0 simple 1
class GenericMessage_subMessageIdentifier : public Asn :: Integer {
	public:
	explicit GenericMessage_subMessageIdentifier ( Asn :: istream & is );
	GenericMessage_subMessageIdentifier ( unsigned v = 0 );
	GenericMessage_subMessageIdentifier & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	GenericMessage_subMessageIdentifier & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	GenericMessage_subMessageIdentifier * clone ( ) const;
};

//
// ArrayOf_GenericParameter
//

// from 0 size 0 type 0 simple 0
class GenericParameter;

class ArrayOf_GenericParameter : public Asn :: Array {
	public:
	explicit ArrayOf_GenericParameter ( Asn :: istream & is );
	ArrayOf_GenericParameter ( );
	explicit ArrayOf_GenericParameter ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const GenericParameter & o );
	const GenericParameter & operator[] ( std :: size_t i ) const;
	GenericParameter & operator[] ( std :: size_t i );
	ArrayOf_GenericParameter * clone ( ) const;
};

//
// MasterSlaveDetermination_terminalType
//

// from 0 size 0 type 0 simple 1
class MasterSlaveDetermination_terminalType : public Asn :: Integer {
	public:
	explicit MasterSlaveDetermination_terminalType ( Asn :: istream & is );
	MasterSlaveDetermination_terminalType ( unsigned v = 0 );
	MasterSlaveDetermination_terminalType & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MasterSlaveDetermination_terminalType & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MasterSlaveDetermination_terminalType * clone ( ) const;
};

//
// MasterSlaveDetermination_statusDeterminationNumber
//

// from 0 size 0 type 0 simple 1
class MasterSlaveDetermination_statusDeterminationNumber : public Asn :: Integer {
	public:
	explicit MasterSlaveDetermination_statusDeterminationNumber ( Asn :: istream & is );
	MasterSlaveDetermination_statusDeterminationNumber ( unsigned v = 0 );
	MasterSlaveDetermination_statusDeterminationNumber & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MasterSlaveDetermination_statusDeterminationNumber & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MasterSlaveDetermination_statusDeterminationNumber * clone ( ) const;
};

//
// MasterSlaveDeterminationAck_decision
//

// from 0 size 0 type 0 simple 0
class MasterSlaveDeterminationAck_decision : public Asn :: Choice {
	public:
	explicit MasterSlaveDeterminationAck_decision ( Asn :: istream & is );
	MasterSlaveDeterminationAck_decision ( );
	enum Choices {
		e_master,
		e_slave
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	MasterSlaveDeterminationAck_decision * clone ( ) const;
};

//
// MasterSlaveDeterminationReject_cause
//

// from 0 size 0 type 0 simple 0
class MasterSlaveDeterminationReject_cause : public Asn :: Choice {
	public:
	explicit MasterSlaveDeterminationReject_cause ( Asn :: istream & is );
	MasterSlaveDeterminationReject_cause ( );
	enum Choices {
		e_identicalNumbers
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	MasterSlaveDeterminationReject_cause * clone ( ) const;
};

//
// TerminalCapabilitySet_capabilityTable
//

// from 0 size 1 type 0 simple 0
class CapabilityTableEntry;

class TerminalCapabilitySet_capabilityTable : public Asn :: Array {
	public:
	explicit TerminalCapabilitySet_capabilityTable ( Asn :: istream & is );
	TerminalCapabilitySet_capabilityTable ( );
	explicit TerminalCapabilitySet_capabilityTable ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const CapabilityTableEntry & o );
	const CapabilityTableEntry & operator[] ( std :: size_t i ) const;
	CapabilityTableEntry & operator[] ( std :: size_t i );
	TerminalCapabilitySet_capabilityTable * clone ( ) const;
};

//
// TerminalCapabilitySet_capabilityDescriptors
//

// from 0 size 1 type 0 simple 0
class CapabilityDescriptor;

class TerminalCapabilitySet_capabilityDescriptors : public Asn :: Array {
	public:
	explicit TerminalCapabilitySet_capabilityDescriptors ( Asn :: istream & is );
	TerminalCapabilitySet_capabilityDescriptors ( );
	explicit TerminalCapabilitySet_capabilityDescriptors ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const CapabilityDescriptor & o );
	const CapabilityDescriptor & operator[] ( std :: size_t i ) const;
	CapabilityDescriptor & operator[] ( std :: size_t i );
	TerminalCapabilitySet_capabilityDescriptors * clone ( ) const;
};

//
// ArrayOf_GenericInformation
//

// from 0 size 0 type 0 simple 0
class GenericInformation;

class ArrayOf_GenericInformation : public Asn :: Array {
	public:
	explicit ArrayOf_GenericInformation ( Asn :: istream & is );
	ArrayOf_GenericInformation ( );
	explicit ArrayOf_GenericInformation ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const GenericInformation & o );
	const GenericInformation & operator[] ( std :: size_t i ) const;
	GenericInformation & operator[] ( std :: size_t i );
	ArrayOf_GenericInformation * clone ( ) const;
};

//
// CapabilityDescriptor_simultaneousCapabilities
//

// from 0 size 1 type 0 simple 0
class CapabilityDescriptor_simultaneousCapabilities : public Asn :: Array {
	public:
	explicit CapabilityDescriptor_simultaneousCapabilities ( Asn :: istream & is );
	CapabilityDescriptor_simultaneousCapabilities ( );
	explicit CapabilityDescriptor_simultaneousCapabilities ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const AlternativeCapabilitySet & o );
	const AlternativeCapabilitySet & operator[] ( std :: size_t i ) const;
	AlternativeCapabilitySet & operator[] ( std :: size_t i );
	CapabilityDescriptor_simultaneousCapabilities * clone ( ) const;
};

//
// Capability_maxPendingReplacementFor
//

// from 0 size 0 type 0 simple 1
class Capability_maxPendingReplacementFor : public Asn :: Integer {
	public:
	explicit Capability_maxPendingReplacementFor ( Asn :: istream & is );
	Capability_maxPendingReplacementFor ( unsigned v = 0 );
	Capability_maxPendingReplacementFor & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	Capability_maxPendingReplacementFor & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	Capability_maxPendingReplacementFor * clone ( ) const;
};

//
// H222Capability_numberOfVCs
//

// from 0 size 0 type 0 simple 1
class H222Capability_numberOfVCs : public Asn :: Integer {
	public:
	explicit H222Capability_numberOfVCs ( Asn :: istream & is );
	H222Capability_numberOfVCs ( unsigned v = 0 );
	H222Capability_numberOfVCs & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H222Capability_numberOfVCs & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H222Capability_numberOfVCs * clone ( ) const;
};

//
// ArrayOf_VCCapability
//

// from 0 size 0 type 0 simple 0
class VCCapability;

class ArrayOf_VCCapability : public Asn :: Array {
	public:
	explicit ArrayOf_VCCapability ( Asn :: istream & is );
	ArrayOf_VCCapability ( );
	explicit ArrayOf_VCCapability ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const VCCapability & o );
	const VCCapability & operator[] ( std :: size_t i ) const;
	VCCapability & operator[] ( std :: size_t i );
	ArrayOf_VCCapability * clone ( ) const;
};

//
// VCCapability_aal1
//

// from 0 size 0 type 0 simple 0
class VCCapability_aal1 : public Asn :: Sequence {
	public:
	explicit VCCapability_aal1 ( Asn :: istream & is );
	VCCapability_aal1 ( );
	Asn :: Boolean m_nullClockRecovery;
	Asn :: Boolean m_srtsClockRecovery;
	Asn :: Boolean m_adaptiveClockRecovery;
	Asn :: Boolean m_nullErrorCorrection;
	Asn :: Boolean m_longInterleaver;
	Asn :: Boolean m_shortInterleaver;
	Asn :: Boolean m_errorCorrectionOnly;
	Asn :: Boolean m_structuredDataTransfer;
	Asn :: Boolean m_partiallyFilledCells;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	VCCapability_aal1 * clone ( ) const;
};

//
// H223Capability_maximumAl2SDUSize
//

// from 0 size 0 type 0 simple 1
class H223Capability_maximumAl2SDUSize : public Asn :: Integer {
	public:
	explicit H223Capability_maximumAl2SDUSize ( Asn :: istream & is );
	H223Capability_maximumAl2SDUSize ( unsigned v = 0 );
	H223Capability_maximumAl2SDUSize & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223Capability_maximumAl2SDUSize & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223Capability_maximumAl2SDUSize * clone ( ) const;
};

//
// H223Capability_maximumAl3SDUSize
//

// from 0 size 0 type 0 simple 1
class H223Capability_maximumAl3SDUSize : public Asn :: Integer {
	public:
	explicit H223Capability_maximumAl3SDUSize ( Asn :: istream & is );
	H223Capability_maximumAl3SDUSize ( unsigned v = 0 );
	H223Capability_maximumAl3SDUSize & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223Capability_maximumAl3SDUSize & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223Capability_maximumAl3SDUSize * clone ( ) const;
};

//
// H223Capability_maximumDelayJitter
//

// from 0 size 0 type 0 simple 1
class H223Capability_maximumDelayJitter : public Asn :: Integer {
	public:
	explicit H223Capability_maximumDelayJitter ( Asn :: istream & is );
	H223Capability_maximumDelayJitter ( unsigned v = 0 );
	H223Capability_maximumDelayJitter & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223Capability_maximumDelayJitter & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223Capability_maximumDelayJitter * clone ( ) const;
};

//
// H223Capability_mobileOperationTransmitCapability
//

// from 0 size 0 type 0 simple 0
class H223Capability_mobileOperationTransmitCapability : public Asn :: Sequence {
	public:
	explicit H223Capability_mobileOperationTransmitCapability ( Asn :: istream & is );
	H223Capability_mobileOperationTransmitCapability ( );
	Asn :: Boolean m_modeChangeCapability;
	Asn :: Boolean m_h223AnnexA;
	Asn :: Boolean m_h223AnnexADoubleFlag;
	Asn :: Boolean m_h223AnnexB;
	Asn :: Boolean m_h223AnnexBwithHeader;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	H223Capability_mobileOperationTransmitCapability * clone ( ) const;
};

//
// H223Capability_bitRate
//

// from 0 size 0 type 0 simple 1
class H223Capability_bitRate : public Asn :: Integer {
	public:
	explicit H223Capability_bitRate ( Asn :: istream & is );
	H223Capability_bitRate ( unsigned v = 0 );
	H223Capability_bitRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223Capability_bitRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223Capability_bitRate * clone ( ) const;
};

//
// H223AnnexCCapability_maximumAL1MPDUSize
//

// from 0 size 0 type 0 simple 1
class H223AnnexCCapability_maximumAL1MPDUSize : public Asn :: Integer {
	public:
	explicit H223AnnexCCapability_maximumAL1MPDUSize ( Asn :: istream & is );
	H223AnnexCCapability_maximumAL1MPDUSize ( unsigned v = 0 );
	H223AnnexCCapability_maximumAL1MPDUSize & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223AnnexCCapability_maximumAL1MPDUSize & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223AnnexCCapability_maximumAL1MPDUSize * clone ( ) const;
};

//
// H223AnnexCCapability_maximumAL2MSDUSize
//

// from 0 size 0 type 0 simple 1
class H223AnnexCCapability_maximumAL2MSDUSize : public Asn :: Integer {
	public:
	explicit H223AnnexCCapability_maximumAL2MSDUSize ( Asn :: istream & is );
	H223AnnexCCapability_maximumAL2MSDUSize ( unsigned v = 0 );
	H223AnnexCCapability_maximumAL2MSDUSize & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223AnnexCCapability_maximumAL2MSDUSize & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223AnnexCCapability_maximumAL2MSDUSize * clone ( ) const;
};

//
// H223AnnexCCapability_maximumAL3MSDUSize
//

// from 0 size 0 type 0 simple 1
class H223AnnexCCapability_maximumAL3MSDUSize : public Asn :: Integer {
	public:
	explicit H223AnnexCCapability_maximumAL3MSDUSize ( Asn :: istream & is );
	H223AnnexCCapability_maximumAL3MSDUSize ( unsigned v = 0 );
	H223AnnexCCapability_maximumAL3MSDUSize & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223AnnexCCapability_maximumAL3MSDUSize & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223AnnexCCapability_maximumAL3MSDUSize * clone ( ) const;
};

//
// V76Capability_numOfDLCS
//

// from 0 size 0 type 0 simple 1
class V76Capability_numOfDLCS : public Asn :: Integer {
	public:
	explicit V76Capability_numOfDLCS ( Asn :: istream & is );
	V76Capability_numOfDLCS ( unsigned v = 0 );
	V76Capability_numOfDLCS & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	V76Capability_numOfDLCS & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	V76Capability_numOfDLCS * clone ( ) const;
};

//
// V76Capability_n401Capability
//

// from 0 size 0 type 0 simple 1
class V76Capability_n401Capability : public Asn :: Integer {
	public:
	explicit V76Capability_n401Capability ( Asn :: istream & is );
	V76Capability_n401Capability ( unsigned v = 0 );
	V76Capability_n401Capability & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	V76Capability_n401Capability & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	V76Capability_n401Capability * clone ( ) const;
};

//
// V76Capability_maxWindowSizeCapability
//

// from 0 size 0 type 0 simple 1
class V76Capability_maxWindowSizeCapability : public Asn :: Integer {
	public:
	explicit V76Capability_maxWindowSizeCapability ( Asn :: istream & is );
	V76Capability_maxWindowSizeCapability ( unsigned v = 0 );
	V76Capability_maxWindowSizeCapability & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	V76Capability_maxWindowSizeCapability & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	V76Capability_maxWindowSizeCapability * clone ( ) const;
};

//
// H2250Capability_maximumAudioDelayJitter
//

// from 0 size 0 type 0 simple 1
class H2250Capability_maximumAudioDelayJitter : public Asn :: Integer {
	public:
	explicit H2250Capability_maximumAudioDelayJitter ( Asn :: istream & is );
	H2250Capability_maximumAudioDelayJitter ( unsigned v = 0 );
	H2250Capability_maximumAudioDelayJitter & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H2250Capability_maximumAudioDelayJitter & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H2250Capability_maximumAudioDelayJitter * clone ( ) const;
};

//
// H2250Capability_mcCapability
//

// from 0 size 0 type 0 simple 0
class H2250Capability_mcCapability : public Asn :: Sequence {
	public:
	explicit H2250Capability_mcCapability ( Asn :: istream & is );
	H2250Capability_mcCapability ( );
	Asn :: Boolean m_centralizedConferenceMC;
	Asn :: Boolean m_decentralizedConferenceMC;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	H2250Capability_mcCapability * clone ( ) const;
};

//
// H2250Capability_redundancyEncodingCapability
//

// from 0 size 1 type 0 simple 0
class RedundancyEncodingCapability;

class H2250Capability_redundancyEncodingCapability : public Asn :: Array {
	public:
	explicit H2250Capability_redundancyEncodingCapability ( Asn :: istream & is );
	H2250Capability_redundancyEncodingCapability ( );
	explicit H2250Capability_redundancyEncodingCapability ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const RedundancyEncodingCapability & o );
	const RedundancyEncodingCapability & operator[] ( std :: size_t i ) const;
	RedundancyEncodingCapability & operator[] ( std :: size_t i );
	H2250Capability_redundancyEncodingCapability * clone ( ) const;
};

//
// MediaPacketizationCapability_rtpPayloadType
//

// from 0 size 1 type 0 simple 0
class RTPPayloadType;

class MediaPacketizationCapability_rtpPayloadType : public Asn :: Array {
	public:
	explicit MediaPacketizationCapability_rtpPayloadType ( Asn :: istream & is );
	MediaPacketizationCapability_rtpPayloadType ( );
	explicit MediaPacketizationCapability_rtpPayloadType ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const RTPPayloadType & o );
	const RTPPayloadType & operator[] ( std :: size_t i ) const;
	RTPPayloadType & operator[] ( std :: size_t i );
	MediaPacketizationCapability_rtpPayloadType * clone ( ) const;
};

//
// RSVPParameters_tokenRate
//

// from 0 size 0 type 0 simple 1
class RSVPParameters_tokenRate : public Asn :: Integer {
	public:
	explicit RSVPParameters_tokenRate ( Asn :: istream & is );
	RSVPParameters_tokenRate ( unsigned v = 0 );
	RSVPParameters_tokenRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RSVPParameters_tokenRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RSVPParameters_tokenRate * clone ( ) const;
};

//
// RSVPParameters_bucketSize
//

// from 0 size 0 type 0 simple 1
class RSVPParameters_bucketSize : public Asn :: Integer {
	public:
	explicit RSVPParameters_bucketSize ( Asn :: istream & is );
	RSVPParameters_bucketSize ( unsigned v = 0 );
	RSVPParameters_bucketSize & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RSVPParameters_bucketSize & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RSVPParameters_bucketSize * clone ( ) const;
};

//
// RSVPParameters_peakRate
//

// from 0 size 0 type 0 simple 1
class RSVPParameters_peakRate : public Asn :: Integer {
	public:
	explicit RSVPParameters_peakRate ( Asn :: istream & is );
	RSVPParameters_peakRate ( unsigned v = 0 );
	RSVPParameters_peakRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RSVPParameters_peakRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RSVPParameters_peakRate * clone ( ) const;
};

//
// RSVPParameters_minPoliced
//

// from 0 size 0 type 0 simple 1
class RSVPParameters_minPoliced : public Asn :: Integer {
	public:
	explicit RSVPParameters_minPoliced ( Asn :: istream & is );
	RSVPParameters_minPoliced ( unsigned v = 0 );
	RSVPParameters_minPoliced & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RSVPParameters_minPoliced & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RSVPParameters_minPoliced * clone ( ) const;
};

//
// RSVPParameters_maxPktSize
//

// from 0 size 0 type 0 simple 1
class RSVPParameters_maxPktSize : public Asn :: Integer {
	public:
	explicit RSVPParameters_maxPktSize ( Asn :: istream & is );
	RSVPParameters_maxPktSize ( unsigned v = 0 );
	RSVPParameters_maxPktSize & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RSVPParameters_maxPktSize & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RSVPParameters_maxPktSize * clone ( ) const;
};

//
// ATMParameters_maxNTUSize
//

// from 0 size 0 type 0 simple 1
class ATMParameters_maxNTUSize : public Asn :: Integer {
	public:
	explicit ATMParameters_maxNTUSize ( Asn :: istream & is );
	ATMParameters_maxNTUSize ( unsigned v = 0 );
	ATMParameters_maxNTUSize & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	ATMParameters_maxNTUSize & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	ATMParameters_maxNTUSize * clone ( ) const;
};

//
// GenericTransportParameters_averageRate
//

// from 0 size 0 type 0 simple 1
class GenericTransportParameters_averageRate : public Asn :: Integer {
	public:
	explicit GenericTransportParameters_averageRate ( Asn :: istream & is );
	GenericTransportParameters_averageRate ( unsigned v = 0 );
	GenericTransportParameters_averageRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	GenericTransportParameters_averageRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	GenericTransportParameters_averageRate * clone ( ) const;
};

//
// GenericTransportParameters_burst
//

// from 0 size 0 type 0 simple 1
class GenericTransportParameters_burst : public Asn :: Integer {
	public:
	explicit GenericTransportParameters_burst ( Asn :: istream & is );
	GenericTransportParameters_burst ( unsigned v = 0 );
	GenericTransportParameters_burst & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	GenericTransportParameters_burst & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	GenericTransportParameters_burst * clone ( ) const;
};

//
// GenericTransportParameters_peakRate
//

// from 0 size 0 type 0 simple 1
class GenericTransportParameters_peakRate : public Asn :: Integer {
	public:
	explicit GenericTransportParameters_peakRate ( Asn :: istream & is );
	GenericTransportParameters_peakRate ( unsigned v = 0 );
	GenericTransportParameters_peakRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	GenericTransportParameters_peakRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	GenericTransportParameters_peakRate * clone ( ) const;
};

//
// GenericTransportParameters_maxPktSize
//

// from 0 size 0 type 0 simple 1
class GenericTransportParameters_maxPktSize : public Asn :: Integer {
	public:
	explicit GenericTransportParameters_maxPktSize ( Asn :: istream & is );
	GenericTransportParameters_maxPktSize ( unsigned v = 0 );
	GenericTransportParameters_maxPktSize & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	GenericTransportParameters_maxPktSize & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	GenericTransportParameters_maxPktSize * clone ( ) const;
};

//
// QOSCapability_dscpValue
//

// from 0 size 0 type 0 simple 1
class QOSCapability_dscpValue : public Asn :: Integer {
	public:
	explicit QOSCapability_dscpValue ( Asn :: istream & is );
	QOSCapability_dscpValue ( unsigned v = 0 );
	QOSCapability_dscpValue & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	QOSCapability_dscpValue & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	QOSCapability_dscpValue * clone ( ) const;
};

//
// MediaTransportType_atm-AAL5-compressed
//

// from 0 size 0 type 0 simple 0
class MediaTransportType_atm_AAL5_compressed : public Asn :: Sequence {
	public:
	explicit MediaTransportType_atm_AAL5_compressed ( Asn :: istream & is );
	MediaTransportType_atm_AAL5_compressed ( );
	Asn :: Boolean m_variable_delta;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MediaTransportType_atm_AAL5_compressed * clone ( ) const;
};

//
// TransportCapability_qOSCapabilities
//

// from 0 size 1 type 0 simple 0
class TransportCapability_qOSCapabilities : public Asn :: Array {
	public:
	explicit TransportCapability_qOSCapabilities ( Asn :: istream & is );
	TransportCapability_qOSCapabilities ( );
	explicit TransportCapability_qOSCapabilities ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const QOSCapability & o );
	const QOSCapability & operator[] ( std :: size_t i ) const;
	QOSCapability & operator[] ( std :: size_t i );
	TransportCapability_qOSCapabilities * clone ( ) const;
};

//
// TransportCapability_mediaChannelCapabilities
//

// from 0 size 1 type 0 simple 0
class TransportCapability_mediaChannelCapabilities : public Asn :: Array {
	public:
	explicit TransportCapability_mediaChannelCapabilities ( Asn :: istream & is );
	TransportCapability_mediaChannelCapabilities ( );
	explicit TransportCapability_mediaChannelCapabilities ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const MediaChannelCapability & o );
	const MediaChannelCapability & operator[] ( std :: size_t i ) const;
	MediaChannelCapability & operator[] ( std :: size_t i );
	TransportCapability_mediaChannelCapabilities * clone ( ) const;
};

//
// RedundancyEncodingCapability_secondaryEncoding
//

// from 0 size 1 type 0 simple 0
class RedundancyEncodingCapability_secondaryEncoding : public Asn :: Array {
	public:
	explicit RedundancyEncodingCapability_secondaryEncoding ( Asn :: istream & is );
	RedundancyEncodingCapability_secondaryEncoding ( );
	explicit RedundancyEncodingCapability_secondaryEncoding ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const CapabilityTableEntryNumber & o );
	const CapabilityTableEntryNumber & operator[] ( std :: size_t i ) const;
	CapabilityTableEntryNumber & operator[] ( std :: size_t i );
	RedundancyEncodingCapability_secondaryEncoding * clone ( ) const;
};

//
// RTPH263VideoRedundancyEncoding_numberOfThreads
//

// from 0 size 0 type 0 simple 1
class RTPH263VideoRedundancyEncoding_numberOfThreads : public Asn :: Integer {
	public:
	explicit RTPH263VideoRedundancyEncoding_numberOfThreads ( Asn :: istream & is );
	RTPH263VideoRedundancyEncoding_numberOfThreads ( unsigned v = 0 );
	RTPH263VideoRedundancyEncoding_numberOfThreads & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RTPH263VideoRedundancyEncoding_numberOfThreads & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RTPH263VideoRedundancyEncoding_numberOfThreads * clone ( ) const;
};

//
// RTPH263VideoRedundancyEncoding_framesBetweenSyncPoints
//

// from 0 size 0 type 0 simple 1
class RTPH263VideoRedundancyEncoding_framesBetweenSyncPoints : public Asn :: Integer {
	public:
	explicit RTPH263VideoRedundancyEncoding_framesBetweenSyncPoints ( Asn :: istream & is );
	RTPH263VideoRedundancyEncoding_framesBetweenSyncPoints ( unsigned v = 0 );
	RTPH263VideoRedundancyEncoding_framesBetweenSyncPoints & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RTPH263VideoRedundancyEncoding_framesBetweenSyncPoints & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RTPH263VideoRedundancyEncoding_framesBetweenSyncPoints * clone ( ) const;
};

//
// RTPH263VideoRedundancyEncoding_containedThreads
//

// from 0 size 1 type 0 simple 0
class RTPH263VideoRedundancyEncoding_containedThreads_subtype;

class RTPH263VideoRedundancyEncoding_containedThreads : public Asn :: Array {
	public:
	explicit RTPH263VideoRedundancyEncoding_containedThreads ( Asn :: istream & is );
	RTPH263VideoRedundancyEncoding_containedThreads ( );
	explicit RTPH263VideoRedundancyEncoding_containedThreads ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const RTPH263VideoRedundancyEncoding_containedThreads_subtype & o );
	const RTPH263VideoRedundancyEncoding_containedThreads_subtype & operator[] ( std :: size_t i ) const;
	RTPH263VideoRedundancyEncoding_containedThreads_subtype & operator[] ( std :: size_t i );
	RTPH263VideoRedundancyEncoding_containedThreads * clone ( ) const;
};

//
// RTPH263VideoRedundancyFrameMapping_threadNumber
//

// from 0 size 0 type 0 simple 1
class RTPH263VideoRedundancyFrameMapping_threadNumber : public Asn :: Integer {
	public:
	explicit RTPH263VideoRedundancyFrameMapping_threadNumber ( Asn :: istream & is );
	RTPH263VideoRedundancyFrameMapping_threadNumber ( unsigned v = 0 );
	RTPH263VideoRedundancyFrameMapping_threadNumber & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RTPH263VideoRedundancyFrameMapping_threadNumber & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RTPH263VideoRedundancyFrameMapping_threadNumber * clone ( ) const;
};

//
// RTPH263VideoRedundancyFrameMapping_frameSequence
//

// from 0 size 1 type 0 simple 0
class RTPH263VideoRedundancyFrameMapping_frameSequence_subtype;

class RTPH263VideoRedundancyFrameMapping_frameSequence : public Asn :: Array {
	public:
	explicit RTPH263VideoRedundancyFrameMapping_frameSequence ( Asn :: istream & is );
	RTPH263VideoRedundancyFrameMapping_frameSequence ( );
	explicit RTPH263VideoRedundancyFrameMapping_frameSequence ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const RTPH263VideoRedundancyFrameMapping_frameSequence_subtype & o );
	const RTPH263VideoRedundancyFrameMapping_frameSequence_subtype & operator[] ( std :: size_t i ) const;
	RTPH263VideoRedundancyFrameMapping_frameSequence_subtype & operator[] ( std :: size_t i );
	RTPH263VideoRedundancyFrameMapping_frameSequence * clone ( ) const;
};

//
// ArrayOf_MediaDistributionCapability
//

// from 0 size 0 type 0 simple 0
class ArrayOf_MediaDistributionCapability : public Asn :: Array {
	public:
	explicit ArrayOf_MediaDistributionCapability ( Asn :: istream & is );
	ArrayOf_MediaDistributionCapability ( );
	explicit ArrayOf_MediaDistributionCapability ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const MediaDistributionCapability & o );
	const MediaDistributionCapability & operator[] ( std :: size_t i ) const;
	MediaDistributionCapability & operator[] ( std :: size_t i );
	ArrayOf_MediaDistributionCapability * clone ( ) const;
};

//
// ArrayOf_DataApplicationCapability
//

// from 0 size 0 type 0 simple 0
class DataApplicationCapability;

class ArrayOf_DataApplicationCapability : public Asn :: Array {
	public:
	explicit ArrayOf_DataApplicationCapability ( Asn :: istream & is );
	ArrayOf_DataApplicationCapability ( );
	explicit ArrayOf_DataApplicationCapability ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const DataApplicationCapability & o );
	const DataApplicationCapability & operator[] ( std :: size_t i ) const;
	DataApplicationCapability & operator[] ( std :: size_t i );
	ArrayOf_DataApplicationCapability * clone ( ) const;
};

//
// ArrayOf_VideoCapability
//

// from 0 size 0 type 0 simple 0
class VideoCapability;

class ArrayOf_VideoCapability : public Asn :: Array {
	public:
	explicit ArrayOf_VideoCapability ( Asn :: istream & is );
	ArrayOf_VideoCapability ( );
	explicit ArrayOf_VideoCapability ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const VideoCapability & o );
	const VideoCapability & operator[] ( std :: size_t i ) const;
	VideoCapability & operator[] ( std :: size_t i );
	ArrayOf_VideoCapability * clone ( ) const;
};

//
// ArrayOf_GenericCapability
//

// from 0 size 0 type 0 simple 0
class ArrayOf_GenericCapability : public Asn :: Array {
	public:
	explicit ArrayOf_GenericCapability ( Asn :: istream & is );
	ArrayOf_GenericCapability ( );
	explicit ArrayOf_GenericCapability ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const GenericCapability & o );
	const GenericCapability & operator[] ( std :: size_t i ) const;
	GenericCapability & operator[] ( std :: size_t i );
	ArrayOf_GenericCapability * clone ( ) const;
};

//
// H261VideoCapability_qcifMPI
//

// from 0 size 0 type 0 simple 1
class H261VideoCapability_qcifMPI : public Asn :: Integer {
	public:
	explicit H261VideoCapability_qcifMPI ( Asn :: istream & is );
	H261VideoCapability_qcifMPI ( unsigned v = 0 );
	H261VideoCapability_qcifMPI & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H261VideoCapability_qcifMPI & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H261VideoCapability_qcifMPI * clone ( ) const;
};

//
// H261VideoCapability_cifMPI
//

// from 0 size 0 type 0 simple 1
class H261VideoCapability_cifMPI : public Asn :: Integer {
	public:
	explicit H261VideoCapability_cifMPI ( Asn :: istream & is );
	H261VideoCapability_cifMPI ( unsigned v = 0 );
	H261VideoCapability_cifMPI & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H261VideoCapability_cifMPI & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H261VideoCapability_cifMPI * clone ( ) const;
};

//
// H261VideoCapability_maxBitRate
//

// from 0 size 0 type 0 simple 1
class H261VideoCapability_maxBitRate : public Asn :: Integer {
	public:
	explicit H261VideoCapability_maxBitRate ( Asn :: istream & is );
	H261VideoCapability_maxBitRate ( unsigned v = 0 );
	H261VideoCapability_maxBitRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H261VideoCapability_maxBitRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H261VideoCapability_maxBitRate * clone ( ) const;
};

//
// H262VideoCapability_videoBitRate
//

// from 0 size 0 type 0 simple 1
class H262VideoCapability_videoBitRate : public Asn :: Integer {
	public:
	explicit H262VideoCapability_videoBitRate ( Asn :: istream & is );
	H262VideoCapability_videoBitRate ( unsigned v = 0 );
	H262VideoCapability_videoBitRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H262VideoCapability_videoBitRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H262VideoCapability_videoBitRate * clone ( ) const;
};

//
// H262VideoCapability_vbvBufferSize
//

// from 0 size 0 type 0 simple 1
class H262VideoCapability_vbvBufferSize : public Asn :: Integer {
	public:
	explicit H262VideoCapability_vbvBufferSize ( Asn :: istream & is );
	H262VideoCapability_vbvBufferSize ( unsigned v = 0 );
	H262VideoCapability_vbvBufferSize & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H262VideoCapability_vbvBufferSize & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H262VideoCapability_vbvBufferSize * clone ( ) const;
};

//
// H262VideoCapability_samplesPerLine
//

// from 0 size 0 type 0 simple 1
class H262VideoCapability_samplesPerLine : public Asn :: Integer {
	public:
	explicit H262VideoCapability_samplesPerLine ( Asn :: istream & is );
	H262VideoCapability_samplesPerLine ( unsigned v = 0 );
	H262VideoCapability_samplesPerLine & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H262VideoCapability_samplesPerLine & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H262VideoCapability_samplesPerLine * clone ( ) const;
};

//
// H262VideoCapability_linesPerFrame
//

// from 0 size 0 type 0 simple 1
class H262VideoCapability_linesPerFrame : public Asn :: Integer {
	public:
	explicit H262VideoCapability_linesPerFrame ( Asn :: istream & is );
	H262VideoCapability_linesPerFrame ( unsigned v = 0 );
	H262VideoCapability_linesPerFrame & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H262VideoCapability_linesPerFrame & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H262VideoCapability_linesPerFrame * clone ( ) const;
};

//
// H262VideoCapability_framesPerSecond
//

// from 0 size 0 type 0 simple 1
class H262VideoCapability_framesPerSecond : public Asn :: Integer {
	public:
	explicit H262VideoCapability_framesPerSecond ( Asn :: istream & is );
	H262VideoCapability_framesPerSecond ( unsigned v = 0 );
	H262VideoCapability_framesPerSecond & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H262VideoCapability_framesPerSecond & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H262VideoCapability_framesPerSecond * clone ( ) const;
};

//
// H262VideoCapability_luminanceSampleRate
//

// from 0 size 0 type 0 simple 1
class H262VideoCapability_luminanceSampleRate : public Asn :: Integer {
	public:
	explicit H262VideoCapability_luminanceSampleRate ( Asn :: istream & is );
	H262VideoCapability_luminanceSampleRate ( unsigned v = 0 );
	H262VideoCapability_luminanceSampleRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H262VideoCapability_luminanceSampleRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H262VideoCapability_luminanceSampleRate * clone ( ) const;
};

//
// H263VideoCapability_sqcifMPI
//

// from 0 size 0 type 0 simple 1
class H263VideoCapability_sqcifMPI : public Asn :: Integer {
	public:
	explicit H263VideoCapability_sqcifMPI ( Asn :: istream & is );
	H263VideoCapability_sqcifMPI ( unsigned v = 0 );
	H263VideoCapability_sqcifMPI & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H263VideoCapability_sqcifMPI & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H263VideoCapability_sqcifMPI * clone ( ) const;
};

//
// H263VideoCapability_qcifMPI
//

// from 0 size 0 type 0 simple 1
class H263VideoCapability_qcifMPI : public Asn :: Integer {
	public:
	explicit H263VideoCapability_qcifMPI ( Asn :: istream & is );
	H263VideoCapability_qcifMPI ( unsigned v = 0 );
	H263VideoCapability_qcifMPI & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H263VideoCapability_qcifMPI & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H263VideoCapability_qcifMPI * clone ( ) const;
};

//
// H263VideoCapability_cifMPI
//

// from 0 size 0 type 0 simple 1
class H263VideoCapability_cifMPI : public Asn :: Integer {
	public:
	explicit H263VideoCapability_cifMPI ( Asn :: istream & is );
	H263VideoCapability_cifMPI ( unsigned v = 0 );
	H263VideoCapability_cifMPI & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H263VideoCapability_cifMPI & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H263VideoCapability_cifMPI * clone ( ) const;
};

//
// H263VideoCapability_cif4MPI
//

// from 0 size 0 type 0 simple 1
class H263VideoCapability_cif4MPI : public Asn :: Integer {
	public:
	explicit H263VideoCapability_cif4MPI ( Asn :: istream & is );
	H263VideoCapability_cif4MPI ( unsigned v = 0 );
	H263VideoCapability_cif4MPI & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H263VideoCapability_cif4MPI & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H263VideoCapability_cif4MPI * clone ( ) const;
};

//
// H263VideoCapability_cif16MPI
//

// from 0 size 0 type 0 simple 1
class H263VideoCapability_cif16MPI : public Asn :: Integer {
	public:
	explicit H263VideoCapability_cif16MPI ( Asn :: istream & is );
	H263VideoCapability_cif16MPI ( unsigned v = 0 );
	H263VideoCapability_cif16MPI & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H263VideoCapability_cif16MPI & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H263VideoCapability_cif16MPI * clone ( ) const;
};

//
// H263VideoCapability_maxBitRate
//

// from 0 size 0 type 0 simple 1
class H263VideoCapability_maxBitRate : public Asn :: Integer {
	public:
	explicit H263VideoCapability_maxBitRate ( Asn :: istream & is );
	H263VideoCapability_maxBitRate ( unsigned v = 0 );
	H263VideoCapability_maxBitRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H263VideoCapability_maxBitRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H263VideoCapability_maxBitRate * clone ( ) const;
};

//
// H263VideoCapability_hrd-B
//

// from 0 size 0 type 0 simple 1
class H263VideoCapability_hrd_B : public Asn :: Integer {
	public:
	explicit H263VideoCapability_hrd_B ( Asn :: istream & is );
	H263VideoCapability_hrd_B ( unsigned v = 0 );
	H263VideoCapability_hrd_B & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H263VideoCapability_hrd_B & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H263VideoCapability_hrd_B * clone ( ) const;
};

//
// H263VideoCapability_bppMaxKb
//

// from 0 size 0 type 0 simple 1
class H263VideoCapability_bppMaxKb : public Asn :: Integer {
	public:
	explicit H263VideoCapability_bppMaxKb ( Asn :: istream & is );
	H263VideoCapability_bppMaxKb ( unsigned v = 0 );
	H263VideoCapability_bppMaxKb & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H263VideoCapability_bppMaxKb & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H263VideoCapability_bppMaxKb * clone ( ) const;
};

//
// H263VideoCapability_slowSqcifMPI
//

// from 0 size 0 type 0 simple 1
class H263VideoCapability_slowSqcifMPI : public Asn :: Integer {
	public:
	explicit H263VideoCapability_slowSqcifMPI ( Asn :: istream & is );
	H263VideoCapability_slowSqcifMPI ( unsigned v = 0 );
	H263VideoCapability_slowSqcifMPI & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H263VideoCapability_slowSqcifMPI & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H263VideoCapability_slowSqcifMPI * clone ( ) const;
};

//
// H263VideoCapability_slowQcifMPI
//

// from 0 size 0 type 0 simple 1
class H263VideoCapability_slowQcifMPI : public Asn :: Integer {
	public:
	explicit H263VideoCapability_slowQcifMPI ( Asn :: istream & is );
	H263VideoCapability_slowQcifMPI ( unsigned v = 0 );
	H263VideoCapability_slowQcifMPI & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H263VideoCapability_slowQcifMPI & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H263VideoCapability_slowQcifMPI * clone ( ) const;
};

//
// H263VideoCapability_slowCifMPI
//

// from 0 size 0 type 0 simple 1
class H263VideoCapability_slowCifMPI : public Asn :: Integer {
	public:
	explicit H263VideoCapability_slowCifMPI ( Asn :: istream & is );
	H263VideoCapability_slowCifMPI ( unsigned v = 0 );
	H263VideoCapability_slowCifMPI & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H263VideoCapability_slowCifMPI & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H263VideoCapability_slowCifMPI * clone ( ) const;
};

//
// H263VideoCapability_slowCif4MPI
//

// from 0 size 0 type 0 simple 1
class H263VideoCapability_slowCif4MPI : public Asn :: Integer {
	public:
	explicit H263VideoCapability_slowCif4MPI ( Asn :: istream & is );
	H263VideoCapability_slowCif4MPI ( unsigned v = 0 );
	H263VideoCapability_slowCif4MPI & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H263VideoCapability_slowCif4MPI & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H263VideoCapability_slowCif4MPI * clone ( ) const;
};

//
// H263VideoCapability_slowCif16MPI
//

// from 0 size 0 type 0 simple 1
class H263VideoCapability_slowCif16MPI : public Asn :: Integer {
	public:
	explicit H263VideoCapability_slowCif16MPI ( Asn :: istream & is );
	H263VideoCapability_slowCif16MPI ( unsigned v = 0 );
	H263VideoCapability_slowCif16MPI & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H263VideoCapability_slowCif16MPI & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H263VideoCapability_slowCif16MPI * clone ( ) const;
};

//
// EnhancementLayerInfo_snrEnhancement
//

// from 0 size 1 type 0 simple 0
class EnhancementOptions;

class EnhancementLayerInfo_snrEnhancement : public Asn :: Array {
	public:
	explicit EnhancementLayerInfo_snrEnhancement ( Asn :: istream & is );
	EnhancementLayerInfo_snrEnhancement ( );
	explicit EnhancementLayerInfo_snrEnhancement ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const EnhancementOptions & o );
	const EnhancementOptions & operator[] ( std :: size_t i ) const;
	EnhancementOptions & operator[] ( std :: size_t i );
	EnhancementLayerInfo_snrEnhancement * clone ( ) const;
};

//
// EnhancementLayerInfo_spatialEnhancement
//

// from 0 size 1 type 0 simple 0
class EnhancementLayerInfo_spatialEnhancement : public Asn :: Array {
	public:
	explicit EnhancementLayerInfo_spatialEnhancement ( Asn :: istream & is );
	EnhancementLayerInfo_spatialEnhancement ( );
	explicit EnhancementLayerInfo_spatialEnhancement ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const EnhancementOptions & o );
	const EnhancementOptions & operator[] ( std :: size_t i ) const;
	EnhancementOptions & operator[] ( std :: size_t i );
	EnhancementLayerInfo_spatialEnhancement * clone ( ) const;
};

//
// EnhancementLayerInfo_bPictureEnhancement
//

// from 0 size 1 type 0 simple 0
class BEnhancementParameters;

class EnhancementLayerInfo_bPictureEnhancement : public Asn :: Array {
	public:
	explicit EnhancementLayerInfo_bPictureEnhancement ( Asn :: istream & is );
	EnhancementLayerInfo_bPictureEnhancement ( );
	explicit EnhancementLayerInfo_bPictureEnhancement ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const BEnhancementParameters & o );
	const BEnhancementParameters & operator[] ( std :: size_t i ) const;
	BEnhancementParameters & operator[] ( std :: size_t i );
	EnhancementLayerInfo_bPictureEnhancement * clone ( ) const;
};

//
// BEnhancementParameters_numberOfBPictures
//

// from 0 size 0 type 0 simple 1
class BEnhancementParameters_numberOfBPictures : public Asn :: Integer {
	public:
	explicit BEnhancementParameters_numberOfBPictures ( Asn :: istream & is );
	BEnhancementParameters_numberOfBPictures ( unsigned v = 0 );
	BEnhancementParameters_numberOfBPictures & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	BEnhancementParameters_numberOfBPictures & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	BEnhancementParameters_numberOfBPictures * clone ( ) const;
};

//
// EnhancementOptions_sqcifMPI
//

// from 0 size 0 type 0 simple 1
class EnhancementOptions_sqcifMPI : public Asn :: Integer {
	public:
	explicit EnhancementOptions_sqcifMPI ( Asn :: istream & is );
	EnhancementOptions_sqcifMPI ( unsigned v = 0 );
	EnhancementOptions_sqcifMPI & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	EnhancementOptions_sqcifMPI & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	EnhancementOptions_sqcifMPI * clone ( ) const;
};

//
// EnhancementOptions_qcifMPI
//

// from 0 size 0 type 0 simple 1
class EnhancementOptions_qcifMPI : public Asn :: Integer {
	public:
	explicit EnhancementOptions_qcifMPI ( Asn :: istream & is );
	EnhancementOptions_qcifMPI ( unsigned v = 0 );
	EnhancementOptions_qcifMPI & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	EnhancementOptions_qcifMPI & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	EnhancementOptions_qcifMPI * clone ( ) const;
};

//
// EnhancementOptions_cifMPI
//

// from 0 size 0 type 0 simple 1
class EnhancementOptions_cifMPI : public Asn :: Integer {
	public:
	explicit EnhancementOptions_cifMPI ( Asn :: istream & is );
	EnhancementOptions_cifMPI ( unsigned v = 0 );
	EnhancementOptions_cifMPI & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	EnhancementOptions_cifMPI & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	EnhancementOptions_cifMPI * clone ( ) const;
};

//
// EnhancementOptions_cif4MPI
//

// from 0 size 0 type 0 simple 1
class EnhancementOptions_cif4MPI : public Asn :: Integer {
	public:
	explicit EnhancementOptions_cif4MPI ( Asn :: istream & is );
	EnhancementOptions_cif4MPI ( unsigned v = 0 );
	EnhancementOptions_cif4MPI & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	EnhancementOptions_cif4MPI & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	EnhancementOptions_cif4MPI * clone ( ) const;
};

//
// EnhancementOptions_cif16MPI
//

// from 0 size 0 type 0 simple 1
class EnhancementOptions_cif16MPI : public Asn :: Integer {
	public:
	explicit EnhancementOptions_cif16MPI ( Asn :: istream & is );
	EnhancementOptions_cif16MPI ( unsigned v = 0 );
	EnhancementOptions_cif16MPI & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	EnhancementOptions_cif16MPI & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	EnhancementOptions_cif16MPI * clone ( ) const;
};

//
// EnhancementOptions_maxBitRate
//

// from 0 size 0 type 0 simple 1
class EnhancementOptions_maxBitRate : public Asn :: Integer {
	public:
	explicit EnhancementOptions_maxBitRate ( Asn :: istream & is );
	EnhancementOptions_maxBitRate ( unsigned v = 0 );
	EnhancementOptions_maxBitRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	EnhancementOptions_maxBitRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	EnhancementOptions_maxBitRate * clone ( ) const;
};

//
// EnhancementOptions_slowSqcifMPI
//

// from 0 size 0 type 0 simple 1
class EnhancementOptions_slowSqcifMPI : public Asn :: Integer {
	public:
	explicit EnhancementOptions_slowSqcifMPI ( Asn :: istream & is );
	EnhancementOptions_slowSqcifMPI ( unsigned v = 0 );
	EnhancementOptions_slowSqcifMPI & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	EnhancementOptions_slowSqcifMPI & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	EnhancementOptions_slowSqcifMPI * clone ( ) const;
};

//
// EnhancementOptions_slowQcifMPI
//

// from 0 size 0 type 0 simple 1
class EnhancementOptions_slowQcifMPI : public Asn :: Integer {
	public:
	explicit EnhancementOptions_slowQcifMPI ( Asn :: istream & is );
	EnhancementOptions_slowQcifMPI ( unsigned v = 0 );
	EnhancementOptions_slowQcifMPI & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	EnhancementOptions_slowQcifMPI & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	EnhancementOptions_slowQcifMPI * clone ( ) const;
};

//
// EnhancementOptions_slowCifMPI
//

// from 0 size 0 type 0 simple 1
class EnhancementOptions_slowCifMPI : public Asn :: Integer {
	public:
	explicit EnhancementOptions_slowCifMPI ( Asn :: istream & is );
	EnhancementOptions_slowCifMPI ( unsigned v = 0 );
	EnhancementOptions_slowCifMPI & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	EnhancementOptions_slowCifMPI & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	EnhancementOptions_slowCifMPI * clone ( ) const;
};

//
// EnhancementOptions_slowCif4MPI
//

// from 0 size 0 type 0 simple 1
class EnhancementOptions_slowCif4MPI : public Asn :: Integer {
	public:
	explicit EnhancementOptions_slowCif4MPI ( Asn :: istream & is );
	EnhancementOptions_slowCif4MPI ( unsigned v = 0 );
	EnhancementOptions_slowCif4MPI & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	EnhancementOptions_slowCif4MPI & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	EnhancementOptions_slowCif4MPI * clone ( ) const;
};

//
// EnhancementOptions_slowCif16MPI
//

// from 0 size 0 type 0 simple 1
class EnhancementOptions_slowCif16MPI : public Asn :: Integer {
	public:
	explicit EnhancementOptions_slowCif16MPI ( Asn :: istream & is );
	EnhancementOptions_slowCif16MPI ( unsigned v = 0 );
	EnhancementOptions_slowCif16MPI & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	EnhancementOptions_slowCif16MPI & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	EnhancementOptions_slowCif16MPI * clone ( ) const;
};

//
// H263Options_customPictureClockFrequency
//

// from 0 size 1 type 0 simple 0
class CustomPictureClockFrequency;

class H263Options_customPictureClockFrequency : public Asn :: Array {
	public:
	explicit H263Options_customPictureClockFrequency ( Asn :: istream & is );
	H263Options_customPictureClockFrequency ( );
	explicit H263Options_customPictureClockFrequency ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const CustomPictureClockFrequency & o );
	const CustomPictureClockFrequency & operator[] ( std :: size_t i ) const;
	CustomPictureClockFrequency & operator[] ( std :: size_t i );
	H263Options_customPictureClockFrequency * clone ( ) const;
};

//
// H263Options_customPictureFormat
//

// from 0 size 1 type 0 simple 0
class CustomPictureFormat;

class H263Options_customPictureFormat : public Asn :: Array {
	public:
	explicit H263Options_customPictureFormat ( Asn :: istream & is );
	H263Options_customPictureFormat ( );
	explicit H263Options_customPictureFormat ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const CustomPictureFormat & o );
	const CustomPictureFormat & operator[] ( std :: size_t i ) const;
	CustomPictureFormat & operator[] ( std :: size_t i );
	H263Options_customPictureFormat * clone ( ) const;
};

//
// H263Options_modeCombos
//

// from 0 size 1 type 0 simple 0
class H263VideoModeCombos;

class H263Options_modeCombos : public Asn :: Array {
	public:
	explicit H263Options_modeCombos ( Asn :: istream & is );
	H263Options_modeCombos ( );
	explicit H263Options_modeCombos ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const H263VideoModeCombos & o );
	const H263VideoModeCombos & operator[] ( std :: size_t i ) const;
	H263VideoModeCombos & operator[] ( std :: size_t i );
	H263Options_modeCombos * clone ( ) const;
};

//
// TransparencyParameters_presentationOrder
//

// from 0 size 0 type 0 simple 1
class TransparencyParameters_presentationOrder : public Asn :: Integer {
	public:
	explicit TransparencyParameters_presentationOrder ( Asn :: istream & is );
	TransparencyParameters_presentationOrder ( unsigned v = 0 );
	TransparencyParameters_presentationOrder & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	TransparencyParameters_presentationOrder & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	TransparencyParameters_presentationOrder * clone ( ) const;
};

//
// TransparencyParameters_offset-x
//

// from 0 size 0 type 0 simple 1
class TransparencyParameters_offset_x : public Asn :: Integer {
	public:
	explicit TransparencyParameters_offset_x ( Asn :: istream & is );
	TransparencyParameters_offset_x ( unsigned v = 0 );
	TransparencyParameters_offset_x & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	TransparencyParameters_offset_x & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	TransparencyParameters_offset_x * clone ( ) const;
};

//
// TransparencyParameters_offset-y
//

// from 0 size 0 type 0 simple 1
class TransparencyParameters_offset_y : public Asn :: Integer {
	public:
	explicit TransparencyParameters_offset_y ( Asn :: istream & is );
	TransparencyParameters_offset_y ( unsigned v = 0 );
	TransparencyParameters_offset_y & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	TransparencyParameters_offset_y & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	TransparencyParameters_offset_y * clone ( ) const;
};

//
// TransparencyParameters_scale-x
//

// from 0 size 0 type 0 simple 1
class TransparencyParameters_scale_x : public Asn :: Integer {
	public:
	explicit TransparencyParameters_scale_x ( Asn :: istream & is );
	TransparencyParameters_scale_x ( unsigned v = 0 );
	TransparencyParameters_scale_x & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	TransparencyParameters_scale_x & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	TransparencyParameters_scale_x * clone ( ) const;
};

//
// TransparencyParameters_scale-y
//

// from 0 size 0 type 0 simple 1
class TransparencyParameters_scale_y : public Asn :: Integer {
	public:
	explicit TransparencyParameters_scale_y ( Asn :: istream & is );
	TransparencyParameters_scale_y ( unsigned v = 0 );
	TransparencyParameters_scale_y & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	TransparencyParameters_scale_y & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	TransparencyParameters_scale_y * clone ( ) const;
};

//
// RefPictureSelection_additionalPictureMemory
//

// from 0 size 0 type 0 simple 0
class RefPictureSelection_additionalPictureMemory_sqcifAdditionalPictureMemory;
class RefPictureSelection_additionalPictureMemory_qcifAdditionalPictureMemory;
class RefPictureSelection_additionalPictureMemory_cifAdditionalPictureMemory;
class RefPictureSelection_additionalPictureMemory_cif4AdditionalPictureMemory;
class RefPictureSelection_additionalPictureMemory_cif16AdditionalPictureMemory;
class RefPictureSelection_additionalPictureMemory_bigCpfAdditionalPictureMemory;

class RefPictureSelection_additionalPictureMemory : public Asn :: Sequence {
	public:
	explicit RefPictureSelection_additionalPictureMemory ( Asn :: istream & is );
	RefPictureSelection_additionalPictureMemory ( );
	enum OptionalFields {
		e_sqcifAdditionalPictureMemory,
		e_qcifAdditionalPictureMemory,
		e_cifAdditionalPictureMemory,
		e_cif4AdditionalPictureMemory,
		e_cif16AdditionalPictureMemory,
		e_bigCpfAdditionalPictureMemory
	};

	RefPictureSelection_additionalPictureMemory ( const RefPictureSelection_additionalPictureMemory & s );
	RefPictureSelection_additionalPictureMemory & operator= ( const RefPictureSelection_additionalPictureMemory & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	RefPictureSelection_additionalPictureMemory_sqcifAdditionalPictureMemory * m_sqcifAdditionalPictureMemory;
	RefPictureSelection_additionalPictureMemory_qcifAdditionalPictureMemory * m_qcifAdditionalPictureMemory;
	RefPictureSelection_additionalPictureMemory_cifAdditionalPictureMemory * m_cifAdditionalPictureMemory;
	RefPictureSelection_additionalPictureMemory_cif4AdditionalPictureMemory * m_cif4AdditionalPictureMemory;
	RefPictureSelection_additionalPictureMemory_cif16AdditionalPictureMemory * m_cif16AdditionalPictureMemory;
	RefPictureSelection_additionalPictureMemory_bigCpfAdditionalPictureMemory * m_bigCpfAdditionalPictureMemory;
	public:
	void encode ( Asn :: ostream & os ) const;
	~RefPictureSelection_additionalPictureMemory ( );
	void printOn ( std :: ostream & os ) const;
	const RefPictureSelection_additionalPictureMemory_sqcifAdditionalPictureMemory & get_sqcifAdditionalPictureMemory ( ) const {
		return * m_sqcifAdditionalPictureMemory;
	}
	RefPictureSelection_additionalPictureMemory_sqcifAdditionalPictureMemory & get_sqcifAdditionalPictureMemory ( ) {
		return * m_sqcifAdditionalPictureMemory;
	}
	const RefPictureSelection_additionalPictureMemory_qcifAdditionalPictureMemory & get_qcifAdditionalPictureMemory ( ) const {
		return * m_qcifAdditionalPictureMemory;
	}
	RefPictureSelection_additionalPictureMemory_qcifAdditionalPictureMemory & get_qcifAdditionalPictureMemory ( ) {
		return * m_qcifAdditionalPictureMemory;
	}
	const RefPictureSelection_additionalPictureMemory_cifAdditionalPictureMemory & get_cifAdditionalPictureMemory ( ) const {
		return * m_cifAdditionalPictureMemory;
	}
	RefPictureSelection_additionalPictureMemory_cifAdditionalPictureMemory & get_cifAdditionalPictureMemory ( ) {
		return * m_cifAdditionalPictureMemory;
	}
	const RefPictureSelection_additionalPictureMemory_cif4AdditionalPictureMemory & get_cif4AdditionalPictureMemory ( ) const {
		return * m_cif4AdditionalPictureMemory;
	}
	RefPictureSelection_additionalPictureMemory_cif4AdditionalPictureMemory & get_cif4AdditionalPictureMemory ( ) {
		return * m_cif4AdditionalPictureMemory;
	}
	const RefPictureSelection_additionalPictureMemory_cif16AdditionalPictureMemory & get_cif16AdditionalPictureMemory ( ) const {
		return * m_cif16AdditionalPictureMemory;
	}
	RefPictureSelection_additionalPictureMemory_cif16AdditionalPictureMemory & get_cif16AdditionalPictureMemory ( ) {
		return * m_cif16AdditionalPictureMemory;
	}
	const RefPictureSelection_additionalPictureMemory_bigCpfAdditionalPictureMemory & get_bigCpfAdditionalPictureMemory ( ) const {
		return * m_bigCpfAdditionalPictureMemory;
	}
	RefPictureSelection_additionalPictureMemory_bigCpfAdditionalPictureMemory & get_bigCpfAdditionalPictureMemory ( ) {
		return * m_bigCpfAdditionalPictureMemory;
	}
	RefPictureSelection_additionalPictureMemory * clone ( ) const;
};

//
// RefPictureSelection_videoBackChannelSend
//

// from 0 size 0 type 0 simple 0
class RefPictureSelection_videoBackChannelSend : public Asn :: Choice {
	public:
	explicit RefPictureSelection_videoBackChannelSend ( Asn :: istream & is );
	RefPictureSelection_videoBackChannelSend ( );
	enum Choices {
		e_none,
		e_ackMessageOnly,
		e_nackMessageOnly,
		e_ackOrNackMessageOnly,
		e_ackAndNackMessage
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	RefPictureSelection_videoBackChannelSend * clone ( ) const;
};

//
// RefPictureSelection_enhancedReferencePicSelect
//

// from 0 size 0 type 0 simple 0
class RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters;

class RefPictureSelection_enhancedReferencePicSelect : public Asn :: Sequence {
	public:
	explicit RefPictureSelection_enhancedReferencePicSelect ( Asn :: istream & is );
	RefPictureSelection_enhancedReferencePicSelect ( );
	enum OptionalFields {
		e_subPictureRemovalParameters
	};

	RefPictureSelection_enhancedReferencePicSelect ( const RefPictureSelection_enhancedReferencePicSelect & s );
	RefPictureSelection_enhancedReferencePicSelect & operator= ( const RefPictureSelection_enhancedReferencePicSelect & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters * m_subPictureRemovalParameters;
	public:
	void encode ( Asn :: ostream & os ) const;
	~RefPictureSelection_enhancedReferencePicSelect ( );
	void printOn ( std :: ostream & os ) const;
	const RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters & get_subPictureRemovalParameters ( ) const {
		return * m_subPictureRemovalParameters;
	}
	RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters & get_subPictureRemovalParameters ( ) {
		return * m_subPictureRemovalParameters;
	}
	RefPictureSelection_enhancedReferencePicSelect * clone ( ) const;
};

//
// CustomPictureClockFrequency_clockConversionCode
//

// from 0 size 0 type 0 simple 1
class CustomPictureClockFrequency_clockConversionCode : public Asn :: Integer {
	public:
	explicit CustomPictureClockFrequency_clockConversionCode ( Asn :: istream & is );
	CustomPictureClockFrequency_clockConversionCode ( unsigned v = 0 );
	CustomPictureClockFrequency_clockConversionCode & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CustomPictureClockFrequency_clockConversionCode & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CustomPictureClockFrequency_clockConversionCode * clone ( ) const;
};

//
// CustomPictureClockFrequency_clockDivisor
//

// from 0 size 0 type 0 simple 1
class CustomPictureClockFrequency_clockDivisor : public Asn :: Integer {
	public:
	explicit CustomPictureClockFrequency_clockDivisor ( Asn :: istream & is );
	CustomPictureClockFrequency_clockDivisor ( unsigned v = 0 );
	CustomPictureClockFrequency_clockDivisor & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CustomPictureClockFrequency_clockDivisor & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CustomPictureClockFrequency_clockDivisor * clone ( ) const;
};

//
// CustomPictureClockFrequency_sqcifMPI
//

// from 0 size 0 type 0 simple 1
class CustomPictureClockFrequency_sqcifMPI : public Asn :: Integer {
	public:
	explicit CustomPictureClockFrequency_sqcifMPI ( Asn :: istream & is );
	CustomPictureClockFrequency_sqcifMPI ( unsigned v = 0 );
	CustomPictureClockFrequency_sqcifMPI & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CustomPictureClockFrequency_sqcifMPI & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CustomPictureClockFrequency_sqcifMPI * clone ( ) const;
};

//
// CustomPictureClockFrequency_qcifMPI
//

// from 0 size 0 type 0 simple 1
class CustomPictureClockFrequency_qcifMPI : public Asn :: Integer {
	public:
	explicit CustomPictureClockFrequency_qcifMPI ( Asn :: istream & is );
	CustomPictureClockFrequency_qcifMPI ( unsigned v = 0 );
	CustomPictureClockFrequency_qcifMPI & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CustomPictureClockFrequency_qcifMPI & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CustomPictureClockFrequency_qcifMPI * clone ( ) const;
};

//
// CustomPictureClockFrequency_cifMPI
//

// from 0 size 0 type 0 simple 1
class CustomPictureClockFrequency_cifMPI : public Asn :: Integer {
	public:
	explicit CustomPictureClockFrequency_cifMPI ( Asn :: istream & is );
	CustomPictureClockFrequency_cifMPI ( unsigned v = 0 );
	CustomPictureClockFrequency_cifMPI & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CustomPictureClockFrequency_cifMPI & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CustomPictureClockFrequency_cifMPI * clone ( ) const;
};

//
// CustomPictureClockFrequency_cif4MPI
//

// from 0 size 0 type 0 simple 1
class CustomPictureClockFrequency_cif4MPI : public Asn :: Integer {
	public:
	explicit CustomPictureClockFrequency_cif4MPI ( Asn :: istream & is );
	CustomPictureClockFrequency_cif4MPI ( unsigned v = 0 );
	CustomPictureClockFrequency_cif4MPI & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CustomPictureClockFrequency_cif4MPI & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CustomPictureClockFrequency_cif4MPI * clone ( ) const;
};

//
// CustomPictureClockFrequency_cif16MPI
//

// from 0 size 0 type 0 simple 1
class CustomPictureClockFrequency_cif16MPI : public Asn :: Integer {
	public:
	explicit CustomPictureClockFrequency_cif16MPI ( Asn :: istream & is );
	CustomPictureClockFrequency_cif16MPI ( unsigned v = 0 );
	CustomPictureClockFrequency_cif16MPI & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CustomPictureClockFrequency_cif16MPI & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CustomPictureClockFrequency_cif16MPI * clone ( ) const;
};

//
// CustomPictureFormat_maxCustomPictureWidth
//

// from 0 size 0 type 0 simple 1
class CustomPictureFormat_maxCustomPictureWidth : public Asn :: Integer {
	public:
	explicit CustomPictureFormat_maxCustomPictureWidth ( Asn :: istream & is );
	CustomPictureFormat_maxCustomPictureWidth ( unsigned v = 0 );
	CustomPictureFormat_maxCustomPictureWidth & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CustomPictureFormat_maxCustomPictureWidth & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CustomPictureFormat_maxCustomPictureWidth * clone ( ) const;
};

//
// CustomPictureFormat_maxCustomPictureHeight
//

// from 0 size 0 type 0 simple 1
class CustomPictureFormat_maxCustomPictureHeight : public Asn :: Integer {
	public:
	explicit CustomPictureFormat_maxCustomPictureHeight ( Asn :: istream & is );
	CustomPictureFormat_maxCustomPictureHeight ( unsigned v = 0 );
	CustomPictureFormat_maxCustomPictureHeight & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CustomPictureFormat_maxCustomPictureHeight & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CustomPictureFormat_maxCustomPictureHeight * clone ( ) const;
};

//
// CustomPictureFormat_minCustomPictureWidth
//

// from 0 size 0 type 0 simple 1
class CustomPictureFormat_minCustomPictureWidth : public Asn :: Integer {
	public:
	explicit CustomPictureFormat_minCustomPictureWidth ( Asn :: istream & is );
	CustomPictureFormat_minCustomPictureWidth ( unsigned v = 0 );
	CustomPictureFormat_minCustomPictureWidth & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CustomPictureFormat_minCustomPictureWidth & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CustomPictureFormat_minCustomPictureWidth * clone ( ) const;
};

//
// CustomPictureFormat_minCustomPictureHeight
//

// from 0 size 0 type 0 simple 1
class CustomPictureFormat_minCustomPictureHeight : public Asn :: Integer {
	public:
	explicit CustomPictureFormat_minCustomPictureHeight ( Asn :: istream & is );
	CustomPictureFormat_minCustomPictureHeight ( unsigned v = 0 );
	CustomPictureFormat_minCustomPictureHeight & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CustomPictureFormat_minCustomPictureHeight & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CustomPictureFormat_minCustomPictureHeight * clone ( ) const;
};

//
// CustomPictureFormat_mPI
//

// from 0 size 0 type 0 simple 0
class CustomPictureFormat_mPI_standardMPI;
class CustomPictureFormat_mPI_customPCF;

class CustomPictureFormat_mPI : public Asn :: Sequence {
	public:
	explicit CustomPictureFormat_mPI ( Asn :: istream & is );
	CustomPictureFormat_mPI ( );
	enum OptionalFields {
		e_standardMPI,
		e_customPCF
	};

	CustomPictureFormat_mPI ( const CustomPictureFormat_mPI & s );
	CustomPictureFormat_mPI & operator= ( const CustomPictureFormat_mPI & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	CustomPictureFormat_mPI_standardMPI * m_standardMPI;
	CustomPictureFormat_mPI_customPCF * m_customPCF;
	public:
	void encode ( Asn :: ostream & os ) const;
	~CustomPictureFormat_mPI ( );
	void printOn ( std :: ostream & os ) const;
	const CustomPictureFormat_mPI_standardMPI & get_standardMPI ( ) const {
		return * m_standardMPI;
	}
	CustomPictureFormat_mPI_standardMPI & get_standardMPI ( ) {
		return * m_standardMPI;
	}
	const CustomPictureFormat_mPI_customPCF & get_customPCF ( ) const {
		return * m_customPCF;
	}
	CustomPictureFormat_mPI_customPCF & get_customPCF ( ) {
		return * m_customPCF;
	}
	CustomPictureFormat_mPI * clone ( ) const;
};

//
// H263VideoModeCombos_h263VideoCoupledModes
//

// from 0 size 1 type 0 simple 0
class H263VideoModeCombos_h263VideoCoupledModes : public Asn :: Array {
	public:
	explicit H263VideoModeCombos_h263VideoCoupledModes ( Asn :: istream & is );
	H263VideoModeCombos_h263VideoCoupledModes ( );
	explicit H263VideoModeCombos_h263VideoCoupledModes ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const H263ModeComboFlags & o );
	const H263ModeComboFlags & operator[] ( std :: size_t i ) const;
	H263ModeComboFlags & operator[] ( std :: size_t i );
	H263VideoModeCombos_h263VideoCoupledModes * clone ( ) const;
};

//
// IS11172VideoCapability_videoBitRate
//

// from 0 size 0 type 0 simple 1
class IS11172VideoCapability_videoBitRate : public Asn :: Integer {
	public:
	explicit IS11172VideoCapability_videoBitRate ( Asn :: istream & is );
	IS11172VideoCapability_videoBitRate ( unsigned v = 0 );
	IS11172VideoCapability_videoBitRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	IS11172VideoCapability_videoBitRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	IS11172VideoCapability_videoBitRate * clone ( ) const;
};

//
// IS11172VideoCapability_vbvBufferSize
//

// from 0 size 0 type 0 simple 1
class IS11172VideoCapability_vbvBufferSize : public Asn :: Integer {
	public:
	explicit IS11172VideoCapability_vbvBufferSize ( Asn :: istream & is );
	IS11172VideoCapability_vbvBufferSize ( unsigned v = 0 );
	IS11172VideoCapability_vbvBufferSize & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	IS11172VideoCapability_vbvBufferSize & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	IS11172VideoCapability_vbvBufferSize * clone ( ) const;
};

//
// IS11172VideoCapability_samplesPerLine
//

// from 0 size 0 type 0 simple 1
class IS11172VideoCapability_samplesPerLine : public Asn :: Integer {
	public:
	explicit IS11172VideoCapability_samplesPerLine ( Asn :: istream & is );
	IS11172VideoCapability_samplesPerLine ( unsigned v = 0 );
	IS11172VideoCapability_samplesPerLine & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	IS11172VideoCapability_samplesPerLine & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	IS11172VideoCapability_samplesPerLine * clone ( ) const;
};

//
// IS11172VideoCapability_linesPerFrame
//

// from 0 size 0 type 0 simple 1
class IS11172VideoCapability_linesPerFrame : public Asn :: Integer {
	public:
	explicit IS11172VideoCapability_linesPerFrame ( Asn :: istream & is );
	IS11172VideoCapability_linesPerFrame ( unsigned v = 0 );
	IS11172VideoCapability_linesPerFrame & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	IS11172VideoCapability_linesPerFrame & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	IS11172VideoCapability_linesPerFrame * clone ( ) const;
};

//
// IS11172VideoCapability_pictureRate
//

// from 0 size 0 type 0 simple 1
class IS11172VideoCapability_pictureRate : public Asn :: Integer {
	public:
	explicit IS11172VideoCapability_pictureRate ( Asn :: istream & is );
	IS11172VideoCapability_pictureRate ( unsigned v = 0 );
	IS11172VideoCapability_pictureRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	IS11172VideoCapability_pictureRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	IS11172VideoCapability_pictureRate * clone ( ) const;
};

//
// IS11172VideoCapability_luminanceSampleRate
//

// from 0 size 0 type 0 simple 1
class IS11172VideoCapability_luminanceSampleRate : public Asn :: Integer {
	public:
	explicit IS11172VideoCapability_luminanceSampleRate ( Asn :: istream & is );
	IS11172VideoCapability_luminanceSampleRate ( unsigned v = 0 );
	IS11172VideoCapability_luminanceSampleRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	IS11172VideoCapability_luminanceSampleRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	IS11172VideoCapability_luminanceSampleRate * clone ( ) const;
};

//
// AudioCapability_g711Alaw64k
//

// from 0 size 0 type 0 simple 1
class AudioCapability_g711Alaw64k : public Asn :: Integer {
	public:
	explicit AudioCapability_g711Alaw64k ( Asn :: istream & is );
	AudioCapability_g711Alaw64k ( unsigned v = 0 );
	AudioCapability_g711Alaw64k & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	AudioCapability_g711Alaw64k & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	AudioCapability_g711Alaw64k * clone ( ) const;
};

//
// AudioCapability_g711Alaw56k
//

// from 0 size 0 type 0 simple 1
class AudioCapability_g711Alaw56k : public Asn :: Integer {
	public:
	explicit AudioCapability_g711Alaw56k ( Asn :: istream & is );
	AudioCapability_g711Alaw56k ( unsigned v = 0 );
	AudioCapability_g711Alaw56k & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	AudioCapability_g711Alaw56k & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	AudioCapability_g711Alaw56k * clone ( ) const;
};

//
// AudioCapability_g711Ulaw64k
//

// from 0 size 0 type 0 simple 1
class AudioCapability_g711Ulaw64k : public Asn :: Integer {
	public:
	explicit AudioCapability_g711Ulaw64k ( Asn :: istream & is );
	AudioCapability_g711Ulaw64k ( unsigned v = 0 );
	AudioCapability_g711Ulaw64k & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	AudioCapability_g711Ulaw64k & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	AudioCapability_g711Ulaw64k * clone ( ) const;
};

//
// AudioCapability_g711Ulaw56k
//

// from 0 size 0 type 0 simple 1
class AudioCapability_g711Ulaw56k : public Asn :: Integer {
	public:
	explicit AudioCapability_g711Ulaw56k ( Asn :: istream & is );
	AudioCapability_g711Ulaw56k ( unsigned v = 0 );
	AudioCapability_g711Ulaw56k & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	AudioCapability_g711Ulaw56k & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	AudioCapability_g711Ulaw56k * clone ( ) const;
};

//
// AudioCapability_g722-64k
//

// from 0 size 0 type 0 simple 1
class AudioCapability_g722_64k : public Asn :: Integer {
	public:
	explicit AudioCapability_g722_64k ( Asn :: istream & is );
	AudioCapability_g722_64k ( unsigned v = 0 );
	AudioCapability_g722_64k & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	AudioCapability_g722_64k & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	AudioCapability_g722_64k * clone ( ) const;
};

//
// AudioCapability_g722-56k
//

// from 0 size 0 type 0 simple 1
class AudioCapability_g722_56k : public Asn :: Integer {
	public:
	explicit AudioCapability_g722_56k ( Asn :: istream & is );
	AudioCapability_g722_56k ( unsigned v = 0 );
	AudioCapability_g722_56k & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	AudioCapability_g722_56k & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	AudioCapability_g722_56k * clone ( ) const;
};

//
// AudioCapability_g722-48k
//

// from 0 size 0 type 0 simple 1
class AudioCapability_g722_48k : public Asn :: Integer {
	public:
	explicit AudioCapability_g722_48k ( Asn :: istream & is );
	AudioCapability_g722_48k ( unsigned v = 0 );
	AudioCapability_g722_48k & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	AudioCapability_g722_48k & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	AudioCapability_g722_48k * clone ( ) const;
};

//
// AudioCapability_g728
//

// from 0 size 0 type 0 simple 1
class AudioCapability_g728 : public Asn :: Integer {
	public:
	explicit AudioCapability_g728 ( Asn :: istream & is );
	AudioCapability_g728 ( unsigned v = 0 );
	AudioCapability_g728 & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	AudioCapability_g728 & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	AudioCapability_g728 * clone ( ) const;
};

//
// AudioCapability_g729
//

// from 0 size 0 type 0 simple 1
class AudioCapability_g729 : public Asn :: Integer {
	public:
	explicit AudioCapability_g729 ( Asn :: istream & is );
	AudioCapability_g729 ( unsigned v = 0 );
	AudioCapability_g729 & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	AudioCapability_g729 & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	AudioCapability_g729 * clone ( ) const;
};

//
// AudioCapability_g729AnnexA
//

// from 0 size 0 type 0 simple 1
class AudioCapability_g729AnnexA : public Asn :: Integer {
	public:
	explicit AudioCapability_g729AnnexA ( Asn :: istream & is );
	AudioCapability_g729AnnexA ( unsigned v = 0 );
	AudioCapability_g729AnnexA & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	AudioCapability_g729AnnexA & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	AudioCapability_g729AnnexA * clone ( ) const;
};

//
// AudioCapability_g729wAnnexB
//

// from 0 size 0 type 0 simple 1
class AudioCapability_g729wAnnexB : public Asn :: Integer {
	public:
	explicit AudioCapability_g729wAnnexB ( Asn :: istream & is );
	AudioCapability_g729wAnnexB ( unsigned v = 0 );
	AudioCapability_g729wAnnexB & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	AudioCapability_g729wAnnexB & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	AudioCapability_g729wAnnexB * clone ( ) const;
};

//
// AudioCapability_g729AnnexAwAnnexB
//

// from 0 size 0 type 0 simple 1
class AudioCapability_g729AnnexAwAnnexB : public Asn :: Integer {
	public:
	explicit AudioCapability_g729AnnexAwAnnexB ( Asn :: istream & is );
	AudioCapability_g729AnnexAwAnnexB ( unsigned v = 0 );
	AudioCapability_g729AnnexAwAnnexB & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	AudioCapability_g729AnnexAwAnnexB & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	AudioCapability_g729AnnexAwAnnexB * clone ( ) const;
};

//
// G729Extensions_audioUnit
//

// from 0 size 0 type 0 simple 1
class G729Extensions_audioUnit : public Asn :: Integer {
	public:
	explicit G729Extensions_audioUnit ( Asn :: istream & is );
	G729Extensions_audioUnit ( unsigned v = 0 );
	G729Extensions_audioUnit & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	G729Extensions_audioUnit & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	G729Extensions_audioUnit * clone ( ) const;
};

//
// G7231AnnexCCapability_maxAl-sduAudioFrames
//

// from 0 size 0 type 0 simple 1
class G7231AnnexCCapability_maxAl_sduAudioFrames : public Asn :: Integer {
	public:
	explicit G7231AnnexCCapability_maxAl_sduAudioFrames ( Asn :: istream & is );
	G7231AnnexCCapability_maxAl_sduAudioFrames ( unsigned v = 0 );
	G7231AnnexCCapability_maxAl_sduAudioFrames & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	G7231AnnexCCapability_maxAl_sduAudioFrames & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	G7231AnnexCCapability_maxAl_sduAudioFrames * clone ( ) const;
};

//
// IS11172AudioCapability_bitRate
//

// from 0 size 0 type 0 simple 1
class IS11172AudioCapability_bitRate : public Asn :: Integer {
	public:
	explicit IS11172AudioCapability_bitRate ( Asn :: istream & is );
	IS11172AudioCapability_bitRate ( unsigned v = 0 );
	IS11172AudioCapability_bitRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	IS11172AudioCapability_bitRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	IS11172AudioCapability_bitRate * clone ( ) const;
};

//
// IS13818AudioCapability_bitRate
//

// from 0 size 0 type 0 simple 1
class IS13818AudioCapability_bitRate : public Asn :: Integer {
	public:
	explicit IS13818AudioCapability_bitRate ( Asn :: istream & is );
	IS13818AudioCapability_bitRate ( unsigned v = 0 );
	IS13818AudioCapability_bitRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	IS13818AudioCapability_bitRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	IS13818AudioCapability_bitRate * clone ( ) const;
};

//
// GSMAudioCapability_audioUnitSize
//

// from 0 size 0 type 0 simple 1
class GSMAudioCapability_audioUnitSize : public Asn :: Integer {
	public:
	explicit GSMAudioCapability_audioUnitSize ( Asn :: istream & is );
	GSMAudioCapability_audioUnitSize ( unsigned v = 0 );
	GSMAudioCapability_audioUnitSize & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	GSMAudioCapability_audioUnitSize & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	GSMAudioCapability_audioUnitSize * clone ( ) const;
};

//
// DataApplicationCapability_maxBitRate
//

// from 0 size 0 type 0 simple 1
class DataApplicationCapability_maxBitRate : public Asn :: Integer {
	public:
	explicit DataApplicationCapability_maxBitRate ( Asn :: istream & is );
	DataApplicationCapability_maxBitRate ( unsigned v = 0 );
	DataApplicationCapability_maxBitRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	DataApplicationCapability_maxBitRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	DataApplicationCapability_maxBitRate * clone ( ) const;
};

//
// V42bis_numberOfCodewords
//

// from 0 size 0 type 0 simple 1
class V42bis_numberOfCodewords : public Asn :: Integer {
	public:
	explicit V42bis_numberOfCodewords ( Asn :: istream & is );
	V42bis_numberOfCodewords ( unsigned v = 0 );
	V42bis_numberOfCodewords & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	V42bis_numberOfCodewords & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	V42bis_numberOfCodewords * clone ( ) const;
};

//
// V42bis_maximumStringLength
//

// from 0 size 0 type 0 simple 1
class V42bis_maximumStringLength : public Asn :: Integer {
	public:
	explicit V42bis_maximumStringLength ( Asn :: istream & is );
	V42bis_maximumStringLength ( unsigned v = 0 );
	V42bis_maximumStringLength & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	V42bis_maximumStringLength & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	V42bis_maximumStringLength * clone ( ) const;
};

//
// T84Profile_t84Restricted
//

// from 0 size 0 type 0 simple 0
class T84Profile_t84Restricted : public Asn :: Sequence {
	public:
	explicit T84Profile_t84Restricted ( Asn :: istream & is );
	T84Profile_t84Restricted ( );
	Asn :: Boolean m_qcif;
	Asn :: Boolean m_cif;
	Asn :: Boolean m_ccir601Seq;
	Asn :: Boolean m_ccir601Prog;
	Asn :: Boolean m_hdtvSeq;
	Asn :: Boolean m_hdtvProg;
	Asn :: Boolean m_g3FacsMH200x100;
	Asn :: Boolean m_g3FacsMH200x200;
	Asn :: Boolean m_g4FacsMMR200x100;
	Asn :: Boolean m_g4FacsMMR200x200;
	Asn :: Boolean m_jbig200x200Seq;
	Asn :: Boolean m_jbig200x200Prog;
	Asn :: Boolean m_jbig300x300Seq;
	Asn :: Boolean m_jbig300x300Prog;
	Asn :: Boolean m_digPhotoLow;
	Asn :: Boolean m_digPhotoMedSeq;
	Asn :: Boolean m_digPhotoMedProg;
	Asn :: Boolean m_digPhotoHighSeq;
	Asn :: Boolean m_digPhotoHighProg;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	T84Profile_t84Restricted * clone ( ) const;
};

//
// T38FaxProfile_version
//

// from 0 size 0 type 0 simple 1
class T38FaxProfile_version : public Asn :: Integer {
	public:
	explicit T38FaxProfile_version ( Asn :: istream & is );
	T38FaxProfile_version ( unsigned v = 0 );
	T38FaxProfile_version & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	T38FaxProfile_version & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	T38FaxProfile_version * clone ( ) const;
};

//
// T38FaxUdpOptions_t38FaxUdpEC
//

// from 0 size 0 type 0 simple 0
class T38FaxUdpOptions_t38FaxUdpEC : public Asn :: Choice {
	public:
	explicit T38FaxUdpOptions_t38FaxUdpEC ( Asn :: istream & is );
	T38FaxUdpOptions_t38FaxUdpEC ( );
	enum Choices {
		e_t38UDPFEC,
		e_t38UDPRedundancy
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	T38FaxUdpOptions_t38FaxUdpEC * clone ( ) const;
};

//
// UserInputCapability_nonStandard
//

// from 0 size 1 type 0 simple 0
class UserInputCapability_nonStandard : public Asn :: Array {
	public:
	explicit UserInputCapability_nonStandard ( Asn :: istream & is );
	UserInputCapability_nonStandard ( );
	explicit UserInputCapability_nonStandard ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const NonStandardParameter & o );
	const NonStandardParameter & operator[] ( std :: size_t i ) const;
	NonStandardParameter & operator[] ( std :: size_t i );
	UserInputCapability_nonStandard * clone ( ) const;
};

//
// ArrayOf_NonStandardParameter
//

// from 0 size 0 type 0 simple 0
class ArrayOf_NonStandardParameter : public Asn :: Array {
	public:
	explicit ArrayOf_NonStandardParameter ( Asn :: istream & is );
	ArrayOf_NonStandardParameter ( );
	explicit ArrayOf_NonStandardParameter ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const NonStandardParameter & o );
	const NonStandardParameter & operator[] ( std :: size_t i ) const;
	NonStandardParameter & operator[] ( std :: size_t i );
	ArrayOf_NonStandardParameter * clone ( ) const;
};

//
// GenericCapability_maxBitRate
//

// from 0 size 0 type 0 simple 1
class GenericCapability_maxBitRate : public Asn :: Integer {
	public:
	explicit GenericCapability_maxBitRate ( Asn :: istream & is );
	GenericCapability_maxBitRate ( unsigned v = 0 );
	GenericCapability_maxBitRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	GenericCapability_maxBitRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	GenericCapability_maxBitRate * clone ( ) const;
};

//
// CapabilityIdentifier_uuid
//

// from 0 size 1 type 0 simple 0
class CapabilityIdentifier_uuid : public Asn :: OctetString {
	public:
	explicit CapabilityIdentifier_uuid ( Asn :: istream & is );
	CapabilityIdentifier_uuid ( const Asn :: string & v = Asn :: string ( ) );
	CapabilityIdentifier_uuid & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	CapabilityIdentifier_uuid * clone ( ) const;
};

//
// CapabilityIdentifier_domainBased
//

// from 0 size 1 type 0 simple 0
class CapabilityIdentifier_domainBased : public Asn :: IA5String {
	public:
	explicit CapabilityIdentifier_domainBased ( Asn :: istream & is );
	CapabilityIdentifier_domainBased ( const Asn :: string & v = Asn :: string ( ) );
	CapabilityIdentifier_domainBased & operator= ( const Asn :: string & v ) {
		Asn :: IA5String :: operator= ( v );
		return * this;
	}
	CapabilityIdentifier_domainBased * clone ( ) const;
};

//
// ArrayOf_ParameterIdentifier
//

// from 0 size 0 type 0 simple 0
class ParameterIdentifier;

class ArrayOf_ParameterIdentifier : public Asn :: Array {
	public:
	explicit ArrayOf_ParameterIdentifier ( Asn :: istream & is );
	ArrayOf_ParameterIdentifier ( );
	explicit ArrayOf_ParameterIdentifier ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const ParameterIdentifier & o );
	const ParameterIdentifier & operator[] ( std :: size_t i ) const;
	ParameterIdentifier & operator[] ( std :: size_t i );
	ArrayOf_ParameterIdentifier * clone ( ) const;
};

//
// ParameterIdentifier_standard
//

// from 0 size 0 type 0 simple 1
class ParameterIdentifier_standard : public Asn :: Integer {
	public:
	explicit ParameterIdentifier_standard ( Asn :: istream & is );
	ParameterIdentifier_standard ( unsigned v = 0 );
	ParameterIdentifier_standard & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	ParameterIdentifier_standard & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	ParameterIdentifier_standard * clone ( ) const;
};

//
// ParameterIdentifier_uuid
//

// from 0 size 1 type 0 simple 0
class ParameterIdentifier_uuid : public Asn :: OctetString {
	public:
	explicit ParameterIdentifier_uuid ( Asn :: istream & is );
	ParameterIdentifier_uuid ( const Asn :: string & v = Asn :: string ( ) );
	ParameterIdentifier_uuid & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	ParameterIdentifier_uuid * clone ( ) const;
};

//
// ParameterIdentifier_domainBased
//

// from 0 size 1 type 0 simple 0
class ParameterIdentifier_domainBased : public Asn :: IA5String {
	public:
	explicit ParameterIdentifier_domainBased ( Asn :: istream & is );
	ParameterIdentifier_domainBased ( const Asn :: string & v = Asn :: string ( ) );
	ParameterIdentifier_domainBased & operator= ( const Asn :: string & v ) {
		Asn :: IA5String :: operator= ( v );
		return * this;
	}
	ParameterIdentifier_domainBased * clone ( ) const;
};

//
// ParameterValue_booleanArray
//

// from 0 size 0 type 0 simple 1
class ParameterValue_booleanArray : public Asn :: Integer {
	public:
	explicit ParameterValue_booleanArray ( Asn :: istream & is );
	ParameterValue_booleanArray ( unsigned v = 0 );
	ParameterValue_booleanArray & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	ParameterValue_booleanArray & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	ParameterValue_booleanArray * clone ( ) const;
};

//
// ParameterValue_unsignedMin
//

// from 0 size 0 type 0 simple 1
class ParameterValue_unsignedMin : public Asn :: Integer {
	public:
	explicit ParameterValue_unsignedMin ( Asn :: istream & is );
	ParameterValue_unsignedMin ( unsigned v = 0 );
	ParameterValue_unsignedMin & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	ParameterValue_unsignedMin & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	ParameterValue_unsignedMin * clone ( ) const;
};

//
// ParameterValue_unsignedMax
//

// from 0 size 0 type 0 simple 1
class ParameterValue_unsignedMax : public Asn :: Integer {
	public:
	explicit ParameterValue_unsignedMax ( Asn :: istream & is );
	ParameterValue_unsignedMax ( unsigned v = 0 );
	ParameterValue_unsignedMax & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	ParameterValue_unsignedMax & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	ParameterValue_unsignedMax * clone ( ) const;
};

//
// ParameterValue_unsigned32Min
//

// from 0 size 0 type 0 simple 1
class ParameterValue_unsigned32Min : public Asn :: Integer {
	public:
	explicit ParameterValue_unsigned32Min ( Asn :: istream & is );
	ParameterValue_unsigned32Min ( unsigned v = 0 );
	ParameterValue_unsigned32Min & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	ParameterValue_unsigned32Min & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	ParameterValue_unsigned32Min * clone ( ) const;
};

//
// ParameterValue_unsigned32Max
//

// from 0 size 0 type 0 simple 1
class ParameterValue_unsigned32Max : public Asn :: Integer {
	public:
	explicit ParameterValue_unsigned32Max ( Asn :: istream & is );
	ParameterValue_unsigned32Max ( unsigned v = 0 );
	ParameterValue_unsigned32Max & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	ParameterValue_unsigned32Max & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	ParameterValue_unsigned32Max * clone ( ) const;
};

//
// MultiplexedStreamCapability_capabilityOnMuxStream
//

// from 0 size 1 type 0 simple 0
class MultiplexedStreamCapability_capabilityOnMuxStream : public Asn :: Array {
	public:
	explicit MultiplexedStreamCapability_capabilityOnMuxStream ( Asn :: istream & is );
	MultiplexedStreamCapability_capabilityOnMuxStream ( );
	explicit MultiplexedStreamCapability_capabilityOnMuxStream ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const AlternativeCapabilitySet & o );
	const AlternativeCapabilitySet & operator[] ( std :: size_t i ) const;
	AlternativeCapabilitySet & operator[] ( std :: size_t i );
	MultiplexedStreamCapability_capabilityOnMuxStream * clone ( ) const;
};

//
// AudioTelephonyEventCapability_dynamicRTPPayloadType
//

// from 0 size 0 type 0 simple 1
class AudioTelephonyEventCapability_dynamicRTPPayloadType : public Asn :: Integer {
	public:
	explicit AudioTelephonyEventCapability_dynamicRTPPayloadType ( Asn :: istream & is );
	AudioTelephonyEventCapability_dynamicRTPPayloadType ( unsigned v = 0 );
	AudioTelephonyEventCapability_dynamicRTPPayloadType & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	AudioTelephonyEventCapability_dynamicRTPPayloadType & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	AudioTelephonyEventCapability_dynamicRTPPayloadType * clone ( ) const;
};

//
// AudioToneCapability_dynamicRTPPayloadType
//

// from 0 size 0 type 0 simple 1
class AudioToneCapability_dynamicRTPPayloadType : public Asn :: Integer {
	public:
	explicit AudioToneCapability_dynamicRTPPayloadType ( Asn :: istream & is );
	AudioToneCapability_dynamicRTPPayloadType ( unsigned v = 0 );
	AudioToneCapability_dynamicRTPPayloadType & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	AudioToneCapability_dynamicRTPPayloadType & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	AudioToneCapability_dynamicRTPPayloadType * clone ( ) const;
};

//
// MultiplePayloadStreamCapability_capabilities
//

// from 0 size 1 type 0 simple 0
class MultiplePayloadStreamCapability_capabilities : public Asn :: Array {
	public:
	explicit MultiplePayloadStreamCapability_capabilities ( Asn :: istream & is );
	MultiplePayloadStreamCapability_capabilities ( );
	explicit MultiplePayloadStreamCapability_capabilities ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const AlternativeCapabilitySet & o );
	const AlternativeCapabilitySet & operator[] ( std :: size_t i ) const;
	AlternativeCapabilitySet & operator[] ( std :: size_t i );
	MultiplePayloadStreamCapability_capabilities * clone ( ) const;
};

//
// FECCapability_rfc2733Format
//

// from 0 size 0 type 0 simple 0
class FECCapability_rfc2733Format : public Asn :: Choice {
	public:
	explicit FECCapability_rfc2733Format ( Asn :: istream & is );
	FECCapability_rfc2733Format ( );
	enum Choices {
		e_rfc2733rfc2198,
		e_rfc2733sameport,
		e_rfc2733diffport
	};

	operator MaxRedundancy & ( ) { return dynamic_cast < MaxRedundancy & > ( * choice ); }
	operator const MaxRedundancy & ( ) const { return dynamic_cast < const MaxRedundancy & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	FECCapability_rfc2733Format * clone ( ) const;
};

//
// NetworkAccessParameters_distribution
//

// from 0 size 0 type 0 simple 0
class NetworkAccessParameters_distribution : public Asn :: Choice {
	public:
	explicit NetworkAccessParameters_distribution ( Asn :: istream & is );
	NetworkAccessParameters_distribution ( );
	enum Choices {
		e_unicast,
		e_multicast
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	NetworkAccessParameters_distribution * clone ( ) const;
};

//
// NetworkAccessParameters_externalReference
//

// from 0 size 1 type 0 simple 0
class NetworkAccessParameters_externalReference : public Asn :: OctetString {
	public:
	explicit NetworkAccessParameters_externalReference ( Asn :: istream & is );
	NetworkAccessParameters_externalReference ( const Asn :: string & v = Asn :: string ( ) );
	NetworkAccessParameters_externalReference & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	NetworkAccessParameters_externalReference * clone ( ) const;
};

//
// NetworkAccessParameters_t120SetupProcedure
//

// from 0 size 0 type 0 simple 0
class NetworkAccessParameters_t120SetupProcedure : public Asn :: Choice {
	public:
	explicit NetworkAccessParameters_t120SetupProcedure ( Asn :: istream & is );
	NetworkAccessParameters_t120SetupProcedure ( );
	enum Choices {
		e_originateCall,
		e_waitForCall,
		e_issueQuery
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	NetworkAccessParameters_t120SetupProcedure * clone ( ) const;
};

//
// Q2931Address_subaddress
//

// from 0 size 1 type 0 simple 0
class Q2931Address_subaddress : public Asn :: OctetString {
	public:
	explicit Q2931Address_subaddress ( Asn :: istream & is );
	Q2931Address_subaddress ( const Asn :: string & v = Asn :: string ( ) );
	Q2931Address_subaddress & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	Q2931Address_subaddress * clone ( ) const;
};

//
// H222LogicalChannelParameters_resourceID
//

// from 0 size 0 type 0 simple 1
class H222LogicalChannelParameters_resourceID : public Asn :: Integer {
	public:
	explicit H222LogicalChannelParameters_resourceID ( Asn :: istream & is );
	H222LogicalChannelParameters_resourceID ( unsigned v = 0 );
	H222LogicalChannelParameters_resourceID & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H222LogicalChannelParameters_resourceID & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H222LogicalChannelParameters_resourceID * clone ( ) const;
};

//
// H222LogicalChannelParameters_subChannelID
//

// from 0 size 0 type 0 simple 1
class H222LogicalChannelParameters_subChannelID : public Asn :: Integer {
	public:
	explicit H222LogicalChannelParameters_subChannelID ( Asn :: istream & is );
	H222LogicalChannelParameters_subChannelID ( unsigned v = 0 );
	H222LogicalChannelParameters_subChannelID & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H222LogicalChannelParameters_subChannelID & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H222LogicalChannelParameters_subChannelID * clone ( ) const;
};

//
// H222LogicalChannelParameters_pcr-pid
//

// from 0 size 0 type 0 simple 1
class H222LogicalChannelParameters_pcr_pid : public Asn :: Integer {
	public:
	explicit H222LogicalChannelParameters_pcr_pid ( Asn :: istream & is );
	H222LogicalChannelParameters_pcr_pid ( unsigned v = 0 );
	H222LogicalChannelParameters_pcr_pid & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H222LogicalChannelParameters_pcr_pid & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H222LogicalChannelParameters_pcr_pid * clone ( ) const;
};

//
// H223AL1MParameters_transferMode
//

// from 0 size 0 type 0 simple 0
class H223AL1MParameters_transferMode : public Asn :: Choice {
	public:
	explicit H223AL1MParameters_transferMode ( Asn :: istream & is );
	H223AL1MParameters_transferMode ( );
	enum Choices {
		e_framed,
		e_unframed
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	H223AL1MParameters_transferMode * clone ( ) const;
};

//
// H223AL1MParameters_headerFEC
//

// from 0 size 0 type 0 simple 0
class H223AL1MParameters_headerFEC : public Asn :: Choice {
	public:
	explicit H223AL1MParameters_headerFEC ( Asn :: istream & is );
	H223AL1MParameters_headerFEC ( );
	enum Choices {
		e_sebch16_7,
		e_golay24_12
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	H223AL1MParameters_headerFEC * clone ( ) const;
};

//
// H223AL1MParameters_crcLength
//

// from 0 size 0 type 0 simple 0
class H223AL1MParameters_crcLength : public Asn :: Choice {
	public:
	explicit H223AL1MParameters_crcLength ( Asn :: istream & is );
	H223AL1MParameters_crcLength ( );
	enum Choices {
		e_crc4bit,
		e_crc12bit,
		e_crc20bit,
		e_crc28bit,
		e_crc8bit,
		e_crc16bit,
		e_crc32bit,
		e_crcNotUsed
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	H223AL1MParameters_crcLength * clone ( ) const;
};

//
// H223AL1MParameters_rcpcCodeRate
//

// from 0 size 0 type 0 simple 1
class H223AL1MParameters_rcpcCodeRate : public Asn :: Integer {
	public:
	explicit H223AL1MParameters_rcpcCodeRate ( Asn :: istream & is );
	H223AL1MParameters_rcpcCodeRate ( unsigned v = 0 );
	H223AL1MParameters_rcpcCodeRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223AL1MParameters_rcpcCodeRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223AL1MParameters_rcpcCodeRate * clone ( ) const;
};

//
// H223AL1MParameters_rsCodeCorrection
//

// from 0 size 0 type 0 simple 1
class H223AL1MParameters_rsCodeCorrection : public Asn :: Integer {
	public:
	explicit H223AL1MParameters_rsCodeCorrection ( Asn :: istream & is );
	H223AL1MParameters_rsCodeCorrection ( unsigned v = 0 );
	H223AL1MParameters_rsCodeCorrection & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223AL1MParameters_rsCodeCorrection & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223AL1MParameters_rsCodeCorrection * clone ( ) const;
};

//
// H223AL2MParameters_headerFEC
//

// from 0 size 0 type 0 simple 0
class H223AL2MParameters_headerFEC : public Asn :: Choice {
	public:
	explicit H223AL2MParameters_headerFEC ( Asn :: istream & is );
	H223AL2MParameters_headerFEC ( );
	enum Choices {
		e_sebch16_5,
		e_golay24_12
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	H223AL2MParameters_headerFEC * clone ( ) const;
};

//
// H223AL3MParameters_headerFormat
//

// from 0 size 0 type 0 simple 0
class H223AL3MParameters_headerFormat : public Asn :: Choice {
	public:
	explicit H223AL3MParameters_headerFormat ( Asn :: istream & is );
	H223AL3MParameters_headerFormat ( );
	enum Choices {
		e_sebch16_7,
		e_golay24_12
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	H223AL3MParameters_headerFormat * clone ( ) const;
};

//
// H223AL3MParameters_crcLength
//

// from 0 size 0 type 0 simple 0
class H223AL3MParameters_crcLength : public Asn :: Choice {
	public:
	explicit H223AL3MParameters_crcLength ( Asn :: istream & is );
	H223AL3MParameters_crcLength ( );
	enum Choices {
		e_crc4bit,
		e_crc12bit,
		e_crc20bit,
		e_crc28bit,
		e_crc8bit,
		e_crc16bit,
		e_crc32bit,
		e_crcNotUsed
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	H223AL3MParameters_crcLength * clone ( ) const;
};

//
// H223AL3MParameters_rcpcCodeRate
//

// from 0 size 0 type 0 simple 1
class H223AL3MParameters_rcpcCodeRate : public Asn :: Integer {
	public:
	explicit H223AL3MParameters_rcpcCodeRate ( Asn :: istream & is );
	H223AL3MParameters_rcpcCodeRate ( unsigned v = 0 );
	H223AL3MParameters_rcpcCodeRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223AL3MParameters_rcpcCodeRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223AL3MParameters_rcpcCodeRate * clone ( ) const;
};

//
// H223AL3MParameters_rsCodeCorrection
//

// from 0 size 0 type 0 simple 1
class H223AL3MParameters_rsCodeCorrection : public Asn :: Integer {
	public:
	explicit H223AL3MParameters_rsCodeCorrection ( Asn :: istream & is );
	H223AL3MParameters_rsCodeCorrection ( unsigned v = 0 );
	H223AL3MParameters_rsCodeCorrection & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223AL3MParameters_rsCodeCorrection & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223AL3MParameters_rsCodeCorrection * clone ( ) const;
};

//
// H223AnnexCArqParameters_sendBufferSize
//

// from 0 size 0 type 0 simple 1
class H223AnnexCArqParameters_sendBufferSize : public Asn :: Integer {
	public:
	explicit H223AnnexCArqParameters_sendBufferSize ( Asn :: istream & is );
	H223AnnexCArqParameters_sendBufferSize ( unsigned v = 0 );
	H223AnnexCArqParameters_sendBufferSize & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223AnnexCArqParameters_sendBufferSize & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223AnnexCArqParameters_sendBufferSize * clone ( ) const;
};

//
// V76LogicalChannelParameters_suspendResume
//

// from 0 size 0 type 0 simple 0
class V76LogicalChannelParameters_suspendResume : public Asn :: Choice {
	public:
	explicit V76LogicalChannelParameters_suspendResume ( Asn :: istream & is );
	V76LogicalChannelParameters_suspendResume ( );
	enum Choices {
		e_noSuspendResume,
		e_suspendResumewAddress,
		e_suspendResumewoAddress
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	V76LogicalChannelParameters_suspendResume * clone ( ) const;
};

//
// V76HDLCParameters_n401
//

// from 0 size 0 type 0 simple 1
class V76HDLCParameters_n401 : public Asn :: Integer {
	public:
	explicit V76HDLCParameters_n401 ( Asn :: istream & is );
	V76HDLCParameters_n401 ( unsigned v = 0 );
	V76HDLCParameters_n401 & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	V76HDLCParameters_n401 & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	V76HDLCParameters_n401 * clone ( ) const;
};

//
// H2250LogicalChannelParameters_sessionID
//

// from 0 size 0 type 0 simple 1
class H2250LogicalChannelParameters_sessionID : public Asn :: Integer {
	public:
	explicit H2250LogicalChannelParameters_sessionID ( Asn :: istream & is );
	H2250LogicalChannelParameters_sessionID ( unsigned v = 0 );
	H2250LogicalChannelParameters_sessionID & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H2250LogicalChannelParameters_sessionID & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H2250LogicalChannelParameters_sessionID * clone ( ) const;
};

//
// H2250LogicalChannelParameters_associatedSessionID
//

// from 0 size 0 type 0 simple 1
class H2250LogicalChannelParameters_associatedSessionID : public Asn :: Integer {
	public:
	explicit H2250LogicalChannelParameters_associatedSessionID ( Asn :: istream & is );
	H2250LogicalChannelParameters_associatedSessionID ( unsigned v = 0 );
	H2250LogicalChannelParameters_associatedSessionID & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H2250LogicalChannelParameters_associatedSessionID & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H2250LogicalChannelParameters_associatedSessionID * clone ( ) const;
};

//
// H2250LogicalChannelParameters_dynamicRTPPayloadType
//

// from 0 size 0 type 0 simple 1
class H2250LogicalChannelParameters_dynamicRTPPayloadType : public Asn :: Integer {
	public:
	explicit H2250LogicalChannelParameters_dynamicRTPPayloadType ( Asn :: istream & is );
	H2250LogicalChannelParameters_dynamicRTPPayloadType ( unsigned v = 0 );
	H2250LogicalChannelParameters_dynamicRTPPayloadType & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H2250LogicalChannelParameters_dynamicRTPPayloadType & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H2250LogicalChannelParameters_dynamicRTPPayloadType * clone ( ) const;
};

//
// RTPPayloadType_payloadType
//

// from 0 size 0 type 0 simple 1
class RTPPayloadType_payloadType : public Asn :: Integer {
	public:
	explicit RTPPayloadType_payloadType ( Asn :: istream & is );
	RTPPayloadType_payloadType ( unsigned v = 0 );
	RTPPayloadType_payloadType & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RTPPayloadType_payloadType & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RTPPayloadType_payloadType * clone ( ) const;
};

//
// RedundancyEncoding_rtpRedundancyEncoding
//

// from 0 size 0 type 0 simple 0
class RedundancyEncodingElement;
class ArrayOf_RedundancyEncodingElement;

class RedundancyEncoding_rtpRedundancyEncoding : public Asn :: Sequence {
	public:
	explicit RedundancyEncoding_rtpRedundancyEncoding ( Asn :: istream & is );
	RedundancyEncoding_rtpRedundancyEncoding ( );
	enum OptionalFields {
		e_primary,
		e_secondary
	};

	RedundancyEncoding_rtpRedundancyEncoding ( const RedundancyEncoding_rtpRedundancyEncoding & s );
	RedundancyEncoding_rtpRedundancyEncoding & operator= ( const RedundancyEncoding_rtpRedundancyEncoding & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	RedundancyEncodingElement * m_primary;
	ArrayOf_RedundancyEncodingElement * m_secondary;
	public:
	void encode ( Asn :: ostream & os ) const;
	~RedundancyEncoding_rtpRedundancyEncoding ( );
	void printOn ( std :: ostream & os ) const;
	const RedundancyEncodingElement & get_primary ( ) const {
		return * m_primary;
	}
	RedundancyEncodingElement & get_primary ( ) {
		return * m_primary;
	}
	const ArrayOf_RedundancyEncodingElement & get_secondary ( ) const {
		return * m_secondary;
	}
	ArrayOf_RedundancyEncodingElement & get_secondary ( ) {
		return * m_secondary;
	}
	RedundancyEncoding_rtpRedundancyEncoding * clone ( ) const;
};

//
// RedundancyEncodingElement_payloadType
//

// from 0 size 0 type 0 simple 1
class RedundancyEncodingElement_payloadType : public Asn :: Integer {
	public:
	explicit RedundancyEncodingElement_payloadType ( Asn :: istream & is );
	RedundancyEncodingElement_payloadType ( unsigned v = 0 );
	RedundancyEncodingElement_payloadType & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RedundancyEncodingElement_payloadType & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RedundancyEncodingElement_payloadType * clone ( ) const;
};

//
// ArrayOf_MultiplePayloadStreamElement
//

// from 0 size 0 type 0 simple 0
class MultiplePayloadStreamElement;

class ArrayOf_MultiplePayloadStreamElement : public Asn :: Array {
	public:
	explicit ArrayOf_MultiplePayloadStreamElement ( Asn :: istream & is );
	ArrayOf_MultiplePayloadStreamElement ( );
	explicit ArrayOf_MultiplePayloadStreamElement ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const MultiplePayloadStreamElement & o );
	const MultiplePayloadStreamElement & operator[] ( std :: size_t i ) const;
	MultiplePayloadStreamElement & operator[] ( std :: size_t i );
	ArrayOf_MultiplePayloadStreamElement * clone ( ) const;
};

//
// MultiplePayloadStreamElement_payloadType
//

// from 0 size 0 type 0 simple 1
class MultiplePayloadStreamElement_payloadType : public Asn :: Integer {
	public:
	explicit MultiplePayloadStreamElement_payloadType ( Asn :: istream & is );
	MultiplePayloadStreamElement_payloadType ( unsigned v = 0 );
	MultiplePayloadStreamElement_payloadType & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MultiplePayloadStreamElement_payloadType & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MultiplePayloadStreamElement_payloadType * clone ( ) const;
};

//
// UnicastAddress_netBios
//

// from 0 size 1 type 0 simple 0
class UnicastAddress_netBios : public Asn :: OctetString {
	public:
	explicit UnicastAddress_netBios ( Asn :: istream & is );
	UnicastAddress_netBios ( const Asn :: string & v = Asn :: string ( ) );
	UnicastAddress_netBios & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	UnicastAddress_netBios * clone ( ) const;
};

//
// UnicastAddress_nsap
//

// from 0 size 1 type 0 simple 0
class UnicastAddress_nsap : public Asn :: OctetString {
	public:
	explicit UnicastAddress_nsap ( Asn :: istream & is );
	UnicastAddress_nsap ( const Asn :: string & v = Asn :: string ( ) );
	UnicastAddress_nsap & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	UnicastAddress_nsap * clone ( ) const;
};

//
// MulticastAddress_nsap
//

// from 0 size 1 type 0 simple 0
class MulticastAddress_nsap : public Asn :: OctetString {
	public:
	explicit MulticastAddress_nsap ( Asn :: istream & is );
	MulticastAddress_nsap ( const Asn :: string & v = Asn :: string ( ) );
	MulticastAddress_nsap & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	MulticastAddress_nsap * clone ( ) const;
};

//
// EncryptionSync_synchFlag
//

// from 0 size 0 type 0 simple 1
class EncryptionSync_synchFlag : public Asn :: Integer {
	public:
	explicit EncryptionSync_synchFlag ( Asn :: istream & is );
	EncryptionSync_synchFlag ( unsigned v = 0 );
	EncryptionSync_synchFlag & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	EncryptionSync_synchFlag & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	EncryptionSync_synchFlag * clone ( ) const;
};

//
// EncryptionSync_h235Key
//

// from 0 size 1 type 0 simple 0
class EncryptionSync_h235Key : public Asn :: OctetString {
	public:
	explicit EncryptionSync_h235Key ( Asn :: istream & is );
	EncryptionSync_h235Key ( const Asn :: string & v = Asn :: string ( ) );
	EncryptionSync_h235Key & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	EncryptionSync_h235Key * clone ( ) const;
};

//
// EncryptionSync_escrowentry
//

// from 0 size 1 type 0 simple 0
class EscrowData;

class EncryptionSync_escrowentry : public Asn :: Array {
	public:
	explicit EncryptionSync_escrowentry ( Asn :: istream & is );
	EncryptionSync_escrowentry ( );
	explicit EncryptionSync_escrowentry ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const EscrowData & o );
	const EscrowData & operator[] ( std :: size_t i ) const;
	EscrowData & operator[] ( std :: size_t i );
	EncryptionSync_escrowentry * clone ( ) const;
};

//
// EscrowData_escrowValue
//

// from 0 size 1 type 0 simple 0
class EscrowData_escrowValue : public Asn :: BitString {
	public:
	explicit EscrowData_escrowValue ( Asn :: istream & is );
	EscrowData_escrowValue ( const Asn :: string & v = Asn :: string ( ), unsigned b = 0 );
	EscrowData_escrowValue * clone ( ) const;
};

//
// OpenLogicalChannelAck_reverseLogicalChannelParameters
//

// from 0 size 0 type 0 simple 0
class OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber;
class OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters;

class OpenLogicalChannelAck_reverseLogicalChannelParameters : public Asn :: Sequence {
	public:
	explicit OpenLogicalChannelAck_reverseLogicalChannelParameters ( Asn :: istream & is );
	OpenLogicalChannelAck_reverseLogicalChannelParameters ( );
	enum OptionalFields {
		e_portNumber,
		e_multiplexParameters,
		e_replacementFor
	};

	OpenLogicalChannelAck_reverseLogicalChannelParameters ( const OpenLogicalChannelAck_reverseLogicalChannelParameters & s );
	OpenLogicalChannelAck_reverseLogicalChannelParameters & operator= ( const OpenLogicalChannelAck_reverseLogicalChannelParameters & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	LogicalChannelNumber m_reverseLogicalChannelNumber;
	protected:
	OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber * m_portNumber;
	OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters * m_multiplexParameters;
	LogicalChannelNumber * m_replacementFor;
	public:
	void encode ( Asn :: ostream & os ) const;
	~OpenLogicalChannelAck_reverseLogicalChannelParameters ( );
	void printOn ( std :: ostream & os ) const;
	const OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber & get_portNumber ( ) const {
		return * m_portNumber;
	}
	OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber & get_portNumber ( ) {
		return * m_portNumber;
	}
	const OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters & get_multiplexParameters ( ) const {
		return * m_multiplexParameters;
	}
	OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters & get_multiplexParameters ( ) {
		return * m_multiplexParameters;
	}
	const LogicalChannelNumber & get_replacementFor ( ) const {
		return * m_replacementFor;
	}
	LogicalChannelNumber & get_replacementFor ( ) {
		return * m_replacementFor;
	}
	OpenLogicalChannelAck_reverseLogicalChannelParameters * clone ( ) const;
};

//
// OpenLogicalChannelAck_forwardMultiplexAckParameters
//

// from 0 size 0 type 0 simple 0
class OpenLogicalChannelAck_forwardMultiplexAckParameters : public Asn :: Choice {
	public:
	explicit OpenLogicalChannelAck_forwardMultiplexAckParameters ( Asn :: istream & is );
	OpenLogicalChannelAck_forwardMultiplexAckParameters ( );
	enum Choices {
		e_h2250LogicalChannelAckParameters
	};

	operator H2250LogicalChannelAckParameters & ( ) { return dynamic_cast < H2250LogicalChannelAckParameters & > ( * choice ); }
	operator const H2250LogicalChannelAckParameters & ( ) const { return dynamic_cast < const H2250LogicalChannelAckParameters & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	OpenLogicalChannelAck_forwardMultiplexAckParameters * clone ( ) const;
};

//
// OpenLogicalChannelReject_cause
//

// from 0 size 0 type 0 simple 0
class OpenLogicalChannelReject_cause : public Asn :: Choice {
	public:
	explicit OpenLogicalChannelReject_cause ( Asn :: istream & is );
	OpenLogicalChannelReject_cause ( );
	enum Choices {
		e_unspecified,
		e_unsuitableReverseParameters,
		e_dataTypeNotSupported,
		e_dataTypeNotAvailable,
		e_unknownDataType,
		e_dataTypeALCombinationNotSupported,
		e_multicastChannelNotAllowed,
		e_insufficientBandwidth,
		e_separateStackEstablishmentFailed,
		e_invalidSessionID,
		e_masterSlaveConflict,
		e_waitForCommunicationMode,
		e_invalidDependentChannel,
		e_replacementForRejected,
		e_securityDenied
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	OpenLogicalChannelReject_cause * clone ( ) const;
};

//
// H2250LogicalChannelAckParameters_sessionID
//

// from 0 size 0 type 0 simple 1
class H2250LogicalChannelAckParameters_sessionID : public Asn :: Integer {
	public:
	explicit H2250LogicalChannelAckParameters_sessionID ( Asn :: istream & is );
	H2250LogicalChannelAckParameters_sessionID ( unsigned v = 0 );
	H2250LogicalChannelAckParameters_sessionID & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H2250LogicalChannelAckParameters_sessionID & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H2250LogicalChannelAckParameters_sessionID * clone ( ) const;
};

//
// H2250LogicalChannelAckParameters_dynamicRTPPayloadType
//

// from 0 size 0 type 0 simple 1
class H2250LogicalChannelAckParameters_dynamicRTPPayloadType : public Asn :: Integer {
	public:
	explicit H2250LogicalChannelAckParameters_dynamicRTPPayloadType ( Asn :: istream & is );
	H2250LogicalChannelAckParameters_dynamicRTPPayloadType ( unsigned v = 0 );
	H2250LogicalChannelAckParameters_dynamicRTPPayloadType & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H2250LogicalChannelAckParameters_dynamicRTPPayloadType & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H2250LogicalChannelAckParameters_dynamicRTPPayloadType * clone ( ) const;
};

//
// H2250LogicalChannelAckParameters_portNumber
//

// from 0 size 0 type 0 simple 1
class H2250LogicalChannelAckParameters_portNumber : public Asn :: Integer {
	public:
	explicit H2250LogicalChannelAckParameters_portNumber ( Asn :: istream & is );
	H2250LogicalChannelAckParameters_portNumber ( unsigned v = 0 );
	H2250LogicalChannelAckParameters_portNumber & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H2250LogicalChannelAckParameters_portNumber & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H2250LogicalChannelAckParameters_portNumber * clone ( ) const;
};

//
// CloseLogicalChannel_source
//

// from 0 size 0 type 0 simple 0
class CloseLogicalChannel_source : public Asn :: Choice {
	public:
	explicit CloseLogicalChannel_source ( Asn :: istream & is );
	CloseLogicalChannel_source ( );
	enum Choices {
		e_user,
		e_lcse
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	CloseLogicalChannel_source * clone ( ) const;
};

//
// CloseLogicalChannel_reason
//

// from 0 size 0 type 0 simple 0
class CloseLogicalChannel_reason : public Asn :: Choice {
	public:
	explicit CloseLogicalChannel_reason ( Asn :: istream & is );
	CloseLogicalChannel_reason ( );
	enum Choices {
		e_unknown,
		e_reopen,
		e_reservationFailure
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	CloseLogicalChannel_reason * clone ( ) const;
};

//
// RequestChannelClose_reason
//

// from 0 size 0 type 0 simple 0
class RequestChannelClose_reason : public Asn :: Choice {
	public:
	explicit RequestChannelClose_reason ( Asn :: istream & is );
	RequestChannelClose_reason ( );
	enum Choices {
		e_unknown,
		e_normal,
		e_reopen,
		e_reservationFailure
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	RequestChannelClose_reason * clone ( ) const;
};

//
// RequestChannelCloseReject_cause
//

// from 0 size 0 type 0 simple 0
class RequestChannelCloseReject_cause : public Asn :: Choice {
	public:
	explicit RequestChannelCloseReject_cause ( Asn :: istream & is );
	RequestChannelCloseReject_cause ( );
	enum Choices {
		e_unspecified
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	RequestChannelCloseReject_cause * clone ( ) const;
};

//
// MultiplexEntrySend_multiplexEntryDescriptors
//

// from 0 size 1 type 0 simple 0
class MultiplexEntryDescriptor;

class MultiplexEntrySend_multiplexEntryDescriptors : public Asn :: Array {
	public:
	explicit MultiplexEntrySend_multiplexEntryDescriptors ( Asn :: istream & is );
	MultiplexEntrySend_multiplexEntryDescriptors ( );
	explicit MultiplexEntrySend_multiplexEntryDescriptors ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const MultiplexEntryDescriptor & o );
	const MultiplexEntryDescriptor & operator[] ( std :: size_t i ) const;
	MultiplexEntryDescriptor & operator[] ( std :: size_t i );
	MultiplexEntrySend_multiplexEntryDescriptors * clone ( ) const;
};

//
// MultiplexEntryDescriptor_elementList
//

// from 0 size 1 type 0 simple 0
class MultiplexElement;

class MultiplexEntryDescriptor_elementList : public Asn :: Array {
	public:
	explicit MultiplexEntryDescriptor_elementList ( Asn :: istream & is );
	MultiplexEntryDescriptor_elementList ( );
	explicit MultiplexEntryDescriptor_elementList ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const MultiplexElement & o );
	const MultiplexElement & operator[] ( std :: size_t i ) const;
	MultiplexElement & operator[] ( std :: size_t i );
	MultiplexEntryDescriptor_elementList * clone ( ) const;
};

//
// MultiplexEntrySendAck_multiplexTableEntryNumber
//

// from 0 size 1 type 0 simple 0
class MultiplexEntrySendAck_multiplexTableEntryNumber : public Asn :: Array {
	public:
	explicit MultiplexEntrySendAck_multiplexTableEntryNumber ( Asn :: istream & is );
	MultiplexEntrySendAck_multiplexTableEntryNumber ( );
	explicit MultiplexEntrySendAck_multiplexTableEntryNumber ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const MultiplexTableEntryNumber & o );
	const MultiplexTableEntryNumber & operator[] ( std :: size_t i ) const;
	MultiplexTableEntryNumber & operator[] ( std :: size_t i );
	MultiplexEntrySendAck_multiplexTableEntryNumber * clone ( ) const;
};

//
// MultiplexEntrySendReject_rejectionDescriptions
//

// from 0 size 1 type 0 simple 0
class MultiplexEntryRejectionDescriptions;

class MultiplexEntrySendReject_rejectionDescriptions : public Asn :: Array {
	public:
	explicit MultiplexEntrySendReject_rejectionDescriptions ( Asn :: istream & is );
	MultiplexEntrySendReject_rejectionDescriptions ( );
	explicit MultiplexEntrySendReject_rejectionDescriptions ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const MultiplexEntryRejectionDescriptions & o );
	const MultiplexEntryRejectionDescriptions & operator[] ( std :: size_t i ) const;
	MultiplexEntryRejectionDescriptions & operator[] ( std :: size_t i );
	MultiplexEntrySendReject_rejectionDescriptions * clone ( ) const;
};

//
// MultiplexEntryRejectionDescriptions_cause
//

// from 0 size 0 type 0 simple 0
class MultiplexEntryRejectionDescriptions_cause : public Asn :: Choice {
	public:
	explicit MultiplexEntryRejectionDescriptions_cause ( Asn :: istream & is );
	MultiplexEntryRejectionDescriptions_cause ( );
	enum Choices {
		e_unspecifiedCause,
		e_descriptorTooComplex
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	MultiplexEntryRejectionDescriptions_cause * clone ( ) const;
};

//
// MultiplexEntrySendRelease_multiplexTableEntryNumber
//

// from 0 size 1 type 0 simple 0
class MultiplexEntrySendRelease_multiplexTableEntryNumber : public Asn :: Array {
	public:
	explicit MultiplexEntrySendRelease_multiplexTableEntryNumber ( Asn :: istream & is );
	MultiplexEntrySendRelease_multiplexTableEntryNumber ( );
	explicit MultiplexEntrySendRelease_multiplexTableEntryNumber ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const MultiplexTableEntryNumber & o );
	const MultiplexTableEntryNumber & operator[] ( std :: size_t i ) const;
	MultiplexTableEntryNumber & operator[] ( std :: size_t i );
	MultiplexEntrySendRelease_multiplexTableEntryNumber * clone ( ) const;
};

//
// RequestMultiplexEntry_entryNumbers
//

// from 0 size 1 type 0 simple 0
class RequestMultiplexEntry_entryNumbers : public Asn :: Array {
	public:
	explicit RequestMultiplexEntry_entryNumbers ( Asn :: istream & is );
	RequestMultiplexEntry_entryNumbers ( );
	explicit RequestMultiplexEntry_entryNumbers ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const MultiplexTableEntryNumber & o );
	const MultiplexTableEntryNumber & operator[] ( std :: size_t i ) const;
	MultiplexTableEntryNumber & operator[] ( std :: size_t i );
	RequestMultiplexEntry_entryNumbers * clone ( ) const;
};

//
// RequestMultiplexEntryAck_entryNumbers
//

// from 0 size 1 type 0 simple 0
class RequestMultiplexEntryAck_entryNumbers : public Asn :: Array {
	public:
	explicit RequestMultiplexEntryAck_entryNumbers ( Asn :: istream & is );
	RequestMultiplexEntryAck_entryNumbers ( );
	explicit RequestMultiplexEntryAck_entryNumbers ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const MultiplexTableEntryNumber & o );
	const MultiplexTableEntryNumber & operator[] ( std :: size_t i ) const;
	MultiplexTableEntryNumber & operator[] ( std :: size_t i );
	RequestMultiplexEntryAck_entryNumbers * clone ( ) const;
};

//
// RequestMultiplexEntryReject_entryNumbers
//

// from 0 size 1 type 0 simple 0
class RequestMultiplexEntryReject_entryNumbers : public Asn :: Array {
	public:
	explicit RequestMultiplexEntryReject_entryNumbers ( Asn :: istream & is );
	RequestMultiplexEntryReject_entryNumbers ( );
	explicit RequestMultiplexEntryReject_entryNumbers ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const MultiplexTableEntryNumber & o );
	const MultiplexTableEntryNumber & operator[] ( std :: size_t i ) const;
	MultiplexTableEntryNumber & operator[] ( std :: size_t i );
	RequestMultiplexEntryReject_entryNumbers * clone ( ) const;
};

//
// RequestMultiplexEntryReject_rejectionDescriptions
//

// from 0 size 1 type 0 simple 0
class RequestMultiplexEntryRejectionDescriptions;

class RequestMultiplexEntryReject_rejectionDescriptions : public Asn :: Array {
	public:
	explicit RequestMultiplexEntryReject_rejectionDescriptions ( Asn :: istream & is );
	RequestMultiplexEntryReject_rejectionDescriptions ( );
	explicit RequestMultiplexEntryReject_rejectionDescriptions ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const RequestMultiplexEntryRejectionDescriptions & o );
	const RequestMultiplexEntryRejectionDescriptions & operator[] ( std :: size_t i ) const;
	RequestMultiplexEntryRejectionDescriptions & operator[] ( std :: size_t i );
	RequestMultiplexEntryReject_rejectionDescriptions * clone ( ) const;
};

//
// RequestMultiplexEntryRejectionDescriptions_cause
//

// from 0 size 0 type 0 simple 0
class RequestMultiplexEntryRejectionDescriptions_cause : public Asn :: Choice {
	public:
	explicit RequestMultiplexEntryRejectionDescriptions_cause ( Asn :: istream & is );
	RequestMultiplexEntryRejectionDescriptions_cause ( );
	enum Choices {
		e_unspecifiedCause
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	RequestMultiplexEntryRejectionDescriptions_cause * clone ( ) const;
};

//
// RequestMultiplexEntryRelease_entryNumbers
//

// from 0 size 1 type 0 simple 0
class RequestMultiplexEntryRelease_entryNumbers : public Asn :: Array {
	public:
	explicit RequestMultiplexEntryRelease_entryNumbers ( Asn :: istream & is );
	RequestMultiplexEntryRelease_entryNumbers ( );
	explicit RequestMultiplexEntryRelease_entryNumbers ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const MultiplexTableEntryNumber & o );
	const MultiplexTableEntryNumber & operator[] ( std :: size_t i ) const;
	MultiplexTableEntryNumber & operator[] ( std :: size_t i );
	RequestMultiplexEntryRelease_entryNumbers * clone ( ) const;
};

//
// RequestMode_requestedModes
//

// from 0 size 1 type 0 simple 0
class RequestMode_requestedModes : public Asn :: Array {
	public:
	explicit RequestMode_requestedModes ( Asn :: istream & is );
	RequestMode_requestedModes ( );
	explicit RequestMode_requestedModes ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const ModeDescription & o );
	const ModeDescription & operator[] ( std :: size_t i ) const;
	ModeDescription & operator[] ( std :: size_t i );
	RequestMode_requestedModes * clone ( ) const;
};

//
// RequestModeAck_response
//

// from 0 size 0 type 0 simple 0
class RequestModeAck_response : public Asn :: Choice {
	public:
	explicit RequestModeAck_response ( Asn :: istream & is );
	RequestModeAck_response ( );
	enum Choices {
		e_willTransmitMostPreferredMode,
		e_willTransmitLessPreferredMode
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	RequestModeAck_response * clone ( ) const;
};

//
// RequestModeReject_cause
//

// from 0 size 0 type 0 simple 0
class RequestModeReject_cause : public Asn :: Choice {
	public:
	explicit RequestModeReject_cause ( Asn :: istream & is );
	RequestModeReject_cause ( );
	enum Choices {
		e_modeUnavailable,
		e_multipointConstraint,
		e_requestDenied
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	RequestModeReject_cause * clone ( ) const;
};

//
// ArrayOf_RedundancyEncodingDTModeElement
//

// from 0 size 0 type 0 simple 0
class RedundancyEncodingDTModeElement;

class ArrayOf_RedundancyEncodingDTModeElement : public Asn :: Array {
	public:
	explicit ArrayOf_RedundancyEncodingDTModeElement ( Asn :: istream & is );
	ArrayOf_RedundancyEncodingDTModeElement ( );
	explicit ArrayOf_RedundancyEncodingDTModeElement ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const RedundancyEncodingDTModeElement & o );
	const RedundancyEncodingDTModeElement & operator[] ( std :: size_t i ) const;
	RedundancyEncodingDTModeElement & operator[] ( std :: size_t i );
	ArrayOf_RedundancyEncodingDTModeElement * clone ( ) const;
};

//
// ArrayOf_MultiplePayloadStreamElementMode
//

// from 0 size 0 type 0 simple 0
class MultiplePayloadStreamElementMode;

class ArrayOf_MultiplePayloadStreamElementMode : public Asn :: Array {
	public:
	explicit ArrayOf_MultiplePayloadStreamElementMode ( Asn :: istream & is );
	ArrayOf_MultiplePayloadStreamElementMode ( );
	explicit ArrayOf_MultiplePayloadStreamElementMode ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const MultiplePayloadStreamElementMode & o );
	const MultiplePayloadStreamElementMode & operator[] ( std :: size_t i ) const;
	MultiplePayloadStreamElementMode & operator[] ( std :: size_t i );
	ArrayOf_MultiplePayloadStreamElementMode * clone ( ) const;
};

//
// FECMode_rfc2733Format
//

// from 0 size 0 type 0 simple 0
class FECMode_rfc2733Format : public Asn :: Choice {
	public:
	explicit FECMode_rfc2733Format ( Asn :: istream & is );
	FECMode_rfc2733Format ( );
	enum Choices {
		e_rfc2733rfc2198,
		e_rfc2733sameport,
		e_rfc2733diffport
	};

	operator MaxRedundancy & ( ) { return dynamic_cast < MaxRedundancy & > ( * choice ); }
	operator const MaxRedundancy & ( ) const { return dynamic_cast < const MaxRedundancy & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	FECMode_rfc2733Format * clone ( ) const;
};

//
// H261VideoMode_resolution
//

// from 0 size 0 type 0 simple 0
class H261VideoMode_resolution : public Asn :: Choice {
	public:
	explicit H261VideoMode_resolution ( Asn :: istream & is );
	H261VideoMode_resolution ( );
	enum Choices {
		e_qcif,
		e_cif
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	H261VideoMode_resolution * clone ( ) const;
};

//
// H261VideoMode_bitRate
//

// from 0 size 0 type 0 simple 1
class H261VideoMode_bitRate : public Asn :: Integer {
	public:
	explicit H261VideoMode_bitRate ( Asn :: istream & is );
	H261VideoMode_bitRate ( unsigned v = 0 );
	H261VideoMode_bitRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H261VideoMode_bitRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H261VideoMode_bitRate * clone ( ) const;
};

//
// H262VideoMode_profileAndLevel
//

// from 0 size 0 type 0 simple 0
class H262VideoMode_profileAndLevel : public Asn :: Choice {
	public:
	explicit H262VideoMode_profileAndLevel ( Asn :: istream & is );
	H262VideoMode_profileAndLevel ( );
	enum Choices {
		e_profileAndLevel_SPatML,
		e_profileAndLevel_MPatLL,
		e_profileAndLevel_MPatML,
		e_profileAndLevel_MPatH_14,
		e_profileAndLevel_MPatHL,
		e_profileAndLevel_SNRatLL,
		e_profileAndLevel_SNRatML,
		e_profileAndLevel_SpatialatH_14,
		e_profileAndLevel_HPatML,
		e_profileAndLevel_HPatH_14,
		e_profileAndLevel_HPatHL
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	H262VideoMode_profileAndLevel * clone ( ) const;
};

//
// H262VideoMode_videoBitRate
//

// from 0 size 0 type 0 simple 1
class H262VideoMode_videoBitRate : public Asn :: Integer {
	public:
	explicit H262VideoMode_videoBitRate ( Asn :: istream & is );
	H262VideoMode_videoBitRate ( unsigned v = 0 );
	H262VideoMode_videoBitRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H262VideoMode_videoBitRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H262VideoMode_videoBitRate * clone ( ) const;
};

//
// H262VideoMode_vbvBufferSize
//

// from 0 size 0 type 0 simple 1
class H262VideoMode_vbvBufferSize : public Asn :: Integer {
	public:
	explicit H262VideoMode_vbvBufferSize ( Asn :: istream & is );
	H262VideoMode_vbvBufferSize ( unsigned v = 0 );
	H262VideoMode_vbvBufferSize & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H262VideoMode_vbvBufferSize & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H262VideoMode_vbvBufferSize * clone ( ) const;
};

//
// H262VideoMode_samplesPerLine
//

// from 0 size 0 type 0 simple 1
class H262VideoMode_samplesPerLine : public Asn :: Integer {
	public:
	explicit H262VideoMode_samplesPerLine ( Asn :: istream & is );
	H262VideoMode_samplesPerLine ( unsigned v = 0 );
	H262VideoMode_samplesPerLine & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H262VideoMode_samplesPerLine & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H262VideoMode_samplesPerLine * clone ( ) const;
};

//
// H262VideoMode_linesPerFrame
//

// from 0 size 0 type 0 simple 1
class H262VideoMode_linesPerFrame : public Asn :: Integer {
	public:
	explicit H262VideoMode_linesPerFrame ( Asn :: istream & is );
	H262VideoMode_linesPerFrame ( unsigned v = 0 );
	H262VideoMode_linesPerFrame & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H262VideoMode_linesPerFrame & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H262VideoMode_linesPerFrame * clone ( ) const;
};

//
// H262VideoMode_framesPerSecond
//

// from 0 size 0 type 0 simple 1
class H262VideoMode_framesPerSecond : public Asn :: Integer {
	public:
	explicit H262VideoMode_framesPerSecond ( Asn :: istream & is );
	H262VideoMode_framesPerSecond ( unsigned v = 0 );
	H262VideoMode_framesPerSecond & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H262VideoMode_framesPerSecond & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H262VideoMode_framesPerSecond * clone ( ) const;
};

//
// H262VideoMode_luminanceSampleRate
//

// from 0 size 0 type 0 simple 1
class H262VideoMode_luminanceSampleRate : public Asn :: Integer {
	public:
	explicit H262VideoMode_luminanceSampleRate ( Asn :: istream & is );
	H262VideoMode_luminanceSampleRate ( unsigned v = 0 );
	H262VideoMode_luminanceSampleRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H262VideoMode_luminanceSampleRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H262VideoMode_luminanceSampleRate * clone ( ) const;
};

//
// H263VideoMode_resolution
//

// from 0 size 0 type 0 simple 0
class H263VideoMode_resolution : public Asn :: Choice {
	public:
	explicit H263VideoMode_resolution ( Asn :: istream & is );
	H263VideoMode_resolution ( );
	enum Choices {
		e_sqcif,
		e_qcif,
		e_cif,
		e_cif4,
		e_cif16,
		e_custom
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	H263VideoMode_resolution * clone ( ) const;
};

//
// H263VideoMode_bitRate
//

// from 0 size 0 type 0 simple 1
class H263VideoMode_bitRate : public Asn :: Integer {
	public:
	explicit H263VideoMode_bitRate ( Asn :: istream & is );
	H263VideoMode_bitRate ( unsigned v = 0 );
	H263VideoMode_bitRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H263VideoMode_bitRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H263VideoMode_bitRate * clone ( ) const;
};

//
// IS11172VideoMode_videoBitRate
//

// from 0 size 0 type 0 simple 1
class IS11172VideoMode_videoBitRate : public Asn :: Integer {
	public:
	explicit IS11172VideoMode_videoBitRate ( Asn :: istream & is );
	IS11172VideoMode_videoBitRate ( unsigned v = 0 );
	IS11172VideoMode_videoBitRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	IS11172VideoMode_videoBitRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	IS11172VideoMode_videoBitRate * clone ( ) const;
};

//
// IS11172VideoMode_vbvBufferSize
//

// from 0 size 0 type 0 simple 1
class IS11172VideoMode_vbvBufferSize : public Asn :: Integer {
	public:
	explicit IS11172VideoMode_vbvBufferSize ( Asn :: istream & is );
	IS11172VideoMode_vbvBufferSize ( unsigned v = 0 );
	IS11172VideoMode_vbvBufferSize & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	IS11172VideoMode_vbvBufferSize & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	IS11172VideoMode_vbvBufferSize * clone ( ) const;
};

//
// IS11172VideoMode_samplesPerLine
//

// from 0 size 0 type 0 simple 1
class IS11172VideoMode_samplesPerLine : public Asn :: Integer {
	public:
	explicit IS11172VideoMode_samplesPerLine ( Asn :: istream & is );
	IS11172VideoMode_samplesPerLine ( unsigned v = 0 );
	IS11172VideoMode_samplesPerLine & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	IS11172VideoMode_samplesPerLine & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	IS11172VideoMode_samplesPerLine * clone ( ) const;
};

//
// IS11172VideoMode_linesPerFrame
//

// from 0 size 0 type 0 simple 1
class IS11172VideoMode_linesPerFrame : public Asn :: Integer {
	public:
	explicit IS11172VideoMode_linesPerFrame ( Asn :: istream & is );
	IS11172VideoMode_linesPerFrame ( unsigned v = 0 );
	IS11172VideoMode_linesPerFrame & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	IS11172VideoMode_linesPerFrame & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	IS11172VideoMode_linesPerFrame * clone ( ) const;
};

//
// IS11172VideoMode_pictureRate
//

// from 0 size 0 type 0 simple 1
class IS11172VideoMode_pictureRate : public Asn :: Integer {
	public:
	explicit IS11172VideoMode_pictureRate ( Asn :: istream & is );
	IS11172VideoMode_pictureRate ( unsigned v = 0 );
	IS11172VideoMode_pictureRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	IS11172VideoMode_pictureRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	IS11172VideoMode_pictureRate * clone ( ) const;
};

//
// IS11172VideoMode_luminanceSampleRate
//

// from 0 size 0 type 0 simple 1
class IS11172VideoMode_luminanceSampleRate : public Asn :: Integer {
	public:
	explicit IS11172VideoMode_luminanceSampleRate ( Asn :: istream & is );
	IS11172VideoMode_luminanceSampleRate ( unsigned v = 0 );
	IS11172VideoMode_luminanceSampleRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	IS11172VideoMode_luminanceSampleRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	IS11172VideoMode_luminanceSampleRate * clone ( ) const;
};

//
// AudioMode_g7231
//

// from 0 size 0 type 0 simple 0
class AudioMode_g7231 : public Asn :: Choice {
	public:
	explicit AudioMode_g7231 ( Asn :: istream & is );
	AudioMode_g7231 ( );
	enum Choices {
		e_noSilenceSuppressionLowRate,
		e_noSilenceSuppressionHighRate,
		e_silenceSuppressionLowRate,
		e_silenceSuppressionHighRate
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	AudioMode_g7231 * clone ( ) const;
};

//
// AudioMode_g729wAnnexB
//

// from 0 size 0 type 0 simple 1
class AudioMode_g729wAnnexB : public Asn :: Integer {
	public:
	explicit AudioMode_g729wAnnexB ( Asn :: istream & is );
	AudioMode_g729wAnnexB ( unsigned v = 0 );
	AudioMode_g729wAnnexB & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	AudioMode_g729wAnnexB & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	AudioMode_g729wAnnexB * clone ( ) const;
};

//
// AudioMode_g729AnnexAwAnnexB
//

// from 0 size 0 type 0 simple 1
class AudioMode_g729AnnexAwAnnexB : public Asn :: Integer {
	public:
	explicit AudioMode_g729AnnexAwAnnexB ( Asn :: istream & is );
	AudioMode_g729AnnexAwAnnexB ( unsigned v = 0 );
	AudioMode_g729AnnexAwAnnexB & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	AudioMode_g729AnnexAwAnnexB & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	AudioMode_g729AnnexAwAnnexB * clone ( ) const;
};

//
// IS11172AudioMode_audioLayer
//

// from 0 size 0 type 0 simple 0
class IS11172AudioMode_audioLayer : public Asn :: Choice {
	public:
	explicit IS11172AudioMode_audioLayer ( Asn :: istream & is );
	IS11172AudioMode_audioLayer ( );
	enum Choices {
		e_audioLayer1,
		e_audioLayer2,
		e_audioLayer3
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	IS11172AudioMode_audioLayer * clone ( ) const;
};

//
// IS11172AudioMode_audioSampling
//

// from 0 size 0 type 0 simple 0
class IS11172AudioMode_audioSampling : public Asn :: Choice {
	public:
	explicit IS11172AudioMode_audioSampling ( Asn :: istream & is );
	IS11172AudioMode_audioSampling ( );
	enum Choices {
		e_audioSampling32k,
		e_audioSampling44k1,
		e_audioSampling48k
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	IS11172AudioMode_audioSampling * clone ( ) const;
};

//
// IS11172AudioMode_multichannelType
//

// from 0 size 0 type 0 simple 0
class IS11172AudioMode_multichannelType : public Asn :: Choice {
	public:
	explicit IS11172AudioMode_multichannelType ( Asn :: istream & is );
	IS11172AudioMode_multichannelType ( );
	enum Choices {
		e_singleChannel,
		e_twoChannelStereo,
		e_twoChannelDual
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	IS11172AudioMode_multichannelType * clone ( ) const;
};

//
// IS11172AudioMode_bitRate
//

// from 0 size 0 type 0 simple 1
class IS11172AudioMode_bitRate : public Asn :: Integer {
	public:
	explicit IS11172AudioMode_bitRate ( Asn :: istream & is );
	IS11172AudioMode_bitRate ( unsigned v = 0 );
	IS11172AudioMode_bitRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	IS11172AudioMode_bitRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	IS11172AudioMode_bitRate * clone ( ) const;
};

//
// IS13818AudioMode_audioLayer
//

// from 0 size 0 type 0 simple 0
class IS13818AudioMode_audioLayer : public Asn :: Choice {
	public:
	explicit IS13818AudioMode_audioLayer ( Asn :: istream & is );
	IS13818AudioMode_audioLayer ( );
	enum Choices {
		e_audioLayer1,
		e_audioLayer2,
		e_audioLayer3
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	IS13818AudioMode_audioLayer * clone ( ) const;
};

//
// IS13818AudioMode_audioSampling
//

// from 0 size 0 type 0 simple 0
class IS13818AudioMode_audioSampling : public Asn :: Choice {
	public:
	explicit IS13818AudioMode_audioSampling ( Asn :: istream & is );
	IS13818AudioMode_audioSampling ( );
	enum Choices {
		e_audioSampling16k,
		e_audioSampling22k05,
		e_audioSampling24k,
		e_audioSampling32k,
		e_audioSampling44k1,
		e_audioSampling48k
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	IS13818AudioMode_audioSampling * clone ( ) const;
};

//
// IS13818AudioMode_multichannelType
//

// from 0 size 0 type 0 simple 0
class IS13818AudioMode_multichannelType : public Asn :: Choice {
	public:
	explicit IS13818AudioMode_multichannelType ( Asn :: istream & is );
	IS13818AudioMode_multichannelType ( );
	enum Choices {
		e_singleChannel,
		e_twoChannelStereo,
		e_twoChannelDual,
		e_threeChannels2_1,
		e_threeChannels3_0,
		e_fourChannels2_0_2_0,
		e_fourChannels2_2,
		e_fourChannels3_1,
		e_fiveChannels3_0_2_0,
		e_fiveChannels3_2
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	IS13818AudioMode_multichannelType * clone ( ) const;
};

//
// IS13818AudioMode_bitRate
//

// from 0 size 0 type 0 simple 1
class IS13818AudioMode_bitRate : public Asn :: Integer {
	public:
	explicit IS13818AudioMode_bitRate ( Asn :: istream & is );
	IS13818AudioMode_bitRate ( unsigned v = 0 );
	IS13818AudioMode_bitRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	IS13818AudioMode_bitRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	IS13818AudioMode_bitRate * clone ( ) const;
};

//
// G7231AnnexCMode_maxAl-sduAudioFrames
//

// from 0 size 0 type 0 simple 1
class G7231AnnexCMode_maxAl_sduAudioFrames : public Asn :: Integer {
	public:
	explicit G7231AnnexCMode_maxAl_sduAudioFrames ( Asn :: istream & is );
	G7231AnnexCMode_maxAl_sduAudioFrames ( unsigned v = 0 );
	G7231AnnexCMode_maxAl_sduAudioFrames & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	G7231AnnexCMode_maxAl_sduAudioFrames & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	G7231AnnexCMode_maxAl_sduAudioFrames * clone ( ) const;
};

//
// DataMode_bitRate
//

// from 0 size 0 type 0 simple 1
class DataMode_bitRate : public Asn :: Integer {
	public:
	explicit DataMode_bitRate ( Asn :: istream & is );
	DataMode_bitRate ( unsigned v = 0 );
	DataMode_bitRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	DataMode_bitRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	DataMode_bitRate * clone ( ) const;
};

//
// MaintenanceLoopRequest_type
//

// from 0 size 0 type 0 simple 0
class MaintenanceLoopRequest_type : public Asn :: Choice {
	public:
	explicit MaintenanceLoopRequest_type ( Asn :: istream & is );
	MaintenanceLoopRequest_type ( );
	enum Choices {
		e_systemLoop,
		e_mediaLoop,
		e_logicalChannelLoop
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator LogicalChannelNumber & ( ) { return dynamic_cast < LogicalChannelNumber & > ( * choice ); }
	operator const LogicalChannelNumber & ( ) const { return dynamic_cast < const LogicalChannelNumber & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	MaintenanceLoopRequest_type * clone ( ) const;
};

//
// MaintenanceLoopAck_type
//

// from 0 size 0 type 0 simple 0
class MaintenanceLoopAck_type : public Asn :: Choice {
	public:
	explicit MaintenanceLoopAck_type ( Asn :: istream & is );
	MaintenanceLoopAck_type ( );
	enum Choices {
		e_systemLoop,
		e_mediaLoop,
		e_logicalChannelLoop
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator LogicalChannelNumber & ( ) { return dynamic_cast < LogicalChannelNumber & > ( * choice ); }
	operator const LogicalChannelNumber & ( ) const { return dynamic_cast < const LogicalChannelNumber & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	MaintenanceLoopAck_type * clone ( ) const;
};

//
// MaintenanceLoopReject_type
//

// from 0 size 0 type 0 simple 0
class MaintenanceLoopReject_type : public Asn :: Choice {
	public:
	explicit MaintenanceLoopReject_type ( Asn :: istream & is );
	MaintenanceLoopReject_type ( );
	enum Choices {
		e_systemLoop,
		e_mediaLoop,
		e_logicalChannelLoop
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator LogicalChannelNumber & ( ) { return dynamic_cast < LogicalChannelNumber & > ( * choice ); }
	operator const LogicalChannelNumber & ( ) const { return dynamic_cast < const LogicalChannelNumber & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	MaintenanceLoopReject_type * clone ( ) const;
};

//
// MaintenanceLoopReject_cause
//

// from 0 size 0 type 0 simple 0
class MaintenanceLoopReject_cause : public Asn :: Choice {
	public:
	explicit MaintenanceLoopReject_cause ( Asn :: istream & is );
	MaintenanceLoopReject_cause ( );
	enum Choices {
		e_canNotPerformLoop
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	MaintenanceLoopReject_cause * clone ( ) const;
};

//
// CommunicationModeCommand_communicationModeTable
//

// from 0 size 1 type 0 simple 0
class CommunicationModeTableEntry;

class CommunicationModeCommand_communicationModeTable : public Asn :: Array {
	public:
	explicit CommunicationModeCommand_communicationModeTable ( Asn :: istream & is );
	CommunicationModeCommand_communicationModeTable ( );
	explicit CommunicationModeCommand_communicationModeTable ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const CommunicationModeTableEntry & o );
	const CommunicationModeTableEntry & operator[] ( std :: size_t i ) const;
	CommunicationModeTableEntry & operator[] ( std :: size_t i );
	CommunicationModeCommand_communicationModeTable * clone ( ) const;
};

//
// CommunicationModeResponse_communicationModeTable
//

// from 0 size 1 type 0 simple 0
class CommunicationModeResponse_communicationModeTable : public Asn :: Array {
	public:
	explicit CommunicationModeResponse_communicationModeTable ( Asn :: istream & is );
	CommunicationModeResponse_communicationModeTable ( );
	explicit CommunicationModeResponse_communicationModeTable ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const CommunicationModeTableEntry & o );
	const CommunicationModeTableEntry & operator[] ( std :: size_t i ) const;
	CommunicationModeTableEntry & operator[] ( std :: size_t i );
	CommunicationModeResponse_communicationModeTable * clone ( ) const;
};

//
// CommunicationModeTableEntry_sessionID
//

// from 0 size 0 type 0 simple 1
class CommunicationModeTableEntry_sessionID : public Asn :: Integer {
	public:
	explicit CommunicationModeTableEntry_sessionID ( Asn :: istream & is );
	CommunicationModeTableEntry_sessionID ( unsigned v = 0 );
	CommunicationModeTableEntry_sessionID & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CommunicationModeTableEntry_sessionID & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CommunicationModeTableEntry_sessionID * clone ( ) const;
};

//
// CommunicationModeTableEntry_associatedSessionID
//

// from 0 size 0 type 0 simple 1
class CommunicationModeTableEntry_associatedSessionID : public Asn :: Integer {
	public:
	explicit CommunicationModeTableEntry_associatedSessionID ( Asn :: istream & is );
	CommunicationModeTableEntry_associatedSessionID ( unsigned v = 0 );
	CommunicationModeTableEntry_associatedSessionID & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CommunicationModeTableEntry_associatedSessionID & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CommunicationModeTableEntry_associatedSessionID * clone ( ) const;
};

//
// CommunicationModeTableEntry_sessionDescription
//

// from 0 size 1 type 0 simple 0
class CommunicationModeTableEntry_sessionDescription : public Asn :: BMPString {
	public:
	explicit CommunicationModeTableEntry_sessionDescription ( Asn :: istream & is );
	CommunicationModeTableEntry_sessionDescription ( const Asn :: string & v = Asn :: string ( ) );
	CommunicationModeTableEntry_sessionDescription & operator= ( const Asn :: string & v ) {
		Asn :: BMPString :: operator= ( v );
		return * this;
	}
	CommunicationModeTableEntry_sessionDescription * clone ( ) const;
};

//
// CommunicationModeTableEntry_sessionDependency
//

// from 0 size 0 type 0 simple 1
class CommunicationModeTableEntry_sessionDependency : public Asn :: Integer {
	public:
	explicit CommunicationModeTableEntry_sessionDependency ( Asn :: istream & is );
	CommunicationModeTableEntry_sessionDependency ( unsigned v = 0 );
	CommunicationModeTableEntry_sessionDependency & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CommunicationModeTableEntry_sessionDependency & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CommunicationModeTableEntry_sessionDependency * clone ( ) const;
};

//
// ConferenceRequest_requestTerminalCertificate
//

// from 0 size 0 type 0 simple 0
class TerminalLabel;
class ConferenceRequest_requestTerminalCertificate_sRandom;

class ConferenceRequest_requestTerminalCertificate : public Asn :: Sequence {
	public:
	explicit ConferenceRequest_requestTerminalCertificate ( Asn :: istream & is );
	ConferenceRequest_requestTerminalCertificate ( );
	enum OptionalFields {
		e_terminalLabel,
		e_certSelectionCriteria,
		e_sRandom
	};

	ConferenceRequest_requestTerminalCertificate ( const ConferenceRequest_requestTerminalCertificate & s );
	ConferenceRequest_requestTerminalCertificate & operator= ( const ConferenceRequest_requestTerminalCertificate & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	TerminalLabel * m_terminalLabel;
	CertSelectionCriteria * m_certSelectionCriteria;
	ConferenceRequest_requestTerminalCertificate_sRandom * m_sRandom;
	public:
	void encode ( Asn :: ostream & os ) const;
	~ConferenceRequest_requestTerminalCertificate ( );
	void printOn ( std :: ostream & os ) const;
	const TerminalLabel & get_terminalLabel ( ) const {
		return * m_terminalLabel;
	}
	TerminalLabel & get_terminalLabel ( ) {
		return * m_terminalLabel;
	}
	const CertSelectionCriteria & get_certSelectionCriteria ( ) const {
		return * m_certSelectionCriteria;
	}
	CertSelectionCriteria & get_certSelectionCriteria ( ) {
		return * m_certSelectionCriteria;
	}
	const ConferenceRequest_requestTerminalCertificate_sRandom & get_sRandom ( ) const {
		return * m_sRandom;
	}
	ConferenceRequest_requestTerminalCertificate_sRandom & get_sRandom ( ) {
		return * m_sRandom;
	}
	ConferenceRequest_requestTerminalCertificate * clone ( ) const;
};

//
// Criteria_value
//

// from 0 size 1 type 0 simple 0
class Criteria_value : public Asn :: OctetString {
	public:
	explicit Criteria_value ( Asn :: istream & is );
	Criteria_value ( const Asn :: string & v = Asn :: string ( ) );
	Criteria_value & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	Criteria_value * clone ( ) const;
};

//
// ConferenceResponse_terminalListResponse
//

// from 0 size 1 type 0 simple 0
class ConferenceResponse_terminalListResponse : public Asn :: Array {
	public:
	explicit ConferenceResponse_terminalListResponse ( Asn :: istream & is );
	ConferenceResponse_terminalListResponse ( );
	explicit ConferenceResponse_terminalListResponse ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const TerminalLabel & o );
	const TerminalLabel & operator[] ( std :: size_t i ) const;
	TerminalLabel & operator[] ( std :: size_t i );
	ConferenceResponse_terminalListResponse * clone ( ) const;
};

//
// ConferenceResponse_makeMeChairResponse
//

// from 0 size 0 type 0 simple 0
class ConferenceResponse_makeMeChairResponse : public Asn :: Choice {
	public:
	explicit ConferenceResponse_makeMeChairResponse ( Asn :: istream & is );
	ConferenceResponse_makeMeChairResponse ( );
	enum Choices {
		e_grantedChairToken,
		e_deniedChairToken
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	ConferenceResponse_makeMeChairResponse * clone ( ) const;
};

//
// ConferenceResponse_extensionAddressResponse
//

// from 0 size 0 type 0 simple 0
class ConferenceResponse_extensionAddressResponse : public Asn :: Sequence {
	public:
	explicit ConferenceResponse_extensionAddressResponse ( Asn :: istream & is );
	ConferenceResponse_extensionAddressResponse ( );
	TerminalID m_extensionAddress;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	ConferenceResponse_extensionAddressResponse * clone ( ) const;
};

//
// ConferenceResponse_terminalCertificateResponse
//

// from 0 size 0 type 0 simple 0
class ConferenceResponse_terminalCertificateResponse_certificateResponse;

class ConferenceResponse_terminalCertificateResponse : public Asn :: Sequence {
	public:
	explicit ConferenceResponse_terminalCertificateResponse ( Asn :: istream & is );
	ConferenceResponse_terminalCertificateResponse ( );
	enum OptionalFields {
		e_terminalLabel,
		e_certificateResponse
	};

	ConferenceResponse_terminalCertificateResponse ( const ConferenceResponse_terminalCertificateResponse & s );
	ConferenceResponse_terminalCertificateResponse & operator= ( const ConferenceResponse_terminalCertificateResponse & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	TerminalLabel * m_terminalLabel;
	ConferenceResponse_terminalCertificateResponse_certificateResponse * m_certificateResponse;
	public:
	void encode ( Asn :: ostream & os ) const;
	~ConferenceResponse_terminalCertificateResponse ( );
	void printOn ( std :: ostream & os ) const;
	const TerminalLabel & get_terminalLabel ( ) const {
		return * m_terminalLabel;
	}
	TerminalLabel & get_terminalLabel ( ) {
		return * m_terminalLabel;
	}
	const ConferenceResponse_terminalCertificateResponse_certificateResponse & get_certificateResponse ( ) const {
		return * m_certificateResponse;
	}
	ConferenceResponse_terminalCertificateResponse_certificateResponse & get_certificateResponse ( ) {
		return * m_certificateResponse;
	}
	ConferenceResponse_terminalCertificateResponse * clone ( ) const;
};

//
// ConferenceResponse_broadcastMyLogicalChannelResponse
//

// from 0 size 0 type 0 simple 0
class ConferenceResponse_broadcastMyLogicalChannelResponse : public Asn :: Choice {
	public:
	explicit ConferenceResponse_broadcastMyLogicalChannelResponse ( Asn :: istream & is );
	ConferenceResponse_broadcastMyLogicalChannelResponse ( );
	enum Choices {
		e_grantedBroadcastMyLogicalChannel,
		e_deniedBroadcastMyLogicalChannel
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	ConferenceResponse_broadcastMyLogicalChannelResponse * clone ( ) const;
};

//
// ConferenceResponse_makeTerminalBroadcasterResponse
//

// from 0 size 0 type 0 simple 0
class ConferenceResponse_makeTerminalBroadcasterResponse : public Asn :: Choice {
	public:
	explicit ConferenceResponse_makeTerminalBroadcasterResponse ( Asn :: istream & is );
	ConferenceResponse_makeTerminalBroadcasterResponse ( );
	enum Choices {
		e_grantedMakeTerminalBroadcaster,
		e_deniedMakeTerminalBroadcaster
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	ConferenceResponse_makeTerminalBroadcasterResponse * clone ( ) const;
};

//
// ConferenceResponse_sendThisSourceResponse
//

// from 0 size 0 type 0 simple 0
class ConferenceResponse_sendThisSourceResponse : public Asn :: Choice {
	public:
	explicit ConferenceResponse_sendThisSourceResponse ( Asn :: istream & is );
	ConferenceResponse_sendThisSourceResponse ( );
	enum Choices {
		e_grantedSendThisSource,
		e_deniedSendThisSource
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	ConferenceResponse_sendThisSourceResponse * clone ( ) const;
};

//
// ArrayOf_TerminalInformation
//

// from 0 size 0 type 0 simple 0
class TerminalInformation;

class ArrayOf_TerminalInformation : public Asn :: Array {
	public:
	explicit ArrayOf_TerminalInformation ( Asn :: istream & is );
	ArrayOf_TerminalInformation ( );
	explicit ArrayOf_TerminalInformation ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const TerminalInformation & o );
	const TerminalInformation & operator[] ( std :: size_t i ) const;
	TerminalInformation & operator[] ( std :: size_t i );
	ArrayOf_TerminalInformation * clone ( ) const;
};

//
// RemoteMCResponse_reject
//

// from 0 size 0 type 0 simple 0
class RemoteMCResponse_reject : public Asn :: Choice {
	public:
	explicit RemoteMCResponse_reject ( Asn :: istream & is );
	RemoteMCResponse_reject ( );
	enum Choices {
		e_unspecified,
		e_functionNotSupported
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	RemoteMCResponse_reject * clone ( ) const;
};

//
// MultilinkIndication_crcDesired
//

// from 0 size 0 type 0 simple 0
class MultilinkIndication_crcDesired : public Asn :: Sequence {
	public:
	explicit MultilinkIndication_crcDesired ( Asn :: istream & is );
	MultilinkIndication_crcDesired ( );
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MultilinkIndication_crcDesired * clone ( ) const;
};

//
// DialingInformation_differential
//

// from 0 size 1 type 0 simple 0
class DialingInformationNumber;

class DialingInformation_differential : public Asn :: Array {
	public:
	explicit DialingInformation_differential ( Asn :: istream & is );
	DialingInformation_differential ( );
	explicit DialingInformation_differential ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const DialingInformationNumber & o );
	const DialingInformationNumber & operator[] ( std :: size_t i ) const;
	DialingInformationNumber & operator[] ( std :: size_t i );
	DialingInformation_differential * clone ( ) const;
};

//
// DialingInformation_infoNotAvailable
//

// from 0 size 0 type 0 simple 1
class DialingInformation_infoNotAvailable : public Asn :: Integer {
	public:
	explicit DialingInformation_infoNotAvailable ( Asn :: istream & is );
	DialingInformation_infoNotAvailable ( unsigned v = 0 );
	DialingInformation_infoNotAvailable & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	DialingInformation_infoNotAvailable & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	DialingInformation_infoNotAvailable * clone ( ) const;
};

//
// DialingInformationNumber_networkAddress
//

// from 0 size 1 type 0 simple 0
class DialingInformationNumber_networkAddress : public Asn :: NumericString {
	public:
	explicit DialingInformationNumber_networkAddress ( Asn :: istream & is );
	DialingInformationNumber_networkAddress ( const Asn :: string & v = Asn :: string ( ) );
	DialingInformationNumber_networkAddress & operator= ( const Asn :: string & v ) {
		Asn :: NumericString :: operator= ( v );
		return * this;
	}
	DialingInformationNumber_networkAddress * clone ( ) const;
};

//
// DialingInformationNumber_subAddress
//

// from 0 size 1 type 0 simple 0
class DialingInformationNumber_subAddress : public Asn :: IA5String {
	public:
	explicit DialingInformationNumber_subAddress ( Asn :: istream & is );
	DialingInformationNumber_subAddress ( const Asn :: string & v = Asn :: string ( ) );
	DialingInformationNumber_subAddress & operator= ( const Asn :: string & v ) {
		Asn :: IA5String :: operator= ( v );
		return * this;
	}
	DialingInformationNumber_subAddress * clone ( ) const;
};

//
// DialingInformationNumber_networkType
//

// from 0 size 1 type 0 simple 0
class DialingInformationNetworkType;

class DialingInformationNumber_networkType : public Asn :: Array {
	public:
	explicit DialingInformationNumber_networkType ( Asn :: istream & is );
	DialingInformationNumber_networkType ( );
	explicit DialingInformationNumber_networkType ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const DialingInformationNetworkType & o );
	const DialingInformationNetworkType & operator[] ( std :: size_t i ) const;
	DialingInformationNetworkType & operator[] ( std :: size_t i );
	DialingInformationNumber_networkType * clone ( ) const;
};

//
// ConnectionIdentifier_channelTag
//

// from 0 size 0 type 0 simple 1
class ConnectionIdentifier_channelTag : public Asn :: Integer {
	public:
	explicit ConnectionIdentifier_channelTag ( Asn :: istream & is );
	ConnectionIdentifier_channelTag ( unsigned v = 0 );
	ConnectionIdentifier_channelTag & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	ConnectionIdentifier_channelTag & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	ConnectionIdentifier_channelTag * clone ( ) const;
};

//
// ConnectionIdentifier_sequenceNumber
//

// from 0 size 0 type 0 simple 1
class ConnectionIdentifier_sequenceNumber : public Asn :: Integer {
	public:
	explicit ConnectionIdentifier_sequenceNumber ( Asn :: istream & is );
	ConnectionIdentifier_sequenceNumber ( unsigned v = 0 );
	ConnectionIdentifier_sequenceNumber & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	ConnectionIdentifier_sequenceNumber & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	ConnectionIdentifier_sequenceNumber * clone ( ) const;
};

//
// SendTerminalCapabilitySet_specificRequest
//

// from 0 size 0 type 0 simple 0
class SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers;
class SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers;

class SendTerminalCapabilitySet_specificRequest : public Asn :: Sequence {
	public:
	explicit SendTerminalCapabilitySet_specificRequest ( Asn :: istream & is );
	SendTerminalCapabilitySet_specificRequest ( );
	enum OptionalFields {
		e_capabilityTableEntryNumbers,
		e_capabilityDescriptorNumbers
	};

	SendTerminalCapabilitySet_specificRequest ( const SendTerminalCapabilitySet_specificRequest & s );
	SendTerminalCapabilitySet_specificRequest & operator= ( const SendTerminalCapabilitySet_specificRequest & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	Asn :: Boolean m_multiplexCapability;
	protected:
	SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers * m_capabilityTableEntryNumbers;
	SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers * m_capabilityDescriptorNumbers;
	public:
	void encode ( Asn :: ostream & os ) const;
	~SendTerminalCapabilitySet_specificRequest ( );
	void printOn ( std :: ostream & os ) const;
	const SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers & get_capabilityTableEntryNumbers ( ) const {
		return * m_capabilityTableEntryNumbers;
	}
	SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers & get_capabilityTableEntryNumbers ( ) {
		return * m_capabilityTableEntryNumbers;
	}
	const SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers & get_capabilityDescriptorNumbers ( ) const {
		return * m_capabilityDescriptorNumbers;
	}
	SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers & get_capabilityDescriptorNumbers ( ) {
		return * m_capabilityDescriptorNumbers;
	}
	SendTerminalCapabilitySet_specificRequest * clone ( ) const;
};

//
// EndSessionCommand_gstnOptions
//

// from 0 size 0 type 0 simple 0
class EndSessionCommand_gstnOptions : public Asn :: Choice {
	public:
	explicit EndSessionCommand_gstnOptions ( Asn :: istream & is );
	EndSessionCommand_gstnOptions ( );
	enum Choices {
		e_telephonyMode,
		e_v8bis,
		e_v34DSVD,
		e_v34DuplexFAX,
		e_v34H324
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	EndSessionCommand_gstnOptions * clone ( ) const;
};

//
// EndSessionCommand_isdnOptions
//

// from 0 size 0 type 0 simple 0
class EndSessionCommand_isdnOptions : public Asn :: Choice {
	public:
	explicit EndSessionCommand_isdnOptions ( Asn :: istream & is );
	EndSessionCommand_isdnOptions ( );
	enum Choices {
		e_telephonyMode,
		e_v140,
		e_terminalOnHold
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	EndSessionCommand_isdnOptions * clone ( ) const;
};

//
// SubstituteConferenceIDCommand_conferenceIdentifier
//

// from 0 size 1 type 0 simple 0
class SubstituteConferenceIDCommand_conferenceIdentifier : public Asn :: OctetString {
	public:
	explicit SubstituteConferenceIDCommand_conferenceIdentifier ( Asn :: istream & is );
	SubstituteConferenceIDCommand_conferenceIdentifier ( const Asn :: string & v = Asn :: string ( ) );
	SubstituteConferenceIDCommand_conferenceIdentifier & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	SubstituteConferenceIDCommand_conferenceIdentifier * clone ( ) const;
};

//
// EncryptionUpdateRequest_synchFlag
//

// from 0 size 0 type 0 simple 1
class EncryptionUpdateRequest_synchFlag : public Asn :: Integer {
	public:
	explicit EncryptionUpdateRequest_synchFlag ( Asn :: istream & is );
	EncryptionUpdateRequest_synchFlag ( unsigned v = 0 );
	EncryptionUpdateRequest_synchFlag & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	EncryptionUpdateRequest_synchFlag & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	EncryptionUpdateRequest_synchFlag * clone ( ) const;
};

//
// PictureReference_pictureNumber
//

// from 0 size 0 type 0 simple 1
class PictureReference_pictureNumber : public Asn :: Integer {
	public:
	explicit PictureReference_pictureNumber ( Asn :: istream & is );
	PictureReference_pictureNumber ( unsigned v = 0 );
	PictureReference_pictureNumber & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	PictureReference_pictureNumber & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	PictureReference_pictureNumber * clone ( ) const;
};

//
// PictureReference_longTermPictureIndex
//

// from 0 size 0 type 0 simple 1
class PictureReference_longTermPictureIndex : public Asn :: Integer {
	public:
	explicit PictureReference_longTermPictureIndex ( Asn :: istream & is );
	PictureReference_longTermPictureIndex ( unsigned v = 0 );
	PictureReference_longTermPictureIndex & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	PictureReference_longTermPictureIndex & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	PictureReference_longTermPictureIndex * clone ( ) const;
};

//
// H223MultiplexReconfiguration_h223ModeChange
//

// from 0 size 0 type 0 simple 0
class H223MultiplexReconfiguration_h223ModeChange : public Asn :: Choice {
	public:
	explicit H223MultiplexReconfiguration_h223ModeChange ( Asn :: istream & is );
	H223MultiplexReconfiguration_h223ModeChange ( );
	enum Choices {
		e_toLevel0,
		e_toLevel1,
		e_toLevel2,
		e_toLevel2withOptionalHeader
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	H223MultiplexReconfiguration_h223ModeChange * clone ( ) const;
};

//
// H223MultiplexReconfiguration_h223AnnexADoubleFlag
//

// from 0 size 0 type 0 simple 0
class H223MultiplexReconfiguration_h223AnnexADoubleFlag : public Asn :: Choice {
	public:
	explicit H223MultiplexReconfiguration_h223AnnexADoubleFlag ( Asn :: istream & is );
	H223MultiplexReconfiguration_h223AnnexADoubleFlag ( );
	enum Choices {
		e_start,
		e_stop
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	H223MultiplexReconfiguration_h223AnnexADoubleFlag * clone ( ) const;
};

//
// NewATMVCCommand_resourceID
//

// from 0 size 0 type 0 simple 1
class NewATMVCCommand_resourceID : public Asn :: Integer {
	public:
	explicit NewATMVCCommand_resourceID ( Asn :: istream & is );
	NewATMVCCommand_resourceID ( unsigned v = 0 );
	NewATMVCCommand_resourceID & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	NewATMVCCommand_resourceID & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	NewATMVCCommand_resourceID * clone ( ) const;
};

//
// NewATMVCCommand_bitRate
//

// from 0 size 0 type 0 simple 1
class NewATMVCCommand_bitRate : public Asn :: Integer {
	public:
	explicit NewATMVCCommand_bitRate ( Asn :: istream & is );
	NewATMVCCommand_bitRate ( unsigned v = 0 );
	NewATMVCCommand_bitRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	NewATMVCCommand_bitRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	NewATMVCCommand_bitRate * clone ( ) const;
};

//
// NewATMVCCommand_multiplex
//

// from 0 size 0 type 0 simple 0
class NewATMVCCommand_multiplex : public Asn :: Choice {
	public:
	explicit NewATMVCCommand_multiplex ( Asn :: istream & is );
	NewATMVCCommand_multiplex ( );
	enum Choices {
		e_noMultiplex,
		e_transportStream,
		e_programStream
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	NewATMVCCommand_multiplex * clone ( ) const;
};

//
// MobileMultilinkReconfigurationCommand_sampleSize
//

// from 0 size 0 type 0 simple 1
class MobileMultilinkReconfigurationCommand_sampleSize : public Asn :: Integer {
	public:
	explicit MobileMultilinkReconfigurationCommand_sampleSize ( Asn :: istream & is );
	MobileMultilinkReconfigurationCommand_sampleSize ( unsigned v = 0 );
	MobileMultilinkReconfigurationCommand_sampleSize & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MobileMultilinkReconfigurationCommand_sampleSize & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MobileMultilinkReconfigurationCommand_sampleSize * clone ( ) const;
};

//
// MobileMultilinkReconfigurationCommand_samplesPerFrame
//

// from 0 size 0 type 0 simple 1
class MobileMultilinkReconfigurationCommand_samplesPerFrame : public Asn :: Integer {
	public:
	explicit MobileMultilinkReconfigurationCommand_samplesPerFrame ( Asn :: istream & is );
	MobileMultilinkReconfigurationCommand_samplesPerFrame ( unsigned v = 0 );
	MobileMultilinkReconfigurationCommand_samplesPerFrame & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MobileMultilinkReconfigurationCommand_samplesPerFrame & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MobileMultilinkReconfigurationCommand_samplesPerFrame * clone ( ) const;
};

//
// MobileMultilinkReconfigurationCommand_status
//

// from 0 size 0 type 0 simple 0
class MobileMultilinkReconfigurationCommand_status : public Asn :: Choice {
	public:
	explicit MobileMultilinkReconfigurationCommand_status ( Asn :: istream & is );
	MobileMultilinkReconfigurationCommand_status ( );
	enum Choices {
		e_synchronized,
		e_reconfiguration
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	MobileMultilinkReconfigurationCommand_status * clone ( ) const;
};

//
// FunctionNotSupported_cause
//

// from 0 size 0 type 0 simple 0
class FunctionNotSupported_cause : public Asn :: Choice {
	public:
	explicit FunctionNotSupported_cause ( Asn :: istream & is );
	FunctionNotSupported_cause ( );
	enum Choices {
		e_syntaxError,
		e_semanticError,
		e_unknownFunction
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	FunctionNotSupported_cause * clone ( ) const;
};

//
// ConferenceIndication_sbeNumber
//

// from 0 size 0 type 0 simple 1
class ConferenceIndication_sbeNumber : public Asn :: Integer {
	public:
	explicit ConferenceIndication_sbeNumber ( Asn :: istream & is );
	ConferenceIndication_sbeNumber ( unsigned v = 0 );
	ConferenceIndication_sbeNumber & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	ConferenceIndication_sbeNumber & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	ConferenceIndication_sbeNumber * clone ( ) const;
};

//
// TerminalYouAreSeeingInSubPictureNumber_subPictureNumber
//

// from 0 size 0 type 0 simple 1
class TerminalYouAreSeeingInSubPictureNumber_subPictureNumber : public Asn :: Integer {
	public:
	explicit TerminalYouAreSeeingInSubPictureNumber_subPictureNumber ( Asn :: istream & is );
	TerminalYouAreSeeingInSubPictureNumber_subPictureNumber ( unsigned v = 0 );
	TerminalYouAreSeeingInSubPictureNumber_subPictureNumber & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	TerminalYouAreSeeingInSubPictureNumber_subPictureNumber & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	TerminalYouAreSeeingInSubPictureNumber_subPictureNumber * clone ( ) const;
};

//
// VideoIndicateCompose_compositionNumber
//

// from 0 size 0 type 0 simple 1
class VideoIndicateCompose_compositionNumber : public Asn :: Integer {
	public:
	explicit VideoIndicateCompose_compositionNumber ( Asn :: istream & is );
	VideoIndicateCompose_compositionNumber ( unsigned v = 0 );
	VideoIndicateCompose_compositionNumber & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	VideoIndicateCompose_compositionNumber & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	VideoIndicateCompose_compositionNumber * clone ( ) const;
};

//
// JitterIndication_estimatedReceivedJitterMantissa
//

// from 0 size 0 type 0 simple 1
class JitterIndication_estimatedReceivedJitterMantissa : public Asn :: Integer {
	public:
	explicit JitterIndication_estimatedReceivedJitterMantissa ( Asn :: istream & is );
	JitterIndication_estimatedReceivedJitterMantissa ( unsigned v = 0 );
	JitterIndication_estimatedReceivedJitterMantissa & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	JitterIndication_estimatedReceivedJitterMantissa & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	JitterIndication_estimatedReceivedJitterMantissa * clone ( ) const;
};

//
// JitterIndication_estimatedReceivedJitterExponent
//

// from 0 size 0 type 0 simple 1
class JitterIndication_estimatedReceivedJitterExponent : public Asn :: Integer {
	public:
	explicit JitterIndication_estimatedReceivedJitterExponent ( Asn :: istream & is );
	JitterIndication_estimatedReceivedJitterExponent ( unsigned v = 0 );
	JitterIndication_estimatedReceivedJitterExponent & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	JitterIndication_estimatedReceivedJitterExponent & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	JitterIndication_estimatedReceivedJitterExponent * clone ( ) const;
};

//
// JitterIndication_skippedFrameCount
//

// from 0 size 0 type 0 simple 1
class JitterIndication_skippedFrameCount : public Asn :: Integer {
	public:
	explicit JitterIndication_skippedFrameCount ( Asn :: istream & is );
	JitterIndication_skippedFrameCount ( unsigned v = 0 );
	JitterIndication_skippedFrameCount & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	JitterIndication_skippedFrameCount & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	JitterIndication_skippedFrameCount * clone ( ) const;
};

//
// JitterIndication_additionalDecoderBuffer
//

// from 0 size 0 type 0 simple 1
class JitterIndication_additionalDecoderBuffer : public Asn :: Integer {
	public:
	explicit JitterIndication_additionalDecoderBuffer ( Asn :: istream & is );
	JitterIndication_additionalDecoderBuffer ( unsigned v = 0 );
	JitterIndication_additionalDecoderBuffer & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	JitterIndication_additionalDecoderBuffer & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	JitterIndication_additionalDecoderBuffer * clone ( ) const;
};

//
// H223SkewIndication_skew
//

// from 0 size 0 type 0 simple 1
class H223SkewIndication_skew : public Asn :: Integer {
	public:
	explicit H223SkewIndication_skew ( Asn :: istream & is );
	H223SkewIndication_skew ( unsigned v = 0 );
	H223SkewIndication_skew & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223SkewIndication_skew & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223SkewIndication_skew * clone ( ) const;
};

//
// H2250MaximumSkewIndication_maximumSkew
//

// from 0 size 0 type 0 simple 1
class H2250MaximumSkewIndication_maximumSkew : public Asn :: Integer {
	public:
	explicit H2250MaximumSkewIndication_maximumSkew ( Asn :: istream & is );
	H2250MaximumSkewIndication_maximumSkew ( unsigned v = 0 );
	H2250MaximumSkewIndication_maximumSkew & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H2250MaximumSkewIndication_maximumSkew & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H2250MaximumSkewIndication_maximumSkew * clone ( ) const;
};

//
// VendorIdentification_productNumber
//

// from 0 size 1 type 0 simple 0
class VendorIdentification_productNumber : public Asn :: OctetString {
	public:
	explicit VendorIdentification_productNumber ( Asn :: istream & is );
	VendorIdentification_productNumber ( const Asn :: string & v = Asn :: string ( ) );
	VendorIdentification_productNumber & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	VendorIdentification_productNumber * clone ( ) const;
};

//
// VendorIdentification_versionNumber
//

// from 0 size 1 type 0 simple 0
class VendorIdentification_versionNumber : public Asn :: OctetString {
	public:
	explicit VendorIdentification_versionNumber ( Asn :: istream & is );
	VendorIdentification_versionNumber ( const Asn :: string & v = Asn :: string ( ) );
	VendorIdentification_versionNumber & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	VendorIdentification_versionNumber * clone ( ) const;
};

//
// NewATMVCIndication_resourceID
//

// from 0 size 0 type 0 simple 1
class NewATMVCIndication_resourceID : public Asn :: Integer {
	public:
	explicit NewATMVCIndication_resourceID ( Asn :: istream & is );
	NewATMVCIndication_resourceID ( unsigned v = 0 );
	NewATMVCIndication_resourceID & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	NewATMVCIndication_resourceID & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	NewATMVCIndication_resourceID * clone ( ) const;
};

//
// NewATMVCIndication_bitRate
//

// from 0 size 0 type 0 simple 1
class NewATMVCIndication_bitRate : public Asn :: Integer {
	public:
	explicit NewATMVCIndication_bitRate ( Asn :: istream & is );
	NewATMVCIndication_bitRate ( unsigned v = 0 );
	NewATMVCIndication_bitRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	NewATMVCIndication_bitRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	NewATMVCIndication_bitRate * clone ( ) const;
};

//
// NewATMVCIndication_multiplex
//

// from 0 size 0 type 0 simple 0
class NewATMVCIndication_multiplex : public Asn :: Choice {
	public:
	explicit NewATMVCIndication_multiplex ( Asn :: istream & is );
	NewATMVCIndication_multiplex ( );
	enum Choices {
		e_noMultiplex,
		e_transportStream,
		e_programStream
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	NewATMVCIndication_multiplex * clone ( ) const;
};

//
// UserInputIndication_extendedAlphanumeric
//

// from 0 size 0 type 0 simple 0
class UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric;

class UserInputIndication_extendedAlphanumeric : public Asn :: Sequence {
	public:
	explicit UserInputIndication_extendedAlphanumeric ( Asn :: istream & is );
	UserInputIndication_extendedAlphanumeric ( );
	enum OptionalFields {
		e_rtpPayloadIndication,
		e_encryptedAlphanumeric
	};

	UserInputIndication_extendedAlphanumeric ( const UserInputIndication_extendedAlphanumeric & s );
	UserInputIndication_extendedAlphanumeric & operator= ( const UserInputIndication_extendedAlphanumeric & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	Asn :: GeneralString m_alphanumeric;
	protected:
	Asn :: Null * m_rtpPayloadIndication;
	UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric * m_encryptedAlphanumeric;
	public:
	void encode ( Asn :: ostream & os ) const;
	~UserInputIndication_extendedAlphanumeric ( );
	void printOn ( std :: ostream & os ) const;
	const Asn :: Null & get_rtpPayloadIndication ( ) const {
		return * m_rtpPayloadIndication;
	}
	Asn :: Null & get_rtpPayloadIndication ( ) {
		return * m_rtpPayloadIndication;
	}
	const UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric & get_encryptedAlphanumeric ( ) const {
		return * m_encryptedAlphanumeric;
	}
	UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric & get_encryptedAlphanumeric ( ) {
		return * m_encryptedAlphanumeric;
	}
	UserInputIndication_extendedAlphanumeric * clone ( ) const;
};

//
// UserInputIndication_encryptedAlphanumeric
//

// from 0 size 0 type 0 simple 0
class UserInputIndication_encryptedAlphanumeric : public Asn :: Sequence {
	public:
	explicit UserInputIndication_encryptedAlphanumeric ( Asn :: istream & is );
	UserInputIndication_encryptedAlphanumeric ( );
	enum OptionalFields {
		e_paramS
	};

	UserInputIndication_encryptedAlphanumeric ( const UserInputIndication_encryptedAlphanumeric & s );
	UserInputIndication_encryptedAlphanumeric & operator= ( const UserInputIndication_encryptedAlphanumeric & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	Asn :: ObjectId m_algorithmOID;
	protected:
	Params * m_paramS;
	public:
	Asn :: OctetString m_encrypted;
	void encode ( Asn :: ostream & os ) const;
	~UserInputIndication_encryptedAlphanumeric ( );
	void printOn ( std :: ostream & os ) const;
	const Params & get_paramS ( ) const {
		return * m_paramS;
	}
	Params & get_paramS ( ) {
		return * m_paramS;
	}
	UserInputIndication_encryptedAlphanumeric * clone ( ) const;
};

//
// MobileMultilinkReconfigurationIndication_sampleSize
//

// from 0 size 0 type 0 simple 1
class MobileMultilinkReconfigurationIndication_sampleSize : public Asn :: Integer {
	public:
	explicit MobileMultilinkReconfigurationIndication_sampleSize ( Asn :: istream & is );
	MobileMultilinkReconfigurationIndication_sampleSize ( unsigned v = 0 );
	MobileMultilinkReconfigurationIndication_sampleSize & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MobileMultilinkReconfigurationIndication_sampleSize & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MobileMultilinkReconfigurationIndication_sampleSize * clone ( ) const;
};

//
// MobileMultilinkReconfigurationIndication_samplesPerFrame
//

// from 0 size 0 type 0 simple 1
class MobileMultilinkReconfigurationIndication_samplesPerFrame : public Asn :: Integer {
	public:
	explicit MobileMultilinkReconfigurationIndication_samplesPerFrame ( Asn :: istream & is );
	MobileMultilinkReconfigurationIndication_samplesPerFrame ( unsigned v = 0 );
	MobileMultilinkReconfigurationIndication_samplesPerFrame & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MobileMultilinkReconfigurationIndication_samplesPerFrame & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MobileMultilinkReconfigurationIndication_samplesPerFrame * clone ( ) const;
};

//
// NonStandardIdentifier_h221NonStandard_t35CountryCode
//

// from 0 size 0 type 0 simple 1
class NonStandardIdentifier_h221NonStandard_t35CountryCode : public Asn :: Integer {
	public:
	explicit NonStandardIdentifier_h221NonStandard_t35CountryCode ( Asn :: istream & is );
	NonStandardIdentifier_h221NonStandard_t35CountryCode ( unsigned v = 0 );
	NonStandardIdentifier_h221NonStandard_t35CountryCode & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	NonStandardIdentifier_h221NonStandard_t35CountryCode & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	NonStandardIdentifier_h221NonStandard_t35CountryCode * clone ( ) const;
};

//
// NonStandardIdentifier_h221NonStandard_t35Extension
//

// from 0 size 0 type 0 simple 1
class NonStandardIdentifier_h221NonStandard_t35Extension : public Asn :: Integer {
	public:
	explicit NonStandardIdentifier_h221NonStandard_t35Extension ( Asn :: istream & is );
	NonStandardIdentifier_h221NonStandard_t35Extension ( unsigned v = 0 );
	NonStandardIdentifier_h221NonStandard_t35Extension & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	NonStandardIdentifier_h221NonStandard_t35Extension & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	NonStandardIdentifier_h221NonStandard_t35Extension * clone ( ) const;
};

//
// NonStandardIdentifier_h221NonStandard_manufacturerCode
//

// from 0 size 0 type 0 simple 1
class NonStandardIdentifier_h221NonStandard_manufacturerCode : public Asn :: Integer {
	public:
	explicit NonStandardIdentifier_h221NonStandard_manufacturerCode ( Asn :: istream & is );
	NonStandardIdentifier_h221NonStandard_manufacturerCode ( unsigned v = 0 );
	NonStandardIdentifier_h221NonStandard_manufacturerCode & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	NonStandardIdentifier_h221NonStandard_manufacturerCode & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	NonStandardIdentifier_h221NonStandard_manufacturerCode * clone ( ) const;
};

//
// TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded
//

// from 0 size 0 type 0 simple 0
class TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded : public Asn :: Choice {
	public:
	explicit TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded ( Asn :: istream & is );
	TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded ( );
	enum Choices {
		e_highestEntryNumberProcessed,
		e_noneProcessed
	};

	operator CapabilityTableEntryNumber & ( ) { return dynamic_cast < CapabilityTableEntryNumber & > ( * choice ); }
	operator const CapabilityTableEntryNumber & ( ) const { return dynamic_cast < const CapabilityTableEntryNumber & > ( * choice ); }
	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded * clone ( ) const;
};

//
// Capability_h233EncryptionReceiveCapability_h233IVResponseTime
//

// from 0 size 0 type 0 simple 1
class Capability_h233EncryptionReceiveCapability_h233IVResponseTime : public Asn :: Integer {
	public:
	explicit Capability_h233EncryptionReceiveCapability_h233IVResponseTime ( Asn :: istream & is );
	Capability_h233EncryptionReceiveCapability_h233IVResponseTime ( unsigned v = 0 );
	Capability_h233EncryptionReceiveCapability_h233IVResponseTime & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	Capability_h233EncryptionReceiveCapability_h233IVResponseTime & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	Capability_h233EncryptionReceiveCapability_h233IVResponseTime * clone ( ) const;
};

//
// VCCapability_aal5_forwardMaximumSDUSize
//

// from 0 size 0 type 0 simple 1
class VCCapability_aal5_forwardMaximumSDUSize : public Asn :: Integer {
	public:
	explicit VCCapability_aal5_forwardMaximumSDUSize ( Asn :: istream & is );
	VCCapability_aal5_forwardMaximumSDUSize ( unsigned v = 0 );
	VCCapability_aal5_forwardMaximumSDUSize & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	VCCapability_aal5_forwardMaximumSDUSize & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	VCCapability_aal5_forwardMaximumSDUSize * clone ( ) const;
};

//
// VCCapability_aal5_backwardMaximumSDUSize
//

// from 0 size 0 type 0 simple 1
class VCCapability_aal5_backwardMaximumSDUSize : public Asn :: Integer {
	public:
	explicit VCCapability_aal5_backwardMaximumSDUSize ( Asn :: istream & is );
	VCCapability_aal5_backwardMaximumSDUSize ( unsigned v = 0 );
	VCCapability_aal5_backwardMaximumSDUSize & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	VCCapability_aal5_backwardMaximumSDUSize & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	VCCapability_aal5_backwardMaximumSDUSize * clone ( ) const;
};

//
// VCCapability_aal1ViaGateway_gatewayAddress
//

// from 0 size 1 type 0 simple 0
class Q2931Address;

class VCCapability_aal1ViaGateway_gatewayAddress : public Asn :: Array {
	public:
	explicit VCCapability_aal1ViaGateway_gatewayAddress ( Asn :: istream & is );
	VCCapability_aal1ViaGateway_gatewayAddress ( );
	explicit VCCapability_aal1ViaGateway_gatewayAddress ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const Q2931Address & o );
	const Q2931Address & operator[] ( std :: size_t i ) const;
	Q2931Address & operator[] ( std :: size_t i );
	VCCapability_aal1ViaGateway_gatewayAddress * clone ( ) const;
};

//
// H223Capability_mobileMultilinkFrameCapability_maximumSampleSize
//

// from 0 size 0 type 0 simple 1
class H223Capability_mobileMultilinkFrameCapability_maximumSampleSize : public Asn :: Integer {
	public:
	explicit H223Capability_mobileMultilinkFrameCapability_maximumSampleSize ( Asn :: istream & is );
	H223Capability_mobileMultilinkFrameCapability_maximumSampleSize ( unsigned v = 0 );
	H223Capability_mobileMultilinkFrameCapability_maximumSampleSize & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223Capability_mobileMultilinkFrameCapability_maximumSampleSize & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223Capability_mobileMultilinkFrameCapability_maximumSampleSize * clone ( ) const;
};

//
// H223Capability_mobileMultilinkFrameCapability_maximumPayloadLength
//

// from 0 size 0 type 0 simple 1
class H223Capability_mobileMultilinkFrameCapability_maximumPayloadLength : public Asn :: Integer {
	public:
	explicit H223Capability_mobileMultilinkFrameCapability_maximumPayloadLength ( Asn :: istream & is );
	H223Capability_mobileMultilinkFrameCapability_maximumPayloadLength ( unsigned v = 0 );
	H223Capability_mobileMultilinkFrameCapability_maximumPayloadLength & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223Capability_mobileMultilinkFrameCapability_maximumPayloadLength & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223Capability_mobileMultilinkFrameCapability_maximumPayloadLength * clone ( ) const;
};

//
// RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom
//

// from 0 size 1 type 0 simple 0
class RTPH263VideoRedundancyFrameMapping;

class RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom : public Asn :: Array {
	public:
	explicit RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom ( Asn :: istream & is );
	RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom ( );
	explicit RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const RTPH263VideoRedundancyFrameMapping & o );
	const RTPH263VideoRedundancyFrameMapping & operator[] ( std :: size_t i ) const;
	RTPH263VideoRedundancyFrameMapping & operator[] ( std :: size_t i );
	RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom * clone ( ) const;
};

//
// RTPH263VideoRedundancyEncoding_containedThreads_subtype
//

// from 0 size 0 type 0 simple 1
class RTPH263VideoRedundancyEncoding_containedThreads_subtype : public Asn :: Integer {
	public:
	explicit RTPH263VideoRedundancyEncoding_containedThreads_subtype ( Asn :: istream & is );
	RTPH263VideoRedundancyEncoding_containedThreads_subtype ( unsigned v = 0 );
	RTPH263VideoRedundancyEncoding_containedThreads_subtype & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RTPH263VideoRedundancyEncoding_containedThreads_subtype & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RTPH263VideoRedundancyEncoding_containedThreads_subtype * clone ( ) const;
};

//
// RTPH263VideoRedundancyFrameMapping_frameSequence_subtype
//

// from 0 size 0 type 0 simple 1
class RTPH263VideoRedundancyFrameMapping_frameSequence_subtype : public Asn :: Integer {
	public:
	explicit RTPH263VideoRedundancyFrameMapping_frameSequence_subtype ( Asn :: istream & is );
	RTPH263VideoRedundancyFrameMapping_frameSequence_subtype ( unsigned v = 0 );
	RTPH263VideoRedundancyFrameMapping_frameSequence_subtype & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RTPH263VideoRedundancyFrameMapping_frameSequence_subtype & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RTPH263VideoRedundancyFrameMapping_frameSequence_subtype * clone ( ) const;
};

//
// RefPictureSelection_additionalPictureMemory_sqcifAdditionalPictureMemory
//

// from 0 size 0 type 0 simple 1
class RefPictureSelection_additionalPictureMemory_sqcifAdditionalPictureMemory : public Asn :: Integer {
	public:
	explicit RefPictureSelection_additionalPictureMemory_sqcifAdditionalPictureMemory ( Asn :: istream & is );
	RefPictureSelection_additionalPictureMemory_sqcifAdditionalPictureMemory ( unsigned v = 0 );
	RefPictureSelection_additionalPictureMemory_sqcifAdditionalPictureMemory & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RefPictureSelection_additionalPictureMemory_sqcifAdditionalPictureMemory & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RefPictureSelection_additionalPictureMemory_sqcifAdditionalPictureMemory * clone ( ) const;
};

//
// RefPictureSelection_additionalPictureMemory_qcifAdditionalPictureMemory
//

// from 0 size 0 type 0 simple 1
class RefPictureSelection_additionalPictureMemory_qcifAdditionalPictureMemory : public Asn :: Integer {
	public:
	explicit RefPictureSelection_additionalPictureMemory_qcifAdditionalPictureMemory ( Asn :: istream & is );
	RefPictureSelection_additionalPictureMemory_qcifAdditionalPictureMemory ( unsigned v = 0 );
	RefPictureSelection_additionalPictureMemory_qcifAdditionalPictureMemory & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RefPictureSelection_additionalPictureMemory_qcifAdditionalPictureMemory & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RefPictureSelection_additionalPictureMemory_qcifAdditionalPictureMemory * clone ( ) const;
};

//
// RefPictureSelection_additionalPictureMemory_cifAdditionalPictureMemory
//

// from 0 size 0 type 0 simple 1
class RefPictureSelection_additionalPictureMemory_cifAdditionalPictureMemory : public Asn :: Integer {
	public:
	explicit RefPictureSelection_additionalPictureMemory_cifAdditionalPictureMemory ( Asn :: istream & is );
	RefPictureSelection_additionalPictureMemory_cifAdditionalPictureMemory ( unsigned v = 0 );
	RefPictureSelection_additionalPictureMemory_cifAdditionalPictureMemory & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RefPictureSelection_additionalPictureMemory_cifAdditionalPictureMemory & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RefPictureSelection_additionalPictureMemory_cifAdditionalPictureMemory * clone ( ) const;
};

//
// RefPictureSelection_additionalPictureMemory_cif4AdditionalPictureMemory
//

// from 0 size 0 type 0 simple 1
class RefPictureSelection_additionalPictureMemory_cif4AdditionalPictureMemory : public Asn :: Integer {
	public:
	explicit RefPictureSelection_additionalPictureMemory_cif4AdditionalPictureMemory ( Asn :: istream & is );
	RefPictureSelection_additionalPictureMemory_cif4AdditionalPictureMemory ( unsigned v = 0 );
	RefPictureSelection_additionalPictureMemory_cif4AdditionalPictureMemory & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RefPictureSelection_additionalPictureMemory_cif4AdditionalPictureMemory & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RefPictureSelection_additionalPictureMemory_cif4AdditionalPictureMemory * clone ( ) const;
};

//
// RefPictureSelection_additionalPictureMemory_cif16AdditionalPictureMemory
//

// from 0 size 0 type 0 simple 1
class RefPictureSelection_additionalPictureMemory_cif16AdditionalPictureMemory : public Asn :: Integer {
	public:
	explicit RefPictureSelection_additionalPictureMemory_cif16AdditionalPictureMemory ( Asn :: istream & is );
	RefPictureSelection_additionalPictureMemory_cif16AdditionalPictureMemory ( unsigned v = 0 );
	RefPictureSelection_additionalPictureMemory_cif16AdditionalPictureMemory & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RefPictureSelection_additionalPictureMemory_cif16AdditionalPictureMemory & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RefPictureSelection_additionalPictureMemory_cif16AdditionalPictureMemory * clone ( ) const;
};

//
// RefPictureSelection_additionalPictureMemory_bigCpfAdditionalPictureMemory
//

// from 0 size 0 type 0 simple 1
class RefPictureSelection_additionalPictureMemory_bigCpfAdditionalPictureMemory : public Asn :: Integer {
	public:
	explicit RefPictureSelection_additionalPictureMemory_bigCpfAdditionalPictureMemory ( Asn :: istream & is );
	RefPictureSelection_additionalPictureMemory_bigCpfAdditionalPictureMemory ( unsigned v = 0 );
	RefPictureSelection_additionalPictureMemory_bigCpfAdditionalPictureMemory & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RefPictureSelection_additionalPictureMemory_bigCpfAdditionalPictureMemory & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RefPictureSelection_additionalPictureMemory_bigCpfAdditionalPictureMemory * clone ( ) const;
};

//
// CustomPictureFormat_mPI_standardMPI
//

// from 0 size 0 type 0 simple 1
class CustomPictureFormat_mPI_standardMPI : public Asn :: Integer {
	public:
	explicit CustomPictureFormat_mPI_standardMPI ( Asn :: istream & is );
	CustomPictureFormat_mPI_standardMPI ( unsigned v = 0 );
	CustomPictureFormat_mPI_standardMPI & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CustomPictureFormat_mPI_standardMPI & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CustomPictureFormat_mPI_standardMPI * clone ( ) const;
};

//
// CustomPictureFormat_mPI_customPCF
//

// from 0 size 1 type 0 simple 0
class CustomPictureFormat_mPI_customPCF_subtype;

class CustomPictureFormat_mPI_customPCF : public Asn :: Array {
	public:
	explicit CustomPictureFormat_mPI_customPCF ( Asn :: istream & is );
	CustomPictureFormat_mPI_customPCF ( );
	explicit CustomPictureFormat_mPI_customPCF ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const CustomPictureFormat_mPI_customPCF_subtype & o );
	const CustomPictureFormat_mPI_customPCF_subtype & operator[] ( std :: size_t i ) const;
	CustomPictureFormat_mPI_customPCF_subtype & operator[] ( std :: size_t i );
	CustomPictureFormat_mPI_customPCF * clone ( ) const;
};

//
// CustomPictureFormat_pixelAspectInformation_pixelAspectCode
//

// from 0 size 1 type 0 simple 0
class CustomPictureFormat_pixelAspectInformation_pixelAspectCode_subtype;

class CustomPictureFormat_pixelAspectInformation_pixelAspectCode : public Asn :: Array {
	public:
	explicit CustomPictureFormat_pixelAspectInformation_pixelAspectCode ( Asn :: istream & is );
	CustomPictureFormat_pixelAspectInformation_pixelAspectCode ( );
	explicit CustomPictureFormat_pixelAspectInformation_pixelAspectCode ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const CustomPictureFormat_pixelAspectInformation_pixelAspectCode_subtype & o );
	const CustomPictureFormat_pixelAspectInformation_pixelAspectCode_subtype & operator[] ( std :: size_t i ) const;
	CustomPictureFormat_pixelAspectInformation_pixelAspectCode_subtype & operator[] ( std :: size_t i );
	CustomPictureFormat_pixelAspectInformation_pixelAspectCode * clone ( ) const;
};

//
// CustomPictureFormat_pixelAspectInformation_extendedPAR
//

// from 0 size 1 type 0 simple 0
class CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype;

class CustomPictureFormat_pixelAspectInformation_extendedPAR : public Asn :: Array {
	public:
	explicit CustomPictureFormat_pixelAspectInformation_extendedPAR ( Asn :: istream & is );
	CustomPictureFormat_pixelAspectInformation_extendedPAR ( );
	explicit CustomPictureFormat_pixelAspectInformation_extendedPAR ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype & o );
	const CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype & operator[] ( std :: size_t i ) const;
	CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype & operator[] ( std :: size_t i );
	CustomPictureFormat_pixelAspectInformation_extendedPAR * clone ( ) const;
};

//
// AudioCapability_g7231_maxAl-sduAudioFrames
//

// from 0 size 0 type 0 simple 1
class AudioCapability_g7231_maxAl_sduAudioFrames : public Asn :: Integer {
	public:
	explicit AudioCapability_g7231_maxAl_sduAudioFrames ( Asn :: istream & is );
	AudioCapability_g7231_maxAl_sduAudioFrames ( unsigned v = 0 );
	AudioCapability_g7231_maxAl_sduAudioFrames & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	AudioCapability_g7231_maxAl_sduAudioFrames & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	AudioCapability_g7231_maxAl_sduAudioFrames * clone ( ) const;
};

//
// G7231AnnexCCapability_g723AnnexCAudioMode_highRateMode0
//

// from 0 size 0 type 0 simple 1
class G7231AnnexCCapability_g723AnnexCAudioMode_highRateMode0 : public Asn :: Integer {
	public:
	explicit G7231AnnexCCapability_g723AnnexCAudioMode_highRateMode0 ( Asn :: istream & is );
	G7231AnnexCCapability_g723AnnexCAudioMode_highRateMode0 ( unsigned v = 0 );
	G7231AnnexCCapability_g723AnnexCAudioMode_highRateMode0 & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	G7231AnnexCCapability_g723AnnexCAudioMode_highRateMode0 & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	G7231AnnexCCapability_g723AnnexCAudioMode_highRateMode0 * clone ( ) const;
};

//
// G7231AnnexCCapability_g723AnnexCAudioMode_highRateMode1
//

// from 0 size 0 type 0 simple 1
class G7231AnnexCCapability_g723AnnexCAudioMode_highRateMode1 : public Asn :: Integer {
	public:
	explicit G7231AnnexCCapability_g723AnnexCAudioMode_highRateMode1 ( Asn :: istream & is );
	G7231AnnexCCapability_g723AnnexCAudioMode_highRateMode1 ( unsigned v = 0 );
	G7231AnnexCCapability_g723AnnexCAudioMode_highRateMode1 & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	G7231AnnexCCapability_g723AnnexCAudioMode_highRateMode1 & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	G7231AnnexCCapability_g723AnnexCAudioMode_highRateMode1 * clone ( ) const;
};

//
// G7231AnnexCCapability_g723AnnexCAudioMode_lowRateMode0
//

// from 0 size 0 type 0 simple 1
class G7231AnnexCCapability_g723AnnexCAudioMode_lowRateMode0 : public Asn :: Integer {
	public:
	explicit G7231AnnexCCapability_g723AnnexCAudioMode_lowRateMode0 ( Asn :: istream & is );
	G7231AnnexCCapability_g723AnnexCAudioMode_lowRateMode0 ( unsigned v = 0 );
	G7231AnnexCCapability_g723AnnexCAudioMode_lowRateMode0 & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	G7231AnnexCCapability_g723AnnexCAudioMode_lowRateMode0 & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	G7231AnnexCCapability_g723AnnexCAudioMode_lowRateMode0 * clone ( ) const;
};

//
// G7231AnnexCCapability_g723AnnexCAudioMode_lowRateMode1
//

// from 0 size 0 type 0 simple 1
class G7231AnnexCCapability_g723AnnexCAudioMode_lowRateMode1 : public Asn :: Integer {
	public:
	explicit G7231AnnexCCapability_g723AnnexCAudioMode_lowRateMode1 ( Asn :: istream & is );
	G7231AnnexCCapability_g723AnnexCAudioMode_lowRateMode1 ( unsigned v = 0 );
	G7231AnnexCCapability_g723AnnexCAudioMode_lowRateMode1 & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	G7231AnnexCCapability_g723AnnexCAudioMode_lowRateMode1 & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	G7231AnnexCCapability_g723AnnexCAudioMode_lowRateMode1 * clone ( ) const;
};

//
// G7231AnnexCCapability_g723AnnexCAudioMode_sidMode0
//

// from 0 size 0 type 0 simple 1
class G7231AnnexCCapability_g723AnnexCAudioMode_sidMode0 : public Asn :: Integer {
	public:
	explicit G7231AnnexCCapability_g723AnnexCAudioMode_sidMode0 ( Asn :: istream & is );
	G7231AnnexCCapability_g723AnnexCAudioMode_sidMode0 ( unsigned v = 0 );
	G7231AnnexCCapability_g723AnnexCAudioMode_sidMode0 & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	G7231AnnexCCapability_g723AnnexCAudioMode_sidMode0 & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	G7231AnnexCCapability_g723AnnexCAudioMode_sidMode0 * clone ( ) const;
};

//
// G7231AnnexCCapability_g723AnnexCAudioMode_sidMode1
//

// from 0 size 0 type 0 simple 1
class G7231AnnexCCapability_g723AnnexCAudioMode_sidMode1 : public Asn :: Integer {
	public:
	explicit G7231AnnexCCapability_g723AnnexCAudioMode_sidMode1 ( Asn :: istream & is );
	G7231AnnexCCapability_g723AnnexCAudioMode_sidMode1 ( unsigned v = 0 );
	G7231AnnexCCapability_g723AnnexCAudioMode_sidMode1 & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	G7231AnnexCCapability_g723AnnexCAudioMode_sidMode1 & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	G7231AnnexCCapability_g723AnnexCAudioMode_sidMode1 * clone ( ) const;
};

//
// DepFECCapability_rfc2733_separateStream
//

// from 0 size 0 type 0 simple 0
class DepFECCapability_rfc2733_separateStream : public Asn :: Sequence {
	public:
	explicit DepFECCapability_rfc2733_separateStream ( Asn :: istream & is );
	DepFECCapability_rfc2733_separateStream ( );
	Asn :: Boolean m_separatePort;
	Asn :: Boolean m_samePort;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	DepFECCapability_rfc2733_separateStream * clone ( ) const;
};

//
// OpenLogicalChannel_forwardLogicalChannelParameters_portNumber
//

// from 0 size 0 type 0 simple 1
class OpenLogicalChannel_forwardLogicalChannelParameters_portNumber : public Asn :: Integer {
	public:
	explicit OpenLogicalChannel_forwardLogicalChannelParameters_portNumber ( Asn :: istream & is );
	OpenLogicalChannel_forwardLogicalChannelParameters_portNumber ( unsigned v = 0 );
	OpenLogicalChannel_forwardLogicalChannelParameters_portNumber & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	OpenLogicalChannel_forwardLogicalChannelParameters_portNumber & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	OpenLogicalChannel_forwardLogicalChannelParameters_portNumber * clone ( ) const;
};

//
// NetworkAccessParameters_networkAddress_e164Address
//

// from 1 size 1 type 0 simple 0
class NetworkAccessParameters_networkAddress_e164Address : public Asn :: IA5String {
	public:
	explicit NetworkAccessParameters_networkAddress_e164Address ( Asn :: istream & is );
	NetworkAccessParameters_networkAddress_e164Address ( const Asn :: string & v = Asn :: string ( ) );
	NetworkAccessParameters_networkAddress_e164Address & operator= ( const Asn :: string & v ) {
		Asn :: IA5String :: operator= ( v );
		return * this;
	}
	NetworkAccessParameters_networkAddress_e164Address * clone ( ) const;
};

//
// Q2931Address_address_internationalNumber
//

// from 0 size 1 type 0 simple 0
class Q2931Address_address_internationalNumber : public Asn :: NumericString {
	public:
	explicit Q2931Address_address_internationalNumber ( Asn :: istream & is );
	Q2931Address_address_internationalNumber ( const Asn :: string & v = Asn :: string ( ) );
	Q2931Address_address_internationalNumber & operator= ( const Asn :: string & v ) {
		Asn :: NumericString :: operator= ( v );
		return * this;
	}
	Q2931Address_address_internationalNumber * clone ( ) const;
};

//
// Q2931Address_address_nsapAddress
//

// from 0 size 1 type 0 simple 0
class Q2931Address_address_nsapAddress : public Asn :: OctetString {
	public:
	explicit Q2931Address_address_nsapAddress ( Asn :: istream & is );
	Q2931Address_address_nsapAddress ( const Asn :: string & v = Asn :: string ( ) );
	Q2931Address_address_nsapAddress & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	Q2931Address_address_nsapAddress * clone ( ) const;
};

//
// H223AnnexCArqParameters_numberOfRetransmissions_finite
//

// from 0 size 0 type 0 simple 1
class H223AnnexCArqParameters_numberOfRetransmissions_finite : public Asn :: Integer {
	public:
	explicit H223AnnexCArqParameters_numberOfRetransmissions_finite ( Asn :: istream & is );
	H223AnnexCArqParameters_numberOfRetransmissions_finite ( unsigned v = 0 );
	H223AnnexCArqParameters_numberOfRetransmissions_finite & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223AnnexCArqParameters_numberOfRetransmissions_finite & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223AnnexCArqParameters_numberOfRetransmissions_finite * clone ( ) const;
};

//
// RTPPayloadType_payloadDescriptor_rfc-number
//

// from 0 size 0 type 0 simple 1
class RTPPayloadType_payloadDescriptor_rfc_number : public Asn :: Integer {
	public:
	explicit RTPPayloadType_payloadDescriptor_rfc_number ( Asn :: istream & is );
	RTPPayloadType_payloadDescriptor_rfc_number ( unsigned v = 0 );
	RTPPayloadType_payloadDescriptor_rfc_number & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RTPPayloadType_payloadDescriptor_rfc_number & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RTPPayloadType_payloadDescriptor_rfc_number * clone ( ) const;
};

//
// ArrayOf_RedundancyEncodingElement
//

// from 0 size 0 type 0 simple 0
class ArrayOf_RedundancyEncodingElement : public Asn :: Array {
	public:
	explicit ArrayOf_RedundancyEncodingElement ( Asn :: istream & is );
	ArrayOf_RedundancyEncodingElement ( );
	explicit ArrayOf_RedundancyEncodingElement ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const RedundancyEncodingElement & o );
	const RedundancyEncodingElement & operator[] ( std :: size_t i ) const;
	RedundancyEncodingElement & operator[] ( std :: size_t i );
	ArrayOf_RedundancyEncodingElement * clone ( ) const;
};

//
// FECData_rfc2733_protectedPayloadType
//

// from 0 size 0 type 0 simple 1
class FECData_rfc2733_protectedPayloadType : public Asn :: Integer {
	public:
	explicit FECData_rfc2733_protectedPayloadType ( Asn :: istream & is );
	FECData_rfc2733_protectedPayloadType ( unsigned v = 0 );
	FECData_rfc2733_protectedPayloadType & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	FECData_rfc2733_protectedPayloadType & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	FECData_rfc2733_protectedPayloadType * clone ( ) const;
};

//
// UnicastAddress_iPAddress_network
//

// from 0 size 1 type 0 simple 0
class UnicastAddress_iPAddress_network : public Asn :: OctetString {
	public:
	explicit UnicastAddress_iPAddress_network ( Asn :: istream & is );
	UnicastAddress_iPAddress_network ( const Asn :: string & v = Asn :: string ( ) );
	UnicastAddress_iPAddress_network & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	UnicastAddress_iPAddress_network * clone ( ) const;
};

//
// UnicastAddress_iPAddress_tsapIdentifier
//

// from 0 size 0 type 0 simple 1
class UnicastAddress_iPAddress_tsapIdentifier : public Asn :: Integer {
	public:
	explicit UnicastAddress_iPAddress_tsapIdentifier ( Asn :: istream & is );
	UnicastAddress_iPAddress_tsapIdentifier ( unsigned v = 0 );
	UnicastAddress_iPAddress_tsapIdentifier & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	UnicastAddress_iPAddress_tsapIdentifier & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	UnicastAddress_iPAddress_tsapIdentifier * clone ( ) const;
};

//
// UnicastAddress_iPXAddress_node
//

// from 0 size 1 type 0 simple 0
class UnicastAddress_iPXAddress_node : public Asn :: OctetString {
	public:
	explicit UnicastAddress_iPXAddress_node ( Asn :: istream & is );
	UnicastAddress_iPXAddress_node ( const Asn :: string & v = Asn :: string ( ) );
	UnicastAddress_iPXAddress_node & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	UnicastAddress_iPXAddress_node * clone ( ) const;
};

//
// UnicastAddress_iPXAddress_netnum
//

// from 0 size 1 type 0 simple 0
class UnicastAddress_iPXAddress_netnum : public Asn :: OctetString {
	public:
	explicit UnicastAddress_iPXAddress_netnum ( Asn :: istream & is );
	UnicastAddress_iPXAddress_netnum ( const Asn :: string & v = Asn :: string ( ) );
	UnicastAddress_iPXAddress_netnum & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	UnicastAddress_iPXAddress_netnum * clone ( ) const;
};

//
// UnicastAddress_iPXAddress_tsapIdentifier
//

// from 0 size 1 type 0 simple 0
class UnicastAddress_iPXAddress_tsapIdentifier : public Asn :: OctetString {
	public:
	explicit UnicastAddress_iPXAddress_tsapIdentifier ( Asn :: istream & is );
	UnicastAddress_iPXAddress_tsapIdentifier ( const Asn :: string & v = Asn :: string ( ) );
	UnicastAddress_iPXAddress_tsapIdentifier & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	UnicastAddress_iPXAddress_tsapIdentifier * clone ( ) const;
};

//
// UnicastAddress_iP6Address_network
//

// from 0 size 1 type 0 simple 0
class UnicastAddress_iP6Address_network : public Asn :: OctetString {
	public:
	explicit UnicastAddress_iP6Address_network ( Asn :: istream & is );
	UnicastAddress_iP6Address_network ( const Asn :: string & v = Asn :: string ( ) );
	UnicastAddress_iP6Address_network & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	UnicastAddress_iP6Address_network * clone ( ) const;
};

//
// UnicastAddress_iP6Address_tsapIdentifier
//

// from 0 size 0 type 0 simple 1
class UnicastAddress_iP6Address_tsapIdentifier : public Asn :: Integer {
	public:
	explicit UnicastAddress_iP6Address_tsapIdentifier ( Asn :: istream & is );
	UnicastAddress_iP6Address_tsapIdentifier ( unsigned v = 0 );
	UnicastAddress_iP6Address_tsapIdentifier & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	UnicastAddress_iP6Address_tsapIdentifier & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	UnicastAddress_iP6Address_tsapIdentifier * clone ( ) const;
};

//
// UnicastAddress_iPSourceRouteAddress_routing
//

// from 0 size 0 type 0 simple 0
class UnicastAddress_iPSourceRouteAddress_routing : public Asn :: Choice {
	public:
	explicit UnicastAddress_iPSourceRouteAddress_routing ( Asn :: istream & is );
	UnicastAddress_iPSourceRouteAddress_routing ( );
	enum Choices {
		e_strict,
		e_loose
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	UnicastAddress_iPSourceRouteAddress_routing * clone ( ) const;
};

//
// UnicastAddress_iPSourceRouteAddress_network
//

// from 0 size 1 type 0 simple 0
class UnicastAddress_iPSourceRouteAddress_network : public Asn :: OctetString {
	public:
	explicit UnicastAddress_iPSourceRouteAddress_network ( Asn :: istream & is );
	UnicastAddress_iPSourceRouteAddress_network ( const Asn :: string & v = Asn :: string ( ) );
	UnicastAddress_iPSourceRouteAddress_network & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	UnicastAddress_iPSourceRouteAddress_network * clone ( ) const;
};

//
// UnicastAddress_iPSourceRouteAddress_tsapIdentifier
//

// from 0 size 0 type 0 simple 1
class UnicastAddress_iPSourceRouteAddress_tsapIdentifier : public Asn :: Integer {
	public:
	explicit UnicastAddress_iPSourceRouteAddress_tsapIdentifier ( Asn :: istream & is );
	UnicastAddress_iPSourceRouteAddress_tsapIdentifier ( unsigned v = 0 );
	UnicastAddress_iPSourceRouteAddress_tsapIdentifier & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	UnicastAddress_iPSourceRouteAddress_tsapIdentifier & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	UnicastAddress_iPSourceRouteAddress_tsapIdentifier * clone ( ) const;
};

//
// UnicastAddress_iPSourceRouteAddress_route
//

// from 0 size 0 type 0 simple 0
class UnicastAddress_iPSourceRouteAddress_route_subtype;

class UnicastAddress_iPSourceRouteAddress_route : public Asn :: Array {
	public:
	explicit UnicastAddress_iPSourceRouteAddress_route ( Asn :: istream & is );
	UnicastAddress_iPSourceRouteAddress_route ( );
	explicit UnicastAddress_iPSourceRouteAddress_route ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const UnicastAddress_iPSourceRouteAddress_route_subtype & o );
	const UnicastAddress_iPSourceRouteAddress_route_subtype & operator[] ( std :: size_t i ) const;
	UnicastAddress_iPSourceRouteAddress_route_subtype & operator[] ( std :: size_t i );
	UnicastAddress_iPSourceRouteAddress_route * clone ( ) const;
};

//
// MulticastAddress_iPAddress_network
//

// from 0 size 1 type 0 simple 0
class MulticastAddress_iPAddress_network : public Asn :: OctetString {
	public:
	explicit MulticastAddress_iPAddress_network ( Asn :: istream & is );
	MulticastAddress_iPAddress_network ( const Asn :: string & v = Asn :: string ( ) );
	MulticastAddress_iPAddress_network & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	MulticastAddress_iPAddress_network * clone ( ) const;
};

//
// MulticastAddress_iPAddress_tsapIdentifier
//

// from 0 size 0 type 0 simple 1
class MulticastAddress_iPAddress_tsapIdentifier : public Asn :: Integer {
	public:
	explicit MulticastAddress_iPAddress_tsapIdentifier ( Asn :: istream & is );
	MulticastAddress_iPAddress_tsapIdentifier ( unsigned v = 0 );
	MulticastAddress_iPAddress_tsapIdentifier & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MulticastAddress_iPAddress_tsapIdentifier & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MulticastAddress_iPAddress_tsapIdentifier * clone ( ) const;
};

//
// MulticastAddress_iP6Address_network
//

// from 0 size 1 type 0 simple 0
class MulticastAddress_iP6Address_network : public Asn :: OctetString {
	public:
	explicit MulticastAddress_iP6Address_network ( Asn :: istream & is );
	MulticastAddress_iP6Address_network ( const Asn :: string & v = Asn :: string ( ) );
	MulticastAddress_iP6Address_network & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	MulticastAddress_iP6Address_network * clone ( ) const;
};

//
// MulticastAddress_iP6Address_tsapIdentifier
//

// from 0 size 0 type 0 simple 1
class MulticastAddress_iP6Address_tsapIdentifier : public Asn :: Integer {
	public:
	explicit MulticastAddress_iP6Address_tsapIdentifier ( Asn :: istream & is );
	MulticastAddress_iP6Address_tsapIdentifier ( unsigned v = 0 );
	MulticastAddress_iP6Address_tsapIdentifier & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MulticastAddress_iP6Address_tsapIdentifier & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MulticastAddress_iP6Address_tsapIdentifier * clone ( ) const;
};

//
// OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber
//

// from 0 size 0 type 0 simple 1
class OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber : public Asn :: Integer {
	public:
	explicit OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber ( Asn :: istream & is );
	OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber ( unsigned v = 0 );
	OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber * clone ( ) const;
};

//
// MultiplexElement_type_logicalChannelNumber
//

// from 0 size 0 type 0 simple 1
class MultiplexElement_type_logicalChannelNumber : public Asn :: Integer {
	public:
	explicit MultiplexElement_type_logicalChannelNumber ( Asn :: istream & is );
	MultiplexElement_type_logicalChannelNumber ( unsigned v = 0 );
	MultiplexElement_type_logicalChannelNumber & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MultiplexElement_type_logicalChannelNumber & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MultiplexElement_type_logicalChannelNumber * clone ( ) const;
};

//
// MultiplexElement_type_subElementList
//

// from 0 size 1 type 0 simple 0
class MultiplexElement_type_subElementList : public Asn :: Array {
	public:
	explicit MultiplexElement_type_subElementList ( Asn :: istream & is );
	MultiplexElement_type_subElementList ( );
	explicit MultiplexElement_type_subElementList ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const MultiplexElement & o );
	const MultiplexElement & operator[] ( std :: size_t i ) const;
	MultiplexElement & operator[] ( std :: size_t i );
	MultiplexElement_type_subElementList * clone ( ) const;
};

//
// MultiplexElement_repeatCount_finite
//

// from 0 size 0 type 0 simple 1
class MultiplexElement_repeatCount_finite : public Asn :: Integer {
	public:
	explicit MultiplexElement_repeatCount_finite ( Asn :: istream & is );
	MultiplexElement_repeatCount_finite ( unsigned v = 0 );
	MultiplexElement_repeatCount_finite & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MultiplexElement_repeatCount_finite & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MultiplexElement_repeatCount_finite * clone ( ) const;
};

//
// G7231AnnexCMode_g723AnnexCAudioMode_highRateMode0
//

// from 0 size 0 type 0 simple 1
class G7231AnnexCMode_g723AnnexCAudioMode_highRateMode0 : public Asn :: Integer {
	public:
	explicit G7231AnnexCMode_g723AnnexCAudioMode_highRateMode0 ( Asn :: istream & is );
	G7231AnnexCMode_g723AnnexCAudioMode_highRateMode0 ( unsigned v = 0 );
	G7231AnnexCMode_g723AnnexCAudioMode_highRateMode0 & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	G7231AnnexCMode_g723AnnexCAudioMode_highRateMode0 & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	G7231AnnexCMode_g723AnnexCAudioMode_highRateMode0 * clone ( ) const;
};

//
// G7231AnnexCMode_g723AnnexCAudioMode_highRateMode1
//

// from 0 size 0 type 0 simple 1
class G7231AnnexCMode_g723AnnexCAudioMode_highRateMode1 : public Asn :: Integer {
	public:
	explicit G7231AnnexCMode_g723AnnexCAudioMode_highRateMode1 ( Asn :: istream & is );
	G7231AnnexCMode_g723AnnexCAudioMode_highRateMode1 ( unsigned v = 0 );
	G7231AnnexCMode_g723AnnexCAudioMode_highRateMode1 & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	G7231AnnexCMode_g723AnnexCAudioMode_highRateMode1 & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	G7231AnnexCMode_g723AnnexCAudioMode_highRateMode1 * clone ( ) const;
};

//
// G7231AnnexCMode_g723AnnexCAudioMode_lowRateMode0
//

// from 0 size 0 type 0 simple 1
class G7231AnnexCMode_g723AnnexCAudioMode_lowRateMode0 : public Asn :: Integer {
	public:
	explicit G7231AnnexCMode_g723AnnexCAudioMode_lowRateMode0 ( Asn :: istream & is );
	G7231AnnexCMode_g723AnnexCAudioMode_lowRateMode0 ( unsigned v = 0 );
	G7231AnnexCMode_g723AnnexCAudioMode_lowRateMode0 & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	G7231AnnexCMode_g723AnnexCAudioMode_lowRateMode0 & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	G7231AnnexCMode_g723AnnexCAudioMode_lowRateMode0 * clone ( ) const;
};

//
// G7231AnnexCMode_g723AnnexCAudioMode_lowRateMode1
//

// from 0 size 0 type 0 simple 1
class G7231AnnexCMode_g723AnnexCAudioMode_lowRateMode1 : public Asn :: Integer {
	public:
	explicit G7231AnnexCMode_g723AnnexCAudioMode_lowRateMode1 ( Asn :: istream & is );
	G7231AnnexCMode_g723AnnexCAudioMode_lowRateMode1 ( unsigned v = 0 );
	G7231AnnexCMode_g723AnnexCAudioMode_lowRateMode1 & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	G7231AnnexCMode_g723AnnexCAudioMode_lowRateMode1 & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	G7231AnnexCMode_g723AnnexCAudioMode_lowRateMode1 * clone ( ) const;
};

//
// G7231AnnexCMode_g723AnnexCAudioMode_sidMode0
//

// from 0 size 0 type 0 simple 1
class G7231AnnexCMode_g723AnnexCAudioMode_sidMode0 : public Asn :: Integer {
	public:
	explicit G7231AnnexCMode_g723AnnexCAudioMode_sidMode0 ( Asn :: istream & is );
	G7231AnnexCMode_g723AnnexCAudioMode_sidMode0 ( unsigned v = 0 );
	G7231AnnexCMode_g723AnnexCAudioMode_sidMode0 & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	G7231AnnexCMode_g723AnnexCAudioMode_sidMode0 & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	G7231AnnexCMode_g723AnnexCAudioMode_sidMode0 * clone ( ) const;
};

//
// G7231AnnexCMode_g723AnnexCAudioMode_sidMode1
//

// from 0 size 0 type 0 simple 1
class G7231AnnexCMode_g723AnnexCAudioMode_sidMode1 : public Asn :: Integer {
	public:
	explicit G7231AnnexCMode_g723AnnexCAudioMode_sidMode1 ( Asn :: istream & is );
	G7231AnnexCMode_g723AnnexCAudioMode_sidMode1 ( unsigned v = 0 );
	G7231AnnexCMode_g723AnnexCAudioMode_sidMode1 & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	G7231AnnexCMode_g723AnnexCAudioMode_sidMode1 & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	G7231AnnexCMode_g723AnnexCAudioMode_sidMode1 * clone ( ) const;
};

//
// ConferenceRequest_requestTerminalCertificate_sRandom
//

// from 0 size 0 type 0 simple 1
class ConferenceRequest_requestTerminalCertificate_sRandom : public Asn :: Integer {
	public:
	explicit ConferenceRequest_requestTerminalCertificate_sRandom ( Asn :: istream & is );
	ConferenceRequest_requestTerminalCertificate_sRandom ( unsigned v = 0 );
	ConferenceRequest_requestTerminalCertificate_sRandom & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	ConferenceRequest_requestTerminalCertificate_sRandom & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	ConferenceRequest_requestTerminalCertificate_sRandom * clone ( ) const;
};

//
// ConferenceResponse_terminalCertificateResponse_certificateResponse
//

// from 0 size 1 type 0 simple 0
class ConferenceResponse_terminalCertificateResponse_certificateResponse : public Asn :: OctetString {
	public:
	explicit ConferenceResponse_terminalCertificateResponse_certificateResponse ( Asn :: istream & is );
	ConferenceResponse_terminalCertificateResponse_certificateResponse ( const Asn :: string & v = Asn :: string ( ) );
	ConferenceResponse_terminalCertificateResponse_certificateResponse & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	ConferenceResponse_terminalCertificateResponse_certificateResponse * clone ( ) const;
};

//
// MultilinkRequest_callInformation_maxNumberOfAdditionalConnections
//

// from 0 size 0 type 0 simple 1
class MultilinkRequest_callInformation_maxNumberOfAdditionalConnections : public Asn :: Integer {
	public:
	explicit MultilinkRequest_callInformation_maxNumberOfAdditionalConnections ( Asn :: istream & is );
	MultilinkRequest_callInformation_maxNumberOfAdditionalConnections ( unsigned v = 0 );
	MultilinkRequest_callInformation_maxNumberOfAdditionalConnections & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MultilinkRequest_callInformation_maxNumberOfAdditionalConnections & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MultilinkRequest_callInformation_maxNumberOfAdditionalConnections * clone ( ) const;
};

//
// MultilinkResponse_callInformation_callAssociationNumber
//

// from 0 size 0 type 0 simple 1
class MultilinkResponse_callInformation_callAssociationNumber : public Asn :: Integer {
	public:
	explicit MultilinkResponse_callInformation_callAssociationNumber ( Asn :: istream & is );
	MultilinkResponse_callInformation_callAssociationNumber ( unsigned v = 0 );
	MultilinkResponse_callInformation_callAssociationNumber & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MultilinkResponse_callInformation_callAssociationNumber & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MultilinkResponse_callInformation_callAssociationNumber * clone ( ) const;
};

//
// MultilinkResponse_maximumHeaderInterval_currentInterval
//

// from 0 size 0 type 0 simple 1
class MultilinkResponse_maximumHeaderInterval_currentInterval : public Asn :: Integer {
	public:
	explicit MultilinkResponse_maximumHeaderInterval_currentInterval ( Asn :: istream & is );
	MultilinkResponse_maximumHeaderInterval_currentInterval ( unsigned v = 0 );
	MultilinkResponse_maximumHeaderInterval_currentInterval & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MultilinkResponse_maximumHeaderInterval_currentInterval & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MultilinkResponse_maximumHeaderInterval_currentInterval * clone ( ) const;
};

//
// SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers
//

// from 0 size 1 type 0 simple 0
class SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers : public Asn :: Array {
	public:
	explicit SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers ( Asn :: istream & is );
	SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers ( );
	explicit SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const CapabilityTableEntryNumber & o );
	const CapabilityTableEntryNumber & operator[] ( std :: size_t i ) const;
	CapabilityTableEntryNumber & operator[] ( std :: size_t i );
	SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers * clone ( ) const;
};

//
// SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers
//

// from 0 size 1 type 0 simple 0
class SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers : public Asn :: Array {
	public:
	explicit SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers ( Asn :: istream & is );
	SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers ( );
	explicit SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const CapabilityDescriptorNumber & o );
	const CapabilityDescriptorNumber & operator[] ( std :: size_t i ) const;
	CapabilityDescriptorNumber & operator[] ( std :: size_t i );
	SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers * clone ( ) const;
};

//
// FlowControlCommand_scope_resourceID
//

// from 0 size 0 type 0 simple 1
class FlowControlCommand_scope_resourceID : public Asn :: Integer {
	public:
	explicit FlowControlCommand_scope_resourceID ( Asn :: istream & is );
	FlowControlCommand_scope_resourceID ( unsigned v = 0 );
	FlowControlCommand_scope_resourceID & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	FlowControlCommand_scope_resourceID & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	FlowControlCommand_scope_resourceID * clone ( ) const;
};

//
// FlowControlCommand_restriction_maximumBitRate
//

// from 0 size 0 type 0 simple 1
class FlowControlCommand_restriction_maximumBitRate : public Asn :: Integer {
	public:
	explicit FlowControlCommand_restriction_maximumBitRate ( Asn :: istream & is );
	FlowControlCommand_restriction_maximumBitRate ( unsigned v = 0 );
	FlowControlCommand_restriction_maximumBitRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	FlowControlCommand_restriction_maximumBitRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	FlowControlCommand_restriction_maximumBitRate * clone ( ) const;
};

//
// MiscellaneousCommand_type_videoTemporalSpatialTradeOff
//

// from 0 size 0 type 0 simple 1
class MiscellaneousCommand_type_videoTemporalSpatialTradeOff : public Asn :: Integer {
	public:
	explicit MiscellaneousCommand_type_videoTemporalSpatialTradeOff ( Asn :: istream & is );
	MiscellaneousCommand_type_videoTemporalSpatialTradeOff ( unsigned v = 0 );
	MiscellaneousCommand_type_videoTemporalSpatialTradeOff & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MiscellaneousCommand_type_videoTemporalSpatialTradeOff & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MiscellaneousCommand_type_videoTemporalSpatialTradeOff * clone ( ) const;
};

//
// MiscellaneousCommand_type_maxH223MUXPDUsize
//

// from 0 size 0 type 0 simple 1
class MiscellaneousCommand_type_maxH223MUXPDUsize : public Asn :: Integer {
	public:
	explicit MiscellaneousCommand_type_maxH223MUXPDUsize ( Asn :: istream & is );
	MiscellaneousCommand_type_maxH223MUXPDUsize ( unsigned v = 0 );
	MiscellaneousCommand_type_maxH223MUXPDUsize & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MiscellaneousCommand_type_maxH223MUXPDUsize & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MiscellaneousCommand_type_maxH223MUXPDUsize * clone ( ) const;
};

//
// ArrayOf_PictureReference
//

// from 0 size 0 type 0 simple 0
class PictureReference;

class ArrayOf_PictureReference : public Asn :: Array {
	public:
	explicit ArrayOf_PictureReference ( Asn :: istream & is );
	ArrayOf_PictureReference ( );
	explicit ArrayOf_PictureReference ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const PictureReference & o );
	const PictureReference & operator[] ( std :: size_t i ) const;
	PictureReference & operator[] ( std :: size_t i );
	ArrayOf_PictureReference * clone ( ) const;
};

//
// NewATMVCCommand_reverseParameters_bitRate
//

// from 0 size 0 type 0 simple 1
class NewATMVCCommand_reverseParameters_bitRate : public Asn :: Integer {
	public:
	explicit NewATMVCCommand_reverseParameters_bitRate ( Asn :: istream & is );
	NewATMVCCommand_reverseParameters_bitRate ( unsigned v = 0 );
	NewATMVCCommand_reverseParameters_bitRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	NewATMVCCommand_reverseParameters_bitRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	NewATMVCCommand_reverseParameters_bitRate * clone ( ) const;
};

//
// NewATMVCCommand_reverseParameters_multiplex
//

// from 0 size 0 type 0 simple 0
class NewATMVCCommand_reverseParameters_multiplex : public Asn :: Choice {
	public:
	explicit NewATMVCCommand_reverseParameters_multiplex ( Asn :: istream & is );
	NewATMVCCommand_reverseParameters_multiplex ( );
	enum Choices {
		e_noMultiplex,
		e_transportStream,
		e_programStream
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	NewATMVCCommand_reverseParameters_multiplex * clone ( ) const;
};

//
// MiscellaneousIndication_type_videoTemporalSpatialTradeOff
//

// from 0 size 0 type 0 simple 1
class MiscellaneousIndication_type_videoTemporalSpatialTradeOff : public Asn :: Integer {
	public:
	explicit MiscellaneousIndication_type_videoTemporalSpatialTradeOff ( Asn :: istream & is );
	MiscellaneousIndication_type_videoTemporalSpatialTradeOff ( unsigned v = 0 );
	MiscellaneousIndication_type_videoTemporalSpatialTradeOff & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MiscellaneousIndication_type_videoTemporalSpatialTradeOff & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MiscellaneousIndication_type_videoTemporalSpatialTradeOff * clone ( ) const;
};

//
// JitterIndication_scope_resourceID
//

// from 0 size 0 type 0 simple 1
class JitterIndication_scope_resourceID : public Asn :: Integer {
	public:
	explicit JitterIndication_scope_resourceID ( Asn :: istream & is );
	JitterIndication_scope_resourceID ( unsigned v = 0 );
	JitterIndication_scope_resourceID & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	JitterIndication_scope_resourceID & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	JitterIndication_scope_resourceID * clone ( ) const;
};

//
// NewATMVCIndication_reverseParameters_bitRate
//

// from 0 size 0 type 0 simple 1
class NewATMVCIndication_reverseParameters_bitRate : public Asn :: Integer {
	public:
	explicit NewATMVCIndication_reverseParameters_bitRate ( Asn :: istream & is );
	NewATMVCIndication_reverseParameters_bitRate ( unsigned v = 0 );
	NewATMVCIndication_reverseParameters_bitRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	NewATMVCIndication_reverseParameters_bitRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	NewATMVCIndication_reverseParameters_bitRate * clone ( ) const;
};

//
// NewATMVCIndication_reverseParameters_multiplex
//

// from 0 size 0 type 0 simple 0
class NewATMVCIndication_reverseParameters_multiplex : public Asn :: Choice {
	public:
	explicit NewATMVCIndication_reverseParameters_multiplex ( Asn :: istream & is );
	NewATMVCIndication_reverseParameters_multiplex ( );
	enum Choices {
		e_noMultiplex,
		e_transportStream,
		e_programStream
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	NewATMVCIndication_reverseParameters_multiplex * clone ( ) const;
};

//
// UserInputIndication_signal_signalType
//

// from 1 size 1 type 0 simple 0
class UserInputIndication_signal_signalType : public Asn :: IA5String {
	public:
	explicit UserInputIndication_signal_signalType ( Asn :: istream & is );
	UserInputIndication_signal_signalType ( const Asn :: string & v = Asn :: string ( ) );
	UserInputIndication_signal_signalType & operator= ( const Asn :: string & v ) {
		Asn :: IA5String :: operator= ( v );
		return * this;
	}
	UserInputIndication_signal_signalType * clone ( ) const;
};

//
// UserInputIndication_signal_duration
//

// from 0 size 0 type 0 simple 1
class UserInputIndication_signal_duration : public Asn :: Integer {
	public:
	explicit UserInputIndication_signal_duration ( Asn :: istream & is );
	UserInputIndication_signal_duration ( unsigned v = 0 );
	UserInputIndication_signal_duration & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	UserInputIndication_signal_duration & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	UserInputIndication_signal_duration * clone ( ) const;
};

//
// UserInputIndication_signal_rtp
//

// from 0 size 0 type 0 simple 0
class UserInputIndication_signal_rtp_timestamp;
class UserInputIndication_signal_rtp_expirationTime;

class UserInputIndication_signal_rtp : public Asn :: Sequence {
	public:
	explicit UserInputIndication_signal_rtp ( Asn :: istream & is );
	UserInputIndication_signal_rtp ( );
	enum OptionalFields {
		e_timestamp,
		e_expirationTime
	};

	UserInputIndication_signal_rtp ( const UserInputIndication_signal_rtp & s );
	UserInputIndication_signal_rtp & operator= ( const UserInputIndication_signal_rtp & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	UserInputIndication_signal_rtp_timestamp * m_timestamp;
	UserInputIndication_signal_rtp_expirationTime * m_expirationTime;
	public:
	LogicalChannelNumber m_logicalChannelNumber;
	void encode ( Asn :: ostream & os ) const;
	~UserInputIndication_signal_rtp ( );
	void printOn ( std :: ostream & os ) const;
	const UserInputIndication_signal_rtp_timestamp & get_timestamp ( ) const {
		return * m_timestamp;
	}
	UserInputIndication_signal_rtp_timestamp & get_timestamp ( ) {
		return * m_timestamp;
	}
	const UserInputIndication_signal_rtp_expirationTime & get_expirationTime ( ) const {
		return * m_expirationTime;
	}
	UserInputIndication_signal_rtp_expirationTime & get_expirationTime ( ) {
		return * m_expirationTime;
	}
	UserInputIndication_signal_rtp * clone ( ) const;
};

//
// UserInputIndication_signal_encryptedSignalType
//

// from 0 size 1 type 0 simple 0
class UserInputIndication_signal_encryptedSignalType : public Asn :: OctetString {
	public:
	explicit UserInputIndication_signal_encryptedSignalType ( Asn :: istream & is );
	UserInputIndication_signal_encryptedSignalType ( const Asn :: string & v = Asn :: string ( ) );
	UserInputIndication_signal_encryptedSignalType & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	UserInputIndication_signal_encryptedSignalType * clone ( ) const;
};

//
// UserInputIndication_signalUpdate_duration
//

// from 0 size 0 type 0 simple 1
class UserInputIndication_signalUpdate_duration : public Asn :: Integer {
	public:
	explicit UserInputIndication_signalUpdate_duration ( Asn :: istream & is );
	UserInputIndication_signalUpdate_duration ( unsigned v = 0 );
	UserInputIndication_signalUpdate_duration & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	UserInputIndication_signalUpdate_duration & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	UserInputIndication_signalUpdate_duration * clone ( ) const;
};

//
// UserInputIndication_signalUpdate_rtp
//

// from 0 size 0 type 0 simple 0
class UserInputIndication_signalUpdate_rtp : public Asn :: Sequence {
	public:
	explicit UserInputIndication_signalUpdate_rtp ( Asn :: istream & is );
	UserInputIndication_signalUpdate_rtp ( );
	LogicalChannelNumber m_logicalChannelNumber;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	UserInputIndication_signalUpdate_rtp * clone ( ) const;
};

//
// UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric
//

// from 0 size 0 type 0 simple 0
class UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric : public Asn :: Sequence {
	public:
	explicit UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric ( Asn :: istream & is );
	UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric ( );
	enum OptionalFields {
		e_paramS
	};

	UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric ( const UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric & s );
	UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric & operator= ( const UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	Asn :: ObjectId m_algorithmOID;
	protected:
	Params * m_paramS;
	public:
	Asn :: OctetString m_encrypted;
	void encode ( Asn :: ostream & os ) const;
	~UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric ( );
	void printOn ( std :: ostream & os ) const;
	const Params & get_paramS ( ) const {
		return * m_paramS;
	}
	Params & get_paramS ( ) {
		return * m_paramS;
	}
	UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric * clone ( ) const;
};

//
// FlowControlIndication_scope_resourceID
//

// from 0 size 0 type 0 simple 1
class FlowControlIndication_scope_resourceID : public Asn :: Integer {
	public:
	explicit FlowControlIndication_scope_resourceID ( Asn :: istream & is );
	FlowControlIndication_scope_resourceID ( unsigned v = 0 );
	FlowControlIndication_scope_resourceID & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	FlowControlIndication_scope_resourceID & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	FlowControlIndication_scope_resourceID * clone ( ) const;
};

//
// FlowControlIndication_restriction_maximumBitRate
//

// from 0 size 0 type 0 simple 1
class FlowControlIndication_restriction_maximumBitRate : public Asn :: Integer {
	public:
	explicit FlowControlIndication_restriction_maximumBitRate ( Asn :: istream & is );
	FlowControlIndication_restriction_maximumBitRate ( unsigned v = 0 );
	FlowControlIndication_restriction_maximumBitRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	FlowControlIndication_restriction_maximumBitRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	FlowControlIndication_restriction_maximumBitRate * clone ( ) const;
};

//
// VCCapability_availableBitRates_type_singleBitRate
//

// from 0 size 0 type 0 simple 1
class VCCapability_availableBitRates_type_singleBitRate : public Asn :: Integer {
	public:
	explicit VCCapability_availableBitRates_type_singleBitRate ( Asn :: istream & is );
	VCCapability_availableBitRates_type_singleBitRate ( unsigned v = 0 );
	VCCapability_availableBitRates_type_singleBitRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	VCCapability_availableBitRates_type_singleBitRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	VCCapability_availableBitRates_type_singleBitRate * clone ( ) const;
};

//
// H223Capability_h223MultiplexTableCapability_enhanced_maximumNestingDepth
//

// from 0 size 0 type 0 simple 1
class H223Capability_h223MultiplexTableCapability_enhanced_maximumNestingDepth : public Asn :: Integer {
	public:
	explicit H223Capability_h223MultiplexTableCapability_enhanced_maximumNestingDepth ( Asn :: istream & is );
	H223Capability_h223MultiplexTableCapability_enhanced_maximumNestingDepth ( unsigned v = 0 );
	H223Capability_h223MultiplexTableCapability_enhanced_maximumNestingDepth & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223Capability_h223MultiplexTableCapability_enhanced_maximumNestingDepth & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223Capability_h223MultiplexTableCapability_enhanced_maximumNestingDepth * clone ( ) const;
};

//
// H223Capability_h223MultiplexTableCapability_enhanced_maximumElementListSize
//

// from 0 size 0 type 0 simple 1
class H223Capability_h223MultiplexTableCapability_enhanced_maximumElementListSize : public Asn :: Integer {
	public:
	explicit H223Capability_h223MultiplexTableCapability_enhanced_maximumElementListSize ( Asn :: istream & is );
	H223Capability_h223MultiplexTableCapability_enhanced_maximumElementListSize ( unsigned v = 0 );
	H223Capability_h223MultiplexTableCapability_enhanced_maximumElementListSize & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223Capability_h223MultiplexTableCapability_enhanced_maximumElementListSize & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223Capability_h223MultiplexTableCapability_enhanced_maximumElementListSize * clone ( ) const;
};

//
// H223Capability_h223MultiplexTableCapability_enhanced_maximumSubElementListSize
//

// from 0 size 0 type 0 simple 1
class H223Capability_h223MultiplexTableCapability_enhanced_maximumSubElementListSize : public Asn :: Integer {
	public:
	explicit H223Capability_h223MultiplexTableCapability_enhanced_maximumSubElementListSize ( Asn :: istream & is );
	H223Capability_h223MultiplexTableCapability_enhanced_maximumSubElementListSize ( unsigned v = 0 );
	H223Capability_h223MultiplexTableCapability_enhanced_maximumSubElementListSize & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223Capability_h223MultiplexTableCapability_enhanced_maximumSubElementListSize & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223Capability_h223MultiplexTableCapability_enhanced_maximumSubElementListSize * clone ( ) const;
};

//
// RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuHorizMBs
//

// from 0 size 0 type 0 simple 1
class RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuHorizMBs : public Asn :: Integer {
	public:
	explicit RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuHorizMBs ( Asn :: istream & is );
	RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuHorizMBs ( unsigned v = 0 );
	RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuHorizMBs & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuHorizMBs & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuHorizMBs * clone ( ) const;
};

//
// RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuVertMBs
//

// from 0 size 0 type 0 simple 1
class RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuVertMBs : public Asn :: Integer {
	public:
	explicit RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuVertMBs ( Asn :: istream & is );
	RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuVertMBs ( unsigned v = 0 );
	RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuVertMBs & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuVertMBs & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuVertMBs * clone ( ) const;
};

//
// RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuTotalNumber
//

// from 0 size 0 type 0 simple 1
class RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuTotalNumber : public Asn :: Integer {
	public:
	explicit RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuTotalNumber ( Asn :: istream & is );
	RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuTotalNumber ( unsigned v = 0 );
	RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuTotalNumber & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuTotalNumber & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuTotalNumber * clone ( ) const;
};

//
// CustomPictureFormat_pixelAspectInformation_pixelAspectCode_subtype
//

// from 0 size 0 type 0 simple 1
class CustomPictureFormat_pixelAspectInformation_pixelAspectCode_subtype : public Asn :: Integer {
	public:
	explicit CustomPictureFormat_pixelAspectInformation_pixelAspectCode_subtype ( Asn :: istream & is );
	CustomPictureFormat_pixelAspectInformation_pixelAspectCode_subtype ( unsigned v = 0 );
	CustomPictureFormat_pixelAspectInformation_pixelAspectCode_subtype & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CustomPictureFormat_pixelAspectInformation_pixelAspectCode_subtype & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CustomPictureFormat_pixelAspectInformation_pixelAspectCode_subtype * clone ( ) const;
};

//
// H223LogicalChannelParameters_adaptationLayerType_al3_controlFieldOctets
//

// from 0 size 0 type 0 simple 1
class H223LogicalChannelParameters_adaptationLayerType_al3_controlFieldOctets : public Asn :: Integer {
	public:
	explicit H223LogicalChannelParameters_adaptationLayerType_al3_controlFieldOctets ( Asn :: istream & is );
	H223LogicalChannelParameters_adaptationLayerType_al3_controlFieldOctets ( unsigned v = 0 );
	H223LogicalChannelParameters_adaptationLayerType_al3_controlFieldOctets & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223LogicalChannelParameters_adaptationLayerType_al3_controlFieldOctets & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223LogicalChannelParameters_adaptationLayerType_al3_controlFieldOctets * clone ( ) const;
};

//
// H223LogicalChannelParameters_adaptationLayerType_al3_sendBufferSize
//

// from 0 size 0 type 0 simple 1
class H223LogicalChannelParameters_adaptationLayerType_al3_sendBufferSize : public Asn :: Integer {
	public:
	explicit H223LogicalChannelParameters_adaptationLayerType_al3_sendBufferSize ( Asn :: istream & is );
	H223LogicalChannelParameters_adaptationLayerType_al3_sendBufferSize ( unsigned v = 0 );
	H223LogicalChannelParameters_adaptationLayerType_al3_sendBufferSize & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223LogicalChannelParameters_adaptationLayerType_al3_sendBufferSize & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223LogicalChannelParameters_adaptationLayerType_al3_sendBufferSize * clone ( ) const;
};

//
// V76LogicalChannelParameters_mode_eRM_windowSize
//

// from 0 size 0 type 0 simple 1
class V76LogicalChannelParameters_mode_eRM_windowSize : public Asn :: Integer {
	public:
	explicit V76LogicalChannelParameters_mode_eRM_windowSize ( Asn :: istream & is );
	V76LogicalChannelParameters_mode_eRM_windowSize ( unsigned v = 0 );
	V76LogicalChannelParameters_mode_eRM_windowSize & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	V76LogicalChannelParameters_mode_eRM_windowSize & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	V76LogicalChannelParameters_mode_eRM_windowSize * clone ( ) const;
};

//
// V76LogicalChannelParameters_mode_eRM_recovery
//

// from 0 size 0 type 0 simple 0
class V76LogicalChannelParameters_mode_eRM_recovery : public Asn :: Choice {
	public:
	explicit V76LogicalChannelParameters_mode_eRM_recovery ( Asn :: istream & is );
	V76LogicalChannelParameters_mode_eRM_recovery ( );
	enum Choices {
		e_rej,
		e_sREJ,
		e_mSREJ
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	V76LogicalChannelParameters_mode_eRM_recovery * clone ( ) const;
};

//
// FECData_rfc2733_pktMode_rfc2733sameport
//

// from 0 size 0 type 0 simple 0
class FECData_rfc2733_pktMode_rfc2733sameport : public Asn :: Sequence {
	public:
	explicit FECData_rfc2733_pktMode_rfc2733sameport ( Asn :: istream & is );
	FECData_rfc2733_pktMode_rfc2733sameport ( );
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	FECData_rfc2733_pktMode_rfc2733sameport * clone ( ) const;
};

//
// FECData_rfc2733_pktMode_rfc2733diffport
//

// from 0 size 0 type 0 simple 0
class FECData_rfc2733_pktMode_rfc2733diffport : public Asn :: Sequence {
	public:
	explicit FECData_rfc2733_pktMode_rfc2733diffport ( Asn :: istream & is );
	FECData_rfc2733_pktMode_rfc2733diffport ( );
	LogicalChannelNumber m_protectedChannel;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	FECData_rfc2733_pktMode_rfc2733diffport * clone ( ) const;
};

//
// UnicastAddress_iPSourceRouteAddress_route_subtype
//

// from 0 size 1 type 0 simple 0
class UnicastAddress_iPSourceRouteAddress_route_subtype : public Asn :: OctetString {
	public:
	explicit UnicastAddress_iPSourceRouteAddress_route_subtype ( Asn :: istream & is );
	UnicastAddress_iPSourceRouteAddress_route_subtype ( const Asn :: string & v = Asn :: string ( ) );
	UnicastAddress_iPSourceRouteAddress_route_subtype & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	UnicastAddress_iPSourceRouteAddress_route_subtype * clone ( ) const;
};

//
// H223ModeParameters_adaptationLayerType_al3_controlFieldOctets
//

// from 0 size 0 type 0 simple 1
class H223ModeParameters_adaptationLayerType_al3_controlFieldOctets : public Asn :: Integer {
	public:
	explicit H223ModeParameters_adaptationLayerType_al3_controlFieldOctets ( Asn :: istream & is );
	H223ModeParameters_adaptationLayerType_al3_controlFieldOctets ( unsigned v = 0 );
	H223ModeParameters_adaptationLayerType_al3_controlFieldOctets & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223ModeParameters_adaptationLayerType_al3_controlFieldOctets & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223ModeParameters_adaptationLayerType_al3_controlFieldOctets * clone ( ) const;
};

//
// H223ModeParameters_adaptationLayerType_al3_sendBufferSize
//

// from 0 size 0 type 0 simple 1
class H223ModeParameters_adaptationLayerType_al3_sendBufferSize : public Asn :: Integer {
	public:
	explicit H223ModeParameters_adaptationLayerType_al3_sendBufferSize ( Asn :: istream & is );
	H223ModeParameters_adaptationLayerType_al3_sendBufferSize ( unsigned v = 0 );
	H223ModeParameters_adaptationLayerType_al3_sendBufferSize & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223ModeParameters_adaptationLayerType_al3_sendBufferSize & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H223ModeParameters_adaptationLayerType_al3_sendBufferSize * clone ( ) const;
};

//
// MultilinkRequest_maximumHeaderInterval_requestType_requestedInterval
//

// from 0 size 0 type 0 simple 1
class MultilinkRequest_maximumHeaderInterval_requestType_requestedInterval : public Asn :: Integer {
	public:
	explicit MultilinkRequest_maximumHeaderInterval_requestType_requestedInterval ( Asn :: istream & is );
	MultilinkRequest_maximumHeaderInterval_requestType_requestedInterval ( unsigned v = 0 );
	MultilinkRequest_maximumHeaderInterval_requestType_requestedInterval & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MultilinkRequest_maximumHeaderInterval_requestType_requestedInterval & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MultilinkRequest_maximumHeaderInterval_requestType_requestedInterval * clone ( ) const;
};

//
// MultilinkResponse_addConnection_responseCode_rejected
//

// from 0 size 0 type 0 simple 0
class MultilinkResponse_addConnection_responseCode_rejected : public Asn :: Choice {
	public:
	explicit MultilinkResponse_addConnection_responseCode_rejected ( Asn :: istream & is );
	MultilinkResponse_addConnection_responseCode_rejected ( );
	enum Choices {
		e_connectionsNotAvailable,
		e_userRejected
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	MultilinkResponse_addConnection_responseCode_rejected * clone ( ) const;
};

//
// MiscellaneousCommand_type_videoFastUpdateGOB_firstGOB
//

// from 0 size 0 type 0 simple 1
class MiscellaneousCommand_type_videoFastUpdateGOB_firstGOB : public Asn :: Integer {
	public:
	explicit MiscellaneousCommand_type_videoFastUpdateGOB_firstGOB ( Asn :: istream & is );
	MiscellaneousCommand_type_videoFastUpdateGOB_firstGOB ( unsigned v = 0 );
	MiscellaneousCommand_type_videoFastUpdateGOB_firstGOB & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MiscellaneousCommand_type_videoFastUpdateGOB_firstGOB & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MiscellaneousCommand_type_videoFastUpdateGOB_firstGOB * clone ( ) const;
};

//
// MiscellaneousCommand_type_videoFastUpdateGOB_numberOfGOBs
//

// from 0 size 0 type 0 simple 1
class MiscellaneousCommand_type_videoFastUpdateGOB_numberOfGOBs : public Asn :: Integer {
	public:
	explicit MiscellaneousCommand_type_videoFastUpdateGOB_numberOfGOBs ( Asn :: istream & is );
	MiscellaneousCommand_type_videoFastUpdateGOB_numberOfGOBs ( unsigned v = 0 );
	MiscellaneousCommand_type_videoFastUpdateGOB_numberOfGOBs & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MiscellaneousCommand_type_videoFastUpdateGOB_numberOfGOBs & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MiscellaneousCommand_type_videoFastUpdateGOB_numberOfGOBs * clone ( ) const;
};

//
// MiscellaneousCommand_type_videoFastUpdateMB_firstGOB
//

// from 0 size 0 type 0 simple 1
class MiscellaneousCommand_type_videoFastUpdateMB_firstGOB : public Asn :: Integer {
	public:
	explicit MiscellaneousCommand_type_videoFastUpdateMB_firstGOB ( Asn :: istream & is );
	MiscellaneousCommand_type_videoFastUpdateMB_firstGOB ( unsigned v = 0 );
	MiscellaneousCommand_type_videoFastUpdateMB_firstGOB & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MiscellaneousCommand_type_videoFastUpdateMB_firstGOB & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MiscellaneousCommand_type_videoFastUpdateMB_firstGOB * clone ( ) const;
};

//
// MiscellaneousCommand_type_videoFastUpdateMB_firstMB
//

// from 0 size 0 type 0 simple 1
class MiscellaneousCommand_type_videoFastUpdateMB_firstMB : public Asn :: Integer {
	public:
	explicit MiscellaneousCommand_type_videoFastUpdateMB_firstMB ( Asn :: istream & is );
	MiscellaneousCommand_type_videoFastUpdateMB_firstMB ( unsigned v = 0 );
	MiscellaneousCommand_type_videoFastUpdateMB_firstMB & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MiscellaneousCommand_type_videoFastUpdateMB_firstMB & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MiscellaneousCommand_type_videoFastUpdateMB_firstMB * clone ( ) const;
};

//
// MiscellaneousCommand_type_videoFastUpdateMB_numberOfMBs
//

// from 0 size 0 type 0 simple 1
class MiscellaneousCommand_type_videoFastUpdateMB_numberOfMBs : public Asn :: Integer {
	public:
	explicit MiscellaneousCommand_type_videoFastUpdateMB_numberOfMBs ( Asn :: istream & is );
	MiscellaneousCommand_type_videoFastUpdateMB_numberOfMBs ( unsigned v = 0 );
	MiscellaneousCommand_type_videoFastUpdateMB_numberOfMBs & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MiscellaneousCommand_type_videoFastUpdateMB_numberOfMBs & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MiscellaneousCommand_type_videoFastUpdateMB_numberOfMBs * clone ( ) const;
};

//
// MiscellaneousCommand_type_progressiveRefinementStart_repeatCount
//

// from 0 size 0 type 0 simple 0
class MiscellaneousCommand_type_progressiveRefinementStart_repeatCount : public Asn :: Choice {
	public:
	explicit MiscellaneousCommand_type_progressiveRefinementStart_repeatCount ( Asn :: istream & is );
	MiscellaneousCommand_type_progressiveRefinementStart_repeatCount ( );
	enum Choices {
		e_doOneProgression,
		e_doContinuousProgressions,
		e_doOneIndependentProgression,
		e_doContinuousIndependentProgressions
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	MiscellaneousCommand_type_progressiveRefinementStart_repeatCount * clone ( ) const;
};

//
// MiscellaneousCommand_type_videoBadMBs_firstMB
//

// from 0 size 0 type 0 simple 1
class MiscellaneousCommand_type_videoBadMBs_firstMB : public Asn :: Integer {
	public:
	explicit MiscellaneousCommand_type_videoBadMBs_firstMB ( Asn :: istream & is );
	MiscellaneousCommand_type_videoBadMBs_firstMB ( unsigned v = 0 );
	MiscellaneousCommand_type_videoBadMBs_firstMB & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MiscellaneousCommand_type_videoBadMBs_firstMB & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MiscellaneousCommand_type_videoBadMBs_firstMB * clone ( ) const;
};

//
// MiscellaneousCommand_type_videoBadMBs_numberOfMBs
//

// from 0 size 0 type 0 simple 1
class MiscellaneousCommand_type_videoBadMBs_numberOfMBs : public Asn :: Integer {
	public:
	explicit MiscellaneousCommand_type_videoBadMBs_numberOfMBs ( Asn :: istream & is );
	MiscellaneousCommand_type_videoBadMBs_numberOfMBs ( unsigned v = 0 );
	MiscellaneousCommand_type_videoBadMBs_numberOfMBs & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MiscellaneousCommand_type_videoBadMBs_numberOfMBs & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MiscellaneousCommand_type_videoBadMBs_numberOfMBs * clone ( ) const;
};

//
// MiscellaneousCommand_type_videoBadMBs_temporalReference
//

// from 0 size 0 type 0 simple 1
class MiscellaneousCommand_type_videoBadMBs_temporalReference : public Asn :: Integer {
	public:
	explicit MiscellaneousCommand_type_videoBadMBs_temporalReference ( Asn :: istream & is );
	MiscellaneousCommand_type_videoBadMBs_temporalReference ( unsigned v = 0 );
	MiscellaneousCommand_type_videoBadMBs_temporalReference & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MiscellaneousCommand_type_videoBadMBs_temporalReference & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MiscellaneousCommand_type_videoBadMBs_temporalReference * clone ( ) const;
};

//
// MiscellaneousCommand_type_lostPartialPicture_firstMB
//

// from 0 size 0 type 0 simple 1
class MiscellaneousCommand_type_lostPartialPicture_firstMB : public Asn :: Integer {
	public:
	explicit MiscellaneousCommand_type_lostPartialPicture_firstMB ( Asn :: istream & is );
	MiscellaneousCommand_type_lostPartialPicture_firstMB ( unsigned v = 0 );
	MiscellaneousCommand_type_lostPartialPicture_firstMB & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MiscellaneousCommand_type_lostPartialPicture_firstMB & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MiscellaneousCommand_type_lostPartialPicture_firstMB * clone ( ) const;
};

//
// MiscellaneousCommand_type_lostPartialPicture_numberOfMBs
//

// from 0 size 0 type 0 simple 1
class MiscellaneousCommand_type_lostPartialPicture_numberOfMBs : public Asn :: Integer {
	public:
	explicit MiscellaneousCommand_type_lostPartialPicture_numberOfMBs ( Asn :: istream & is );
	MiscellaneousCommand_type_lostPartialPicture_numberOfMBs ( unsigned v = 0 );
	MiscellaneousCommand_type_lostPartialPicture_numberOfMBs & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MiscellaneousCommand_type_lostPartialPicture_numberOfMBs & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MiscellaneousCommand_type_lostPartialPicture_numberOfMBs * clone ( ) const;
};

//
// MiscellaneousCommand_type_encryptionUpdateAck_synchFlag
//

// from 0 size 0 type 0 simple 1
class MiscellaneousCommand_type_encryptionUpdateAck_synchFlag : public Asn :: Integer {
	public:
	explicit MiscellaneousCommand_type_encryptionUpdateAck_synchFlag ( Asn :: istream & is );
	MiscellaneousCommand_type_encryptionUpdateAck_synchFlag ( unsigned v = 0 );
	MiscellaneousCommand_type_encryptionUpdateAck_synchFlag & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MiscellaneousCommand_type_encryptionUpdateAck_synchFlag & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MiscellaneousCommand_type_encryptionUpdateAck_synchFlag * clone ( ) const;
};

//
// NewATMVCCommand_aal_aal1_clockRecovery
//

// from 0 size 0 type 0 simple 0
class NewATMVCCommand_aal_aal1_clockRecovery : public Asn :: Choice {
	public:
	explicit NewATMVCCommand_aal_aal1_clockRecovery ( Asn :: istream & is );
	NewATMVCCommand_aal_aal1_clockRecovery ( );
	enum Choices {
		e_nullClockRecovery,
		e_srtsClockRecovery,
		e_adaptiveClockRecovery
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	NewATMVCCommand_aal_aal1_clockRecovery * clone ( ) const;
};

//
// NewATMVCCommand_aal_aal1_errorCorrection
//

// from 0 size 0 type 0 simple 0
class NewATMVCCommand_aal_aal1_errorCorrection : public Asn :: Choice {
	public:
	explicit NewATMVCCommand_aal_aal1_errorCorrection ( Asn :: istream & is );
	NewATMVCCommand_aal_aal1_errorCorrection ( );
	enum Choices {
		e_nullErrorCorrection,
		e_longInterleaver,
		e_shortInterleaver,
		e_errorCorrectionOnly
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	NewATMVCCommand_aal_aal1_errorCorrection * clone ( ) const;
};

//
// NewATMVCCommand_aal_aal5_forwardMaximumSDUSize
//

// from 0 size 0 type 0 simple 1
class NewATMVCCommand_aal_aal5_forwardMaximumSDUSize : public Asn :: Integer {
	public:
	explicit NewATMVCCommand_aal_aal5_forwardMaximumSDUSize ( Asn :: istream & is );
	NewATMVCCommand_aal_aal5_forwardMaximumSDUSize ( unsigned v = 0 );
	NewATMVCCommand_aal_aal5_forwardMaximumSDUSize & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	NewATMVCCommand_aal_aal5_forwardMaximumSDUSize & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	NewATMVCCommand_aal_aal5_forwardMaximumSDUSize * clone ( ) const;
};

//
// NewATMVCCommand_aal_aal5_backwardMaximumSDUSize
//

// from 0 size 0 type 0 simple 1
class NewATMVCCommand_aal_aal5_backwardMaximumSDUSize : public Asn :: Integer {
	public:
	explicit NewATMVCCommand_aal_aal5_backwardMaximumSDUSize ( Asn :: istream & is );
	NewATMVCCommand_aal_aal5_backwardMaximumSDUSize ( unsigned v = 0 );
	NewATMVCCommand_aal_aal5_backwardMaximumSDUSize & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	NewATMVCCommand_aal_aal5_backwardMaximumSDUSize & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	NewATMVCCommand_aal_aal5_backwardMaximumSDUSize * clone ( ) const;
};

//
// MiscellaneousIndication_type_videoNotDecodedMBs_firstMB
//

// from 0 size 0 type 0 simple 1
class MiscellaneousIndication_type_videoNotDecodedMBs_firstMB : public Asn :: Integer {
	public:
	explicit MiscellaneousIndication_type_videoNotDecodedMBs_firstMB ( Asn :: istream & is );
	MiscellaneousIndication_type_videoNotDecodedMBs_firstMB ( unsigned v = 0 );
	MiscellaneousIndication_type_videoNotDecodedMBs_firstMB & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MiscellaneousIndication_type_videoNotDecodedMBs_firstMB & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MiscellaneousIndication_type_videoNotDecodedMBs_firstMB * clone ( ) const;
};

//
// MiscellaneousIndication_type_videoNotDecodedMBs_numberOfMBs
//

// from 0 size 0 type 0 simple 1
class MiscellaneousIndication_type_videoNotDecodedMBs_numberOfMBs : public Asn :: Integer {
	public:
	explicit MiscellaneousIndication_type_videoNotDecodedMBs_numberOfMBs ( Asn :: istream & is );
	MiscellaneousIndication_type_videoNotDecodedMBs_numberOfMBs ( unsigned v = 0 );
	MiscellaneousIndication_type_videoNotDecodedMBs_numberOfMBs & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MiscellaneousIndication_type_videoNotDecodedMBs_numberOfMBs & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MiscellaneousIndication_type_videoNotDecodedMBs_numberOfMBs * clone ( ) const;
};

//
// MiscellaneousIndication_type_videoNotDecodedMBs_temporalReference
//

// from 0 size 0 type 0 simple 1
class MiscellaneousIndication_type_videoNotDecodedMBs_temporalReference : public Asn :: Integer {
	public:
	explicit MiscellaneousIndication_type_videoNotDecodedMBs_temporalReference ( Asn :: istream & is );
	MiscellaneousIndication_type_videoNotDecodedMBs_temporalReference ( unsigned v = 0 );
	MiscellaneousIndication_type_videoNotDecodedMBs_temporalReference & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MiscellaneousIndication_type_videoNotDecodedMBs_temporalReference & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	MiscellaneousIndication_type_videoNotDecodedMBs_temporalReference * clone ( ) const;
};

//
// NewATMVCIndication_aal_aal1_clockRecovery
//

// from 0 size 0 type 0 simple 0
class NewATMVCIndication_aal_aal1_clockRecovery : public Asn :: Choice {
	public:
	explicit NewATMVCIndication_aal_aal1_clockRecovery ( Asn :: istream & is );
	NewATMVCIndication_aal_aal1_clockRecovery ( );
	enum Choices {
		e_nullClockRecovery,
		e_srtsClockRecovery,
		e_adaptiveClockRecovery
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	NewATMVCIndication_aal_aal1_clockRecovery * clone ( ) const;
};

//
// NewATMVCIndication_aal_aal1_errorCorrection
//

// from 0 size 0 type 0 simple 0
class NewATMVCIndication_aal_aal1_errorCorrection : public Asn :: Choice {
	public:
	explicit NewATMVCIndication_aal_aal1_errorCorrection ( Asn :: istream & is );
	NewATMVCIndication_aal_aal1_errorCorrection ( );
	enum Choices {
		e_nullErrorCorrection,
		e_longInterleaver,
		e_shortInterleaver,
		e_errorCorrectionOnly
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	NewATMVCIndication_aal_aal1_errorCorrection * clone ( ) const;
};

//
// NewATMVCIndication_aal_aal5_forwardMaximumSDUSize
//

// from 0 size 0 type 0 simple 1
class NewATMVCIndication_aal_aal5_forwardMaximumSDUSize : public Asn :: Integer {
	public:
	explicit NewATMVCIndication_aal_aal5_forwardMaximumSDUSize ( Asn :: istream & is );
	NewATMVCIndication_aal_aal5_forwardMaximumSDUSize ( unsigned v = 0 );
	NewATMVCIndication_aal_aal5_forwardMaximumSDUSize & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	NewATMVCIndication_aal_aal5_forwardMaximumSDUSize & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	NewATMVCIndication_aal_aal5_forwardMaximumSDUSize * clone ( ) const;
};

//
// NewATMVCIndication_aal_aal5_backwardMaximumSDUSize
//

// from 0 size 0 type 0 simple 1
class NewATMVCIndication_aal_aal5_backwardMaximumSDUSize : public Asn :: Integer {
	public:
	explicit NewATMVCIndication_aal_aal5_backwardMaximumSDUSize ( Asn :: istream & is );
	NewATMVCIndication_aal_aal5_backwardMaximumSDUSize ( unsigned v = 0 );
	NewATMVCIndication_aal_aal5_backwardMaximumSDUSize & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	NewATMVCIndication_aal_aal5_backwardMaximumSDUSize & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	NewATMVCIndication_aal_aal5_backwardMaximumSDUSize * clone ( ) const;
};

//
// UserInputIndication_signal_rtp_timestamp
//

// from 0 size 0 type 0 simple 1
class UserInputIndication_signal_rtp_timestamp : public Asn :: Integer {
	public:
	explicit UserInputIndication_signal_rtp_timestamp ( Asn :: istream & is );
	UserInputIndication_signal_rtp_timestamp ( unsigned v = 0 );
	UserInputIndication_signal_rtp_timestamp & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	UserInputIndication_signal_rtp_timestamp & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	UserInputIndication_signal_rtp_timestamp * clone ( ) const;
};

//
// UserInputIndication_signal_rtp_expirationTime
//

// from 0 size 0 type 0 simple 1
class UserInputIndication_signal_rtp_expirationTime : public Asn :: Integer {
	public:
	explicit UserInputIndication_signal_rtp_expirationTime ( Asn :: istream & is );
	UserInputIndication_signal_rtp_expirationTime ( unsigned v = 0 );
	UserInputIndication_signal_rtp_expirationTime & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	UserInputIndication_signal_rtp_expirationTime & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	UserInputIndication_signal_rtp_expirationTime * clone ( ) const;
};

//
// VCCapability_availableBitRates_type_rangeOfBitRates_lowerBitRate
//

// from 0 size 0 type 0 simple 1
class VCCapability_availableBitRates_type_rangeOfBitRates_lowerBitRate : public Asn :: Integer {
	public:
	explicit VCCapability_availableBitRates_type_rangeOfBitRates_lowerBitRate ( Asn :: istream & is );
	VCCapability_availableBitRates_type_rangeOfBitRates_lowerBitRate ( unsigned v = 0 );
	VCCapability_availableBitRates_type_rangeOfBitRates_lowerBitRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	VCCapability_availableBitRates_type_rangeOfBitRates_lowerBitRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	VCCapability_availableBitRates_type_rangeOfBitRates_lowerBitRate * clone ( ) const;
};

//
// VCCapability_availableBitRates_type_rangeOfBitRates_higherBitRate
//

// from 0 size 0 type 0 simple 1
class VCCapability_availableBitRates_type_rangeOfBitRates_higherBitRate : public Asn :: Integer {
	public:
	explicit VCCapability_availableBitRates_type_rangeOfBitRates_higherBitRate ( Asn :: istream & is );
	VCCapability_availableBitRates_type_rangeOfBitRates_higherBitRate ( unsigned v = 0 );
	VCCapability_availableBitRates_type_rangeOfBitRates_higherBitRate & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	VCCapability_availableBitRates_type_rangeOfBitRates_higherBitRate & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	VCCapability_availableBitRates_type_rangeOfBitRates_higherBitRate * clone ( ) const;
};

//
// CustomPictureFormat_mPI_customPCF_subtype_clockConversionCode
//

// from 0 size 0 type 0 simple 1
class CustomPictureFormat_mPI_customPCF_subtype_clockConversionCode : public Asn :: Integer {
	public:
	explicit CustomPictureFormat_mPI_customPCF_subtype_clockConversionCode ( Asn :: istream & is );
	CustomPictureFormat_mPI_customPCF_subtype_clockConversionCode ( unsigned v = 0 );
	CustomPictureFormat_mPI_customPCF_subtype_clockConversionCode & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CustomPictureFormat_mPI_customPCF_subtype_clockConversionCode & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CustomPictureFormat_mPI_customPCF_subtype_clockConversionCode * clone ( ) const;
};

//
// CustomPictureFormat_mPI_customPCF_subtype_clockDivisor
//

// from 0 size 0 type 0 simple 1
class CustomPictureFormat_mPI_customPCF_subtype_clockDivisor : public Asn :: Integer {
	public:
	explicit CustomPictureFormat_mPI_customPCF_subtype_clockDivisor ( Asn :: istream & is );
	CustomPictureFormat_mPI_customPCF_subtype_clockDivisor ( unsigned v = 0 );
	CustomPictureFormat_mPI_customPCF_subtype_clockDivisor & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CustomPictureFormat_mPI_customPCF_subtype_clockDivisor & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CustomPictureFormat_mPI_customPCF_subtype_clockDivisor * clone ( ) const;
};

//
// CustomPictureFormat_mPI_customPCF_subtype_customMPI
//

// from 0 size 0 type 0 simple 1
class CustomPictureFormat_mPI_customPCF_subtype_customMPI : public Asn :: Integer {
	public:
	explicit CustomPictureFormat_mPI_customPCF_subtype_customMPI ( Asn :: istream & is );
	CustomPictureFormat_mPI_customPCF_subtype_customMPI ( unsigned v = 0 );
	CustomPictureFormat_mPI_customPCF_subtype_customMPI & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CustomPictureFormat_mPI_customPCF_subtype_customMPI & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CustomPictureFormat_mPI_customPCF_subtype_customMPI * clone ( ) const;
};

//
// CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype_width
//

// from 0 size 0 type 0 simple 1
class CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype_width : public Asn :: Integer {
	public:
	explicit CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype_width ( Asn :: istream & is );
	CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype_width ( unsigned v = 0 );
	CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype_width & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype_width & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype_width * clone ( ) const;
};

//
// CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype_height
//

// from 0 size 0 type 0 simple 1
class CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype_height : public Asn :: Integer {
	public:
	explicit CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype_height ( Asn :: istream & is );
	CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype_height ( unsigned v = 0 );
	CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype_height & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype_height & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype_height * clone ( ) const;
};

//
// DepFECData_rfc2733_mode_separateStream_differentPort_protectedSessionID
//

// from 0 size 0 type 0 simple 1
class DepFECData_rfc2733_mode_separateStream_differentPort_protectedSessionID : public Asn :: Integer {
	public:
	explicit DepFECData_rfc2733_mode_separateStream_differentPort_protectedSessionID ( Asn :: istream & is );
	DepFECData_rfc2733_mode_separateStream_differentPort_protectedSessionID ( unsigned v = 0 );
	DepFECData_rfc2733_mode_separateStream_differentPort_protectedSessionID & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	DepFECData_rfc2733_mode_separateStream_differentPort_protectedSessionID & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	DepFECData_rfc2733_mode_separateStream_differentPort_protectedSessionID * clone ( ) const;
};

//
// DepFECData_rfc2733_mode_separateStream_differentPort_protectedPayloadType
//

// from 0 size 0 type 0 simple 1
class DepFECData_rfc2733_mode_separateStream_differentPort_protectedPayloadType : public Asn :: Integer {
	public:
	explicit DepFECData_rfc2733_mode_separateStream_differentPort_protectedPayloadType ( Asn :: istream & is );
	DepFECData_rfc2733_mode_separateStream_differentPort_protectedPayloadType ( unsigned v = 0 );
	DepFECData_rfc2733_mode_separateStream_differentPort_protectedPayloadType & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	DepFECData_rfc2733_mode_separateStream_differentPort_protectedPayloadType & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	DepFECData_rfc2733_mode_separateStream_differentPort_protectedPayloadType * clone ( ) const;
};

//
// DepFECData_rfc2733_mode_separateStream_samePort_protectedPayloadType
//

// from 0 size 0 type 0 simple 1
class DepFECData_rfc2733_mode_separateStream_samePort_protectedPayloadType : public Asn :: Integer {
	public:
	explicit DepFECData_rfc2733_mode_separateStream_samePort_protectedPayloadType ( Asn :: istream & is );
	DepFECData_rfc2733_mode_separateStream_samePort_protectedPayloadType ( unsigned v = 0 );
	DepFECData_rfc2733_mode_separateStream_samePort_protectedPayloadType & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	DepFECData_rfc2733_mode_separateStream_samePort_protectedPayloadType & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	DepFECData_rfc2733_mode_separateStream_samePort_protectedPayloadType * clone ( ) const;
};

//
// DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedSessionID
//

// from 0 size 0 type 0 simple 1
class DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedSessionID : public Asn :: Integer {
	public:
	explicit DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedSessionID ( Asn :: istream & is );
	DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedSessionID ( unsigned v = 0 );
	DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedSessionID & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedSessionID & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedSessionID * clone ( ) const;
};

//
// DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedPayloadType
//

// from 0 size 0 type 0 simple 1
class DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedPayloadType : public Asn :: Integer {
	public:
	explicit DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedPayloadType ( Asn :: istream & is );
	DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedPayloadType ( unsigned v = 0 );
	DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedPayloadType & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedPayloadType & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedPayloadType * clone ( ) const;
};

//
// MasterSlaveDetermination
//

// from 0 size 0 type 0 simple 0
class MasterSlaveDetermination : public Asn :: Sequence {
	public:
	explicit MasterSlaveDetermination ( Asn :: istream & is );
	MasterSlaveDetermination ( );
	MasterSlaveDetermination_terminalType m_terminalType;
	MasterSlaveDetermination_statusDeterminationNumber m_statusDeterminationNumber;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MasterSlaveDetermination * clone ( ) const;
};

//
// MasterSlaveDeterminationAck
//

// from 0 size 0 type 0 simple 0
class MasterSlaveDeterminationAck : public Asn :: Sequence {
	public:
	explicit MasterSlaveDeterminationAck ( Asn :: istream & is );
	MasterSlaveDeterminationAck ( );
	MasterSlaveDeterminationAck_decision m_decision;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MasterSlaveDeterminationAck * clone ( ) const;
};

//
// MasterSlaveDeterminationReject
//

// from 0 size 0 type 0 simple 0
class MasterSlaveDeterminationReject : public Asn :: Sequence {
	public:
	explicit MasterSlaveDeterminationReject ( Asn :: istream & is );
	MasterSlaveDeterminationReject ( );
	MasterSlaveDeterminationReject_cause m_cause;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MasterSlaveDeterminationReject * clone ( ) const;
};

//
// CapabilityTableEntry
//

// from 0 size 0 type 0 simple 0
class Capability;

class CapabilityTableEntry : public Asn :: Sequence {
	public:
	explicit CapabilityTableEntry ( Asn :: istream & is );
	CapabilityTableEntry ( );
	enum OptionalFields {
		e_capability
	};

	CapabilityTableEntry ( const CapabilityTableEntry & s );
	CapabilityTableEntry & operator= ( const CapabilityTableEntry & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	CapabilityTableEntryNumber m_capabilityTableEntryNumber;
	protected:
	Capability * m_capability;
	public:
	void encode ( Asn :: ostream & os ) const;
	~CapabilityTableEntry ( );
	void printOn ( std :: ostream & os ) const;
	const Capability & get_capability ( ) const {
		return * m_capability;
	}
	Capability & get_capability ( ) {
		return * m_capability;
	}
	CapabilityTableEntry * clone ( ) const;
};

//
// CapabilityDescriptor
//

// from 0 size 0 type 0 simple 0
class CapabilityDescriptor : public Asn :: Sequence {
	public:
	explicit CapabilityDescriptor ( Asn :: istream & is );
	CapabilityDescriptor ( );
	enum OptionalFields {
		e_simultaneousCapabilities
	};

	CapabilityDescriptor ( const CapabilityDescriptor & s );
	CapabilityDescriptor & operator= ( const CapabilityDescriptor & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	CapabilityDescriptorNumber m_capabilityDescriptorNumber;
	protected:
	CapabilityDescriptor_simultaneousCapabilities * m_simultaneousCapabilities;
	public:
	void encode ( Asn :: ostream & os ) const;
	~CapabilityDescriptor ( );
	void printOn ( std :: ostream & os ) const;
	const CapabilityDescriptor_simultaneousCapabilities & get_simultaneousCapabilities ( ) const {
		return * m_simultaneousCapabilities;
	}
	CapabilityDescriptor_simultaneousCapabilities & get_simultaneousCapabilities ( ) {
		return * m_simultaneousCapabilities;
	}
	CapabilityDescriptor * clone ( ) const;
};

//
// H235SecurityCapability
//

// from 0 size 0 type 0 simple 0
class H235SecurityCapability : public Asn :: Sequence {
	public:
	explicit H235SecurityCapability ( Asn :: istream & is );
	H235SecurityCapability ( );
	EncryptionAuthenticationAndIntegrity m_encryptionAuthenticationAndIntegrity;
	CapabilityTableEntryNumber m_mediaCapability;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	H235SecurityCapability * clone ( ) const;
};

//
// H222Capability
//

// from 0 size 0 type 0 simple 0
class H222Capability : public Asn :: Sequence {
	public:
	explicit H222Capability ( Asn :: istream & is );
	H222Capability ( );
	H222Capability_numberOfVCs m_numberOfVCs;
	ArrayOf_VCCapability m_vcCapability;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	H222Capability * clone ( ) const;
};

//
// H223AnnexCCapability
//

// from 0 size 0 type 0 simple 0
class H223AnnexCCapability : public Asn :: Sequence {
	public:
	explicit H223AnnexCCapability ( Asn :: istream & is );
	H223AnnexCCapability ( );
	enum OptionalFields {
		e_rsCodeCapability
	};

	H223AnnexCCapability ( const H223AnnexCCapability & s );
	H223AnnexCCapability & operator= ( const H223AnnexCCapability & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	Asn :: Boolean m_videoWithAL1M;
	Asn :: Boolean m_videoWithAL2M;
	Asn :: Boolean m_videoWithAL3M;
	Asn :: Boolean m_audioWithAL1M;
	Asn :: Boolean m_audioWithAL2M;
	Asn :: Boolean m_audioWithAL3M;
	Asn :: Boolean m_dataWithAL1M;
	Asn :: Boolean m_dataWithAL2M;
	Asn :: Boolean m_dataWithAL3M;
	Asn :: Boolean m_alpduInterleaving;
	H223AnnexCCapability_maximumAL1MPDUSize m_maximumAL1MPDUSize;
	H223AnnexCCapability_maximumAL2MSDUSize m_maximumAL2MSDUSize;
	H223AnnexCCapability_maximumAL3MSDUSize m_maximumAL3MSDUSize;
	protected:
	Asn :: Boolean * m_rsCodeCapability;
	public:
	void encode ( Asn :: ostream & os ) const;
	~H223AnnexCCapability ( );
	void printOn ( std :: ostream & os ) const;
	const Asn :: Boolean & get_rsCodeCapability ( ) const {
		return * m_rsCodeCapability;
	}
	Asn :: Boolean & get_rsCodeCapability ( ) {
		return * m_rsCodeCapability;
	}
	H223AnnexCCapability * clone ( ) const;
};

//
// V76Capability
//

// from 0 size 0 type 0 simple 0
class V76Capability : public Asn :: Sequence {
	public:
	explicit V76Capability ( Asn :: istream & is );
	V76Capability ( );
	Asn :: Boolean m_suspendResumeCapabilitywAddress;
	Asn :: Boolean m_suspendResumeCapabilitywoAddress;
	Asn :: Boolean m_rejCapability;
	Asn :: Boolean m_sREJCapability;
	Asn :: Boolean m_mREJCapability;
	Asn :: Boolean m_crc8bitCapability;
	Asn :: Boolean m_crc16bitCapability;
	Asn :: Boolean m_crc32bitCapability;
	Asn :: Boolean m_uihCapability;
	V76Capability_numOfDLCS m_numOfDLCS;
	Asn :: Boolean m_twoOctetAddressFieldCapability;
	Asn :: Boolean m_loopBackTestCapability;
	V76Capability_n401Capability m_n401Capability;
	V76Capability_maxWindowSizeCapability m_maxWindowSizeCapability;
	V75Capability m_v75Capability;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	V76Capability * clone ( ) const;
};

//
// ATMParameters
//

// from 0 size 0 type 0 simple 0
class ATMParameters : public Asn :: Sequence {
	public:
	explicit ATMParameters ( Asn :: istream & is );
	ATMParameters ( );
	ATMParameters_maxNTUSize m_maxNTUSize;
	Asn :: Boolean m_atmUBR;
	Asn :: Boolean m_atmrtVBR;
	Asn :: Boolean m_atmnrtVBR;
	Asn :: Boolean m_atmABR;
	Asn :: Boolean m_atmCBR;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	ATMParameters * clone ( ) const;
};

//
// MediaTransportType
//

// from 0 size 0 type 0 simple 0
class MediaTransportType : public Asn :: Choice {
	public:
	explicit MediaTransportType ( Asn :: istream & is );
	MediaTransportType ( );
	enum Choices {
		e_ip_UDP,
		e_ip_TCP,
		e_atm_AAL5_UNIDIR,
		e_atm_AAL5_BIDIR,
		e_atm_AAL5_compressed
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator MediaTransportType_atm_AAL5_compressed & ( ) { return dynamic_cast < MediaTransportType_atm_AAL5_compressed & > ( * choice ); }
	operator const MediaTransportType_atm_AAL5_compressed & ( ) const { return dynamic_cast < const MediaTransportType_atm_AAL5_compressed & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	MediaTransportType * clone ( ) const;
};

//
// RTPH263VideoRedundancyFrameMapping
//

// from 0 size 0 type 0 simple 0
class RTPH263VideoRedundancyFrameMapping : public Asn :: Sequence {
	public:
	explicit RTPH263VideoRedundancyFrameMapping ( Asn :: istream & is );
	RTPH263VideoRedundancyFrameMapping ( );
	RTPH263VideoRedundancyFrameMapping_threadNumber m_threadNumber;
	RTPH263VideoRedundancyFrameMapping_frameSequence m_frameSequence;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	RTPH263VideoRedundancyFrameMapping * clone ( ) const;
};

//
// MultipointCapability
//

// from 0 size 0 type 0 simple 0
class MultipointCapability : public Asn :: Sequence {
	public:
	explicit MultipointCapability ( Asn :: istream & is );
	MultipointCapability ( );
	Asn :: Boolean m_multicastCapability;
	Asn :: Boolean m_multiUniCastConference;
	ArrayOf_MediaDistributionCapability m_mediaDistributionCapability;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MultipointCapability * clone ( ) const;
};

//
// ExtendedVideoCapability
//

// from 0 size 0 type 0 simple 0
class ExtendedVideoCapability : public Asn :: Sequence {
	public:
	explicit ExtendedVideoCapability ( Asn :: istream & is );
	ExtendedVideoCapability ( );
	enum OptionalFields {
		e_videoCapabilityExtension
	};

	ExtendedVideoCapability ( const ExtendedVideoCapability & s );
	ExtendedVideoCapability & operator= ( const ExtendedVideoCapability & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	ArrayOf_VideoCapability m_videoCapability;
	protected:
	ArrayOf_GenericCapability * m_videoCapabilityExtension;
	public:
	void encode ( Asn :: ostream & os ) const;
	~ExtendedVideoCapability ( );
	void printOn ( std :: ostream & os ) const;
	const ArrayOf_GenericCapability & get_videoCapabilityExtension ( ) const {
		return * m_videoCapabilityExtension;
	}
	ArrayOf_GenericCapability & get_videoCapabilityExtension ( ) {
		return * m_videoCapabilityExtension;
	}
	ExtendedVideoCapability * clone ( ) const;
};

//
// H261VideoCapability
//

// from 0 size 0 type 0 simple 0
class H261VideoCapability : public Asn :: Sequence {
	public:
	explicit H261VideoCapability ( Asn :: istream & is );
	H261VideoCapability ( );
	enum OptionalFields {
		e_qcifMPI,
		e_cifMPI,
		e_videoBadMBsCap
	};

	H261VideoCapability ( const H261VideoCapability & s );
	H261VideoCapability & operator= ( const H261VideoCapability & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	H261VideoCapability_qcifMPI * m_qcifMPI;
	H261VideoCapability_cifMPI * m_cifMPI;
	public:
	Asn :: Boolean m_temporalSpatialTradeOffCapability;
	H261VideoCapability_maxBitRate m_maxBitRate;
	Asn :: Boolean m_stillImageTransmission;
	protected:
	Asn :: Boolean * m_videoBadMBsCap;
	public:
	void encode ( Asn :: ostream & os ) const;
	~H261VideoCapability ( );
	void printOn ( std :: ostream & os ) const;
	const H261VideoCapability_qcifMPI & get_qcifMPI ( ) const {
		return * m_qcifMPI;
	}
	H261VideoCapability_qcifMPI & get_qcifMPI ( ) {
		return * m_qcifMPI;
	}
	const H261VideoCapability_cifMPI & get_cifMPI ( ) const {
		return * m_cifMPI;
	}
	H261VideoCapability_cifMPI & get_cifMPI ( ) {
		return * m_cifMPI;
	}
	const Asn :: Boolean & get_videoBadMBsCap ( ) const {
		return * m_videoBadMBsCap;
	}
	Asn :: Boolean & get_videoBadMBsCap ( ) {
		return * m_videoBadMBsCap;
	}
	H261VideoCapability * clone ( ) const;
};

//
// H263VideoCapability
//

// from 0 size 0 type 0 simple 0
class H263VideoCapability : public Asn :: Sequence {
	public:
	explicit H263VideoCapability ( Asn :: istream & is );
	H263VideoCapability ( );
	enum OptionalFields {
		e_sqcifMPI,
		e_qcifMPI,
		e_cifMPI,
		e_cif4MPI,
		e_cif16MPI,
		e_hrd_B,
		e_bppMaxKb,
		e_slowSqcifMPI,
		e_slowQcifMPI,
		e_slowCifMPI,
		e_slowCif4MPI,
		e_slowCif16MPI,
		e_errorCompensation,
		e_enhancementLayerInfo,
		e_h263Options
	};

	H263VideoCapability ( const H263VideoCapability & s );
	H263VideoCapability & operator= ( const H263VideoCapability & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	H263VideoCapability_sqcifMPI * m_sqcifMPI;
	H263VideoCapability_qcifMPI * m_qcifMPI;
	H263VideoCapability_cifMPI * m_cifMPI;
	H263VideoCapability_cif4MPI * m_cif4MPI;
	H263VideoCapability_cif16MPI * m_cif16MPI;
	public:
	H263VideoCapability_maxBitRate m_maxBitRate;
	Asn :: Boolean m_unrestrictedVector;
	Asn :: Boolean m_arithmeticCoding;
	Asn :: Boolean m_advancedPrediction;
	Asn :: Boolean m_pbFrames;
	Asn :: Boolean m_temporalSpatialTradeOffCapability;
	protected:
	H263VideoCapability_hrd_B * m_hrd_B;
	H263VideoCapability_bppMaxKb * m_bppMaxKb;
	H263VideoCapability_slowSqcifMPI * m_slowSqcifMPI;
	H263VideoCapability_slowQcifMPI * m_slowQcifMPI;
	H263VideoCapability_slowCifMPI * m_slowCifMPI;
	H263VideoCapability_slowCif4MPI * m_slowCif4MPI;
	H263VideoCapability_slowCif16MPI * m_slowCif16MPI;
	Asn :: Boolean * m_errorCompensation;
	EnhancementLayerInfo * m_enhancementLayerInfo;
	H263Options * m_h263Options;
	public:
	void encode ( Asn :: ostream & os ) const;
	~H263VideoCapability ( );
	void printOn ( std :: ostream & os ) const;
	const H263VideoCapability_sqcifMPI & get_sqcifMPI ( ) const {
		return * m_sqcifMPI;
	}
	H263VideoCapability_sqcifMPI & get_sqcifMPI ( ) {
		return * m_sqcifMPI;
	}
	const H263VideoCapability_qcifMPI & get_qcifMPI ( ) const {
		return * m_qcifMPI;
	}
	H263VideoCapability_qcifMPI & get_qcifMPI ( ) {
		return * m_qcifMPI;
	}
	const H263VideoCapability_cifMPI & get_cifMPI ( ) const {
		return * m_cifMPI;
	}
	H263VideoCapability_cifMPI & get_cifMPI ( ) {
		return * m_cifMPI;
	}
	const H263VideoCapability_cif4MPI & get_cif4MPI ( ) const {
		return * m_cif4MPI;
	}
	H263VideoCapability_cif4MPI & get_cif4MPI ( ) {
		return * m_cif4MPI;
	}
	const H263VideoCapability_cif16MPI & get_cif16MPI ( ) const {
		return * m_cif16MPI;
	}
	H263VideoCapability_cif16MPI & get_cif16MPI ( ) {
		return * m_cif16MPI;
	}
	const H263VideoCapability_hrd_B & get_hrd_B ( ) const {
		return * m_hrd_B;
	}
	H263VideoCapability_hrd_B & get_hrd_B ( ) {
		return * m_hrd_B;
	}
	const H263VideoCapability_bppMaxKb & get_bppMaxKb ( ) const {
		return * m_bppMaxKb;
	}
	H263VideoCapability_bppMaxKb & get_bppMaxKb ( ) {
		return * m_bppMaxKb;
	}
	const H263VideoCapability_slowSqcifMPI & get_slowSqcifMPI ( ) const {
		return * m_slowSqcifMPI;
	}
	H263VideoCapability_slowSqcifMPI & get_slowSqcifMPI ( ) {
		return * m_slowSqcifMPI;
	}
	const H263VideoCapability_slowQcifMPI & get_slowQcifMPI ( ) const {
		return * m_slowQcifMPI;
	}
	H263VideoCapability_slowQcifMPI & get_slowQcifMPI ( ) {
		return * m_slowQcifMPI;
	}
	const H263VideoCapability_slowCifMPI & get_slowCifMPI ( ) const {
		return * m_slowCifMPI;
	}
	H263VideoCapability_slowCifMPI & get_slowCifMPI ( ) {
		return * m_slowCifMPI;
	}
	const H263VideoCapability_slowCif4MPI & get_slowCif4MPI ( ) const {
		return * m_slowCif4MPI;
	}
	H263VideoCapability_slowCif4MPI & get_slowCif4MPI ( ) {
		return * m_slowCif4MPI;
	}
	const H263VideoCapability_slowCif16MPI & get_slowCif16MPI ( ) const {
		return * m_slowCif16MPI;
	}
	H263VideoCapability_slowCif16MPI & get_slowCif16MPI ( ) {
		return * m_slowCif16MPI;
	}
	const Asn :: Boolean & get_errorCompensation ( ) const {
		return * m_errorCompensation;
	}
	Asn :: Boolean & get_errorCompensation ( ) {
		return * m_errorCompensation;
	}
	const EnhancementLayerInfo & get_enhancementLayerInfo ( ) const {
		return * m_enhancementLayerInfo;
	}
	EnhancementLayerInfo & get_enhancementLayerInfo ( ) {
		return * m_enhancementLayerInfo;
	}
	const H263Options & get_h263Options ( ) const {
		return * m_h263Options;
	}
	H263Options & get_h263Options ( ) {
		return * m_h263Options;
	}
	H263VideoCapability * clone ( ) const;
};

//
// EnhancementOptions
//

// from 0 size 0 type 0 simple 0
class EnhancementOptions : public Asn :: Sequence {
	public:
	explicit EnhancementOptions ( Asn :: istream & is );
	EnhancementOptions ( );
	enum OptionalFields {
		e_sqcifMPI,
		e_qcifMPI,
		e_cifMPI,
		e_cif4MPI,
		e_cif16MPI,
		e_slowSqcifMPI,
		e_slowQcifMPI,
		e_slowCifMPI,
		e_slowCif4MPI,
		e_slowCif16MPI,
		e_h263Options
	};

	EnhancementOptions ( const EnhancementOptions & s );
	EnhancementOptions & operator= ( const EnhancementOptions & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	EnhancementOptions_sqcifMPI * m_sqcifMPI;
	EnhancementOptions_qcifMPI * m_qcifMPI;
	EnhancementOptions_cifMPI * m_cifMPI;
	EnhancementOptions_cif4MPI * m_cif4MPI;
	EnhancementOptions_cif16MPI * m_cif16MPI;
	public:
	EnhancementOptions_maxBitRate m_maxBitRate;
	Asn :: Boolean m_unrestrictedVector;
	Asn :: Boolean m_arithmeticCoding;
	Asn :: Boolean m_temporalSpatialTradeOffCapability;
	protected:
	EnhancementOptions_slowSqcifMPI * m_slowSqcifMPI;
	EnhancementOptions_slowQcifMPI * m_slowQcifMPI;
	EnhancementOptions_slowCifMPI * m_slowCifMPI;
	EnhancementOptions_slowCif4MPI * m_slowCif4MPI;
	EnhancementOptions_slowCif16MPI * m_slowCif16MPI;
	public:
	Asn :: Boolean m_errorCompensation;
	protected:
	H263Options * m_h263Options;
	public:
	void encode ( Asn :: ostream & os ) const;
	~EnhancementOptions ( );
	void printOn ( std :: ostream & os ) const;
	const EnhancementOptions_sqcifMPI & get_sqcifMPI ( ) const {
		return * m_sqcifMPI;
	}
	EnhancementOptions_sqcifMPI & get_sqcifMPI ( ) {
		return * m_sqcifMPI;
	}
	const EnhancementOptions_qcifMPI & get_qcifMPI ( ) const {
		return * m_qcifMPI;
	}
	EnhancementOptions_qcifMPI & get_qcifMPI ( ) {
		return * m_qcifMPI;
	}
	const EnhancementOptions_cifMPI & get_cifMPI ( ) const {
		return * m_cifMPI;
	}
	EnhancementOptions_cifMPI & get_cifMPI ( ) {
		return * m_cifMPI;
	}
	const EnhancementOptions_cif4MPI & get_cif4MPI ( ) const {
		return * m_cif4MPI;
	}
	EnhancementOptions_cif4MPI & get_cif4MPI ( ) {
		return * m_cif4MPI;
	}
	const EnhancementOptions_cif16MPI & get_cif16MPI ( ) const {
		return * m_cif16MPI;
	}
	EnhancementOptions_cif16MPI & get_cif16MPI ( ) {
		return * m_cif16MPI;
	}
	const EnhancementOptions_slowSqcifMPI & get_slowSqcifMPI ( ) const {
		return * m_slowSqcifMPI;
	}
	EnhancementOptions_slowSqcifMPI & get_slowSqcifMPI ( ) {
		return * m_slowSqcifMPI;
	}
	const EnhancementOptions_slowQcifMPI & get_slowQcifMPI ( ) const {
		return * m_slowQcifMPI;
	}
	EnhancementOptions_slowQcifMPI & get_slowQcifMPI ( ) {
		return * m_slowQcifMPI;
	}
	const EnhancementOptions_slowCifMPI & get_slowCifMPI ( ) const {
		return * m_slowCifMPI;
	}
	EnhancementOptions_slowCifMPI & get_slowCifMPI ( ) {
		return * m_slowCifMPI;
	}
	const EnhancementOptions_slowCif4MPI & get_slowCif4MPI ( ) const {
		return * m_slowCif4MPI;
	}
	EnhancementOptions_slowCif4MPI & get_slowCif4MPI ( ) {
		return * m_slowCif4MPI;
	}
	const EnhancementOptions_slowCif16MPI & get_slowCif16MPI ( ) const {
		return * m_slowCif16MPI;
	}
	EnhancementOptions_slowCif16MPI & get_slowCif16MPI ( ) {
		return * m_slowCif16MPI;
	}
	const H263Options & get_h263Options ( ) const {
		return * m_h263Options;
	}
	H263Options & get_h263Options ( ) {
		return * m_h263Options;
	}
	EnhancementOptions * clone ( ) const;
};

//
// TransparencyParameters
//

// from 0 size 0 type 0 simple 0
class TransparencyParameters : public Asn :: Sequence {
	public:
	explicit TransparencyParameters ( Asn :: istream & is );
	TransparencyParameters ( );
	TransparencyParameters_presentationOrder m_presentationOrder;
	TransparencyParameters_offset_x m_offset_x;
	TransparencyParameters_offset_y m_offset_y;
	TransparencyParameters_scale_x m_scale_x;
	TransparencyParameters_scale_y m_scale_y;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	TransparencyParameters * clone ( ) const;
};

//
// RefPictureSelection
//

// from 0 size 0 type 0 simple 0
class RefPictureSelection : public Asn :: Sequence {
	public:
	explicit RefPictureSelection ( Asn :: istream & is );
	RefPictureSelection ( );
	enum OptionalFields {
		e_additionalPictureMemory,
		e_enhancedReferencePicSelect
	};

	RefPictureSelection ( const RefPictureSelection & s );
	RefPictureSelection & operator= ( const RefPictureSelection & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	RefPictureSelection_additionalPictureMemory * m_additionalPictureMemory;
	public:
	Asn :: Boolean m_videoMux;
	RefPictureSelection_videoBackChannelSend m_videoBackChannelSend;
	protected:
	RefPictureSelection_enhancedReferencePicSelect * m_enhancedReferencePicSelect;
	public:
	void encode ( Asn :: ostream & os ) const;
	~RefPictureSelection ( );
	void printOn ( std :: ostream & os ) const;
	const RefPictureSelection_additionalPictureMemory & get_additionalPictureMemory ( ) const {
		return * m_additionalPictureMemory;
	}
	RefPictureSelection_additionalPictureMemory & get_additionalPictureMemory ( ) {
		return * m_additionalPictureMemory;
	}
	const RefPictureSelection_enhancedReferencePicSelect & get_enhancedReferencePicSelect ( ) const {
		return * m_enhancedReferencePicSelect;
	}
	RefPictureSelection_enhancedReferencePicSelect & get_enhancedReferencePicSelect ( ) {
		return * m_enhancedReferencePicSelect;
	}
	RefPictureSelection * clone ( ) const;
};

//
// CustomPictureClockFrequency
//

// from 0 size 0 type 0 simple 0
class CustomPictureClockFrequency : public Asn :: Sequence {
	public:
	explicit CustomPictureClockFrequency ( Asn :: istream & is );
	CustomPictureClockFrequency ( );
	enum OptionalFields {
		e_sqcifMPI,
		e_qcifMPI,
		e_cifMPI,
		e_cif4MPI,
		e_cif16MPI
	};

	CustomPictureClockFrequency ( const CustomPictureClockFrequency & s );
	CustomPictureClockFrequency & operator= ( const CustomPictureClockFrequency & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	CustomPictureClockFrequency_clockConversionCode m_clockConversionCode;
	CustomPictureClockFrequency_clockDivisor m_clockDivisor;
	protected:
	CustomPictureClockFrequency_sqcifMPI * m_sqcifMPI;
	CustomPictureClockFrequency_qcifMPI * m_qcifMPI;
	CustomPictureClockFrequency_cifMPI * m_cifMPI;
	CustomPictureClockFrequency_cif4MPI * m_cif4MPI;
	CustomPictureClockFrequency_cif16MPI * m_cif16MPI;
	public:
	void encode ( Asn :: ostream & os ) const;
	~CustomPictureClockFrequency ( );
	void printOn ( std :: ostream & os ) const;
	const CustomPictureClockFrequency_sqcifMPI & get_sqcifMPI ( ) const {
		return * m_sqcifMPI;
	}
	CustomPictureClockFrequency_sqcifMPI & get_sqcifMPI ( ) {
		return * m_sqcifMPI;
	}
	const CustomPictureClockFrequency_qcifMPI & get_qcifMPI ( ) const {
		return * m_qcifMPI;
	}
	CustomPictureClockFrequency_qcifMPI & get_qcifMPI ( ) {
		return * m_qcifMPI;
	}
	const CustomPictureClockFrequency_cifMPI & get_cifMPI ( ) const {
		return * m_cifMPI;
	}
	CustomPictureClockFrequency_cifMPI & get_cifMPI ( ) {
		return * m_cifMPI;
	}
	const CustomPictureClockFrequency_cif4MPI & get_cif4MPI ( ) const {
		return * m_cif4MPI;
	}
	CustomPictureClockFrequency_cif4MPI & get_cif4MPI ( ) {
		return * m_cif4MPI;
	}
	const CustomPictureClockFrequency_cif16MPI & get_cif16MPI ( ) const {
		return * m_cif16MPI;
	}
	CustomPictureClockFrequency_cif16MPI & get_cif16MPI ( ) {
		return * m_cif16MPI;
	}
	CustomPictureClockFrequency * clone ( ) const;
};

//
// H263VideoModeCombos
//

// from 0 size 0 type 0 simple 0
class H263VideoModeCombos : public Asn :: Sequence {
	public:
	explicit H263VideoModeCombos ( Asn :: istream & is );
	H263VideoModeCombos ( );
	H263ModeComboFlags m_h263VideoUncoupledModes;
	H263VideoModeCombos_h263VideoCoupledModes m_h263VideoCoupledModes;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	H263VideoModeCombos * clone ( ) const;
};

//
// G7231AnnexCCapability
//

// from 0 size 0 type 0 simple 0
class G7231AnnexCCapability_g723AnnexCAudioMode;

class G7231AnnexCCapability : public Asn :: Sequence {
	public:
	explicit G7231AnnexCCapability ( Asn :: istream & is );
	G7231AnnexCCapability ( );
	enum OptionalFields {
		e_g723AnnexCAudioMode
	};

	G7231AnnexCCapability ( const G7231AnnexCCapability & s );
	G7231AnnexCCapability & operator= ( const G7231AnnexCCapability & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	G7231AnnexCCapability_maxAl_sduAudioFrames m_maxAl_sduAudioFrames;
	Asn :: Boolean m_silenceSuppression;
	protected:
	G7231AnnexCCapability_g723AnnexCAudioMode * m_g723AnnexCAudioMode;
	public:
	void encode ( Asn :: ostream & os ) const;
	~G7231AnnexCCapability ( );
	void printOn ( std :: ostream & os ) const;
	const G7231AnnexCCapability_g723AnnexCAudioMode & get_g723AnnexCAudioMode ( ) const {
		return * m_g723AnnexCAudioMode;
	}
	G7231AnnexCCapability_g723AnnexCAudioMode & get_g723AnnexCAudioMode ( ) {
		return * m_g723AnnexCAudioMode;
	}
	G7231AnnexCCapability * clone ( ) const;
};

//
// IS11172AudioCapability
//

// from 0 size 0 type 0 simple 0
class IS11172AudioCapability : public Asn :: Sequence {
	public:
	explicit IS11172AudioCapability ( Asn :: istream & is );
	IS11172AudioCapability ( );
	Asn :: Boolean m_audioLayer1;
	Asn :: Boolean m_audioLayer2;
	Asn :: Boolean m_audioLayer3;
	Asn :: Boolean m_audioSampling32k;
	Asn :: Boolean m_audioSampling44k1;
	Asn :: Boolean m_audioSampling48k;
	Asn :: Boolean m_singleChannel;
	Asn :: Boolean m_twoChannels;
	IS11172AudioCapability_bitRate m_bitRate;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	IS11172AudioCapability * clone ( ) const;
};

//
// IS13818AudioCapability
//

// from 0 size 0 type 0 simple 0
class IS13818AudioCapability : public Asn :: Sequence {
	public:
	explicit IS13818AudioCapability ( Asn :: istream & is );
	IS13818AudioCapability ( );
	Asn :: Boolean m_audioLayer1;
	Asn :: Boolean m_audioLayer2;
	Asn :: Boolean m_audioLayer3;
	Asn :: Boolean m_audioSampling16k;
	Asn :: Boolean m_audioSampling22k05;
	Asn :: Boolean m_audioSampling24k;
	Asn :: Boolean m_audioSampling32k;
	Asn :: Boolean m_audioSampling44k1;
	Asn :: Boolean m_audioSampling48k;
	Asn :: Boolean m_singleChannel;
	Asn :: Boolean m_twoChannels;
	Asn :: Boolean m_threeChannels2_1;
	Asn :: Boolean m_threeChannels3_0;
	Asn :: Boolean m_fourChannels2_0_2_0;
	Asn :: Boolean m_fourChannels2_2;
	Asn :: Boolean m_fourChannels3_1;
	Asn :: Boolean m_fiveChannels3_0_2_0;
	Asn :: Boolean m_fiveChannels3_2;
	Asn :: Boolean m_lowFrequencyEnhancement;
	Asn :: Boolean m_multilingual;
	IS13818AudioCapability_bitRate m_bitRate;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	IS13818AudioCapability * clone ( ) const;
};

//
// GSMAudioCapability
//

// from 0 size 0 type 0 simple 0
class GSMAudioCapability : public Asn :: Sequence {
	public:
	explicit GSMAudioCapability ( Asn :: istream & is );
	GSMAudioCapability ( );
	GSMAudioCapability_audioUnitSize m_audioUnitSize;
	Asn :: Boolean m_comfortNoise;
	Asn :: Boolean m_scrambled;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	GSMAudioCapability * clone ( ) const;
};

//
// V42bis
//

// from 0 size 0 type 0 simple 0
class V42bis : public Asn :: Sequence {
	public:
	explicit V42bis ( Asn :: istream & is );
	V42bis ( );
	V42bis_numberOfCodewords m_numberOfCodewords;
	V42bis_maximumStringLength m_maximumStringLength;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	V42bis * clone ( ) const;
};

//
// T84Profile
//

// from 0 size 0 type 0 simple 0
class T84Profile : public Asn :: Choice {
	public:
	explicit T84Profile ( Asn :: istream & is );
	T84Profile ( );
	enum Choices {
		e_t84Unrestricted,
		e_t84Restricted
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator T84Profile_t84Restricted & ( ) { return dynamic_cast < T84Profile_t84Restricted & > ( * choice ); }
	operator const T84Profile_t84Restricted & ( ) const { return dynamic_cast < const T84Profile_t84Restricted & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	T84Profile * clone ( ) const;
};

//
// T38FaxUdpOptions
//

// from 0 size 0 type 0 simple 0
class T38FaxUdpOptions : public Asn :: Sequence {
	public:
	explicit T38FaxUdpOptions ( Asn :: istream & is );
	T38FaxUdpOptions ( );
	enum OptionalFields {
		e_t38FaxMaxBuffer,
		e_t38FaxMaxDatagram
	};

	T38FaxUdpOptions ( const T38FaxUdpOptions & s );
	T38FaxUdpOptions & operator= ( const T38FaxUdpOptions & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	Asn :: Integer * m_t38FaxMaxBuffer;
	Asn :: Integer * m_t38FaxMaxDatagram;
	public:
	T38FaxUdpOptions_t38FaxUdpEC m_t38FaxUdpEC;
	void encode ( Asn :: ostream & os ) const;
	~T38FaxUdpOptions ( );
	void printOn ( std :: ostream & os ) const;
	const Asn :: Integer & get_t38FaxMaxBuffer ( ) const {
		return * m_t38FaxMaxBuffer;
	}
	Asn :: Integer & get_t38FaxMaxBuffer ( ) {
		return * m_t38FaxMaxBuffer;
	}
	const Asn :: Integer & get_t38FaxMaxDatagram ( ) const {
		return * m_t38FaxMaxDatagram;
	}
	Asn :: Integer & get_t38FaxMaxDatagram ( ) {
		return * m_t38FaxMaxDatagram;
	}
	T38FaxUdpOptions * clone ( ) const;
};

//
// ParameterValue
//

// from 0 size 0 type 0 simple 0
class ParameterValue : public Asn :: Choice {
	public:
	explicit ParameterValue ( Asn :: istream & is );
	ParameterValue ( );
	enum Choices {
		e_logical,
		e_booleanArray,
		e_unsignedMin,
		e_unsignedMax,
		e_unsigned32Min,
		e_unsigned32Max,
		e_octetString,
		e_genericParameter
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator ParameterValue_booleanArray & ( ) { return dynamic_cast < ParameterValue_booleanArray & > ( * choice ); }
	operator const ParameterValue_booleanArray & ( ) const { return dynamic_cast < const ParameterValue_booleanArray & > ( * choice ); }
	operator ParameterValue_unsignedMin & ( ) { return dynamic_cast < ParameterValue_unsignedMin & > ( * choice ); }
	operator const ParameterValue_unsignedMin & ( ) const { return dynamic_cast < const ParameterValue_unsignedMin & > ( * choice ); }
	operator ParameterValue_unsignedMax & ( ) { return dynamic_cast < ParameterValue_unsignedMax & > ( * choice ); }
	operator const ParameterValue_unsignedMax & ( ) const { return dynamic_cast < const ParameterValue_unsignedMax & > ( * choice ); }
	operator ParameterValue_unsigned32Min & ( ) { return dynamic_cast < ParameterValue_unsigned32Min & > ( * choice ); }
	operator const ParameterValue_unsigned32Min & ( ) const { return dynamic_cast < const ParameterValue_unsigned32Min & > ( * choice ); }
	operator ParameterValue_unsigned32Max & ( ) { return dynamic_cast < ParameterValue_unsigned32Max & > ( * choice ); }
	operator const ParameterValue_unsigned32Max & ( ) const { return dynamic_cast < const ParameterValue_unsigned32Max & > ( * choice ); }
	operator ArrayOf_GenericParameter & ( ) { return dynamic_cast < ArrayOf_GenericParameter & > ( * choice ); }
	operator const ArrayOf_GenericParameter & ( ) const { return dynamic_cast < const ArrayOf_GenericParameter & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	ParameterValue * clone ( ) const;
};

//
// AudioTelephonyEventCapability
//

// from 0 size 0 type 0 simple 0
class AudioTelephonyEventCapability : public Asn :: Sequence {
	public:
	explicit AudioTelephonyEventCapability ( Asn :: istream & is );
	AudioTelephonyEventCapability ( );
	AudioTelephonyEventCapability_dynamicRTPPayloadType m_dynamicRTPPayloadType;
	Asn :: GeneralString m_audioTelephoneEvent;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	AudioTelephonyEventCapability * clone ( ) const;
};

//
// AudioToneCapability
//

// from 0 size 0 type 0 simple 0
class AudioToneCapability : public Asn :: Sequence {
	public:
	explicit AudioToneCapability ( Asn :: istream & is );
	AudioToneCapability ( );
	AudioToneCapability_dynamicRTPPayloadType m_dynamicRTPPayloadType;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	AudioToneCapability * clone ( ) const;
};

//
// MultiplePayloadStreamCapability
//

// from 0 size 0 type 0 simple 0
class MultiplePayloadStreamCapability : public Asn :: Sequence {
	public:
	explicit MultiplePayloadStreamCapability ( Asn :: istream & is );
	MultiplePayloadStreamCapability ( );
	MultiplePayloadStreamCapability_capabilities m_capabilities;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MultiplePayloadStreamCapability * clone ( ) const;
};

//
// H222LogicalChannelParameters
//

// from 0 size 0 type 0 simple 0
class H222LogicalChannelParameters : public Asn :: Sequence {
	public:
	explicit H222LogicalChannelParameters ( Asn :: istream & is );
	H222LogicalChannelParameters ( );
	enum OptionalFields {
		e_pcr_pid,
		e_programDescriptors,
		e_streamDescriptors
	};

	H222LogicalChannelParameters ( const H222LogicalChannelParameters & s );
	H222LogicalChannelParameters & operator= ( const H222LogicalChannelParameters & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	H222LogicalChannelParameters_resourceID m_resourceID;
	H222LogicalChannelParameters_subChannelID m_subChannelID;
	protected:
	H222LogicalChannelParameters_pcr_pid * m_pcr_pid;
	Asn :: OctetString * m_programDescriptors;
	Asn :: OctetString * m_streamDescriptors;
	public:
	void encode ( Asn :: ostream & os ) const;
	~H222LogicalChannelParameters ( );
	void printOn ( std :: ostream & os ) const;
	const H222LogicalChannelParameters_pcr_pid & get_pcr_pid ( ) const {
		return * m_pcr_pid;
	}
	H222LogicalChannelParameters_pcr_pid & get_pcr_pid ( ) {
		return * m_pcr_pid;
	}
	const Asn :: OctetString & get_programDescriptors ( ) const {
		return * m_programDescriptors;
	}
	Asn :: OctetString & get_programDescriptors ( ) {
		return * m_programDescriptors;
	}
	const Asn :: OctetString & get_streamDescriptors ( ) const {
		return * m_streamDescriptors;
	}
	Asn :: OctetString & get_streamDescriptors ( ) {
		return * m_streamDescriptors;
	}
	H222LogicalChannelParameters * clone ( ) const;
};

//
// H223AL2MParameters
//

// from 0 size 0 type 0 simple 0
class H223AL2MParameters : public Asn :: Sequence {
	public:
	explicit H223AL2MParameters ( Asn :: istream & is );
	H223AL2MParameters ( );
	H223AL2MParameters_headerFEC m_headerFEC;
	Asn :: Boolean m_alpduInterleaving;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	H223AL2MParameters * clone ( ) const;
};

//
// V76HDLCParameters
//

// from 0 size 0 type 0 simple 0
class V76HDLCParameters : public Asn :: Sequence {
	public:
	explicit V76HDLCParameters ( Asn :: istream & is );
	V76HDLCParameters ( );
	CRCLength m_crcLength;
	V76HDLCParameters_n401 m_n401;
	Asn :: Boolean m_loopbackTestProcedure;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	V76HDLCParameters * clone ( ) const;
};

//
// H2250LogicalChannelParameters
//

// from 0 size 0 type 0 simple 0
class H2250LogicalChannelParameters_mediaPacketization;
class RedundancyEncoding;

class H2250LogicalChannelParameters : public Asn :: Sequence {
	public:
	explicit H2250LogicalChannelParameters ( Asn :: istream & is );
	H2250LogicalChannelParameters ( );
	enum OptionalFields {
		e_nonStandard,
		e_associatedSessionID,
		e_mediaChannel,
		e_mediaGuaranteedDelivery,
		e_mediaControlChannel,
		e_mediaControlGuaranteedDelivery,
		e_silenceSuppression,
		e_destination,
		e_dynamicRTPPayloadType,
		e_mediaPacketization,
		e_transportCapability,
		e_redundancyEncoding,
		e_source
	};

	H2250LogicalChannelParameters ( const H2250LogicalChannelParameters & s );
	H2250LogicalChannelParameters & operator= ( const H2250LogicalChannelParameters & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	ArrayOf_NonStandardParameter * m_nonStandard;
	public:
	H2250LogicalChannelParameters_sessionID m_sessionID;
	protected:
	H2250LogicalChannelParameters_associatedSessionID * m_associatedSessionID;
	TransportAddress * m_mediaChannel;
	Asn :: Boolean * m_mediaGuaranteedDelivery;
	TransportAddress * m_mediaControlChannel;
	Asn :: Boolean * m_mediaControlGuaranteedDelivery;
	Asn :: Boolean * m_silenceSuppression;
	TerminalLabel * m_destination;
	H2250LogicalChannelParameters_dynamicRTPPayloadType * m_dynamicRTPPayloadType;
	H2250LogicalChannelParameters_mediaPacketization * m_mediaPacketization;
	TransportCapability * m_transportCapability;
	RedundancyEncoding * m_redundancyEncoding;
	TerminalLabel * m_source;
	public:
	void encode ( Asn :: ostream & os ) const;
	~H2250LogicalChannelParameters ( );
	void printOn ( std :: ostream & os ) const;
	const ArrayOf_NonStandardParameter & get_nonStandard ( ) const {
		return * m_nonStandard;
	}
	ArrayOf_NonStandardParameter & get_nonStandard ( ) {
		return * m_nonStandard;
	}
	const H2250LogicalChannelParameters_associatedSessionID & get_associatedSessionID ( ) const {
		return * m_associatedSessionID;
	}
	H2250LogicalChannelParameters_associatedSessionID & get_associatedSessionID ( ) {
		return * m_associatedSessionID;
	}
	const TransportAddress & get_mediaChannel ( ) const {
		return * m_mediaChannel;
	}
	TransportAddress & get_mediaChannel ( ) {
		return * m_mediaChannel;
	}
	const Asn :: Boolean & get_mediaGuaranteedDelivery ( ) const {
		return * m_mediaGuaranteedDelivery;
	}
	Asn :: Boolean & get_mediaGuaranteedDelivery ( ) {
		return * m_mediaGuaranteedDelivery;
	}
	const TransportAddress & get_mediaControlChannel ( ) const {
		return * m_mediaControlChannel;
	}
	TransportAddress & get_mediaControlChannel ( ) {
		return * m_mediaControlChannel;
	}
	const Asn :: Boolean & get_mediaControlGuaranteedDelivery ( ) const {
		return * m_mediaControlGuaranteedDelivery;
	}
	Asn :: Boolean & get_mediaControlGuaranteedDelivery ( ) {
		return * m_mediaControlGuaranteedDelivery;
	}
	const Asn :: Boolean & get_silenceSuppression ( ) const {
		return * m_silenceSuppression;
	}
	Asn :: Boolean & get_silenceSuppression ( ) {
		return * m_silenceSuppression;
	}
	const TerminalLabel & get_destination ( ) const {
		return * m_destination;
	}
	TerminalLabel & get_destination ( ) {
		return * m_destination;
	}
	const H2250LogicalChannelParameters_dynamicRTPPayloadType & get_dynamicRTPPayloadType ( ) const {
		return * m_dynamicRTPPayloadType;
	}
	H2250LogicalChannelParameters_dynamicRTPPayloadType & get_dynamicRTPPayloadType ( ) {
		return * m_dynamicRTPPayloadType;
	}
	const H2250LogicalChannelParameters_mediaPacketization & get_mediaPacketization ( ) const {
		return * m_mediaPacketization;
	}
	H2250LogicalChannelParameters_mediaPacketization & get_mediaPacketization ( ) {
		return * m_mediaPacketization;
	}
	const TransportCapability & get_transportCapability ( ) const {
		return * m_transportCapability;
	}
	TransportCapability & get_transportCapability ( ) {
		return * m_transportCapability;
	}
	const RedundancyEncoding & get_redundancyEncoding ( ) const {
		return * m_redundancyEncoding;
	}
	RedundancyEncoding & get_redundancyEncoding ( ) {
		return * m_redundancyEncoding;
	}
	const TerminalLabel & get_source ( ) const {
		return * m_source;
	}
	TerminalLabel & get_source ( ) {
		return * m_source;
	}
	H2250LogicalChannelParameters * clone ( ) const;
};

//
// MultiplePayloadStream
//

// from 0 size 0 type 0 simple 0
class MultiplePayloadStream : public Asn :: Sequence {
	public:
	explicit MultiplePayloadStream ( Asn :: istream & is );
	MultiplePayloadStream ( );
	ArrayOf_MultiplePayloadStreamElement m_elements;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MultiplePayloadStream * clone ( ) const;
};

//
// EncryptionSync
//

// from 0 size 0 type 0 simple 0
class EncryptionSync : public Asn :: Sequence {
	public:
	explicit EncryptionSync ( Asn :: istream & is );
	EncryptionSync ( );
	enum OptionalFields {
		e_nonStandard,
		e_escrowentry,
		e_genericParameter
	};

	EncryptionSync ( const EncryptionSync & s );
	EncryptionSync & operator= ( const EncryptionSync & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	NonStandardParameter * m_nonStandard;
	public:
	EncryptionSync_synchFlag m_synchFlag;
	EncryptionSync_h235Key m_h235Key;
	protected:
	EncryptionSync_escrowentry * m_escrowentry;
	GenericParameter * m_genericParameter;
	public:
	void encode ( Asn :: ostream & os ) const;
	~EncryptionSync ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandard ( ) const {
		return * m_nonStandard;
	}
	NonStandardParameter & get_nonStandard ( ) {
		return * m_nonStandard;
	}
	const EncryptionSync_escrowentry & get_escrowentry ( ) const {
		return * m_escrowentry;
	}
	EncryptionSync_escrowentry & get_escrowentry ( ) {
		return * m_escrowentry;
	}
	const GenericParameter & get_genericParameter ( ) const {
		return * m_genericParameter;
	}
	GenericParameter & get_genericParameter ( ) {
		return * m_genericParameter;
	}
	EncryptionSync * clone ( ) const;
};

//
// EscrowData
//

// from 0 size 0 type 0 simple 0
class EscrowData : public Asn :: Sequence {
	public:
	explicit EscrowData ( Asn :: istream & is );
	EscrowData ( );
	Asn :: ObjectId m_escrowID;
	EscrowData_escrowValue m_escrowValue;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	EscrowData * clone ( ) const;
};

//
// OpenLogicalChannelReject
//

// from 0 size 0 type 0 simple 0
class OpenLogicalChannelReject : public Asn :: Sequence {
	public:
	explicit OpenLogicalChannelReject ( Asn :: istream & is );
	OpenLogicalChannelReject ( );
	enum OptionalFields {
		e_genericInformation
	};

	OpenLogicalChannelReject ( const OpenLogicalChannelReject & s );
	OpenLogicalChannelReject & operator= ( const OpenLogicalChannelReject & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	LogicalChannelNumber m_forwardLogicalChannelNumber;
	OpenLogicalChannelReject_cause m_cause;
	protected:
	ArrayOf_GenericInformation * m_genericInformation;
	public:
	void encode ( Asn :: ostream & os ) const;
	~OpenLogicalChannelReject ( );
	void printOn ( std :: ostream & os ) const;
	const ArrayOf_GenericInformation & get_genericInformation ( ) const {
		return * m_genericInformation;
	}
	ArrayOf_GenericInformation & get_genericInformation ( ) {
		return * m_genericInformation;
	}
	OpenLogicalChannelReject * clone ( ) const;
};

//
// CloseLogicalChannel
//

// from 0 size 0 type 0 simple 0
class CloseLogicalChannel : public Asn :: Sequence {
	public:
	explicit CloseLogicalChannel ( Asn :: istream & is );
	CloseLogicalChannel ( );
	enum OptionalFields {
		e_reason
	};

	CloseLogicalChannel ( const CloseLogicalChannel & s );
	CloseLogicalChannel & operator= ( const CloseLogicalChannel & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	LogicalChannelNumber m_forwardLogicalChannelNumber;
	CloseLogicalChannel_source m_source;
	protected:
	CloseLogicalChannel_reason * m_reason;
	public:
	void encode ( Asn :: ostream & os ) const;
	~CloseLogicalChannel ( );
	void printOn ( std :: ostream & os ) const;
	const CloseLogicalChannel_reason & get_reason ( ) const {
		return * m_reason;
	}
	CloseLogicalChannel_reason & get_reason ( ) {
		return * m_reason;
	}
	CloseLogicalChannel * clone ( ) const;
};

//
// RequestChannelCloseReject
//

// from 0 size 0 type 0 simple 0
class RequestChannelCloseReject : public Asn :: Sequence {
	public:
	explicit RequestChannelCloseReject ( Asn :: istream & is );
	RequestChannelCloseReject ( );
	LogicalChannelNumber m_forwardLogicalChannelNumber;
	RequestChannelCloseReject_cause m_cause;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	RequestChannelCloseReject * clone ( ) const;
};

//
// MultiplexEntrySend
//

// from 0 size 0 type 0 simple 0
class MultiplexEntrySend : public Asn :: Sequence {
	public:
	explicit MultiplexEntrySend ( Asn :: istream & is );
	MultiplexEntrySend ( );
	SequenceNumber m_sequenceNumber;
	MultiplexEntrySend_multiplexEntryDescriptors m_multiplexEntryDescriptors;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MultiplexEntrySend * clone ( ) const;
};

//
// MultiplexEntryDescriptor
//

// from 0 size 0 type 0 simple 0
class MultiplexEntryDescriptor : public Asn :: Sequence {
	public:
	explicit MultiplexEntryDescriptor ( Asn :: istream & is );
	MultiplexEntryDescriptor ( );
	enum OptionalFields {
		e_elementList
	};

	MultiplexEntryDescriptor ( const MultiplexEntryDescriptor & s );
	MultiplexEntryDescriptor & operator= ( const MultiplexEntryDescriptor & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	MultiplexTableEntryNumber m_multiplexTableEntryNumber;
	protected:
	MultiplexEntryDescriptor_elementList * m_elementList;
	public:
	void encode ( Asn :: ostream & os ) const;
	~MultiplexEntryDescriptor ( );
	void printOn ( std :: ostream & os ) const;
	const MultiplexEntryDescriptor_elementList & get_elementList ( ) const {
		return * m_elementList;
	}
	MultiplexEntryDescriptor_elementList & get_elementList ( ) {
		return * m_elementList;
	}
	MultiplexEntryDescriptor * clone ( ) const;
};

//
// MultiplexEntrySendAck
//

// from 0 size 0 type 0 simple 0
class MultiplexEntrySendAck : public Asn :: Sequence {
	public:
	explicit MultiplexEntrySendAck ( Asn :: istream & is );
	MultiplexEntrySendAck ( );
	SequenceNumber m_sequenceNumber;
	MultiplexEntrySendAck_multiplexTableEntryNumber m_multiplexTableEntryNumber;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MultiplexEntrySendAck * clone ( ) const;
};

//
// MultiplexEntrySendReject
//

// from 0 size 0 type 0 simple 0
class MultiplexEntrySendReject : public Asn :: Sequence {
	public:
	explicit MultiplexEntrySendReject ( Asn :: istream & is );
	MultiplexEntrySendReject ( );
	SequenceNumber m_sequenceNumber;
	MultiplexEntrySendReject_rejectionDescriptions m_rejectionDescriptions;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MultiplexEntrySendReject * clone ( ) const;
};

//
// MultiplexEntryRejectionDescriptions
//

// from 0 size 0 type 0 simple 0
class MultiplexEntryRejectionDescriptions : public Asn :: Sequence {
	public:
	explicit MultiplexEntryRejectionDescriptions ( Asn :: istream & is );
	MultiplexEntryRejectionDescriptions ( );
	MultiplexTableEntryNumber m_multiplexTableEntryNumber;
	MultiplexEntryRejectionDescriptions_cause m_cause;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MultiplexEntryRejectionDescriptions * clone ( ) const;
};

//
// MultiplexEntrySendRelease
//

// from 0 size 0 type 0 simple 0
class MultiplexEntrySendRelease : public Asn :: Sequence {
	public:
	explicit MultiplexEntrySendRelease ( Asn :: istream & is );
	MultiplexEntrySendRelease ( );
	MultiplexEntrySendRelease_multiplexTableEntryNumber m_multiplexTableEntryNumber;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MultiplexEntrySendRelease * clone ( ) const;
};

//
// RequestMultiplexEntry
//

// from 0 size 0 type 0 simple 0
class RequestMultiplexEntry : public Asn :: Sequence {
	public:
	explicit RequestMultiplexEntry ( Asn :: istream & is );
	RequestMultiplexEntry ( );
	RequestMultiplexEntry_entryNumbers m_entryNumbers;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	RequestMultiplexEntry * clone ( ) const;
};

//
// RequestMultiplexEntryAck
//

// from 0 size 0 type 0 simple 0
class RequestMultiplexEntryAck : public Asn :: Sequence {
	public:
	explicit RequestMultiplexEntryAck ( Asn :: istream & is );
	RequestMultiplexEntryAck ( );
	RequestMultiplexEntryAck_entryNumbers m_entryNumbers;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	RequestMultiplexEntryAck * clone ( ) const;
};

//
// RequestMultiplexEntryReject
//

// from 0 size 0 type 0 simple 0
class RequestMultiplexEntryReject : public Asn :: Sequence {
	public:
	explicit RequestMultiplexEntryReject ( Asn :: istream & is );
	RequestMultiplexEntryReject ( );
	RequestMultiplexEntryReject_entryNumbers m_entryNumbers;
	RequestMultiplexEntryReject_rejectionDescriptions m_rejectionDescriptions;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	RequestMultiplexEntryReject * clone ( ) const;
};

//
// RequestMultiplexEntryRejectionDescriptions
//

// from 0 size 0 type 0 simple 0
class RequestMultiplexEntryRejectionDescriptions : public Asn :: Sequence {
	public:
	explicit RequestMultiplexEntryRejectionDescriptions ( Asn :: istream & is );
	RequestMultiplexEntryRejectionDescriptions ( );
	MultiplexTableEntryNumber m_multiplexTableEntryNumber;
	RequestMultiplexEntryRejectionDescriptions_cause m_cause;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	RequestMultiplexEntryRejectionDescriptions * clone ( ) const;
};

//
// RequestMultiplexEntryRelease
//

// from 0 size 0 type 0 simple 0
class RequestMultiplexEntryRelease : public Asn :: Sequence {
	public:
	explicit RequestMultiplexEntryRelease ( Asn :: istream & is );
	RequestMultiplexEntryRelease ( );
	RequestMultiplexEntryRelease_entryNumbers m_entryNumbers;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	RequestMultiplexEntryRelease * clone ( ) const;
};

//
// RequestMode
//

// from 0 size 0 type 0 simple 0
class RequestMode : public Asn :: Sequence {
	public:
	explicit RequestMode ( Asn :: istream & is );
	RequestMode ( );
	SequenceNumber m_sequenceNumber;
	RequestMode_requestedModes m_requestedModes;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	RequestMode * clone ( ) const;
};

//
// RequestModeAck
//

// from 0 size 0 type 0 simple 0
class RequestModeAck : public Asn :: Sequence {
	public:
	explicit RequestModeAck ( Asn :: istream & is );
	RequestModeAck ( );
	SequenceNumber m_sequenceNumber;
	RequestModeAck_response m_response;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	RequestModeAck * clone ( ) const;
};

//
// RequestModeReject
//

// from 0 size 0 type 0 simple 0
class RequestModeReject : public Asn :: Sequence {
	public:
	explicit RequestModeReject ( Asn :: istream & is );
	RequestModeReject ( );
	SequenceNumber m_sequenceNumber;
	RequestModeReject_cause m_cause;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	RequestModeReject * clone ( ) const;
};

//
// MultiplePayloadStreamMode
//

// from 0 size 0 type 0 simple 0
class MultiplePayloadStreamMode : public Asn :: Sequence {
	public:
	explicit MultiplePayloadStreamMode ( Asn :: istream & is );
	MultiplePayloadStreamMode ( );
	ArrayOf_MultiplePayloadStreamElementMode m_elements;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MultiplePayloadStreamMode * clone ( ) const;
};

//
// H261VideoMode
//

// from 0 size 0 type 0 simple 0
class H261VideoMode : public Asn :: Sequence {
	public:
	explicit H261VideoMode ( Asn :: istream & is );
	H261VideoMode ( );
	H261VideoMode_resolution m_resolution;
	H261VideoMode_bitRate m_bitRate;
	Asn :: Boolean m_stillImageTransmission;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	H261VideoMode * clone ( ) const;
};

//
// H262VideoMode
//

// from 0 size 0 type 0 simple 0
class H262VideoMode : public Asn :: Sequence {
	public:
	explicit H262VideoMode ( Asn :: istream & is );
	H262VideoMode ( );
	enum OptionalFields {
		e_videoBitRate,
		e_vbvBufferSize,
		e_samplesPerLine,
		e_linesPerFrame,
		e_framesPerSecond,
		e_luminanceSampleRate
	};

	H262VideoMode ( const H262VideoMode & s );
	H262VideoMode & operator= ( const H262VideoMode & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	H262VideoMode_profileAndLevel m_profileAndLevel;
	protected:
	H262VideoMode_videoBitRate * m_videoBitRate;
	H262VideoMode_vbvBufferSize * m_vbvBufferSize;
	H262VideoMode_samplesPerLine * m_samplesPerLine;
	H262VideoMode_linesPerFrame * m_linesPerFrame;
	H262VideoMode_framesPerSecond * m_framesPerSecond;
	H262VideoMode_luminanceSampleRate * m_luminanceSampleRate;
	public:
	void encode ( Asn :: ostream & os ) const;
	~H262VideoMode ( );
	void printOn ( std :: ostream & os ) const;
	const H262VideoMode_videoBitRate & get_videoBitRate ( ) const {
		return * m_videoBitRate;
	}
	H262VideoMode_videoBitRate & get_videoBitRate ( ) {
		return * m_videoBitRate;
	}
	const H262VideoMode_vbvBufferSize & get_vbvBufferSize ( ) const {
		return * m_vbvBufferSize;
	}
	H262VideoMode_vbvBufferSize & get_vbvBufferSize ( ) {
		return * m_vbvBufferSize;
	}
	const H262VideoMode_samplesPerLine & get_samplesPerLine ( ) const {
		return * m_samplesPerLine;
	}
	H262VideoMode_samplesPerLine & get_samplesPerLine ( ) {
		return * m_samplesPerLine;
	}
	const H262VideoMode_linesPerFrame & get_linesPerFrame ( ) const {
		return * m_linesPerFrame;
	}
	H262VideoMode_linesPerFrame & get_linesPerFrame ( ) {
		return * m_linesPerFrame;
	}
	const H262VideoMode_framesPerSecond & get_framesPerSecond ( ) const {
		return * m_framesPerSecond;
	}
	H262VideoMode_framesPerSecond & get_framesPerSecond ( ) {
		return * m_framesPerSecond;
	}
	const H262VideoMode_luminanceSampleRate & get_luminanceSampleRate ( ) const {
		return * m_luminanceSampleRate;
	}
	H262VideoMode_luminanceSampleRate & get_luminanceSampleRate ( ) {
		return * m_luminanceSampleRate;
	}
	H262VideoMode * clone ( ) const;
};

//
// H263VideoMode
//

// from 0 size 0 type 0 simple 0
class H263VideoMode : public Asn :: Sequence {
	public:
	explicit H263VideoMode ( Asn :: istream & is );
	H263VideoMode ( );
	enum OptionalFields {
		e_errorCompensation,
		e_enhancementLayerInfo,
		e_h263Options
	};

	H263VideoMode ( const H263VideoMode & s );
	H263VideoMode & operator= ( const H263VideoMode & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	H263VideoMode_resolution m_resolution;
	H263VideoMode_bitRate m_bitRate;
	Asn :: Boolean m_unrestrictedVector;
	Asn :: Boolean m_arithmeticCoding;
	Asn :: Boolean m_advancedPrediction;
	Asn :: Boolean m_pbFrames;
	protected:
	Asn :: Boolean * m_errorCompensation;
	EnhancementLayerInfo * m_enhancementLayerInfo;
	H263Options * m_h263Options;
	public:
	void encode ( Asn :: ostream & os ) const;
	~H263VideoMode ( );
	void printOn ( std :: ostream & os ) const;
	const Asn :: Boolean & get_errorCompensation ( ) const {
		return * m_errorCompensation;
	}
	Asn :: Boolean & get_errorCompensation ( ) {
		return * m_errorCompensation;
	}
	const EnhancementLayerInfo & get_enhancementLayerInfo ( ) const {
		return * m_enhancementLayerInfo;
	}
	EnhancementLayerInfo & get_enhancementLayerInfo ( ) {
		return * m_enhancementLayerInfo;
	}
	const H263Options & get_h263Options ( ) const {
		return * m_h263Options;
	}
	H263Options & get_h263Options ( ) {
		return * m_h263Options;
	}
	H263VideoMode * clone ( ) const;
};

//
// IS11172AudioMode
//

// from 0 size 0 type 0 simple 0
class IS11172AudioMode : public Asn :: Sequence {
	public:
	explicit IS11172AudioMode ( Asn :: istream & is );
	IS11172AudioMode ( );
	IS11172AudioMode_audioLayer m_audioLayer;
	IS11172AudioMode_audioSampling m_audioSampling;
	IS11172AudioMode_multichannelType m_multichannelType;
	IS11172AudioMode_bitRate m_bitRate;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	IS11172AudioMode * clone ( ) const;
};

//
// IS13818AudioMode
//

// from 0 size 0 type 0 simple 0
class IS13818AudioMode : public Asn :: Sequence {
	public:
	explicit IS13818AudioMode ( Asn :: istream & is );
	IS13818AudioMode ( );
	IS13818AudioMode_audioLayer m_audioLayer;
	IS13818AudioMode_audioSampling m_audioSampling;
	IS13818AudioMode_multichannelType m_multichannelType;
	Asn :: Boolean m_lowFrequencyEnhancement;
	Asn :: Boolean m_multilingual;
	IS13818AudioMode_bitRate m_bitRate;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	IS13818AudioMode * clone ( ) const;
};

//
// MaintenanceLoopRequest
//

// from 0 size 0 type 0 simple 0
class MaintenanceLoopRequest : public Asn :: Sequence {
	public:
	explicit MaintenanceLoopRequest ( Asn :: istream & is );
	MaintenanceLoopRequest ( );
	MaintenanceLoopRequest_type m_type;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MaintenanceLoopRequest * clone ( ) const;
};

//
// MaintenanceLoopAck
//

// from 0 size 0 type 0 simple 0
class MaintenanceLoopAck : public Asn :: Sequence {
	public:
	explicit MaintenanceLoopAck ( Asn :: istream & is );
	MaintenanceLoopAck ( );
	MaintenanceLoopAck_type m_type;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MaintenanceLoopAck * clone ( ) const;
};

//
// MaintenanceLoopReject
//

// from 0 size 0 type 0 simple 0
class MaintenanceLoopReject : public Asn :: Sequence {
	public:
	explicit MaintenanceLoopReject ( Asn :: istream & is );
	MaintenanceLoopReject ( );
	MaintenanceLoopReject_type m_type;
	MaintenanceLoopReject_cause m_cause;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MaintenanceLoopReject * clone ( ) const;
};

//
// CommunicationModeCommand
//

// from 0 size 0 type 0 simple 0
class CommunicationModeCommand : public Asn :: Sequence {
	public:
	explicit CommunicationModeCommand ( Asn :: istream & is );
	CommunicationModeCommand ( );
	CommunicationModeCommand_communicationModeTable m_communicationModeTable;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	CommunicationModeCommand * clone ( ) const;
};

//
// CommunicationModeResponse
//

// from 0 size 0 type 0 simple 0
class CommunicationModeResponse : public Asn :: Choice {
	public:
	explicit CommunicationModeResponse ( Asn :: istream & is );
	CommunicationModeResponse ( );
	enum Choices {
		e_communicationModeTable
	};

	operator CommunicationModeResponse_communicationModeTable & ( ) { return dynamic_cast < CommunicationModeResponse_communicationModeTable & > ( * choice ); }
	operator const CommunicationModeResponse_communicationModeTable & ( ) const { return dynamic_cast < const CommunicationModeResponse_communicationModeTable & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	CommunicationModeResponse * clone ( ) const;
};

//
// Criteria
//

// from 0 size 0 type 0 simple 0
class Criteria : public Asn :: Sequence {
	public:
	explicit Criteria ( Asn :: istream & is );
	Criteria ( );
	Asn :: ObjectId m_field;
	Criteria_value m_value;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	Criteria * clone ( ) const;
};

//
// TerminalLabel
//

// from 0 size 0 type 0 simple 0
class TerminalLabel : public Asn :: Sequence {
	public:
	explicit TerminalLabel ( Asn :: istream & is );
	TerminalLabel ( );
	McuNumber m_mcuNumber;
	TerminalNumber m_terminalNumber;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	TerminalLabel * clone ( ) const;
};

//
// RequestAllTerminalIDsResponse
//

// from 0 size 0 type 0 simple 0
class RequestAllTerminalIDsResponse : public Asn :: Sequence {
	public:
	explicit RequestAllTerminalIDsResponse ( Asn :: istream & is );
	RequestAllTerminalIDsResponse ( );
	ArrayOf_TerminalInformation m_terminalInformation;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	RequestAllTerminalIDsResponse * clone ( ) const;
};

//
// TerminalInformation
//

// from 0 size 0 type 0 simple 0
class TerminalInformation : public Asn :: Sequence {
	public:
	explicit TerminalInformation ( Asn :: istream & is );
	TerminalInformation ( );
	TerminalLabel m_terminalLabel;
	TerminalID m_terminalID;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	TerminalInformation * clone ( ) const;
};

//
// RemoteMCResponse
//

// from 0 size 0 type 0 simple 0
class RemoteMCResponse : public Asn :: Choice {
	public:
	explicit RemoteMCResponse ( Asn :: istream & is );
	RemoteMCResponse ( );
	enum Choices {
		e_accept,
		e_reject
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator RemoteMCResponse_reject & ( ) { return dynamic_cast < RemoteMCResponse_reject & > ( * choice ); }
	operator const RemoteMCResponse_reject & ( ) const { return dynamic_cast < const RemoteMCResponse_reject & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	RemoteMCResponse * clone ( ) const;
};

//
// DialingInformationNumber
//

// from 0 size 0 type 0 simple 0
class DialingInformationNumber : public Asn :: Sequence {
	public:
	explicit DialingInformationNumber ( Asn :: istream & is );
	DialingInformationNumber ( );
	enum OptionalFields {
		e_subAddress
	};

	DialingInformationNumber ( const DialingInformationNumber & s );
	DialingInformationNumber & operator= ( const DialingInformationNumber & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	DialingInformationNumber_networkAddress m_networkAddress;
	protected:
	DialingInformationNumber_subAddress * m_subAddress;
	public:
	DialingInformationNumber_networkType m_networkType;
	void encode ( Asn :: ostream & os ) const;
	~DialingInformationNumber ( );
	void printOn ( std :: ostream & os ) const;
	const DialingInformationNumber_subAddress & get_subAddress ( ) const {
		return * m_subAddress;
	}
	DialingInformationNumber_subAddress & get_subAddress ( ) {
		return * m_subAddress;
	}
	DialingInformationNumber * clone ( ) const;
};

//
// ConnectionIdentifier
//

// from 0 size 0 type 0 simple 0
class ConnectionIdentifier : public Asn :: Sequence {
	public:
	explicit ConnectionIdentifier ( Asn :: istream & is );
	ConnectionIdentifier ( );
	ConnectionIdentifier_channelTag m_channelTag;
	ConnectionIdentifier_sequenceNumber m_sequenceNumber;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	ConnectionIdentifier * clone ( ) const;
};

//
// LogicalChannelRateReject
//

// from 0 size 0 type 0 simple 0
class LogicalChannelRateReject : public Asn :: Sequence {
	public:
	explicit LogicalChannelRateReject ( Asn :: istream & is );
	LogicalChannelRateReject ( );
	enum OptionalFields {
		e_currentMaximumBitRate
	};

	LogicalChannelRateReject ( const LogicalChannelRateReject & s );
	LogicalChannelRateReject & operator= ( const LogicalChannelRateReject & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	SequenceNumber m_sequenceNumber;
	LogicalChannelNumber m_logicalChannelNumber;
	LogicalChannelRateRejectReason m_rejectReason;
	protected:
	MaximumBitRate * m_currentMaximumBitRate;
	public:
	void encode ( Asn :: ostream & os ) const;
	~LogicalChannelRateReject ( );
	void printOn ( std :: ostream & os ) const;
	const MaximumBitRate & get_currentMaximumBitRate ( ) const {
		return * m_currentMaximumBitRate;
	}
	MaximumBitRate & get_currentMaximumBitRate ( ) {
		return * m_currentMaximumBitRate;
	}
	LogicalChannelRateReject * clone ( ) const;
};

//
// SendTerminalCapabilitySet
//

// from 0 size 0 type 0 simple 0
class SendTerminalCapabilitySet : public Asn :: Choice {
	public:
	explicit SendTerminalCapabilitySet ( Asn :: istream & is );
	SendTerminalCapabilitySet ( );
	enum Choices {
		e_specificRequest,
		e_genericRequest
	};

	operator SendTerminalCapabilitySet_specificRequest & ( ) { return dynamic_cast < SendTerminalCapabilitySet_specificRequest & > ( * choice ); }
	operator const SendTerminalCapabilitySet_specificRequest & ( ) const { return dynamic_cast < const SendTerminalCapabilitySet_specificRequest & > ( * choice ); }
	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	SendTerminalCapabilitySet * clone ( ) const;
};

//
// SubstituteConferenceIDCommand
//

// from 0 size 0 type 0 simple 0
class SubstituteConferenceIDCommand : public Asn :: Sequence {
	public:
	explicit SubstituteConferenceIDCommand ( Asn :: istream & is );
	SubstituteConferenceIDCommand ( );
	SubstituteConferenceIDCommand_conferenceIdentifier m_conferenceIdentifier;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	SubstituteConferenceIDCommand * clone ( ) const;
};

//
// PictureReference
//

// from 0 size 0 type 0 simple 0
class PictureReference : public Asn :: Choice {
	public:
	explicit PictureReference ( Asn :: istream & is );
	PictureReference ( );
	enum Choices {
		e_pictureNumber,
		e_longTermPictureIndex
	};

	operator PictureReference_pictureNumber & ( ) { return dynamic_cast < PictureReference_pictureNumber & > ( * choice ); }
	operator const PictureReference_pictureNumber & ( ) const { return dynamic_cast < const PictureReference_pictureNumber & > ( * choice ); }
	operator PictureReference_longTermPictureIndex & ( ) { return dynamic_cast < PictureReference_longTermPictureIndex & > ( * choice ); }
	operator const PictureReference_longTermPictureIndex & ( ) const { return dynamic_cast < const PictureReference_longTermPictureIndex & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	PictureReference * clone ( ) const;
};

//
// H223MultiplexReconfiguration
//

// from 0 size 0 type 0 simple 0
class H223MultiplexReconfiguration : public Asn :: Choice {
	public:
	explicit H223MultiplexReconfiguration ( Asn :: istream & is );
	H223MultiplexReconfiguration ( );
	enum Choices {
		e_h223ModeChange,
		e_h223AnnexADoubleFlag
	};

	operator H223MultiplexReconfiguration_h223ModeChange & ( ) { return dynamic_cast < H223MultiplexReconfiguration_h223ModeChange & > ( * choice ); }
	operator const H223MultiplexReconfiguration_h223ModeChange & ( ) const { return dynamic_cast < const H223MultiplexReconfiguration_h223ModeChange & > ( * choice ); }
	operator H223MultiplexReconfiguration_h223AnnexADoubleFlag & ( ) { return dynamic_cast < H223MultiplexReconfiguration_h223AnnexADoubleFlag & > ( * choice ); }
	operator const H223MultiplexReconfiguration_h223AnnexADoubleFlag & ( ) const { return dynamic_cast < const H223MultiplexReconfiguration_h223AnnexADoubleFlag & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	H223MultiplexReconfiguration * clone ( ) const;
};

//
// MobileMultilinkReconfigurationCommand
//

// from 0 size 0 type 0 simple 0
class MobileMultilinkReconfigurationCommand : public Asn :: Sequence {
	public:
	explicit MobileMultilinkReconfigurationCommand ( Asn :: istream & is );
	MobileMultilinkReconfigurationCommand ( );
	MobileMultilinkReconfigurationCommand_sampleSize m_sampleSize;
	MobileMultilinkReconfigurationCommand_samplesPerFrame m_samplesPerFrame;
	MobileMultilinkReconfigurationCommand_status m_status;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MobileMultilinkReconfigurationCommand * clone ( ) const;
};

//
// FunctionNotSupported
//

// from 0 size 0 type 0 simple 0
class FunctionNotSupported : public Asn :: Sequence {
	public:
	explicit FunctionNotSupported ( Asn :: istream & is );
	FunctionNotSupported ( );
	enum OptionalFields {
		e_returnedFunction
	};

	FunctionNotSupported ( const FunctionNotSupported & s );
	FunctionNotSupported & operator= ( const FunctionNotSupported & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	FunctionNotSupported_cause m_cause;
	protected:
	Asn :: OctetString * m_returnedFunction;
	public:
	void encode ( Asn :: ostream & os ) const;
	~FunctionNotSupported ( );
	void printOn ( std :: ostream & os ) const;
	const Asn :: OctetString & get_returnedFunction ( ) const {
		return * m_returnedFunction;
	}
	Asn :: OctetString & get_returnedFunction ( ) {
		return * m_returnedFunction;
	}
	FunctionNotSupported * clone ( ) const;
};

//
// TerminalYouAreSeeingInSubPictureNumber
//

// from 0 size 0 type 0 simple 0
class TerminalYouAreSeeingInSubPictureNumber : public Asn :: Sequence {
	public:
	explicit TerminalYouAreSeeingInSubPictureNumber ( Asn :: istream & is );
	TerminalYouAreSeeingInSubPictureNumber ( );
	TerminalNumber m_terminalNumber;
	TerminalYouAreSeeingInSubPictureNumber_subPictureNumber m_subPictureNumber;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	TerminalYouAreSeeingInSubPictureNumber * clone ( ) const;
};

//
// VideoIndicateCompose
//

// from 0 size 0 type 0 simple 0
class VideoIndicateCompose : public Asn :: Sequence {
	public:
	explicit VideoIndicateCompose ( Asn :: istream & is );
	VideoIndicateCompose ( );
	VideoIndicateCompose_compositionNumber m_compositionNumber;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	VideoIndicateCompose * clone ( ) const;
};

//
// H223SkewIndication
//

// from 0 size 0 type 0 simple 0
class H223SkewIndication : public Asn :: Sequence {
	public:
	explicit H223SkewIndication ( Asn :: istream & is );
	H223SkewIndication ( );
	LogicalChannelNumber m_logicalChannelNumber1;
	LogicalChannelNumber m_logicalChannelNumber2;
	H223SkewIndication_skew m_skew;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	H223SkewIndication * clone ( ) const;
};

//
// H2250MaximumSkewIndication
//

// from 0 size 0 type 0 simple 0
class H2250MaximumSkewIndication : public Asn :: Sequence {
	public:
	explicit H2250MaximumSkewIndication ( Asn :: istream & is );
	H2250MaximumSkewIndication ( );
	LogicalChannelNumber m_logicalChannelNumber1;
	LogicalChannelNumber m_logicalChannelNumber2;
	H2250MaximumSkewIndication_maximumSkew m_maximumSkew;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	H2250MaximumSkewIndication * clone ( ) const;
};

//
// MobileMultilinkReconfigurationIndication
//

// from 0 size 0 type 0 simple 0
class MobileMultilinkReconfigurationIndication : public Asn :: Sequence {
	public:
	explicit MobileMultilinkReconfigurationIndication ( Asn :: istream & is );
	MobileMultilinkReconfigurationIndication ( );
	MobileMultilinkReconfigurationIndication_sampleSize m_sampleSize;
	MobileMultilinkReconfigurationIndication_samplesPerFrame m_samplesPerFrame;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MobileMultilinkReconfigurationIndication * clone ( ) const;
};

//
// NonStandardIdentifier_h221NonStandard
//

// from 0 size 0 type 0 simple 0
class NonStandardIdentifier_h221NonStandard : public Asn :: Sequence {
	public:
	explicit NonStandardIdentifier_h221NonStandard ( Asn :: istream & is );
	NonStandardIdentifier_h221NonStandard ( );
	NonStandardIdentifier_h221NonStandard_t35CountryCode m_t35CountryCode;
	NonStandardIdentifier_h221NonStandard_t35Extension m_t35Extension;
	NonStandardIdentifier_h221NonStandard_manufacturerCode m_manufacturerCode;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	NonStandardIdentifier_h221NonStandard * clone ( ) const;
};

//
// TerminalCapabilitySetReject_cause
//

// from 0 size 0 type 0 simple 0
class TerminalCapabilitySetReject_cause : public Asn :: Choice {
	public:
	explicit TerminalCapabilitySetReject_cause ( Asn :: istream & is );
	TerminalCapabilitySetReject_cause ( );
	enum Choices {
		e_unspecified,
		e_undefinedTableEntryUsed,
		e_descriptorCapacityExceeded,
		e_tableEntryCapacityExceeded
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded & ( ) { return dynamic_cast < TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded & > ( * choice ); }
	operator const TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded & ( ) const { return dynamic_cast < const TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	TerminalCapabilitySetReject_cause * clone ( ) const;
};

//
// Capability_h233EncryptionReceiveCapability
//

// from 0 size 0 type 0 simple 0
class Capability_h233EncryptionReceiveCapability : public Asn :: Sequence {
	public:
	explicit Capability_h233EncryptionReceiveCapability ( Asn :: istream & is );
	Capability_h233EncryptionReceiveCapability ( );
	Capability_h233EncryptionReceiveCapability_h233IVResponseTime m_h233IVResponseTime;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	Capability_h233EncryptionReceiveCapability * clone ( ) const;
};

//
// VCCapability_aal5
//

// from 0 size 0 type 0 simple 0
class VCCapability_aal5 : public Asn :: Sequence {
	public:
	explicit VCCapability_aal5 ( Asn :: istream & is );
	VCCapability_aal5 ( );
	VCCapability_aal5_forwardMaximumSDUSize m_forwardMaximumSDUSize;
	VCCapability_aal5_backwardMaximumSDUSize m_backwardMaximumSDUSize;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	VCCapability_aal5 * clone ( ) const;
};

//
// VCCapability_aal1ViaGateway
//

// from 0 size 0 type 0 simple 0
class VCCapability_aal1ViaGateway : public Asn :: Sequence {
	public:
	explicit VCCapability_aal1ViaGateway ( Asn :: istream & is );
	VCCapability_aal1ViaGateway ( );
	VCCapability_aal1ViaGateway_gatewayAddress m_gatewayAddress;
	Asn :: Boolean m_nullClockRecovery;
	Asn :: Boolean m_srtsClockRecovery;
	Asn :: Boolean m_adaptiveClockRecovery;
	Asn :: Boolean m_nullErrorCorrection;
	Asn :: Boolean m_longInterleaver;
	Asn :: Boolean m_shortInterleaver;
	Asn :: Boolean m_errorCorrectionOnly;
	Asn :: Boolean m_structuredDataTransfer;
	Asn :: Boolean m_partiallyFilledCells;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	VCCapability_aal1ViaGateway * clone ( ) const;
};

//
// H223Capability_mobileMultilinkFrameCapability
//

// from 0 size 0 type 0 simple 0
class H223Capability_mobileMultilinkFrameCapability : public Asn :: Sequence {
	public:
	explicit H223Capability_mobileMultilinkFrameCapability ( Asn :: istream & is );
	H223Capability_mobileMultilinkFrameCapability ( );
	H223Capability_mobileMultilinkFrameCapability_maximumSampleSize m_maximumSampleSize;
	H223Capability_mobileMultilinkFrameCapability_maximumPayloadLength m_maximumPayloadLength;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	H223Capability_mobileMultilinkFrameCapability * clone ( ) const;
};

//
// RTPH263VideoRedundancyEncoding_frameToThreadMapping
//

// from 0 size 0 type 0 simple 0
class RTPH263VideoRedundancyEncoding_frameToThreadMapping : public Asn :: Choice {
	public:
	explicit RTPH263VideoRedundancyEncoding_frameToThreadMapping ( Asn :: istream & is );
	RTPH263VideoRedundancyEncoding_frameToThreadMapping ( );
	enum Choices {
		e_roundrobin,
		e_custom
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom & ( ) { return dynamic_cast < RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom & > ( * choice ); }
	operator const RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom & ( ) const { return dynamic_cast < const RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	RTPH263VideoRedundancyEncoding_frameToThreadMapping * clone ( ) const;
};

//
// CustomPictureFormat_pixelAspectInformation
//

// from 0 size 0 type 0 simple 0
class CustomPictureFormat_pixelAspectInformation : public Asn :: Choice {
	public:
	explicit CustomPictureFormat_pixelAspectInformation ( Asn :: istream & is );
	CustomPictureFormat_pixelAspectInformation ( );
	enum Choices {
		e_anyPixelAspectRatio,
		e_pixelAspectCode,
		e_extendedPAR
	};

	operator CustomPictureFormat_pixelAspectInformation_pixelAspectCode & ( ) { return dynamic_cast < CustomPictureFormat_pixelAspectInformation_pixelAspectCode & > ( * choice ); }
	operator const CustomPictureFormat_pixelAspectInformation_pixelAspectCode & ( ) const { return dynamic_cast < const CustomPictureFormat_pixelAspectInformation_pixelAspectCode & > ( * choice ); }
	operator CustomPictureFormat_pixelAspectInformation_extendedPAR & ( ) { return dynamic_cast < CustomPictureFormat_pixelAspectInformation_extendedPAR & > ( * choice ); }
	operator const CustomPictureFormat_pixelAspectInformation_extendedPAR & ( ) const { return dynamic_cast < const CustomPictureFormat_pixelAspectInformation_extendedPAR & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	CustomPictureFormat_pixelAspectInformation * clone ( ) const;
};

//
// AudioCapability_g7231
//

// from 0 size 0 type 0 simple 0
class AudioCapability_g7231 : public Asn :: Sequence {
	public:
	explicit AudioCapability_g7231 ( Asn :: istream & is );
	AudioCapability_g7231 ( );
	AudioCapability_g7231_maxAl_sduAudioFrames m_maxAl_sduAudioFrames;
	Asn :: Boolean m_silenceSuppression;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	AudioCapability_g7231 * clone ( ) const;
};

//
// G7231AnnexCCapability_g723AnnexCAudioMode
//

// from 0 size 0 type 0 simple 0
class G7231AnnexCCapability_g723AnnexCAudioMode : public Asn :: Sequence {
	public:
	explicit G7231AnnexCCapability_g723AnnexCAudioMode ( Asn :: istream & is );
	G7231AnnexCCapability_g723AnnexCAudioMode ( );
	G7231AnnexCCapability_g723AnnexCAudioMode_highRateMode0 m_highRateMode0;
	G7231AnnexCCapability_g723AnnexCAudioMode_highRateMode1 m_highRateMode1;
	G7231AnnexCCapability_g723AnnexCAudioMode_lowRateMode0 m_lowRateMode0;
	G7231AnnexCCapability_g723AnnexCAudioMode_lowRateMode1 m_lowRateMode1;
	G7231AnnexCCapability_g723AnnexCAudioMode_sidMode0 m_sidMode0;
	G7231AnnexCCapability_g723AnnexCAudioMode_sidMode1 m_sidMode1;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	G7231AnnexCCapability_g723AnnexCAudioMode * clone ( ) const;
};

//
// DepFECCapability_rfc2733
//

// from 0 size 0 type 0 simple 0
class DepFECCapability_rfc2733 : public Asn :: Sequence {
	public:
	explicit DepFECCapability_rfc2733 ( Asn :: istream & is );
	DepFECCapability_rfc2733 ( );
	Asn :: Boolean m_redundancyEncoding;
	DepFECCapability_rfc2733_separateStream m_separateStream;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	DepFECCapability_rfc2733 * clone ( ) const;
};

//
// Q2931Address_address
//

// from 0 size 0 type 0 simple 0
class Q2931Address_address : public Asn :: Choice {
	public:
	explicit Q2931Address_address ( Asn :: istream & is );
	Q2931Address_address ( );
	enum Choices {
		e_internationalNumber,
		e_nsapAddress
	};

	operator Q2931Address_address_internationalNumber & ( ) { return dynamic_cast < Q2931Address_address_internationalNumber & > ( * choice ); }
	operator const Q2931Address_address_internationalNumber & ( ) const { return dynamic_cast < const Q2931Address_address_internationalNumber & > ( * choice ); }
	operator Q2931Address_address_nsapAddress & ( ) { return dynamic_cast < Q2931Address_address_nsapAddress & > ( * choice ); }
	operator const Q2931Address_address_nsapAddress & ( ) const { return dynamic_cast < const Q2931Address_address_nsapAddress & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	Q2931Address_address * clone ( ) const;
};

//
// H223AnnexCArqParameters_numberOfRetransmissions
//

// from 0 size 0 type 0 simple 0
class H223AnnexCArqParameters_numberOfRetransmissions : public Asn :: Choice {
	public:
	explicit H223AnnexCArqParameters_numberOfRetransmissions ( Asn :: istream & is );
	H223AnnexCArqParameters_numberOfRetransmissions ( );
	enum Choices {
		e_finite,
		e_infinite
	};

	operator H223AnnexCArqParameters_numberOfRetransmissions_finite & ( ) { return dynamic_cast < H223AnnexCArqParameters_numberOfRetransmissions_finite & > ( * choice ); }
	operator const H223AnnexCArqParameters_numberOfRetransmissions_finite & ( ) const { return dynamic_cast < const H223AnnexCArqParameters_numberOfRetransmissions_finite & > ( * choice ); }
	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	H223AnnexCArqParameters_numberOfRetransmissions * clone ( ) const;
};

//
// UnicastAddress_iPAddress
//

// from 0 size 0 type 0 simple 0
class UnicastAddress_iPAddress : public Asn :: Sequence {
	public:
	explicit UnicastAddress_iPAddress ( Asn :: istream & is );
	UnicastAddress_iPAddress ( );
	UnicastAddress_iPAddress_network m_network;
	UnicastAddress_iPAddress_tsapIdentifier m_tsapIdentifier;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	UnicastAddress_iPAddress * clone ( ) const;
};

//
// UnicastAddress_iPXAddress
//

// from 0 size 0 type 0 simple 0
class UnicastAddress_iPXAddress : public Asn :: Sequence {
	public:
	explicit UnicastAddress_iPXAddress ( Asn :: istream & is );
	UnicastAddress_iPXAddress ( );
	UnicastAddress_iPXAddress_node m_node;
	UnicastAddress_iPXAddress_netnum m_netnum;
	UnicastAddress_iPXAddress_tsapIdentifier m_tsapIdentifier;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	UnicastAddress_iPXAddress * clone ( ) const;
};

//
// UnicastAddress_iP6Address
//

// from 0 size 0 type 0 simple 0
class UnicastAddress_iP6Address : public Asn :: Sequence {
	public:
	explicit UnicastAddress_iP6Address ( Asn :: istream & is );
	UnicastAddress_iP6Address ( );
	UnicastAddress_iP6Address_network m_network;
	UnicastAddress_iP6Address_tsapIdentifier m_tsapIdentifier;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	UnicastAddress_iP6Address * clone ( ) const;
};

//
// UnicastAddress_iPSourceRouteAddress
//

// from 0 size 0 type 0 simple 0
class UnicastAddress_iPSourceRouteAddress : public Asn :: Sequence {
	public:
	explicit UnicastAddress_iPSourceRouteAddress ( Asn :: istream & is );
	UnicastAddress_iPSourceRouteAddress ( );
	UnicastAddress_iPSourceRouteAddress_routing m_routing;
	UnicastAddress_iPSourceRouteAddress_network m_network;
	UnicastAddress_iPSourceRouteAddress_tsapIdentifier m_tsapIdentifier;
	UnicastAddress_iPSourceRouteAddress_route m_route;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	UnicastAddress_iPSourceRouteAddress * clone ( ) const;
};

//
// MulticastAddress_iPAddress
//

// from 0 size 0 type 0 simple 0
class MulticastAddress_iPAddress : public Asn :: Sequence {
	public:
	explicit MulticastAddress_iPAddress ( Asn :: istream & is );
	MulticastAddress_iPAddress ( );
	MulticastAddress_iPAddress_network m_network;
	MulticastAddress_iPAddress_tsapIdentifier m_tsapIdentifier;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MulticastAddress_iPAddress * clone ( ) const;
};

//
// MulticastAddress_iP6Address
//

// from 0 size 0 type 0 simple 0
class MulticastAddress_iP6Address : public Asn :: Sequence {
	public:
	explicit MulticastAddress_iP6Address ( Asn :: istream & is );
	MulticastAddress_iP6Address ( );
	MulticastAddress_iP6Address_network m_network;
	MulticastAddress_iP6Address_tsapIdentifier m_tsapIdentifier;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MulticastAddress_iP6Address * clone ( ) const;
};

//
// MultiplexElement_type
//

// from 0 size 0 type 0 simple 0
class MultiplexElement_type : public Asn :: Choice {
	public:
	explicit MultiplexElement_type ( Asn :: istream & is );
	MultiplexElement_type ( );
	enum Choices {
		e_logicalChannelNumber,
		e_subElementList
	};

	operator MultiplexElement_type_logicalChannelNumber & ( ) { return dynamic_cast < MultiplexElement_type_logicalChannelNumber & > ( * choice ); }
	operator const MultiplexElement_type_logicalChannelNumber & ( ) const { return dynamic_cast < const MultiplexElement_type_logicalChannelNumber & > ( * choice ); }
	operator MultiplexElement_type_subElementList & ( ) { return dynamic_cast < MultiplexElement_type_subElementList & > ( * choice ); }
	operator const MultiplexElement_type_subElementList & ( ) const { return dynamic_cast < const MultiplexElement_type_subElementList & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	MultiplexElement_type * clone ( ) const;
};

//
// MultiplexElement_repeatCount
//

// from 0 size 0 type 0 simple 0
class MultiplexElement_repeatCount : public Asn :: Choice {
	public:
	explicit MultiplexElement_repeatCount ( Asn :: istream & is );
	MultiplexElement_repeatCount ( );
	enum Choices {
		e_finite,
		e_untilClosingFlag
	};

	operator MultiplexElement_repeatCount_finite & ( ) { return dynamic_cast < MultiplexElement_repeatCount_finite & > ( * choice ); }
	operator const MultiplexElement_repeatCount_finite & ( ) const { return dynamic_cast < const MultiplexElement_repeatCount_finite & > ( * choice ); }
	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	MultiplexElement_repeatCount * clone ( ) const;
};

//
// G7231AnnexCMode_g723AnnexCAudioMode
//

// from 0 size 0 type 0 simple 0
class G7231AnnexCMode_g723AnnexCAudioMode : public Asn :: Sequence {
	public:
	explicit G7231AnnexCMode_g723AnnexCAudioMode ( Asn :: istream & is );
	G7231AnnexCMode_g723AnnexCAudioMode ( );
	G7231AnnexCMode_g723AnnexCAudioMode_highRateMode0 m_highRateMode0;
	G7231AnnexCMode_g723AnnexCAudioMode_highRateMode1 m_highRateMode1;
	G7231AnnexCMode_g723AnnexCAudioMode_lowRateMode0 m_lowRateMode0;
	G7231AnnexCMode_g723AnnexCAudioMode_lowRateMode1 m_lowRateMode1;
	G7231AnnexCMode_g723AnnexCAudioMode_sidMode0 m_sidMode0;
	G7231AnnexCMode_g723AnnexCAudioMode_sidMode1 m_sidMode1;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	G7231AnnexCMode_g723AnnexCAudioMode * clone ( ) const;
};

//
// ConferenceResponse_mCTerminalIDResponse
//

// from 0 size 0 type 0 simple 0
class ConferenceResponse_mCTerminalIDResponse : public Asn :: Sequence {
	public:
	explicit ConferenceResponse_mCTerminalIDResponse ( Asn :: istream & is );
	ConferenceResponse_mCTerminalIDResponse ( );
	TerminalLabel m_terminalLabel;
	TerminalID m_terminalID;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	ConferenceResponse_mCTerminalIDResponse * clone ( ) const;
};

//
// ConferenceResponse_terminalIDResponse
//

// from 0 size 0 type 0 simple 0
class ConferenceResponse_terminalIDResponse : public Asn :: Sequence {
	public:
	explicit ConferenceResponse_terminalIDResponse ( Asn :: istream & is );
	ConferenceResponse_terminalIDResponse ( );
	TerminalLabel m_terminalLabel;
	TerminalID m_terminalID;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	ConferenceResponse_terminalIDResponse * clone ( ) const;
};

//
// ConferenceResponse_conferenceIDResponse
//

// from 0 size 0 type 0 simple 0
class ConferenceResponse_conferenceIDResponse : public Asn :: Sequence {
	public:
	explicit ConferenceResponse_conferenceIDResponse ( Asn :: istream & is );
	ConferenceResponse_conferenceIDResponse ( );
	TerminalLabel m_terminalLabel;
	ConferenceID m_conferenceID;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	ConferenceResponse_conferenceIDResponse * clone ( ) const;
};

//
// ConferenceResponse_passwordResponse
//

// from 0 size 0 type 0 simple 0
class ConferenceResponse_passwordResponse : public Asn :: Sequence {
	public:
	explicit ConferenceResponse_passwordResponse ( Asn :: istream & is );
	ConferenceResponse_passwordResponse ( );
	TerminalLabel m_terminalLabel;
	Password m_password;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	ConferenceResponse_passwordResponse * clone ( ) const;
};

//
// ConferenceResponse_chairTokenOwnerResponse
//

// from 0 size 0 type 0 simple 0
class ConferenceResponse_chairTokenOwnerResponse : public Asn :: Sequence {
	public:
	explicit ConferenceResponse_chairTokenOwnerResponse ( Asn :: istream & is );
	ConferenceResponse_chairTokenOwnerResponse ( );
	TerminalLabel m_terminalLabel;
	TerminalID m_terminalID;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	ConferenceResponse_chairTokenOwnerResponse * clone ( ) const;
};

//
// MultilinkRequest_callInformation
//

// from 0 size 0 type 0 simple 0
class MultilinkRequest_callInformation : public Asn :: Sequence {
	public:
	explicit MultilinkRequest_callInformation ( Asn :: istream & is );
	MultilinkRequest_callInformation ( );
	MultilinkRequest_callInformation_maxNumberOfAdditionalConnections m_maxNumberOfAdditionalConnections;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MultilinkRequest_callInformation * clone ( ) const;
};

//
// MultilinkRequest_removeConnection
//

// from 0 size 0 type 0 simple 0
class MultilinkRequest_removeConnection : public Asn :: Sequence {
	public:
	explicit MultilinkRequest_removeConnection ( Asn :: istream & is );
	MultilinkRequest_removeConnection ( );
	ConnectionIdentifier m_connectionIdentifier;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MultilinkRequest_removeConnection * clone ( ) const;
};

//
// MultilinkResponse_removeConnection
//

// from 0 size 0 type 0 simple 0
class MultilinkResponse_removeConnection : public Asn :: Sequence {
	public:
	explicit MultilinkResponse_removeConnection ( Asn :: istream & is );
	MultilinkResponse_removeConnection ( );
	ConnectionIdentifier m_connectionIdentifier;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MultilinkResponse_removeConnection * clone ( ) const;
};

//
// MultilinkResponse_maximumHeaderInterval
//

// from 0 size 0 type 0 simple 0
class MultilinkResponse_maximumHeaderInterval : public Asn :: Sequence {
	public:
	explicit MultilinkResponse_maximumHeaderInterval ( Asn :: istream & is );
	MultilinkResponse_maximumHeaderInterval ( );
	MultilinkResponse_maximumHeaderInterval_currentInterval m_currentInterval;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MultilinkResponse_maximumHeaderInterval * clone ( ) const;
};

//
// MultilinkIndication_excessiveError
//

// from 0 size 0 type 0 simple 0
class MultilinkIndication_excessiveError : public Asn :: Sequence {
	public:
	explicit MultilinkIndication_excessiveError ( Asn :: istream & is );
	MultilinkIndication_excessiveError ( );
	ConnectionIdentifier m_connectionIdentifier;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MultilinkIndication_excessiveError * clone ( ) const;
};

//
// FlowControlCommand_scope
//

// from 0 size 0 type 0 simple 0
class FlowControlCommand_scope : public Asn :: Choice {
	public:
	explicit FlowControlCommand_scope ( Asn :: istream & is );
	FlowControlCommand_scope ( );
	enum Choices {
		e_logicalChannelNumber,
		e_resourceID,
		e_wholeMultiplex
	};

	operator LogicalChannelNumber & ( ) { return dynamic_cast < LogicalChannelNumber & > ( * choice ); }
	operator const LogicalChannelNumber & ( ) const { return dynamic_cast < const LogicalChannelNumber & > ( * choice ); }
	operator FlowControlCommand_scope_resourceID & ( ) { return dynamic_cast < FlowControlCommand_scope_resourceID & > ( * choice ); }
	operator const FlowControlCommand_scope_resourceID & ( ) const { return dynamic_cast < const FlowControlCommand_scope_resourceID & > ( * choice ); }
	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	FlowControlCommand_scope * clone ( ) const;
};

//
// FlowControlCommand_restriction
//

// from 0 size 0 type 0 simple 0
class FlowControlCommand_restriction : public Asn :: Choice {
	public:
	explicit FlowControlCommand_restriction ( Asn :: istream & is );
	FlowControlCommand_restriction ( );
	enum Choices {
		e_maximumBitRate,
		e_noRestriction
	};

	operator FlowControlCommand_restriction_maximumBitRate & ( ) { return dynamic_cast < FlowControlCommand_restriction_maximumBitRate & > ( * choice ); }
	operator const FlowControlCommand_restriction_maximumBitRate & ( ) const { return dynamic_cast < const FlowControlCommand_restriction_maximumBitRate & > ( * choice ); }
	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	FlowControlCommand_restriction * clone ( ) const;
};

//
// NewATMVCCommand_reverseParameters
//

// from 0 size 0 type 0 simple 0
class NewATMVCCommand_reverseParameters : public Asn :: Sequence {
	public:
	explicit NewATMVCCommand_reverseParameters ( Asn :: istream & is );
	NewATMVCCommand_reverseParameters ( );
	NewATMVCCommand_reverseParameters_bitRate m_bitRate;
	Asn :: Boolean m_bitRateLockedToPCRClock;
	Asn :: Boolean m_bitRateLockedToNetworkClock;
	NewATMVCCommand_reverseParameters_multiplex m_multiplex;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	NewATMVCCommand_reverseParameters * clone ( ) const;
};

//
// JitterIndication_scope
//

// from 0 size 0 type 0 simple 0
class JitterIndication_scope : public Asn :: Choice {
	public:
	explicit JitterIndication_scope ( Asn :: istream & is );
	JitterIndication_scope ( );
	enum Choices {
		e_logicalChannelNumber,
		e_resourceID,
		e_wholeMultiplex
	};

	operator LogicalChannelNumber & ( ) { return dynamic_cast < LogicalChannelNumber & > ( * choice ); }
	operator const LogicalChannelNumber & ( ) const { return dynamic_cast < const LogicalChannelNumber & > ( * choice ); }
	operator JitterIndication_scope_resourceID & ( ) { return dynamic_cast < JitterIndication_scope_resourceID & > ( * choice ); }
	operator const JitterIndication_scope_resourceID & ( ) const { return dynamic_cast < const JitterIndication_scope_resourceID & > ( * choice ); }
	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	JitterIndication_scope * clone ( ) const;
};

//
// NewATMVCIndication_reverseParameters
//

// from 0 size 0 type 0 simple 0
class NewATMVCIndication_reverseParameters : public Asn :: Sequence {
	public:
	explicit NewATMVCIndication_reverseParameters ( Asn :: istream & is );
	NewATMVCIndication_reverseParameters ( );
	NewATMVCIndication_reverseParameters_bitRate m_bitRate;
	Asn :: Boolean m_bitRateLockedToPCRClock;
	Asn :: Boolean m_bitRateLockedToNetworkClock;
	NewATMVCIndication_reverseParameters_multiplex m_multiplex;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	NewATMVCIndication_reverseParameters * clone ( ) const;
};

//
// UserInputIndication_signal
//

// from 0 size 0 type 0 simple 0
class UserInputIndication_signal : public Asn :: Sequence {
	public:
	explicit UserInputIndication_signal ( Asn :: istream & is );
	UserInputIndication_signal ( );
	enum OptionalFields {
		e_duration,
		e_rtp,
		e_rtpPayloadIndication,
		e_paramS,
		e_encryptedSignalType,
		e_algorithmOID
	};

	UserInputIndication_signal ( const UserInputIndication_signal & s );
	UserInputIndication_signal & operator= ( const UserInputIndication_signal & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	UserInputIndication_signal_signalType m_signalType;
	protected:
	UserInputIndication_signal_duration * m_duration;
	UserInputIndication_signal_rtp * m_rtp;
	Asn :: Null * m_rtpPayloadIndication;
	Params * m_paramS;
	UserInputIndication_signal_encryptedSignalType * m_encryptedSignalType;
	Asn :: ObjectId * m_algorithmOID;
	public:
	void encode ( Asn :: ostream & os ) const;
	~UserInputIndication_signal ( );
	void printOn ( std :: ostream & os ) const;
	const UserInputIndication_signal_duration & get_duration ( ) const {
		return * m_duration;
	}
	UserInputIndication_signal_duration & get_duration ( ) {
		return * m_duration;
	}
	const UserInputIndication_signal_rtp & get_rtp ( ) const {
		return * m_rtp;
	}
	UserInputIndication_signal_rtp & get_rtp ( ) {
		return * m_rtp;
	}
	const Asn :: Null & get_rtpPayloadIndication ( ) const {
		return * m_rtpPayloadIndication;
	}
	Asn :: Null & get_rtpPayloadIndication ( ) {
		return * m_rtpPayloadIndication;
	}
	const Params & get_paramS ( ) const {
		return * m_paramS;
	}
	Params & get_paramS ( ) {
		return * m_paramS;
	}
	const UserInputIndication_signal_encryptedSignalType & get_encryptedSignalType ( ) const {
		return * m_encryptedSignalType;
	}
	UserInputIndication_signal_encryptedSignalType & get_encryptedSignalType ( ) {
		return * m_encryptedSignalType;
	}
	const Asn :: ObjectId & get_algorithmOID ( ) const {
		return * m_algorithmOID;
	}
	Asn :: ObjectId & get_algorithmOID ( ) {
		return * m_algorithmOID;
	}
	UserInputIndication_signal * clone ( ) const;
};

//
// UserInputIndication_signalUpdate
//

// from 0 size 0 type 0 simple 0
class UserInputIndication_signalUpdate : public Asn :: Sequence {
	public:
	explicit UserInputIndication_signalUpdate ( Asn :: istream & is );
	UserInputIndication_signalUpdate ( );
	enum OptionalFields {
		e_rtp
	};

	UserInputIndication_signalUpdate ( const UserInputIndication_signalUpdate & s );
	UserInputIndication_signalUpdate & operator= ( const UserInputIndication_signalUpdate & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	UserInputIndication_signalUpdate_duration m_duration;
	protected:
	UserInputIndication_signalUpdate_rtp * m_rtp;
	public:
	void encode ( Asn :: ostream & os ) const;
	~UserInputIndication_signalUpdate ( );
	void printOn ( std :: ostream & os ) const;
	const UserInputIndication_signalUpdate_rtp & get_rtp ( ) const {
		return * m_rtp;
	}
	UserInputIndication_signalUpdate_rtp & get_rtp ( ) {
		return * m_rtp;
	}
	UserInputIndication_signalUpdate * clone ( ) const;
};

//
// FlowControlIndication_scope
//

// from 0 size 0 type 0 simple 0
class FlowControlIndication_scope : public Asn :: Choice {
	public:
	explicit FlowControlIndication_scope ( Asn :: istream & is );
	FlowControlIndication_scope ( );
	enum Choices {
		e_logicalChannelNumber,
		e_resourceID,
		e_wholeMultiplex
	};

	operator LogicalChannelNumber & ( ) { return dynamic_cast < LogicalChannelNumber & > ( * choice ); }
	operator const LogicalChannelNumber & ( ) const { return dynamic_cast < const LogicalChannelNumber & > ( * choice ); }
	operator FlowControlIndication_scope_resourceID & ( ) { return dynamic_cast < FlowControlIndication_scope_resourceID & > ( * choice ); }
	operator const FlowControlIndication_scope_resourceID & ( ) const { return dynamic_cast < const FlowControlIndication_scope_resourceID & > ( * choice ); }
	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	FlowControlIndication_scope * clone ( ) const;
};

//
// FlowControlIndication_restriction
//

// from 0 size 0 type 0 simple 0
class FlowControlIndication_restriction : public Asn :: Choice {
	public:
	explicit FlowControlIndication_restriction ( Asn :: istream & is );
	FlowControlIndication_restriction ( );
	enum Choices {
		e_maximumBitRate,
		e_noRestriction
	};

	operator FlowControlIndication_restriction_maximumBitRate & ( ) { return dynamic_cast < FlowControlIndication_restriction_maximumBitRate & > ( * choice ); }
	operator const FlowControlIndication_restriction_maximumBitRate & ( ) const { return dynamic_cast < const FlowControlIndication_restriction_maximumBitRate & > ( * choice ); }
	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	FlowControlIndication_restriction * clone ( ) const;
};

//
// H223Capability_h223MultiplexTableCapability_enhanced
//

// from 0 size 0 type 0 simple 0
class H223Capability_h223MultiplexTableCapability_enhanced : public Asn :: Sequence {
	public:
	explicit H223Capability_h223MultiplexTableCapability_enhanced ( Asn :: istream & is );
	H223Capability_h223MultiplexTableCapability_enhanced ( );
	H223Capability_h223MultiplexTableCapability_enhanced_maximumNestingDepth m_maximumNestingDepth;
	H223Capability_h223MultiplexTableCapability_enhanced_maximumElementListSize m_maximumElementListSize;
	H223Capability_h223MultiplexTableCapability_enhanced_maximumSubElementListSize m_maximumSubElementListSize;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	H223Capability_h223MultiplexTableCapability_enhanced * clone ( ) const;
};

//
// RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters
//

// from 0 size 0 type 0 simple 0
class RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters : public Asn :: Sequence {
	public:
	explicit RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters ( Asn :: istream & is );
	RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters ( );
	RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuHorizMBs m_mpuHorizMBs;
	RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuVertMBs m_mpuVertMBs;
	RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuTotalNumber m_mpuTotalNumber;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters * clone ( ) const;
};

//
// H223LogicalChannelParameters_adaptationLayerType_al3
//

// from 0 size 0 type 0 simple 0
class H223LogicalChannelParameters_adaptationLayerType_al3 : public Asn :: Sequence {
	public:
	explicit H223LogicalChannelParameters_adaptationLayerType_al3 ( Asn :: istream & is );
	H223LogicalChannelParameters_adaptationLayerType_al3 ( );
	H223LogicalChannelParameters_adaptationLayerType_al3_controlFieldOctets m_controlFieldOctets;
	H223LogicalChannelParameters_adaptationLayerType_al3_sendBufferSize m_sendBufferSize;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	H223LogicalChannelParameters_adaptationLayerType_al3 * clone ( ) const;
};

//
// V76LogicalChannelParameters_mode_eRM
//

// from 0 size 0 type 0 simple 0
class V76LogicalChannelParameters_mode_eRM : public Asn :: Sequence {
	public:
	explicit V76LogicalChannelParameters_mode_eRM ( Asn :: istream & is );
	V76LogicalChannelParameters_mode_eRM ( );
	V76LogicalChannelParameters_mode_eRM_windowSize m_windowSize;
	V76LogicalChannelParameters_mode_eRM_recovery m_recovery;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	V76LogicalChannelParameters_mode_eRM * clone ( ) const;
};

//
// FECData_rfc2733_pktMode
//

// from 0 size 0 type 0 simple 0
class FECData_rfc2733_pktMode : public Asn :: Choice {
	public:
	explicit FECData_rfc2733_pktMode ( Asn :: istream & is );
	FECData_rfc2733_pktMode ( );
	enum Choices {
		e_rfc2198coding,
		e_rfc2733sameport,
		e_rfc2733diffport
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator FECData_rfc2733_pktMode_rfc2733sameport & ( ) { return dynamic_cast < FECData_rfc2733_pktMode_rfc2733sameport & > ( * choice ); }
	operator const FECData_rfc2733_pktMode_rfc2733sameport & ( ) const { return dynamic_cast < const FECData_rfc2733_pktMode_rfc2733sameport & > ( * choice ); }
	operator FECData_rfc2733_pktMode_rfc2733diffport & ( ) { return dynamic_cast < FECData_rfc2733_pktMode_rfc2733diffport & > ( * choice ); }
	operator const FECData_rfc2733_pktMode_rfc2733diffport & ( ) const { return dynamic_cast < const FECData_rfc2733_pktMode_rfc2733diffport & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	FECData_rfc2733_pktMode * clone ( ) const;
};

//
// OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters
//

// from 0 size 0 type 0 simple 0
class OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters : public Asn :: Choice {
	public:
	explicit OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters ( Asn :: istream & is );
	OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters ( );
	enum Choices {
		e_h222LogicalChannelParameters,
		e_h2250LogicalChannelParameters
	};

	operator H222LogicalChannelParameters & ( ) { return dynamic_cast < H222LogicalChannelParameters & > ( * choice ); }
	operator const H222LogicalChannelParameters & ( ) const { return dynamic_cast < const H222LogicalChannelParameters & > ( * choice ); }
	operator H2250LogicalChannelParameters & ( ) { return dynamic_cast < H2250LogicalChannelParameters & > ( * choice ); }
	operator const H2250LogicalChannelParameters & ( ) const { return dynamic_cast < const H2250LogicalChannelParameters & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters * clone ( ) const;
};

//
// H223ModeParameters_adaptationLayerType_al3
//

// from 0 size 0 type 0 simple 0
class H223ModeParameters_adaptationLayerType_al3 : public Asn :: Sequence {
	public:
	explicit H223ModeParameters_adaptationLayerType_al3 ( Asn :: istream & is );
	H223ModeParameters_adaptationLayerType_al3 ( );
	H223ModeParameters_adaptationLayerType_al3_controlFieldOctets m_controlFieldOctets;
	H223ModeParameters_adaptationLayerType_al3_sendBufferSize m_sendBufferSize;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	H223ModeParameters_adaptationLayerType_al3 * clone ( ) const;
};

//
// MultilinkRequest_maximumHeaderInterval_requestType
//

// from 0 size 0 type 0 simple 0
class MultilinkRequest_maximumHeaderInterval_requestType : public Asn :: Choice {
	public:
	explicit MultilinkRequest_maximumHeaderInterval_requestType ( Asn :: istream & is );
	MultilinkRequest_maximumHeaderInterval_requestType ( );
	enum Choices {
		e_currentIntervalInformation,
		e_requestedInterval
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator MultilinkRequest_maximumHeaderInterval_requestType_requestedInterval & ( ) { return dynamic_cast < MultilinkRequest_maximumHeaderInterval_requestType_requestedInterval & > ( * choice ); }
	operator const MultilinkRequest_maximumHeaderInterval_requestType_requestedInterval & ( ) const { return dynamic_cast < const MultilinkRequest_maximumHeaderInterval_requestType_requestedInterval & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	MultilinkRequest_maximumHeaderInterval_requestType * clone ( ) const;
};

//
// MultilinkResponse_addConnection_responseCode
//

// from 0 size 0 type 0 simple 0
class MultilinkResponse_addConnection_responseCode : public Asn :: Choice {
	public:
	explicit MultilinkResponse_addConnection_responseCode ( Asn :: istream & is );
	MultilinkResponse_addConnection_responseCode ( );
	enum Choices {
		e_accepted,
		e_rejected
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator MultilinkResponse_addConnection_responseCode_rejected & ( ) { return dynamic_cast < MultilinkResponse_addConnection_responseCode_rejected & > ( * choice ); }
	operator const MultilinkResponse_addConnection_responseCode_rejected & ( ) const { return dynamic_cast < const MultilinkResponse_addConnection_responseCode_rejected & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	MultilinkResponse_addConnection_responseCode * clone ( ) const;
};

//
// MiscellaneousCommand_type_videoFastUpdateGOB
//

// from 0 size 0 type 0 simple 0
class MiscellaneousCommand_type_videoFastUpdateGOB : public Asn :: Sequence {
	public:
	explicit MiscellaneousCommand_type_videoFastUpdateGOB ( Asn :: istream & is );
	MiscellaneousCommand_type_videoFastUpdateGOB ( );
	MiscellaneousCommand_type_videoFastUpdateGOB_firstGOB m_firstGOB;
	MiscellaneousCommand_type_videoFastUpdateGOB_numberOfGOBs m_numberOfGOBs;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MiscellaneousCommand_type_videoFastUpdateGOB * clone ( ) const;
};

//
// MiscellaneousCommand_type_videoFastUpdateMB
//

// from 0 size 0 type 0 simple 0
class MiscellaneousCommand_type_videoFastUpdateMB : public Asn :: Sequence {
	public:
	explicit MiscellaneousCommand_type_videoFastUpdateMB ( Asn :: istream & is );
	MiscellaneousCommand_type_videoFastUpdateMB ( );
	enum OptionalFields {
		e_firstGOB,
		e_firstMB
	};

	MiscellaneousCommand_type_videoFastUpdateMB ( const MiscellaneousCommand_type_videoFastUpdateMB & s );
	MiscellaneousCommand_type_videoFastUpdateMB & operator= ( const MiscellaneousCommand_type_videoFastUpdateMB & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	MiscellaneousCommand_type_videoFastUpdateMB_firstGOB * m_firstGOB;
	MiscellaneousCommand_type_videoFastUpdateMB_firstMB * m_firstMB;
	public:
	MiscellaneousCommand_type_videoFastUpdateMB_numberOfMBs m_numberOfMBs;
	void encode ( Asn :: ostream & os ) const;
	~MiscellaneousCommand_type_videoFastUpdateMB ( );
	void printOn ( std :: ostream & os ) const;
	const MiscellaneousCommand_type_videoFastUpdateMB_firstGOB & get_firstGOB ( ) const {
		return * m_firstGOB;
	}
	MiscellaneousCommand_type_videoFastUpdateMB_firstGOB & get_firstGOB ( ) {
		return * m_firstGOB;
	}
	const MiscellaneousCommand_type_videoFastUpdateMB_firstMB & get_firstMB ( ) const {
		return * m_firstMB;
	}
	MiscellaneousCommand_type_videoFastUpdateMB_firstMB & get_firstMB ( ) {
		return * m_firstMB;
	}
	MiscellaneousCommand_type_videoFastUpdateMB * clone ( ) const;
};

//
// MiscellaneousCommand_type_progressiveRefinementStart
//

// from 0 size 0 type 0 simple 0
class MiscellaneousCommand_type_progressiveRefinementStart : public Asn :: Sequence {
	public:
	explicit MiscellaneousCommand_type_progressiveRefinementStart ( Asn :: istream & is );
	MiscellaneousCommand_type_progressiveRefinementStart ( );
	MiscellaneousCommand_type_progressiveRefinementStart_repeatCount m_repeatCount;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MiscellaneousCommand_type_progressiveRefinementStart * clone ( ) const;
};

//
// MiscellaneousCommand_type_videoBadMBs
//

// from 0 size 0 type 0 simple 0
class MiscellaneousCommand_type_videoBadMBs : public Asn :: Sequence {
	public:
	explicit MiscellaneousCommand_type_videoBadMBs ( Asn :: istream & is );
	MiscellaneousCommand_type_videoBadMBs ( );
	MiscellaneousCommand_type_videoBadMBs_firstMB m_firstMB;
	MiscellaneousCommand_type_videoBadMBs_numberOfMBs m_numberOfMBs;
	MiscellaneousCommand_type_videoBadMBs_temporalReference m_temporalReference;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MiscellaneousCommand_type_videoBadMBs * clone ( ) const;
};

//
// MiscellaneousCommand_type_lostPartialPicture
//

// from 0 size 0 type 0 simple 0
class MiscellaneousCommand_type_lostPartialPicture : public Asn :: Sequence {
	public:
	explicit MiscellaneousCommand_type_lostPartialPicture ( Asn :: istream & is );
	MiscellaneousCommand_type_lostPartialPicture ( );
	PictureReference m_pictureReference;
	MiscellaneousCommand_type_lostPartialPicture_firstMB m_firstMB;
	MiscellaneousCommand_type_lostPartialPicture_numberOfMBs m_numberOfMBs;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MiscellaneousCommand_type_lostPartialPicture * clone ( ) const;
};

//
// MiscellaneousCommand_type_encryptionUpdateCommand
//

// from 0 size 0 type 0 simple 0
class MiscellaneousCommand_type_encryptionUpdateCommand : public Asn :: Sequence {
	public:
	explicit MiscellaneousCommand_type_encryptionUpdateCommand ( Asn :: istream & is );
	MiscellaneousCommand_type_encryptionUpdateCommand ( );
	enum OptionalFields {
		e_multiplePayloadStream
	};

	MiscellaneousCommand_type_encryptionUpdateCommand ( const MiscellaneousCommand_type_encryptionUpdateCommand & s );
	MiscellaneousCommand_type_encryptionUpdateCommand & operator= ( const MiscellaneousCommand_type_encryptionUpdateCommand & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	EncryptionSync m_encryptionSync;
	protected:
	MultiplePayloadStream * m_multiplePayloadStream;
	public:
	void encode ( Asn :: ostream & os ) const;
	~MiscellaneousCommand_type_encryptionUpdateCommand ( );
	void printOn ( std :: ostream & os ) const;
	const MultiplePayloadStream & get_multiplePayloadStream ( ) const {
		return * m_multiplePayloadStream;
	}
	MultiplePayloadStream & get_multiplePayloadStream ( ) {
		return * m_multiplePayloadStream;
	}
	MiscellaneousCommand_type_encryptionUpdateCommand * clone ( ) const;
};

//
// MiscellaneousCommand_type_encryptionUpdateAck
//

// from 0 size 0 type 0 simple 0
class MiscellaneousCommand_type_encryptionUpdateAck : public Asn :: Sequence {
	public:
	explicit MiscellaneousCommand_type_encryptionUpdateAck ( Asn :: istream & is );
	MiscellaneousCommand_type_encryptionUpdateAck ( );
	MiscellaneousCommand_type_encryptionUpdateAck_synchFlag m_synchFlag;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MiscellaneousCommand_type_encryptionUpdateAck * clone ( ) const;
};

//
// NewATMVCCommand_aal_aal1
//

// from 0 size 0 type 0 simple 0
class NewATMVCCommand_aal_aal1 : public Asn :: Sequence {
	public:
	explicit NewATMVCCommand_aal_aal1 ( Asn :: istream & is );
	NewATMVCCommand_aal_aal1 ( );
	NewATMVCCommand_aal_aal1_clockRecovery m_clockRecovery;
	NewATMVCCommand_aal_aal1_errorCorrection m_errorCorrection;
	Asn :: Boolean m_structuredDataTransfer;
	Asn :: Boolean m_partiallyFilledCells;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	NewATMVCCommand_aal_aal1 * clone ( ) const;
};

//
// NewATMVCCommand_aal_aal5
//

// from 0 size 0 type 0 simple 0
class NewATMVCCommand_aal_aal5 : public Asn :: Sequence {
	public:
	explicit NewATMVCCommand_aal_aal5 ( Asn :: istream & is );
	NewATMVCCommand_aal_aal5 ( );
	NewATMVCCommand_aal_aal5_forwardMaximumSDUSize m_forwardMaximumSDUSize;
	NewATMVCCommand_aal_aal5_backwardMaximumSDUSize m_backwardMaximumSDUSize;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	NewATMVCCommand_aal_aal5 * clone ( ) const;
};

//
// MiscellaneousIndication_type_videoNotDecodedMBs
//

// from 0 size 0 type 0 simple 0
class MiscellaneousIndication_type_videoNotDecodedMBs : public Asn :: Sequence {
	public:
	explicit MiscellaneousIndication_type_videoNotDecodedMBs ( Asn :: istream & is );
	MiscellaneousIndication_type_videoNotDecodedMBs ( );
	MiscellaneousIndication_type_videoNotDecodedMBs_firstMB m_firstMB;
	MiscellaneousIndication_type_videoNotDecodedMBs_numberOfMBs m_numberOfMBs;
	MiscellaneousIndication_type_videoNotDecodedMBs_temporalReference m_temporalReference;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MiscellaneousIndication_type_videoNotDecodedMBs * clone ( ) const;
};

//
// NewATMVCIndication_aal_aal1
//

// from 0 size 0 type 0 simple 0
class NewATMVCIndication_aal_aal1 : public Asn :: Sequence {
	public:
	explicit NewATMVCIndication_aal_aal1 ( Asn :: istream & is );
	NewATMVCIndication_aal_aal1 ( );
	NewATMVCIndication_aal_aal1_clockRecovery m_clockRecovery;
	NewATMVCIndication_aal_aal1_errorCorrection m_errorCorrection;
	Asn :: Boolean m_structuredDataTransfer;
	Asn :: Boolean m_partiallyFilledCells;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	NewATMVCIndication_aal_aal1 * clone ( ) const;
};

//
// NewATMVCIndication_aal_aal5
//

// from 0 size 0 type 0 simple 0
class NewATMVCIndication_aal_aal5 : public Asn :: Sequence {
	public:
	explicit NewATMVCIndication_aal_aal5 ( Asn :: istream & is );
	NewATMVCIndication_aal_aal5 ( );
	NewATMVCIndication_aal_aal5_forwardMaximumSDUSize m_forwardMaximumSDUSize;
	NewATMVCIndication_aal_aal5_backwardMaximumSDUSize m_backwardMaximumSDUSize;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	NewATMVCIndication_aal_aal5 * clone ( ) const;
};

//
// VCCapability_availableBitRates_type_rangeOfBitRates
//

// from 0 size 0 type 0 simple 0
class VCCapability_availableBitRates_type_rangeOfBitRates : public Asn :: Sequence {
	public:
	explicit VCCapability_availableBitRates_type_rangeOfBitRates ( Asn :: istream & is );
	VCCapability_availableBitRates_type_rangeOfBitRates ( );
	VCCapability_availableBitRates_type_rangeOfBitRates_lowerBitRate m_lowerBitRate;
	VCCapability_availableBitRates_type_rangeOfBitRates_higherBitRate m_higherBitRate;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	VCCapability_availableBitRates_type_rangeOfBitRates * clone ( ) const;
};

//
// CustomPictureFormat_mPI_customPCF_subtype
//

// from 0 size 0 type 0 simple 0
class CustomPictureFormat_mPI_customPCF_subtype : public Asn :: Sequence {
	public:
	explicit CustomPictureFormat_mPI_customPCF_subtype ( Asn :: istream & is );
	CustomPictureFormat_mPI_customPCF_subtype ( );
	CustomPictureFormat_mPI_customPCF_subtype_clockConversionCode m_clockConversionCode;
	CustomPictureFormat_mPI_customPCF_subtype_clockDivisor m_clockDivisor;
	CustomPictureFormat_mPI_customPCF_subtype_customMPI m_customMPI;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	CustomPictureFormat_mPI_customPCF_subtype * clone ( ) const;
};

//
// CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype
//

// from 0 size 0 type 0 simple 0
class CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype : public Asn :: Sequence {
	public:
	explicit CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype ( Asn :: istream & is );
	CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype ( );
	CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype_width m_width;
	CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype_height m_height;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype * clone ( ) const;
};

//
// DepFECData_rfc2733_mode_separateStream_differentPort
//

// from 0 size 0 type 0 simple 0
class DepFECData_rfc2733_mode_separateStream_differentPort : public Asn :: Sequence {
	public:
	explicit DepFECData_rfc2733_mode_separateStream_differentPort ( Asn :: istream & is );
	DepFECData_rfc2733_mode_separateStream_differentPort ( );
	enum OptionalFields {
		e_protectedPayloadType
	};

	DepFECData_rfc2733_mode_separateStream_differentPort ( const DepFECData_rfc2733_mode_separateStream_differentPort & s );
	DepFECData_rfc2733_mode_separateStream_differentPort & operator= ( const DepFECData_rfc2733_mode_separateStream_differentPort & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	DepFECData_rfc2733_mode_separateStream_differentPort_protectedSessionID m_protectedSessionID;
	protected:
	DepFECData_rfc2733_mode_separateStream_differentPort_protectedPayloadType * m_protectedPayloadType;
	public:
	void encode ( Asn :: ostream & os ) const;
	~DepFECData_rfc2733_mode_separateStream_differentPort ( );
	void printOn ( std :: ostream & os ) const;
	const DepFECData_rfc2733_mode_separateStream_differentPort_protectedPayloadType & get_protectedPayloadType ( ) const {
		return * m_protectedPayloadType;
	}
	DepFECData_rfc2733_mode_separateStream_differentPort_protectedPayloadType & get_protectedPayloadType ( ) {
		return * m_protectedPayloadType;
	}
	DepFECData_rfc2733_mode_separateStream_differentPort * clone ( ) const;
};

//
// DepFECData_rfc2733_mode_separateStream_samePort
//

// from 0 size 0 type 0 simple 0
class DepFECData_rfc2733_mode_separateStream_samePort : public Asn :: Sequence {
	public:
	explicit DepFECData_rfc2733_mode_separateStream_samePort ( Asn :: istream & is );
	DepFECData_rfc2733_mode_separateStream_samePort ( );
	DepFECData_rfc2733_mode_separateStream_samePort_protectedPayloadType m_protectedPayloadType;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	DepFECData_rfc2733_mode_separateStream_samePort * clone ( ) const;
};

//
// DepFECMode_rfc2733Mode_mode_separateStream_differentPort
//

// from 0 size 0 type 0 simple 0
class DepFECMode_rfc2733Mode_mode_separateStream_differentPort : public Asn :: Sequence {
	public:
	explicit DepFECMode_rfc2733Mode_mode_separateStream_differentPort ( Asn :: istream & is );
	DepFECMode_rfc2733Mode_mode_separateStream_differentPort ( );
	enum OptionalFields {
		e_protectedPayloadType
	};

	DepFECMode_rfc2733Mode_mode_separateStream_differentPort ( const DepFECMode_rfc2733Mode_mode_separateStream_differentPort & s );
	DepFECMode_rfc2733Mode_mode_separateStream_differentPort & operator= ( const DepFECMode_rfc2733Mode_mode_separateStream_differentPort & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedSessionID m_protectedSessionID;
	protected:
	DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedPayloadType * m_protectedPayloadType;
	public:
	void encode ( Asn :: ostream & os ) const;
	~DepFECMode_rfc2733Mode_mode_separateStream_differentPort ( );
	void printOn ( std :: ostream & os ) const;
	const DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedPayloadType & get_protectedPayloadType ( ) const {
		return * m_protectedPayloadType;
	}
	DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedPayloadType & get_protectedPayloadType ( ) {
		return * m_protectedPayloadType;
	}
	DepFECMode_rfc2733Mode_mode_separateStream_differentPort * clone ( ) const;
};

//
// NonStandardIdentifier
//

// from 0 size 0 type 0 simple 0
class NonStandardIdentifier : public Asn :: Choice {
	public:
	explicit NonStandardIdentifier ( Asn :: istream & is );
	NonStandardIdentifier ( );
	enum Choices {
		e_object,
		e_h221NonStandard
	};

	operator Asn :: ObjectId & ( ) { return dynamic_cast < Asn :: ObjectId & > ( * choice ); }
	operator const Asn :: ObjectId & ( ) const { return dynamic_cast < const Asn :: ObjectId & > ( * choice ); }
	operator NonStandardIdentifier_h221NonStandard & ( ) { return dynamic_cast < NonStandardIdentifier_h221NonStandard & > ( * choice ); }
	operator const NonStandardIdentifier_h221NonStandard & ( ) const { return dynamic_cast < const NonStandardIdentifier_h221NonStandard & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	NonStandardIdentifier * clone ( ) const;
};

//
// TerminalCapabilitySetReject
//

// from 0 size 0 type 0 simple 0
class TerminalCapabilitySetReject : public Asn :: Sequence {
	public:
	explicit TerminalCapabilitySetReject ( Asn :: istream & is );
	TerminalCapabilitySetReject ( );
	enum OptionalFields {
		e_genericInformation
	};

	TerminalCapabilitySetReject ( const TerminalCapabilitySetReject & s );
	TerminalCapabilitySetReject & operator= ( const TerminalCapabilitySetReject & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	SequenceNumber m_sequenceNumber;
	TerminalCapabilitySetReject_cause m_cause;
	protected:
	ArrayOf_GenericInformation * m_genericInformation;
	public:
	void encode ( Asn :: ostream & os ) const;
	~TerminalCapabilitySetReject ( );
	void printOn ( std :: ostream & os ) const;
	const ArrayOf_GenericInformation & get_genericInformation ( ) const {
		return * m_genericInformation;
	}
	ArrayOf_GenericInformation & get_genericInformation ( ) {
		return * m_genericInformation;
	}
	TerminalCapabilitySetReject * clone ( ) const;
};

//
// H2250Capability
//

// from 0 size 0 type 0 simple 0
class H2250Capability : public Asn :: Sequence {
	public:
	explicit H2250Capability ( Asn :: istream & is );
	H2250Capability ( );
	enum OptionalFields {
		e_transportCapability,
		e_redundancyEncodingCapability,
		e_logicalChannelSwitchingCapability,
		e_t120DynamicPortCapability
	};

	H2250Capability ( const H2250Capability & s );
	H2250Capability & operator= ( const H2250Capability & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	H2250Capability_maximumAudioDelayJitter m_maximumAudioDelayJitter;
	MultipointCapability m_receiveMultipointCapability;
	MultipointCapability m_transmitMultipointCapability;
	MultipointCapability m_receiveAndTransmitMultipointCapability;
	H2250Capability_mcCapability m_mcCapability;
	Asn :: Boolean m_rtcpVideoControlCapability;
	MediaPacketizationCapability m_mediaPacketizationCapability;
	protected:
	TransportCapability * m_transportCapability;
	H2250Capability_redundancyEncodingCapability * m_redundancyEncodingCapability;
	Asn :: Boolean * m_logicalChannelSwitchingCapability;
	Asn :: Boolean * m_t120DynamicPortCapability;
	public:
	void encode ( Asn :: ostream & os ) const;
	~H2250Capability ( );
	void printOn ( std :: ostream & os ) const;
	const TransportCapability & get_transportCapability ( ) const {
		return * m_transportCapability;
	}
	TransportCapability & get_transportCapability ( ) {
		return * m_transportCapability;
	}
	const H2250Capability_redundancyEncodingCapability & get_redundancyEncodingCapability ( ) const {
		return * m_redundancyEncodingCapability;
	}
	H2250Capability_redundancyEncodingCapability & get_redundancyEncodingCapability ( ) {
		return * m_redundancyEncodingCapability;
	}
	const Asn :: Boolean & get_logicalChannelSwitchingCapability ( ) const {
		return * m_logicalChannelSwitchingCapability;
	}
	Asn :: Boolean & get_logicalChannelSwitchingCapability ( ) {
		return * m_logicalChannelSwitchingCapability;
	}
	const Asn :: Boolean & get_t120DynamicPortCapability ( ) const {
		return * m_t120DynamicPortCapability;
	}
	Asn :: Boolean & get_t120DynamicPortCapability ( ) {
		return * m_t120DynamicPortCapability;
	}
	H2250Capability * clone ( ) const;
};

//
// RTPH263VideoRedundancyEncoding
//

// from 0 size 0 type 0 simple 0
class RTPH263VideoRedundancyEncoding : public Asn :: Sequence {
	public:
	explicit RTPH263VideoRedundancyEncoding ( Asn :: istream & is );
	RTPH263VideoRedundancyEncoding ( );
	enum OptionalFields {
		e_containedThreads
	};

	RTPH263VideoRedundancyEncoding ( const RTPH263VideoRedundancyEncoding & s );
	RTPH263VideoRedundancyEncoding & operator= ( const RTPH263VideoRedundancyEncoding & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	RTPH263VideoRedundancyEncoding_numberOfThreads m_numberOfThreads;
	RTPH263VideoRedundancyEncoding_framesBetweenSyncPoints m_framesBetweenSyncPoints;
	RTPH263VideoRedundancyEncoding_frameToThreadMapping m_frameToThreadMapping;
	protected:
	RTPH263VideoRedundancyEncoding_containedThreads * m_containedThreads;
	public:
	void encode ( Asn :: ostream & os ) const;
	~RTPH263VideoRedundancyEncoding ( );
	void printOn ( std :: ostream & os ) const;
	const RTPH263VideoRedundancyEncoding_containedThreads & get_containedThreads ( ) const {
		return * m_containedThreads;
	}
	RTPH263VideoRedundancyEncoding_containedThreads & get_containedThreads ( ) {
		return * m_containedThreads;
	}
	RTPH263VideoRedundancyEncoding * clone ( ) const;
};

//
// BEnhancementParameters
//

// from 0 size 0 type 0 simple 0
class BEnhancementParameters : public Asn :: Sequence {
	public:
	explicit BEnhancementParameters ( Asn :: istream & is );
	BEnhancementParameters ( );
	EnhancementOptions m_enhancementOptions;
	BEnhancementParameters_numberOfBPictures m_numberOfBPictures;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	BEnhancementParameters * clone ( ) const;
};

//
// CustomPictureFormat
//

// from 0 size 0 type 0 simple 0
class CustomPictureFormat : public Asn :: Sequence {
	public:
	explicit CustomPictureFormat ( Asn :: istream & is );
	CustomPictureFormat ( );
	CustomPictureFormat_maxCustomPictureWidth m_maxCustomPictureWidth;
	CustomPictureFormat_maxCustomPictureHeight m_maxCustomPictureHeight;
	CustomPictureFormat_minCustomPictureWidth m_minCustomPictureWidth;
	CustomPictureFormat_minCustomPictureHeight m_minCustomPictureHeight;
	CustomPictureFormat_mPI m_mPI;
	CustomPictureFormat_pixelAspectInformation m_pixelAspectInformation;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	CustomPictureFormat * clone ( ) const;
};

//
// CompressionType
//

// from 0 size 0 type 0 simple 0
class CompressionType : public Asn :: Choice {
	public:
	explicit CompressionType ( Asn :: istream & is );
	CompressionType ( );
	enum Choices {
		e_v42bis
	};

	operator V42bis & ( ) { return dynamic_cast < V42bis & > ( * choice ); }
	operator const V42bis & ( ) const { return dynamic_cast < const V42bis & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	CompressionType * clone ( ) const;
};

//
// DepFECCapability
//

// from 0 size 0 type 0 simple 0
class DepFECCapability : public Asn :: Choice {
	public:
	explicit DepFECCapability ( Asn :: istream & is );
	DepFECCapability ( );
	enum Choices {
		e_rfc2733
	};

	operator DepFECCapability_rfc2733 & ( ) { return dynamic_cast < DepFECCapability_rfc2733 & > ( * choice ); }
	operator const DepFECCapability_rfc2733 & ( ) const { return dynamic_cast < const DepFECCapability_rfc2733 & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	DepFECCapability * clone ( ) const;
};

//
// Q2931Address
//

// from 0 size 0 type 0 simple 0
class Q2931Address : public Asn :: Sequence {
	public:
	explicit Q2931Address ( Asn :: istream & is );
	Q2931Address ( );
	enum OptionalFields {
		e_subaddress
	};

	Q2931Address ( const Q2931Address & s );
	Q2931Address & operator= ( const Q2931Address & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	Q2931Address_address m_address;
	protected:
	Q2931Address_subaddress * m_subaddress;
	public:
	void encode ( Asn :: ostream & os ) const;
	~Q2931Address ( );
	void printOn ( std :: ostream & os ) const;
	const Q2931Address_subaddress & get_subaddress ( ) const {
		return * m_subaddress;
	}
	Q2931Address_subaddress & get_subaddress ( ) {
		return * m_subaddress;
	}
	Q2931Address * clone ( ) const;
};

//
// H223AnnexCArqParameters
//

// from 0 size 0 type 0 simple 0
class H223AnnexCArqParameters : public Asn :: Sequence {
	public:
	explicit H223AnnexCArqParameters ( Asn :: istream & is );
	H223AnnexCArqParameters ( );
	H223AnnexCArqParameters_numberOfRetransmissions m_numberOfRetransmissions;
	H223AnnexCArqParameters_sendBufferSize m_sendBufferSize;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	H223AnnexCArqParameters * clone ( ) const;
};

//
// MultiplexElement
//

// from 0 size 0 type 0 simple 0
class MultiplexElement : public Asn :: Sequence {
	public:
	explicit MultiplexElement ( Asn :: istream & is );
	MultiplexElement ( );
	MultiplexElement_type m_type;
	MultiplexElement_repeatCount m_repeatCount;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MultiplexElement * clone ( ) const;
};

//
// G7231AnnexCMode
//

// from 0 size 0 type 0 simple 0
class G7231AnnexCMode : public Asn :: Sequence {
	public:
	explicit G7231AnnexCMode ( Asn :: istream & is );
	G7231AnnexCMode ( );
	G7231AnnexCMode_maxAl_sduAudioFrames m_maxAl_sduAudioFrames;
	Asn :: Boolean m_silenceSuppression;
	G7231AnnexCMode_g723AnnexCAudioMode m_g723AnnexCAudioMode;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	G7231AnnexCMode * clone ( ) const;
};

//
// ConferenceRequest
//

// from 0 size 0 type 0 simple 0
class ConferenceRequest : public Asn :: Choice {
	public:
	explicit ConferenceRequest ( Asn :: istream & is );
	ConferenceRequest ( );
	enum Choices {
		e_terminalListRequest,
		e_makeMeChair,
		e_cancelMakeMeChair,
		e_dropTerminal,
		e_requestTerminalID,
		e_enterH243Password,
		e_enterH243TerminalID,
		e_enterH243ConferenceID,
		e_enterExtensionAddress,
		e_requestChairTokenOwner,
		e_requestTerminalCertificate,
		e_broadcastMyLogicalChannel,
		e_makeTerminalBroadcaster,
		e_sendThisSource,
		e_requestAllTerminalIDs,
		e_remoteMCRequest
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator TerminalLabel & ( ) { return dynamic_cast < TerminalLabel & > ( * choice ); }
	operator const TerminalLabel & ( ) const { return dynamic_cast < const TerminalLabel & > ( * choice ); }
	operator ConferenceRequest_requestTerminalCertificate & ( ) { return dynamic_cast < ConferenceRequest_requestTerminalCertificate & > ( * choice ); }
	operator const ConferenceRequest_requestTerminalCertificate & ( ) const { return dynamic_cast < const ConferenceRequest_requestTerminalCertificate & > ( * choice ); }
	operator LogicalChannelNumber & ( ) { return dynamic_cast < LogicalChannelNumber & > ( * choice ); }
	operator const LogicalChannelNumber & ( ) const { return dynamic_cast < const LogicalChannelNumber & > ( * choice ); }
	operator RemoteMCRequest & ( ) { return dynamic_cast < RemoteMCRequest & > ( * choice ); }
	operator const RemoteMCRequest & ( ) const { return dynamic_cast < const RemoteMCRequest & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	ConferenceRequest * clone ( ) const;
};

//
// ConferenceResponse
//

// from 0 size 0 type 0 simple 0
class ConferenceResponse : public Asn :: Choice {
	public:
	explicit ConferenceResponse ( Asn :: istream & is );
	ConferenceResponse ( );
	enum Choices {
		e_mCTerminalIDResponse,
		e_terminalIDResponse,
		e_conferenceIDResponse,
		e_passwordResponse,
		e_terminalListResponse,
		e_videoCommandReject,
		e_terminalDropReject,
		e_makeMeChairResponse,
		e_extensionAddressResponse,
		e_chairTokenOwnerResponse,
		e_terminalCertificateResponse,
		e_broadcastMyLogicalChannelResponse,
		e_makeTerminalBroadcasterResponse,
		e_sendThisSourceResponse,
		e_requestAllTerminalIDsResponse,
		e_remoteMCResponse
	};

	operator ConferenceResponse_mCTerminalIDResponse & ( ) { return dynamic_cast < ConferenceResponse_mCTerminalIDResponse & > ( * choice ); }
	operator const ConferenceResponse_mCTerminalIDResponse & ( ) const { return dynamic_cast < const ConferenceResponse_mCTerminalIDResponse & > ( * choice ); }
	operator ConferenceResponse_terminalIDResponse & ( ) { return dynamic_cast < ConferenceResponse_terminalIDResponse & > ( * choice ); }
	operator const ConferenceResponse_terminalIDResponse & ( ) const { return dynamic_cast < const ConferenceResponse_terminalIDResponse & > ( * choice ); }
	operator ConferenceResponse_conferenceIDResponse & ( ) { return dynamic_cast < ConferenceResponse_conferenceIDResponse & > ( * choice ); }
	operator const ConferenceResponse_conferenceIDResponse & ( ) const { return dynamic_cast < const ConferenceResponse_conferenceIDResponse & > ( * choice ); }
	operator ConferenceResponse_passwordResponse & ( ) { return dynamic_cast < ConferenceResponse_passwordResponse & > ( * choice ); }
	operator const ConferenceResponse_passwordResponse & ( ) const { return dynamic_cast < const ConferenceResponse_passwordResponse & > ( * choice ); }
	operator ConferenceResponse_terminalListResponse & ( ) { return dynamic_cast < ConferenceResponse_terminalListResponse & > ( * choice ); }
	operator const ConferenceResponse_terminalListResponse & ( ) const { return dynamic_cast < const ConferenceResponse_terminalListResponse & > ( * choice ); }
	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator ConferenceResponse_makeMeChairResponse & ( ) { return dynamic_cast < ConferenceResponse_makeMeChairResponse & > ( * choice ); }
	operator const ConferenceResponse_makeMeChairResponse & ( ) const { return dynamic_cast < const ConferenceResponse_makeMeChairResponse & > ( * choice ); }
	operator ConferenceResponse_extensionAddressResponse & ( ) { return dynamic_cast < ConferenceResponse_extensionAddressResponse & > ( * choice ); }
	operator const ConferenceResponse_extensionAddressResponse & ( ) const { return dynamic_cast < const ConferenceResponse_extensionAddressResponse & > ( * choice ); }
	operator ConferenceResponse_chairTokenOwnerResponse & ( ) { return dynamic_cast < ConferenceResponse_chairTokenOwnerResponse & > ( * choice ); }
	operator const ConferenceResponse_chairTokenOwnerResponse & ( ) const { return dynamic_cast < const ConferenceResponse_chairTokenOwnerResponse & > ( * choice ); }
	operator ConferenceResponse_terminalCertificateResponse & ( ) { return dynamic_cast < ConferenceResponse_terminalCertificateResponse & > ( * choice ); }
	operator const ConferenceResponse_terminalCertificateResponse & ( ) const { return dynamic_cast < const ConferenceResponse_terminalCertificateResponse & > ( * choice ); }
	operator ConferenceResponse_broadcastMyLogicalChannelResponse & ( ) { return dynamic_cast < ConferenceResponse_broadcastMyLogicalChannelResponse & > ( * choice ); }
	operator const ConferenceResponse_broadcastMyLogicalChannelResponse & ( ) const { return dynamic_cast < const ConferenceResponse_broadcastMyLogicalChannelResponse & > ( * choice ); }
	operator ConferenceResponse_makeTerminalBroadcasterResponse & ( ) { return dynamic_cast < ConferenceResponse_makeTerminalBroadcasterResponse & > ( * choice ); }
	operator const ConferenceResponse_makeTerminalBroadcasterResponse & ( ) const { return dynamic_cast < const ConferenceResponse_makeTerminalBroadcasterResponse & > ( * choice ); }
	operator ConferenceResponse_sendThisSourceResponse & ( ) { return dynamic_cast < ConferenceResponse_sendThisSourceResponse & > ( * choice ); }
	operator const ConferenceResponse_sendThisSourceResponse & ( ) const { return dynamic_cast < const ConferenceResponse_sendThisSourceResponse & > ( * choice ); }
	operator RequestAllTerminalIDsResponse & ( ) { return dynamic_cast < RequestAllTerminalIDsResponse & > ( * choice ); }
	operator const RequestAllTerminalIDsResponse & ( ) const { return dynamic_cast < const RequestAllTerminalIDsResponse & > ( * choice ); }
	operator RemoteMCResponse & ( ) { return dynamic_cast < RemoteMCResponse & > ( * choice ); }
	operator const RemoteMCResponse & ( ) const { return dynamic_cast < const RemoteMCResponse & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	ConferenceResponse * clone ( ) const;
};

//
// FlowControlCommand
//

// from 0 size 0 type 0 simple 0
class FlowControlCommand : public Asn :: Sequence {
	public:
	explicit FlowControlCommand ( Asn :: istream & is );
	FlowControlCommand ( );
	FlowControlCommand_scope m_scope;
	FlowControlCommand_restriction m_restriction;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	FlowControlCommand * clone ( ) const;
};

//
// ConferenceCommand
//

// from 0 size 0 type 0 simple 0
class ConferenceCommand : public Asn :: Choice {
	public:
	explicit ConferenceCommand ( Asn :: istream & is );
	ConferenceCommand ( );
	enum Choices {
		e_broadcastMyLogicalChannel,
		e_cancelBroadcastMyLogicalChannel,
		e_makeTerminalBroadcaster,
		e_cancelMakeTerminalBroadcaster,
		e_sendThisSource,
		e_cancelSendThisSource,
		e_dropConference,
		e_substituteConferenceIDCommand
	};

	operator LogicalChannelNumber & ( ) { return dynamic_cast < LogicalChannelNumber & > ( * choice ); }
	operator const LogicalChannelNumber & ( ) const { return dynamic_cast < const LogicalChannelNumber & > ( * choice ); }
	operator TerminalLabel & ( ) { return dynamic_cast < TerminalLabel & > ( * choice ); }
	operator const TerminalLabel & ( ) const { return dynamic_cast < const TerminalLabel & > ( * choice ); }
	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator SubstituteConferenceIDCommand & ( ) { return dynamic_cast < SubstituteConferenceIDCommand & > ( * choice ); }
	operator const SubstituteConferenceIDCommand & ( ) const { return dynamic_cast < const SubstituteConferenceIDCommand & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	ConferenceCommand * clone ( ) const;
};

//
// ConferenceIndication
//

// from 0 size 0 type 0 simple 0
class ConferenceIndication : public Asn :: Choice {
	public:
	explicit ConferenceIndication ( Asn :: istream & is );
	ConferenceIndication ( );
	enum Choices {
		e_sbeNumber,
		e_terminalNumberAssign,
		e_terminalJoinedConference,
		e_terminalLeftConference,
		e_seenByAtLeastOneOther,
		e_cancelSeenByAtLeastOneOther,
		e_seenByAll,
		e_cancelSeenByAll,
		e_terminalYouAreSeeing,
		e_requestForFloor,
		e_withdrawChairToken,
		e_floorRequested,
		e_terminalYouAreSeeingInSubPictureNumber,
		e_videoIndicateCompose
	};

	operator ConferenceIndication_sbeNumber & ( ) { return dynamic_cast < ConferenceIndication_sbeNumber & > ( * choice ); }
	operator const ConferenceIndication_sbeNumber & ( ) const { return dynamic_cast < const ConferenceIndication_sbeNumber & > ( * choice ); }
	operator TerminalLabel & ( ) { return dynamic_cast < TerminalLabel & > ( * choice ); }
	operator const TerminalLabel & ( ) const { return dynamic_cast < const TerminalLabel & > ( * choice ); }
	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator TerminalYouAreSeeingInSubPictureNumber & ( ) { return dynamic_cast < TerminalYouAreSeeingInSubPictureNumber & > ( * choice ); }
	operator const TerminalYouAreSeeingInSubPictureNumber & ( ) const { return dynamic_cast < const TerminalYouAreSeeingInSubPictureNumber & > ( * choice ); }
	operator VideoIndicateCompose & ( ) { return dynamic_cast < VideoIndicateCompose & > ( * choice ); }
	operator const VideoIndicateCompose & ( ) const { return dynamic_cast < const VideoIndicateCompose & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	ConferenceIndication * clone ( ) const;
};

//
// JitterIndication
//

// from 0 size 0 type 0 simple 0
class JitterIndication : public Asn :: Sequence {
	public:
	explicit JitterIndication ( Asn :: istream & is );
	JitterIndication ( );
	enum OptionalFields {
		e_skippedFrameCount,
		e_additionalDecoderBuffer
	};

	JitterIndication ( const JitterIndication & s );
	JitterIndication & operator= ( const JitterIndication & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	JitterIndication_scope m_scope;
	JitterIndication_estimatedReceivedJitterMantissa m_estimatedReceivedJitterMantissa;
	JitterIndication_estimatedReceivedJitterExponent m_estimatedReceivedJitterExponent;
	protected:
	JitterIndication_skippedFrameCount * m_skippedFrameCount;
	JitterIndication_additionalDecoderBuffer * m_additionalDecoderBuffer;
	public:
	void encode ( Asn :: ostream & os ) const;
	~JitterIndication ( );
	void printOn ( std :: ostream & os ) const;
	const JitterIndication_skippedFrameCount & get_skippedFrameCount ( ) const {
		return * m_skippedFrameCount;
	}
	JitterIndication_skippedFrameCount & get_skippedFrameCount ( ) {
		return * m_skippedFrameCount;
	}
	const JitterIndication_additionalDecoderBuffer & get_additionalDecoderBuffer ( ) const {
		return * m_additionalDecoderBuffer;
	}
	JitterIndication_additionalDecoderBuffer & get_additionalDecoderBuffer ( ) {
		return * m_additionalDecoderBuffer;
	}
	JitterIndication * clone ( ) const;
};

//
// VendorIdentification
//

// from 0 size 0 type 0 simple 0
class VendorIdentification : public Asn :: Sequence {
	public:
	explicit VendorIdentification ( Asn :: istream & is );
	VendorIdentification ( );
	enum OptionalFields {
		e_productNumber,
		e_versionNumber
	};

	VendorIdentification ( const VendorIdentification & s );
	VendorIdentification & operator= ( const VendorIdentification & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	NonStandardIdentifier m_vendor;
	protected:
	VendorIdentification_productNumber * m_productNumber;
	VendorIdentification_versionNumber * m_versionNumber;
	public:
	void encode ( Asn :: ostream & os ) const;
	~VendorIdentification ( );
	void printOn ( std :: ostream & os ) const;
	const VendorIdentification_productNumber & get_productNumber ( ) const {
		return * m_productNumber;
	}
	VendorIdentification_productNumber & get_productNumber ( ) {
		return * m_productNumber;
	}
	const VendorIdentification_versionNumber & get_versionNumber ( ) const {
		return * m_versionNumber;
	}
	VendorIdentification_versionNumber & get_versionNumber ( ) {
		return * m_versionNumber;
	}
	VendorIdentification * clone ( ) const;
};

//
// FlowControlIndication
//

// from 0 size 0 type 0 simple 0
class FlowControlIndication : public Asn :: Sequence {
	public:
	explicit FlowControlIndication ( Asn :: istream & is );
	FlowControlIndication ( );
	FlowControlIndication_scope m_scope;
	FlowControlIndication_restriction m_restriction;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	FlowControlIndication * clone ( ) const;
};

//
// H223Capability_h223MultiplexTableCapability
//

// from 0 size 0 type 0 simple 0
class H223Capability_h223MultiplexTableCapability : public Asn :: Choice {
	public:
	explicit H223Capability_h223MultiplexTableCapability ( Asn :: istream & is );
	H223Capability_h223MultiplexTableCapability ( );
	enum Choices {
		e_basic,
		e_enhanced
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator H223Capability_h223MultiplexTableCapability_enhanced & ( ) { return dynamic_cast < H223Capability_h223MultiplexTableCapability_enhanced & > ( * choice ); }
	operator const H223Capability_h223MultiplexTableCapability_enhanced & ( ) const { return dynamic_cast < const H223Capability_h223MultiplexTableCapability_enhanced & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	H223Capability_h223MultiplexTableCapability * clone ( ) const;
};

//
// DataProtocolCapability_v76wCompression
//

// from 0 size 0 type 0 simple 0
class DataProtocolCapability_v76wCompression : public Asn :: Choice {
	public:
	explicit DataProtocolCapability_v76wCompression ( Asn :: istream & is );
	DataProtocolCapability_v76wCompression ( );
	enum Choices {
		e_transmitCompression,
		e_receiveCompression,
		e_transmitAndReceiveCompression
	};

	operator CompressionType & ( ) { return dynamic_cast < CompressionType & > ( * choice ); }
	operator const CompressionType & ( ) const { return dynamic_cast < const CompressionType & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	DataProtocolCapability_v76wCompression * clone ( ) const;
};

//
// H223AL1MParameters_arqType
//

// from 0 size 0 type 0 simple 0
class H223AL1MParameters_arqType : public Asn :: Choice {
	public:
	explicit H223AL1MParameters_arqType ( Asn :: istream & is );
	H223AL1MParameters_arqType ( );
	enum Choices {
		e_noArq,
		e_typeIArq,
		e_typeIIArq
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator H223AnnexCArqParameters & ( ) { return dynamic_cast < H223AnnexCArqParameters & > ( * choice ); }
	operator const H223AnnexCArqParameters & ( ) const { return dynamic_cast < const H223AnnexCArqParameters & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	H223AL1MParameters_arqType * clone ( ) const;
};

//
// H223AL3MParameters_arqType
//

// from 0 size 0 type 0 simple 0
class H223AL3MParameters_arqType : public Asn :: Choice {
	public:
	explicit H223AL3MParameters_arqType ( Asn :: istream & is );
	H223AL3MParameters_arqType ( );
	enum Choices {
		e_noArq,
		e_typeIArq,
		e_typeIIArq
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator H223AnnexCArqParameters & ( ) { return dynamic_cast < H223AnnexCArqParameters & > ( * choice ); }
	operator const H223AnnexCArqParameters & ( ) const { return dynamic_cast < const H223AnnexCArqParameters & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	H223AL3MParameters_arqType * clone ( ) const;
};

//
// V76LogicalChannelParameters_mode
//

// from 0 size 0 type 0 simple 0
class V76LogicalChannelParameters_mode : public Asn :: Choice {
	public:
	explicit V76LogicalChannelParameters_mode ( Asn :: istream & is );
	V76LogicalChannelParameters_mode ( );
	enum Choices {
		e_eRM,
		e_uNERM
	};

	operator V76LogicalChannelParameters_mode_eRM & ( ) { return dynamic_cast < V76LogicalChannelParameters_mode_eRM & > ( * choice ); }
	operator const V76LogicalChannelParameters_mode_eRM & ( ) const { return dynamic_cast < const V76LogicalChannelParameters_mode_eRM & > ( * choice ); }
	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	V76LogicalChannelParameters_mode * clone ( ) const;
};

//
// FECData_rfc2733
//

// from 0 size 0 type 0 simple 0
class FECData_rfc2733 : public Asn :: Sequence {
	public:
	explicit FECData_rfc2733 ( Asn :: istream & is );
	FECData_rfc2733 ( );
	enum OptionalFields {
		e_fecScheme
	};

	FECData_rfc2733 ( const FECData_rfc2733 & s );
	FECData_rfc2733 & operator= ( const FECData_rfc2733 & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	FECData_rfc2733_protectedPayloadType m_protectedPayloadType;
	protected:
	Asn :: ObjectId * m_fecScheme;
	public:
	FECData_rfc2733_pktMode m_pktMode;
	void encode ( Asn :: ostream & os ) const;
	~FECData_rfc2733 ( );
	void printOn ( std :: ostream & os ) const;
	const Asn :: ObjectId & get_fecScheme ( ) const {
		return * m_fecScheme;
	}
	Asn :: ObjectId & get_fecScheme ( ) {
		return * m_fecScheme;
	}
	FECData_rfc2733 * clone ( ) const;
};

//
// MultilinkRequest_maximumHeaderInterval
//

// from 0 size 0 type 0 simple 0
class MultilinkRequest_maximumHeaderInterval : public Asn :: Sequence {
	public:
	explicit MultilinkRequest_maximumHeaderInterval ( Asn :: istream & is );
	MultilinkRequest_maximumHeaderInterval ( );
	MultilinkRequest_maximumHeaderInterval_requestType m_requestType;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MultilinkRequest_maximumHeaderInterval * clone ( ) const;
};

//
// MultilinkResponse_addConnection
//

// from 0 size 0 type 0 simple 0
class MultilinkResponse_addConnection : public Asn :: Sequence {
	public:
	explicit MultilinkResponse_addConnection ( Asn :: istream & is );
	MultilinkResponse_addConnection ( );
	SequenceNumber m_sequenceNumber;
	MultilinkResponse_addConnection_responseCode m_responseCode;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MultilinkResponse_addConnection * clone ( ) const;
};

//
// MiscellaneousCommand_type
//

// from 0 size 0 type 0 simple 0
class MiscellaneousCommand_type : public Asn :: Choice {
	public:
	explicit MiscellaneousCommand_type ( Asn :: istream & is );
	MiscellaneousCommand_type ( );
	enum Choices {
		e_equaliseDelay,
		e_zeroDelay,
		e_multipointModeCommand,
		e_cancelMultipointModeCommand,
		e_videoFreezePicture,
		e_videoFastUpdatePicture,
		e_videoFastUpdateGOB,
		e_videoTemporalSpatialTradeOff,
		e_videoSendSyncEveryGOB,
		e_videoSendSyncEveryGOBCancel,
		e_videoFastUpdateMB,
		e_maxH223MUXPDUsize,
		e_encryptionUpdate,
		e_encryptionUpdateRequest,
		e_switchReceiveMediaOff,
		e_switchReceiveMediaOn,
		e_progressiveRefinementStart,
		e_progressiveRefinementAbortOne,
		e_progressiveRefinementAbortContinuous,
		e_videoBadMBs,
		e_lostPicture,
		e_lostPartialPicture,
		e_recoveryReferencePicture,
		e_encryptionUpdateCommand,
		e_encryptionUpdateAck
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator MiscellaneousCommand_type_videoFastUpdateGOB & ( ) { return dynamic_cast < MiscellaneousCommand_type_videoFastUpdateGOB & > ( * choice ); }
	operator const MiscellaneousCommand_type_videoFastUpdateGOB & ( ) const { return dynamic_cast < const MiscellaneousCommand_type_videoFastUpdateGOB & > ( * choice ); }
	operator MiscellaneousCommand_type_videoTemporalSpatialTradeOff & ( ) { return dynamic_cast < MiscellaneousCommand_type_videoTemporalSpatialTradeOff & > ( * choice ); }
	operator const MiscellaneousCommand_type_videoTemporalSpatialTradeOff & ( ) const { return dynamic_cast < const MiscellaneousCommand_type_videoTemporalSpatialTradeOff & > ( * choice ); }
	operator MiscellaneousCommand_type_videoFastUpdateMB & ( ) { return dynamic_cast < MiscellaneousCommand_type_videoFastUpdateMB & > ( * choice ); }
	operator const MiscellaneousCommand_type_videoFastUpdateMB & ( ) const { return dynamic_cast < const MiscellaneousCommand_type_videoFastUpdateMB & > ( * choice ); }
	operator MiscellaneousCommand_type_maxH223MUXPDUsize & ( ) { return dynamic_cast < MiscellaneousCommand_type_maxH223MUXPDUsize & > ( * choice ); }
	operator const MiscellaneousCommand_type_maxH223MUXPDUsize & ( ) const { return dynamic_cast < const MiscellaneousCommand_type_maxH223MUXPDUsize & > ( * choice ); }
	operator EncryptionSync & ( ) { return dynamic_cast < EncryptionSync & > ( * choice ); }
	operator const EncryptionSync & ( ) const { return dynamic_cast < const EncryptionSync & > ( * choice ); }
	operator EncryptionUpdateRequest & ( ) { return dynamic_cast < EncryptionUpdateRequest & > ( * choice ); }
	operator const EncryptionUpdateRequest & ( ) const { return dynamic_cast < const EncryptionUpdateRequest & > ( * choice ); }
	operator MiscellaneousCommand_type_progressiveRefinementStart & ( ) { return dynamic_cast < MiscellaneousCommand_type_progressiveRefinementStart & > ( * choice ); }
	operator const MiscellaneousCommand_type_progressiveRefinementStart & ( ) const { return dynamic_cast < const MiscellaneousCommand_type_progressiveRefinementStart & > ( * choice ); }
	operator MiscellaneousCommand_type_videoBadMBs & ( ) { return dynamic_cast < MiscellaneousCommand_type_videoBadMBs & > ( * choice ); }
	operator const MiscellaneousCommand_type_videoBadMBs & ( ) const { return dynamic_cast < const MiscellaneousCommand_type_videoBadMBs & > ( * choice ); }
	operator ArrayOf_PictureReference & ( ) { return dynamic_cast < ArrayOf_PictureReference & > ( * choice ); }
	operator const ArrayOf_PictureReference & ( ) const { return dynamic_cast < const ArrayOf_PictureReference & > ( * choice ); }
	operator MiscellaneousCommand_type_lostPartialPicture & ( ) { return dynamic_cast < MiscellaneousCommand_type_lostPartialPicture & > ( * choice ); }
	operator const MiscellaneousCommand_type_lostPartialPicture & ( ) const { return dynamic_cast < const MiscellaneousCommand_type_lostPartialPicture & > ( * choice ); }
	operator MiscellaneousCommand_type_encryptionUpdateCommand & ( ) { return dynamic_cast < MiscellaneousCommand_type_encryptionUpdateCommand & > ( * choice ); }
	operator const MiscellaneousCommand_type_encryptionUpdateCommand & ( ) const { return dynamic_cast < const MiscellaneousCommand_type_encryptionUpdateCommand & > ( * choice ); }
	operator MiscellaneousCommand_type_encryptionUpdateAck & ( ) { return dynamic_cast < MiscellaneousCommand_type_encryptionUpdateAck & > ( * choice ); }
	operator const MiscellaneousCommand_type_encryptionUpdateAck & ( ) const { return dynamic_cast < const MiscellaneousCommand_type_encryptionUpdateAck & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	MiscellaneousCommand_type * clone ( ) const;
};

//
// NewATMVCCommand_aal
//

// from 0 size 0 type 0 simple 0
class NewATMVCCommand_aal : public Asn :: Choice {
	public:
	explicit NewATMVCCommand_aal ( Asn :: istream & is );
	NewATMVCCommand_aal ( );
	enum Choices {
		e_aal1,
		e_aal5
	};

	operator NewATMVCCommand_aal_aal1 & ( ) { return dynamic_cast < NewATMVCCommand_aal_aal1 & > ( * choice ); }
	operator const NewATMVCCommand_aal_aal1 & ( ) const { return dynamic_cast < const NewATMVCCommand_aal_aal1 & > ( * choice ); }
	operator NewATMVCCommand_aal_aal5 & ( ) { return dynamic_cast < NewATMVCCommand_aal_aal5 & > ( * choice ); }
	operator const NewATMVCCommand_aal_aal5 & ( ) const { return dynamic_cast < const NewATMVCCommand_aal_aal5 & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	NewATMVCCommand_aal * clone ( ) const;
};

//
// MiscellaneousIndication_type
//

// from 0 size 0 type 0 simple 0
class MiscellaneousIndication_type : public Asn :: Choice {
	public:
	explicit MiscellaneousIndication_type ( Asn :: istream & is );
	MiscellaneousIndication_type ( );
	enum Choices {
		e_logicalChannelActive,
		e_logicalChannelInactive,
		e_multipointConference,
		e_cancelMultipointConference,
		e_multipointZeroComm,
		e_cancelMultipointZeroComm,
		e_multipointSecondaryStatus,
		e_cancelMultipointSecondaryStatus,
		e_videoIndicateReadyToActivate,
		e_videoTemporalSpatialTradeOff,
		e_videoNotDecodedMBs,
		e_transportCapability
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator MiscellaneousIndication_type_videoTemporalSpatialTradeOff & ( ) { return dynamic_cast < MiscellaneousIndication_type_videoTemporalSpatialTradeOff & > ( * choice ); }
	operator const MiscellaneousIndication_type_videoTemporalSpatialTradeOff & ( ) const { return dynamic_cast < const MiscellaneousIndication_type_videoTemporalSpatialTradeOff & > ( * choice ); }
	operator MiscellaneousIndication_type_videoNotDecodedMBs & ( ) { return dynamic_cast < MiscellaneousIndication_type_videoNotDecodedMBs & > ( * choice ); }
	operator const MiscellaneousIndication_type_videoNotDecodedMBs & ( ) const { return dynamic_cast < const MiscellaneousIndication_type_videoNotDecodedMBs & > ( * choice ); }
	operator TransportCapability & ( ) { return dynamic_cast < TransportCapability & > ( * choice ); }
	operator const TransportCapability & ( ) const { return dynamic_cast < const TransportCapability & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	MiscellaneousIndication_type * clone ( ) const;
};

//
// NewATMVCIndication_aal
//

// from 0 size 0 type 0 simple 0
class NewATMVCIndication_aal : public Asn :: Choice {
	public:
	explicit NewATMVCIndication_aal ( Asn :: istream & is );
	NewATMVCIndication_aal ( );
	enum Choices {
		e_aal1,
		e_aal5
	};

	operator NewATMVCIndication_aal_aal1 & ( ) { return dynamic_cast < NewATMVCIndication_aal_aal1 & > ( * choice ); }
	operator const NewATMVCIndication_aal_aal1 & ( ) const { return dynamic_cast < const NewATMVCIndication_aal_aal1 & > ( * choice ); }
	operator NewATMVCIndication_aal_aal5 & ( ) { return dynamic_cast < NewATMVCIndication_aal_aal5 & > ( * choice ); }
	operator const NewATMVCIndication_aal_aal5 & ( ) const { return dynamic_cast < const NewATMVCIndication_aal_aal5 & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	NewATMVCIndication_aal * clone ( ) const;
};

//
// VCCapability_availableBitRates_type
//

// from 0 size 0 type 0 simple 0
class VCCapability_availableBitRates_type : public Asn :: Choice {
	public:
	explicit VCCapability_availableBitRates_type ( Asn :: istream & is );
	VCCapability_availableBitRates_type ( );
	enum Choices {
		e_singleBitRate,
		e_rangeOfBitRates
	};

	operator VCCapability_availableBitRates_type_singleBitRate & ( ) { return dynamic_cast < VCCapability_availableBitRates_type_singleBitRate & > ( * choice ); }
	operator const VCCapability_availableBitRates_type_singleBitRate & ( ) const { return dynamic_cast < const VCCapability_availableBitRates_type_singleBitRate & > ( * choice ); }
	operator VCCapability_availableBitRates_type_rangeOfBitRates & ( ) { return dynamic_cast < VCCapability_availableBitRates_type_rangeOfBitRates & > ( * choice ); }
	operator const VCCapability_availableBitRates_type_rangeOfBitRates & ( ) const { return dynamic_cast < const VCCapability_availableBitRates_type_rangeOfBitRates & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	VCCapability_availableBitRates_type * clone ( ) const;
};

//
// DepFECData_rfc2733_mode_separateStream
//

// from 0 size 0 type 0 simple 0
class DepFECData_rfc2733_mode_separateStream : public Asn :: Choice {
	public:
	explicit DepFECData_rfc2733_mode_separateStream ( Asn :: istream & is );
	DepFECData_rfc2733_mode_separateStream ( );
	enum Choices {
		e_differentPort,
		e_samePort
	};

	operator DepFECData_rfc2733_mode_separateStream_differentPort & ( ) { return dynamic_cast < DepFECData_rfc2733_mode_separateStream_differentPort & > ( * choice ); }
	operator const DepFECData_rfc2733_mode_separateStream_differentPort & ( ) const { return dynamic_cast < const DepFECData_rfc2733_mode_separateStream_differentPort & > ( * choice ); }
	operator DepFECData_rfc2733_mode_separateStream_samePort & ( ) { return dynamic_cast < DepFECData_rfc2733_mode_separateStream_samePort & > ( * choice ); }
	operator const DepFECData_rfc2733_mode_separateStream_samePort & ( ) const { return dynamic_cast < const DepFECData_rfc2733_mode_separateStream_samePort & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	DepFECData_rfc2733_mode_separateStream * clone ( ) const;
};

//
// NonStandardParameter
//

// from 0 size 0 type 0 simple 0
class NonStandardParameter : public Asn :: Sequence {
	public:
	explicit NonStandardParameter ( Asn :: istream & is );
	NonStandardParameter ( );
	NonStandardIdentifier m_nonStandardIdentifier;
	Asn :: OctetString m_data;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	NonStandardParameter * clone ( ) const;
};

//
// H223Capability
//

// from 0 size 0 type 0 simple 0
class H223Capability : public Asn :: Sequence {
	public:
	explicit H223Capability ( Asn :: istream & is );
	H223Capability ( );
	enum OptionalFields {
		e_maxMUXPDUSizeCapability,
		e_nsrpSupport,
		e_mobileOperationTransmitCapability,
		e_h223AnnexCCapability,
		e_bitRate,
		e_mobileMultilinkFrameCapability
	};

	H223Capability ( const H223Capability & s );
	H223Capability & operator= ( const H223Capability & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	Asn :: Boolean m_transportWithI_frames;
	Asn :: Boolean m_videoWithAL1;
	Asn :: Boolean m_videoWithAL2;
	Asn :: Boolean m_videoWithAL3;
	Asn :: Boolean m_audioWithAL1;
	Asn :: Boolean m_audioWithAL2;
	Asn :: Boolean m_audioWithAL3;
	Asn :: Boolean m_dataWithAL1;
	Asn :: Boolean m_dataWithAL2;
	Asn :: Boolean m_dataWithAL3;
	H223Capability_maximumAl2SDUSize m_maximumAl2SDUSize;
	H223Capability_maximumAl3SDUSize m_maximumAl3SDUSize;
	H223Capability_maximumDelayJitter m_maximumDelayJitter;
	H223Capability_h223MultiplexTableCapability m_h223MultiplexTableCapability;
	protected:
	Asn :: Boolean * m_maxMUXPDUSizeCapability;
	Asn :: Boolean * m_nsrpSupport;
	H223Capability_mobileOperationTransmitCapability * m_mobileOperationTransmitCapability;
	H223AnnexCCapability * m_h223AnnexCCapability;
	H223Capability_bitRate * m_bitRate;
	H223Capability_mobileMultilinkFrameCapability * m_mobileMultilinkFrameCapability;
	public:
	void encode ( Asn :: ostream & os ) const;
	~H223Capability ( );
	void printOn ( std :: ostream & os ) const;
	const Asn :: Boolean & get_maxMUXPDUSizeCapability ( ) const {
		return * m_maxMUXPDUSizeCapability;
	}
	Asn :: Boolean & get_maxMUXPDUSizeCapability ( ) {
		return * m_maxMUXPDUSizeCapability;
	}
	const Asn :: Boolean & get_nsrpSupport ( ) const {
		return * m_nsrpSupport;
	}
	Asn :: Boolean & get_nsrpSupport ( ) {
		return * m_nsrpSupport;
	}
	const H223Capability_mobileOperationTransmitCapability & get_mobileOperationTransmitCapability ( ) const {
		return * m_mobileOperationTransmitCapability;
	}
	H223Capability_mobileOperationTransmitCapability & get_mobileOperationTransmitCapability ( ) {
		return * m_mobileOperationTransmitCapability;
	}
	const H223AnnexCCapability & get_h223AnnexCCapability ( ) const {
		return * m_h223AnnexCCapability;
	}
	H223AnnexCCapability & get_h223AnnexCCapability ( ) {
		return * m_h223AnnexCCapability;
	}
	const H223Capability_bitRate & get_bitRate ( ) const {
		return * m_bitRate;
	}
	H223Capability_bitRate & get_bitRate ( ) {
		return * m_bitRate;
	}
	const H223Capability_mobileMultilinkFrameCapability & get_mobileMultilinkFrameCapability ( ) const {
		return * m_mobileMultilinkFrameCapability;
	}
	H223Capability_mobileMultilinkFrameCapability & get_mobileMultilinkFrameCapability ( ) {
		return * m_mobileMultilinkFrameCapability;
	}
	H223Capability * clone ( ) const;
};

//
// RedundancyEncodingMethod
//

// from 0 size 0 type 0 simple 0
class RedundancyEncodingMethod : public Asn :: Choice {
	public:
	explicit RedundancyEncodingMethod ( Asn :: istream & is );
	RedundancyEncodingMethod ( );
	enum Choices {
		e_nonStandard,
		e_rtpAudioRedundancyEncoding,
		e_rtpH263VideoRedundancyEncoding
	};

	operator NonStandardParameter & ( ) { return dynamic_cast < NonStandardParameter & > ( * choice ); }
	operator const NonStandardParameter & ( ) const { return dynamic_cast < const NonStandardParameter & > ( * choice ); }
	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator RTPH263VideoRedundancyEncoding & ( ) { return dynamic_cast < RTPH263VideoRedundancyEncoding & > ( * choice ); }
	operator const RTPH263VideoRedundancyEncoding & ( ) const { return dynamic_cast < const RTPH263VideoRedundancyEncoding & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	RedundancyEncodingMethod * clone ( ) const;
};

//
// DataProtocolCapability
//

// from 0 size 0 type 0 simple 0
class DataProtocolCapability : public Asn :: Choice {
	public:
	explicit DataProtocolCapability ( Asn :: istream & is );
	DataProtocolCapability ( );
	enum Choices {
		e_nonStandard,
		e_v14buffered,
		e_v42lapm,
		e_hdlcFrameTunnelling,
		e_h310SeparateVCStack,
		e_h310SingleVCStack,
		e_transparent,
		e_segmentationAndReassembly,
		e_hdlcFrameTunnelingwSAR,
		e_v120,
		e_separateLANStack,
		e_v76wCompression,
		e_tcp,
		e_udp
	};

	operator NonStandardParameter & ( ) { return dynamic_cast < NonStandardParameter & > ( * choice ); }
	operator const NonStandardParameter & ( ) const { return dynamic_cast < const NonStandardParameter & > ( * choice ); }
	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator DataProtocolCapability_v76wCompression & ( ) { return dynamic_cast < DataProtocolCapability_v76wCompression & > ( * choice ); }
	operator const DataProtocolCapability_v76wCompression & ( ) const { return dynamic_cast < const DataProtocolCapability_v76wCompression & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	DataProtocolCapability * clone ( ) const;
};

//
// MediaEncryptionAlgorithm
//

// from 0 size 0 type 0 simple 0
class MediaEncryptionAlgorithm : public Asn :: Choice {
	public:
	explicit MediaEncryptionAlgorithm ( Asn :: istream & is );
	MediaEncryptionAlgorithm ( );
	enum Choices {
		e_nonStandard,
		e_algorithm
	};

	operator NonStandardParameter & ( ) { return dynamic_cast < NonStandardParameter & > ( * choice ); }
	operator const NonStandardParameter & ( ) const { return dynamic_cast < const NonStandardParameter & > ( * choice ); }
	operator Asn :: ObjectId & ( ) { return dynamic_cast < Asn :: ObjectId & > ( * choice ); }
	operator const Asn :: ObjectId & ( ) const { return dynamic_cast < const Asn :: ObjectId & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	MediaEncryptionAlgorithm * clone ( ) const;
};

//
// CapabilityIdentifier
//

// from 0 size 0 type 0 simple 0
class CapabilityIdentifier : public Asn :: Choice {
	public:
	explicit CapabilityIdentifier ( Asn :: istream & is );
	CapabilityIdentifier ( );
	enum Choices {
		e_standard,
		e_h221NonStandard,
		e_uuid,
		e_domainBased
	};

	operator Asn :: ObjectId & ( ) { return dynamic_cast < Asn :: ObjectId & > ( * choice ); }
	operator const Asn :: ObjectId & ( ) const { return dynamic_cast < const Asn :: ObjectId & > ( * choice ); }
	operator NonStandardParameter & ( ) { return dynamic_cast < NonStandardParameter & > ( * choice ); }
	operator const NonStandardParameter & ( ) const { return dynamic_cast < const NonStandardParameter & > ( * choice ); }
	operator CapabilityIdentifier_uuid & ( ) { return dynamic_cast < CapabilityIdentifier_uuid & > ( * choice ); }
	operator const CapabilityIdentifier_uuid & ( ) const { return dynamic_cast < const CapabilityIdentifier_uuid & > ( * choice ); }
	operator CapabilityIdentifier_domainBased & ( ) { return dynamic_cast < CapabilityIdentifier_domainBased & > ( * choice ); }
	operator const CapabilityIdentifier_domainBased & ( ) const { return dynamic_cast < const CapabilityIdentifier_domainBased & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	CapabilityIdentifier * clone ( ) const;
};

//
// ParameterIdentifier
//

// from 0 size 0 type 0 simple 0
class ParameterIdentifier : public Asn :: Choice {
	public:
	explicit ParameterIdentifier ( Asn :: istream & is );
	ParameterIdentifier ( );
	enum Choices {
		e_standard,
		e_h221NonStandard,
		e_uuid,
		e_domainBased
	};

	operator ParameterIdentifier_standard & ( ) { return dynamic_cast < ParameterIdentifier_standard & > ( * choice ); }
	operator const ParameterIdentifier_standard & ( ) const { return dynamic_cast < const ParameterIdentifier_standard & > ( * choice ); }
	operator NonStandardParameter & ( ) { return dynamic_cast < NonStandardParameter & > ( * choice ); }
	operator const NonStandardParameter & ( ) const { return dynamic_cast < const NonStandardParameter & > ( * choice ); }
	operator ParameterIdentifier_uuid & ( ) { return dynamic_cast < ParameterIdentifier_uuid & > ( * choice ); }
	operator const ParameterIdentifier_uuid & ( ) const { return dynamic_cast < const ParameterIdentifier_uuid & > ( * choice ); }
	operator ParameterIdentifier_domainBased & ( ) { return dynamic_cast < ParameterIdentifier_domainBased & > ( * choice ); }
	operator const ParameterIdentifier_domainBased & ( ) const { return dynamic_cast < const ParameterIdentifier_domainBased & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	ParameterIdentifier * clone ( ) const;
};

//
// MultiplexFormat
//

// from 0 size 0 type 0 simple 0
class MultiplexFormat : public Asn :: Choice {
	public:
	explicit MultiplexFormat ( Asn :: istream & is );
	MultiplexFormat ( );
	enum Choices {
		e_nonStandard,
		e_h222Capability,
		e_h223Capability
	};

	operator NonStandardParameter & ( ) { return dynamic_cast < NonStandardParameter & > ( * choice ); }
	operator const NonStandardParameter & ( ) const { return dynamic_cast < const NonStandardParameter & > ( * choice ); }
	operator H222Capability & ( ) { return dynamic_cast < H222Capability & > ( * choice ); }
	operator const H222Capability & ( ) const { return dynamic_cast < const H222Capability & > ( * choice ); }
	operator H223Capability & ( ) { return dynamic_cast < H223Capability & > ( * choice ); }
	operator const H223Capability & ( ) const { return dynamic_cast < const H223Capability & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	MultiplexFormat * clone ( ) const;
};

//
// MultiplexedStreamParameter
//

// from 0 size 0 type 0 simple 0
class MultiplexedStreamParameter : public Asn :: Sequence {
	public:
	explicit MultiplexedStreamParameter ( Asn :: istream & is );
	MultiplexedStreamParameter ( );
	MultiplexFormat m_multiplexFormat;
	Asn :: Boolean m_controlOnMuxStream;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MultiplexedStreamParameter * clone ( ) const;
};

//
// H223AL1MParameters
//

// from 0 size 0 type 0 simple 0
class H223AL1MParameters : public Asn :: Sequence {
	public:
	explicit H223AL1MParameters ( Asn :: istream & is );
	H223AL1MParameters ( );
	enum OptionalFields {
		e_rsCodeCorrection
	};

	H223AL1MParameters ( const H223AL1MParameters & s );
	H223AL1MParameters & operator= ( const H223AL1MParameters & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	H223AL1MParameters_transferMode m_transferMode;
	H223AL1MParameters_headerFEC m_headerFEC;
	H223AL1MParameters_crcLength m_crcLength;
	H223AL1MParameters_rcpcCodeRate m_rcpcCodeRate;
	H223AL1MParameters_arqType m_arqType;
	Asn :: Boolean m_alpduInterleaving;
	Asn :: Boolean m_alsduSplitting;
	protected:
	H223AL1MParameters_rsCodeCorrection * m_rsCodeCorrection;
	public:
	void encode ( Asn :: ostream & os ) const;
	~H223AL1MParameters ( );
	void printOn ( std :: ostream & os ) const;
	const H223AL1MParameters_rsCodeCorrection & get_rsCodeCorrection ( ) const {
		return * m_rsCodeCorrection;
	}
	H223AL1MParameters_rsCodeCorrection & get_rsCodeCorrection ( ) {
		return * m_rsCodeCorrection;
	}
	H223AL1MParameters * clone ( ) const;
};

//
// H223AL3MParameters
//

// from 0 size 0 type 0 simple 0
class H223AL3MParameters : public Asn :: Sequence {
	public:
	explicit H223AL3MParameters ( Asn :: istream & is );
	H223AL3MParameters ( );
	enum OptionalFields {
		e_rsCodeCorrection
	};

	H223AL3MParameters ( const H223AL3MParameters & s );
	H223AL3MParameters & operator= ( const H223AL3MParameters & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	H223AL3MParameters_headerFormat m_headerFormat;
	H223AL3MParameters_crcLength m_crcLength;
	H223AL3MParameters_rcpcCodeRate m_rcpcCodeRate;
	H223AL3MParameters_arqType m_arqType;
	Asn :: Boolean m_alpduInterleaving;
	protected:
	H223AL3MParameters_rsCodeCorrection * m_rsCodeCorrection;
	public:
	void encode ( Asn :: ostream & os ) const;
	~H223AL3MParameters ( );
	void printOn ( std :: ostream & os ) const;
	const H223AL3MParameters_rsCodeCorrection & get_rsCodeCorrection ( ) const {
		return * m_rsCodeCorrection;
	}
	H223AL3MParameters_rsCodeCorrection & get_rsCodeCorrection ( ) {
		return * m_rsCodeCorrection;
	}
	H223AL3MParameters * clone ( ) const;
};

//
// V76LogicalChannelParameters
//

// from 0 size 0 type 0 simple 0
class V76LogicalChannelParameters : public Asn :: Sequence {
	public:
	explicit V76LogicalChannelParameters ( Asn :: istream & is );
	V76LogicalChannelParameters ( );
	V76HDLCParameters m_hdlcParameters;
	V76LogicalChannelParameters_suspendResume m_suspendResume;
	Asn :: Boolean m_uIH;
	V76LogicalChannelParameters_mode m_mode;
	V75Parameters m_v75Parameters;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	V76LogicalChannelParameters * clone ( ) const;
};

//
// RedundancyEncoding
//

// from 0 size 0 type 0 simple 0
class DataType;

class RedundancyEncoding : public Asn :: Sequence {
	public:
	explicit RedundancyEncoding ( Asn :: istream & is );
	RedundancyEncoding ( );
	enum OptionalFields {
		e_secondaryEncoding,
		e_rtpRedundancyEncoding
	};

	RedundancyEncoding ( const RedundancyEncoding & s );
	RedundancyEncoding & operator= ( const RedundancyEncoding & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	RedundancyEncodingMethod m_redundancyEncodingMethod;
	protected:
	DataType * m_secondaryEncoding;
	RedundancyEncoding_rtpRedundancyEncoding * m_rtpRedundancyEncoding;
	public:
	void encode ( Asn :: ostream & os ) const;
	~RedundancyEncoding ( );
	void printOn ( std :: ostream & os ) const;
	const DataType & get_secondaryEncoding ( ) const {
		return * m_secondaryEncoding;
	}
	DataType & get_secondaryEncoding ( ) {
		return * m_secondaryEncoding;
	}
	const RedundancyEncoding_rtpRedundancyEncoding & get_rtpRedundancyEncoding ( ) const {
		return * m_rtpRedundancyEncoding;
	}
	RedundancyEncoding_rtpRedundancyEncoding & get_rtpRedundancyEncoding ( ) {
		return * m_rtpRedundancyEncoding;
	}
	RedundancyEncoding * clone ( ) const;
};

//
// FECData
//

// from 0 size 0 type 0 simple 0
class FECData : public Asn :: Choice {
	public:
	explicit FECData ( Asn :: istream & is );
	FECData ( );
	enum Choices {
		e_rfc2733
	};

	operator FECData_rfc2733 & ( ) { return dynamic_cast < FECData_rfc2733 & > ( * choice ); }
	operator const FECData_rfc2733 & ( ) const { return dynamic_cast < const FECData_rfc2733 & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	FECData * clone ( ) const;
};

//
// UnicastAddress
//

// from 0 size 0 type 0 simple 0
class UnicastAddress : public Asn :: Choice {
	public:
	explicit UnicastAddress ( Asn :: istream & is );
	UnicastAddress ( );
	enum Choices {
		e_iPAddress,
		e_iPXAddress,
		e_iP6Address,
		e_netBios,
		e_iPSourceRouteAddress,
		e_nsap,
		e_nonStandardAddress
	};

	operator UnicastAddress_iPAddress & ( ) { return dynamic_cast < UnicastAddress_iPAddress & > ( * choice ); }
	operator const UnicastAddress_iPAddress & ( ) const { return dynamic_cast < const UnicastAddress_iPAddress & > ( * choice ); }
	operator UnicastAddress_iPXAddress & ( ) { return dynamic_cast < UnicastAddress_iPXAddress & > ( * choice ); }
	operator const UnicastAddress_iPXAddress & ( ) const { return dynamic_cast < const UnicastAddress_iPXAddress & > ( * choice ); }
	operator UnicastAddress_iP6Address & ( ) { return dynamic_cast < UnicastAddress_iP6Address & > ( * choice ); }
	operator const UnicastAddress_iP6Address & ( ) const { return dynamic_cast < const UnicastAddress_iP6Address & > ( * choice ); }
	operator UnicastAddress_netBios & ( ) { return dynamic_cast < UnicastAddress_netBios & > ( * choice ); }
	operator const UnicastAddress_netBios & ( ) const { return dynamic_cast < const UnicastAddress_netBios & > ( * choice ); }
	operator UnicastAddress_iPSourceRouteAddress & ( ) { return dynamic_cast < UnicastAddress_iPSourceRouteAddress & > ( * choice ); }
	operator const UnicastAddress_iPSourceRouteAddress & ( ) const { return dynamic_cast < const UnicastAddress_iPSourceRouteAddress & > ( * choice ); }
	operator UnicastAddress_nsap & ( ) { return dynamic_cast < UnicastAddress_nsap & > ( * choice ); }
	operator const UnicastAddress_nsap & ( ) const { return dynamic_cast < const UnicastAddress_nsap & > ( * choice ); }
	operator NonStandardParameter & ( ) { return dynamic_cast < NonStandardParameter & > ( * choice ); }
	operator const NonStandardParameter & ( ) const { return dynamic_cast < const NonStandardParameter & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	UnicastAddress * clone ( ) const;
};

//
// MulticastAddress
//

// from 0 size 0 type 0 simple 0
class MulticastAddress : public Asn :: Choice {
	public:
	explicit MulticastAddress ( Asn :: istream & is );
	MulticastAddress ( );
	enum Choices {
		e_iPAddress,
		e_iP6Address,
		e_nsap,
		e_nonStandardAddress
	};

	operator MulticastAddress_iPAddress & ( ) { return dynamic_cast < MulticastAddress_iPAddress & > ( * choice ); }
	operator const MulticastAddress_iPAddress & ( ) const { return dynamic_cast < const MulticastAddress_iPAddress & > ( * choice ); }
	operator MulticastAddress_iP6Address & ( ) { return dynamic_cast < MulticastAddress_iP6Address & > ( * choice ); }
	operator const MulticastAddress_iP6Address & ( ) const { return dynamic_cast < const MulticastAddress_iP6Address & > ( * choice ); }
	operator MulticastAddress_nsap & ( ) { return dynamic_cast < MulticastAddress_nsap & > ( * choice ); }
	operator const MulticastAddress_nsap & ( ) const { return dynamic_cast < const MulticastAddress_nsap & > ( * choice ); }
	operator NonStandardParameter & ( ) { return dynamic_cast < NonStandardParameter & > ( * choice ); }
	operator const NonStandardParameter & ( ) const { return dynamic_cast < const NonStandardParameter & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	MulticastAddress * clone ( ) const;
};

//
// RedundancyEncodingMode
//

// from 0 size 0 type 0 simple 0
class RedundancyEncodingMode_secondaryEncoding;

class RedundancyEncodingMode : public Asn :: Sequence {
	public:
	explicit RedundancyEncodingMode ( Asn :: istream & is );
	RedundancyEncodingMode ( );
	enum OptionalFields {
		e_secondaryEncoding
	};

	RedundancyEncodingMode ( const RedundancyEncodingMode & s );
	RedundancyEncodingMode & operator= ( const RedundancyEncodingMode & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	RedundancyEncodingMethod m_redundancyEncodingMethod;
	protected:
	RedundancyEncodingMode_secondaryEncoding * m_secondaryEncoding;
	public:
	void encode ( Asn :: ostream & os ) const;
	~RedundancyEncodingMode ( );
	void printOn ( std :: ostream & os ) const;
	const RedundancyEncodingMode_secondaryEncoding & get_secondaryEncoding ( ) const {
		return * m_secondaryEncoding;
	}
	RedundancyEncodingMode_secondaryEncoding & get_secondaryEncoding ( ) {
		return * m_secondaryEncoding;
	}
	RedundancyEncodingMode * clone ( ) const;
};

//
// EncryptionMode
//

// from 0 size 0 type 0 simple 0
class EncryptionMode : public Asn :: Choice {
	public:
	explicit EncryptionMode ( Asn :: istream & is );
	EncryptionMode ( );
	enum Choices {
		e_nonStandard,
		e_h233Encryption
	};

	operator NonStandardParameter & ( ) { return dynamic_cast < NonStandardParameter & > ( * choice ); }
	operator const NonStandardParameter & ( ) const { return dynamic_cast < const NonStandardParameter & > ( * choice ); }
	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	EncryptionMode * clone ( ) const;
};

//
// EndSessionCommand
//

// from 0 size 0 type 0 simple 0
class EndSessionCommand : public Asn :: Choice {
	public:
	explicit EndSessionCommand ( Asn :: istream & is );
	EndSessionCommand ( );
	enum Choices {
		e_nonStandard,
		e_disconnect,
		e_gstnOptions,
		e_isdnOptions,
		e_genericInformation
	};

	operator NonStandardParameter & ( ) { return dynamic_cast < NonStandardParameter & > ( * choice ); }
	operator const NonStandardParameter & ( ) const { return dynamic_cast < const NonStandardParameter & > ( * choice ); }
	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator EndSessionCommand_gstnOptions & ( ) { return dynamic_cast < EndSessionCommand_gstnOptions & > ( * choice ); }
	operator const EndSessionCommand_gstnOptions & ( ) const { return dynamic_cast < const EndSessionCommand_gstnOptions & > ( * choice ); }
	operator EndSessionCommand_isdnOptions & ( ) { return dynamic_cast < EndSessionCommand_isdnOptions & > ( * choice ); }
	operator const EndSessionCommand_isdnOptions & ( ) const { return dynamic_cast < const EndSessionCommand_isdnOptions & > ( * choice ); }
	operator ArrayOf_GenericInformation & ( ) { return dynamic_cast < ArrayOf_GenericInformation & > ( * choice ); }
	operator const ArrayOf_GenericInformation & ( ) const { return dynamic_cast < const ArrayOf_GenericInformation & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	EndSessionCommand * clone ( ) const;
};

//
// MiscellaneousCommand
//

// from 0 size 0 type 0 simple 0
class MiscellaneousCommand : public Asn :: Sequence {
	public:
	explicit MiscellaneousCommand ( Asn :: istream & is );
	MiscellaneousCommand ( );
	enum OptionalFields {
		e_direction
	};

	MiscellaneousCommand ( const MiscellaneousCommand & s );
	MiscellaneousCommand & operator= ( const MiscellaneousCommand & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	LogicalChannelNumber m_logicalChannelNumber;
	MiscellaneousCommand_type m_type;
	protected:
	EncryptionUpdateDirection * m_direction;
	public:
	void encode ( Asn :: ostream & os ) const;
	~MiscellaneousCommand ( );
	void printOn ( std :: ostream & os ) const;
	const EncryptionUpdateDirection & get_direction ( ) const {
		return * m_direction;
	}
	EncryptionUpdateDirection & get_direction ( ) {
		return * m_direction;
	}
	MiscellaneousCommand * clone ( ) const;
};

//
// NewATMVCCommand
//

// from 0 size 0 type 0 simple 0
class NewATMVCCommand : public Asn :: Sequence {
	public:
	explicit NewATMVCCommand ( Asn :: istream & is );
	NewATMVCCommand ( );
	NewATMVCCommand_resourceID m_resourceID;
	NewATMVCCommand_bitRate m_bitRate;
	Asn :: Boolean m_bitRateLockedToPCRClock;
	Asn :: Boolean m_bitRateLockedToNetworkClock;
	NewATMVCCommand_aal m_aal;
	NewATMVCCommand_multiplex m_multiplex;
	NewATMVCCommand_reverseParameters m_reverseParameters;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	NewATMVCCommand * clone ( ) const;
};

//
// MiscellaneousIndication
//

// from 0 size 0 type 0 simple 0
class MiscellaneousIndication : public Asn :: Sequence {
	public:
	explicit MiscellaneousIndication ( Asn :: istream & is );
	MiscellaneousIndication ( );
	LogicalChannelNumber m_logicalChannelNumber;
	MiscellaneousIndication_type m_type;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MiscellaneousIndication * clone ( ) const;
};

//
// NewATMVCIndication
//

// from 0 size 0 type 0 simple 0
class NewATMVCIndication : public Asn :: Sequence {
	public:
	explicit NewATMVCIndication ( Asn :: istream & is );
	NewATMVCIndication ( );
	enum OptionalFields {
		e_reverseParameters
	};

	NewATMVCIndication ( const NewATMVCIndication & s );
	NewATMVCIndication & operator= ( const NewATMVCIndication & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	NewATMVCIndication_resourceID m_resourceID;
	NewATMVCIndication_bitRate m_bitRate;
	Asn :: Boolean m_bitRateLockedToPCRClock;
	Asn :: Boolean m_bitRateLockedToNetworkClock;
	NewATMVCIndication_aal m_aal;
	NewATMVCIndication_multiplex m_multiplex;
	protected:
	NewATMVCIndication_reverseParameters * m_reverseParameters;
	public:
	void encode ( Asn :: ostream & os ) const;
	~NewATMVCIndication ( );
	void printOn ( std :: ostream & os ) const;
	const NewATMVCIndication_reverseParameters & get_reverseParameters ( ) const {
		return * m_reverseParameters;
	}
	NewATMVCIndication_reverseParameters & get_reverseParameters ( ) {
		return * m_reverseParameters;
	}
	NewATMVCIndication * clone ( ) const;
};

//
// VCCapability_availableBitRates
//

// from 0 size 0 type 0 simple 0
class VCCapability_availableBitRates : public Asn :: Sequence {
	public:
	explicit VCCapability_availableBitRates ( Asn :: istream & is );
	VCCapability_availableBitRates ( );
	VCCapability_availableBitRates_type m_type;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	VCCapability_availableBitRates * clone ( ) const;
};

//
// H223LogicalChannelParameters_adaptationLayerType
//

// from 0 size 0 type 0 simple 0
class H223LogicalChannelParameters_adaptationLayerType : public Asn :: Choice {
	public:
	explicit H223LogicalChannelParameters_adaptationLayerType ( Asn :: istream & is );
	H223LogicalChannelParameters_adaptationLayerType ( );
	enum Choices {
		e_nonStandard,
		e_al1Framed,
		e_al1NotFramed,
		e_al2WithoutSequenceNumbers,
		e_al2WithSequenceNumbers,
		e_al3,
		e_al1M,
		e_al2M,
		e_al3M
	};

	operator NonStandardParameter & ( ) { return dynamic_cast < NonStandardParameter & > ( * choice ); }
	operator const NonStandardParameter & ( ) const { return dynamic_cast < const NonStandardParameter & > ( * choice ); }
	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator H223LogicalChannelParameters_adaptationLayerType_al3 & ( ) { return dynamic_cast < H223LogicalChannelParameters_adaptationLayerType_al3 & > ( * choice ); }
	operator const H223LogicalChannelParameters_adaptationLayerType_al3 & ( ) const { return dynamic_cast < const H223LogicalChannelParameters_adaptationLayerType_al3 & > ( * choice ); }
	operator H223AL1MParameters & ( ) { return dynamic_cast < H223AL1MParameters & > ( * choice ); }
	operator const H223AL1MParameters & ( ) const { return dynamic_cast < const H223AL1MParameters & > ( * choice ); }
	operator H223AL2MParameters & ( ) { return dynamic_cast < H223AL2MParameters & > ( * choice ); }
	operator const H223AL2MParameters & ( ) const { return dynamic_cast < const H223AL2MParameters & > ( * choice ); }
	operator H223AL3MParameters & ( ) { return dynamic_cast < H223AL3MParameters & > ( * choice ); }
	operator const H223AL3MParameters & ( ) const { return dynamic_cast < const H223AL3MParameters & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	H223LogicalChannelParameters_adaptationLayerType * clone ( ) const;
};

//
// RTPPayloadType_payloadDescriptor
//

// from 0 size 0 type 0 simple 0
class RTPPayloadType_payloadDescriptor : public Asn :: Choice {
	public:
	explicit RTPPayloadType_payloadDescriptor ( Asn :: istream & is );
	RTPPayloadType_payloadDescriptor ( );
	enum Choices {
		e_nonStandardIdentifier,
		e_rfc_number,
		e_oid
	};

	operator NonStandardParameter & ( ) { return dynamic_cast < NonStandardParameter & > ( * choice ); }
	operator const NonStandardParameter & ( ) const { return dynamic_cast < const NonStandardParameter & > ( * choice ); }
	operator RTPPayloadType_payloadDescriptor_rfc_number & ( ) { return dynamic_cast < RTPPayloadType_payloadDescriptor_rfc_number & > ( * choice ); }
	operator const RTPPayloadType_payloadDescriptor_rfc_number & ( ) const { return dynamic_cast < const RTPPayloadType_payloadDescriptor_rfc_number & > ( * choice ); }
	operator Asn :: ObjectId & ( ) { return dynamic_cast < Asn :: ObjectId & > ( * choice ); }
	operator const Asn :: ObjectId & ( ) const { return dynamic_cast < const Asn :: ObjectId & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	RTPPayloadType_payloadDescriptor * clone ( ) const;
};

//
// H223ModeParameters_adaptationLayerType
//

// from 0 size 0 type 0 simple 0
class H223ModeParameters_adaptationLayerType : public Asn :: Choice {
	public:
	explicit H223ModeParameters_adaptationLayerType ( Asn :: istream & is );
	H223ModeParameters_adaptationLayerType ( );
	enum Choices {
		e_nonStandard,
		e_al1Framed,
		e_al1NotFramed,
		e_al2WithoutSequenceNumbers,
		e_al2WithSequenceNumbers,
		e_al3,
		e_al1M,
		e_al2M,
		e_al3M
	};

	operator NonStandardParameter & ( ) { return dynamic_cast < NonStandardParameter & > ( * choice ); }
	operator const NonStandardParameter & ( ) const { return dynamic_cast < const NonStandardParameter & > ( * choice ); }
	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator H223ModeParameters_adaptationLayerType_al3 & ( ) { return dynamic_cast < H223ModeParameters_adaptationLayerType_al3 & > ( * choice ); }
	operator const H223ModeParameters_adaptationLayerType_al3 & ( ) const { return dynamic_cast < const H223ModeParameters_adaptationLayerType_al3 & > ( * choice ); }
	operator H223AL1MParameters & ( ) { return dynamic_cast < H223AL1MParameters & > ( * choice ); }
	operator const H223AL1MParameters & ( ) const { return dynamic_cast < const H223AL1MParameters & > ( * choice ); }
	operator H223AL2MParameters & ( ) { return dynamic_cast < H223AL2MParameters & > ( * choice ); }
	operator const H223AL2MParameters & ( ) const { return dynamic_cast < const H223AL2MParameters & > ( * choice ); }
	operator H223AL3MParameters & ( ) { return dynamic_cast < H223AL3MParameters & > ( * choice ); }
	operator const H223AL3MParameters & ( ) const { return dynamic_cast < const H223AL3MParameters & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	H223ModeParameters_adaptationLayerType * clone ( ) const;
};

//
// EncryptionCommand_encryptionAlgorithmID
//

// from 0 size 0 type 0 simple 0
class EncryptionCommand_encryptionAlgorithmID : public Asn :: Sequence {
	public:
	explicit EncryptionCommand_encryptionAlgorithmID ( Asn :: istream & is );
	EncryptionCommand_encryptionAlgorithmID ( );
	SequenceNumber m_h233AlgorithmIdentifier;
	NonStandardParameter m_associatedAlgorithm;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	EncryptionCommand_encryptionAlgorithmID * clone ( ) const;
};

//
// UserInputIndication_userInputSupportIndication
//

// from 0 size 0 type 0 simple 0
class UserInputIndication_userInputSupportIndication : public Asn :: Choice {
	public:
	explicit UserInputIndication_userInputSupportIndication ( Asn :: istream & is );
	UserInputIndication_userInputSupportIndication ( );
	enum Choices {
		e_nonStandard,
		e_basicString,
		e_iA5String,
		e_generalString,
		e_encryptedBasicString,
		e_encryptedIA5String,
		e_encryptedGeneralString
	};

	operator NonStandardParameter & ( ) { return dynamic_cast < NonStandardParameter & > ( * choice ); }
	operator const NonStandardParameter & ( ) const { return dynamic_cast < const NonStandardParameter & > ( * choice ); }
	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	UserInputIndication_userInputSupportIndication * clone ( ) const;
};

//
// DataApplicationCapability_application_t84
//

// from 0 size 0 type 0 simple 0
class DataApplicationCapability_application_t84 : public Asn :: Sequence {
	public:
	explicit DataApplicationCapability_application_t84 ( Asn :: istream & is );
	DataApplicationCapability_application_t84 ( );
	DataProtocolCapability m_t84Protocol;
	T84Profile m_t84Profile;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	DataApplicationCapability_application_t84 * clone ( ) const;
};

//
// DataApplicationCapability_application_nlpid
//

// from 0 size 0 type 0 simple 0
class DataApplicationCapability_application_nlpid : public Asn :: Sequence {
	public:
	explicit DataApplicationCapability_application_nlpid ( Asn :: istream & is );
	DataApplicationCapability_application_nlpid ( );
	DataProtocolCapability m_nlpidProtocol;
	Asn :: OctetString m_nlpidData;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	DataApplicationCapability_application_nlpid * clone ( ) const;
};

//
// DataApplicationCapability_application_t38fax
//

// from 0 size 0 type 0 simple 0
class DataApplicationCapability_application_t38fax : public Asn :: Sequence {
	public:
	explicit DataApplicationCapability_application_t38fax ( Asn :: istream & is );
	DataApplicationCapability_application_t38fax ( );
	DataProtocolCapability m_t38FaxProtocol;
	T38FaxProfile m_t38FaxProfile;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	DataApplicationCapability_application_t38fax * clone ( ) const;
};

//
// DepFECData_rfc2733_mode
//

// from 0 size 0 type 0 simple 0
class DepFECData_rfc2733_mode : public Asn :: Choice {
	public:
	explicit DepFECData_rfc2733_mode ( Asn :: istream & is );
	DepFECData_rfc2733_mode ( );
	enum Choices {
		e_redundancyEncoding,
		e_separateStream
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator DepFECData_rfc2733_mode_separateStream & ( ) { return dynamic_cast < DepFECData_rfc2733_mode_separateStream & > ( * choice ); }
	operator const DepFECData_rfc2733_mode_separateStream & ( ) const { return dynamic_cast < const DepFECData_rfc2733_mode_separateStream & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	DepFECData_rfc2733_mode * clone ( ) const;
};

//
// DataMode_application_nlpid
//

// from 0 size 0 type 0 simple 0
class DataMode_application_nlpid : public Asn :: Sequence {
	public:
	explicit DataMode_application_nlpid ( Asn :: istream & is );
	DataMode_application_nlpid ( );
	DataProtocolCapability m_nlpidProtocol;
	Asn :: OctetString m_nlpidData;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	DataMode_application_nlpid * clone ( ) const;
};

//
// DataMode_application_t38fax
//

// from 0 size 0 type 0 simple 0
class DataMode_application_t38fax : public Asn :: Sequence {
	public:
	explicit DataMode_application_t38fax ( Asn :: istream & is );
	DataMode_application_t38fax ( );
	DataProtocolCapability m_t38FaxProtocol;
	T38FaxProfile m_t38FaxProfile;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	DataMode_application_t38fax * clone ( ) const;
};

//
// GenericMessage
//

// from 0 size 0 type 0 simple 0
class GenericMessage : public Asn :: Sequence {
	public:
	explicit GenericMessage ( Asn :: istream & is );
	GenericMessage ( );
	enum OptionalFields {
		e_subMessageIdentifier,
		e_messageContent
	};

	GenericMessage ( const GenericMessage & s );
	GenericMessage & operator= ( const GenericMessage & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	CapabilityIdentifier m_messageIdentifier;
	protected:
	GenericMessage_subMessageIdentifier * m_subMessageIdentifier;
	ArrayOf_GenericParameter * m_messageContent;
	public:
	void encode ( Asn :: ostream & os ) const;
	~GenericMessage ( );
	void printOn ( std :: ostream & os ) const;
	const GenericMessage_subMessageIdentifier & get_subMessageIdentifier ( ) const {
		return * m_subMessageIdentifier;
	}
	GenericMessage_subMessageIdentifier & get_subMessageIdentifier ( ) {
		return * m_subMessageIdentifier;
	}
	const ArrayOf_GenericParameter & get_messageContent ( ) const {
		return * m_messageContent;
	}
	ArrayOf_GenericParameter & get_messageContent ( ) {
		return * m_messageContent;
	}
	GenericMessage * clone ( ) const;
};

//
// GenericInformation
//

// from 0 size 0 type 0 simple 0
class GenericInformation : public GenericMessage {
	public:
	explicit GenericInformation ( Asn :: istream & is );
	GenericInformation ( );
	GenericInformation * clone ( ) const;
};

//
// NonStandardMessage
//

// from 0 size 0 type 0 simple 0
class NonStandardMessage : public Asn :: Sequence {
	public:
	explicit NonStandardMessage ( Asn :: istream & is );
	NonStandardMessage ( );
	NonStandardParameter m_nonStandardData;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	NonStandardMessage * clone ( ) const;
};

//
// VCCapability
//

// from 0 size 0 type 0 simple 0
class VCCapability : public Asn :: Sequence {
	public:
	explicit VCCapability ( Asn :: istream & is );
	VCCapability ( );
	enum OptionalFields {
		e_aal1,
		e_aal5,
		e_aal1ViaGateway
	};

	VCCapability ( const VCCapability & s );
	VCCapability & operator= ( const VCCapability & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	VCCapability_aal1 * m_aal1;
	VCCapability_aal5 * m_aal5;
	public:
	Asn :: Boolean m_transportStream;
	Asn :: Boolean m_programStream;
	VCCapability_availableBitRates m_availableBitRates;
	protected:
	VCCapability_aal1ViaGateway * m_aal1ViaGateway;
	public:
	void encode ( Asn :: ostream & os ) const;
	~VCCapability ( );
	void printOn ( std :: ostream & os ) const;
	const VCCapability_aal1 & get_aal1 ( ) const {
		return * m_aal1;
	}
	VCCapability_aal1 & get_aal1 ( ) {
		return * m_aal1;
	}
	const VCCapability_aal5 & get_aal5 ( ) const {
		return * m_aal5;
	}
	VCCapability_aal5 & get_aal5 ( ) {
		return * m_aal5;
	}
	const VCCapability_aal1ViaGateway & get_aal1ViaGateway ( ) const {
		return * m_aal1ViaGateway;
	}
	VCCapability_aal1ViaGateway & get_aal1ViaGateway ( ) {
		return * m_aal1ViaGateway;
	}
	VCCapability * clone ( ) const;
};

//
// RedundancyEncodingCapability
//

// from 0 size 0 type 0 simple 0
class RedundancyEncodingCapability : public Asn :: Sequence {
	public:
	explicit RedundancyEncodingCapability ( Asn :: istream & is );
	RedundancyEncodingCapability ( );
	enum OptionalFields {
		e_secondaryEncoding
	};

	RedundancyEncodingCapability ( const RedundancyEncodingCapability & s );
	RedundancyEncodingCapability & operator= ( const RedundancyEncodingCapability & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	RedundancyEncodingMethod m_redundancyEncodingMethod;
	CapabilityTableEntryNumber m_primaryEncoding;
	protected:
	RedundancyEncodingCapability_secondaryEncoding * m_secondaryEncoding;
	public:
	void encode ( Asn :: ostream & os ) const;
	~RedundancyEncodingCapability ( );
	void printOn ( std :: ostream & os ) const;
	const RedundancyEncodingCapability_secondaryEncoding & get_secondaryEncoding ( ) const {
		return * m_secondaryEncoding;
	}
	RedundancyEncodingCapability_secondaryEncoding & get_secondaryEncoding ( ) {
		return * m_secondaryEncoding;
	}
	RedundancyEncodingCapability * clone ( ) const;
};

//
// GenericCapability
//

// from 0 size 0 type 0 simple 0
class GenericCapability : public Asn :: Sequence {
	public:
	explicit GenericCapability ( Asn :: istream & is );
	GenericCapability ( );
	enum OptionalFields {
		e_maxBitRate,
		e_collapsing,
		e_nonCollapsing,
		e_nonCollapsingRaw,
		e_transport
	};

	GenericCapability ( const GenericCapability & s );
	GenericCapability & operator= ( const GenericCapability & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	CapabilityIdentifier m_capabilityIdentifier;
	protected:
	GenericCapability_maxBitRate * m_maxBitRate;
	ArrayOf_GenericParameter * m_collapsing;
	ArrayOf_GenericParameter * m_nonCollapsing;
	Asn :: OctetString * m_nonCollapsingRaw;
	DataProtocolCapability * m_transport;
	public:
	void encode ( Asn :: ostream & os ) const;
	~GenericCapability ( );
	void printOn ( std :: ostream & os ) const;
	const GenericCapability_maxBitRate & get_maxBitRate ( ) const {
		return * m_maxBitRate;
	}
	GenericCapability_maxBitRate & get_maxBitRate ( ) {
		return * m_maxBitRate;
	}
	const ArrayOf_GenericParameter & get_collapsing ( ) const {
		return * m_collapsing;
	}
	ArrayOf_GenericParameter & get_collapsing ( ) {
		return * m_collapsing;
	}
	const ArrayOf_GenericParameter & get_nonCollapsing ( ) const {
		return * m_nonCollapsing;
	}
	ArrayOf_GenericParameter & get_nonCollapsing ( ) {
		return * m_nonCollapsing;
	}
	const Asn :: OctetString & get_nonCollapsingRaw ( ) const {
		return * m_nonCollapsingRaw;
	}
	Asn :: OctetString & get_nonCollapsingRaw ( ) {
		return * m_nonCollapsingRaw;
	}
	const DataProtocolCapability & get_transport ( ) const {
		return * m_transport;
	}
	DataProtocolCapability & get_transport ( ) {
		return * m_transport;
	}
	GenericCapability * clone ( ) const;
};

//
// GenericParameter
//

// from 0 size 0 type 0 simple 0
class GenericParameter : public Asn :: Sequence {
	public:
	explicit GenericParameter ( Asn :: istream & is );
	GenericParameter ( );
	enum OptionalFields {
		e_supersedes
	};

	GenericParameter ( const GenericParameter & s );
	GenericParameter & operator= ( const GenericParameter & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	ParameterIdentifier m_parameterIdentifier;
	ParameterValue m_parameterValue;
	protected:
	ArrayOf_ParameterIdentifier * m_supersedes;
	public:
	void encode ( Asn :: ostream & os ) const;
	~GenericParameter ( );
	void printOn ( std :: ostream & os ) const;
	const ArrayOf_ParameterIdentifier & get_supersedes ( ) const {
		return * m_supersedes;
	}
	ArrayOf_ParameterIdentifier & get_supersedes ( ) {
		return * m_supersedes;
	}
	GenericParameter * clone ( ) const;
};

//
// MultiplexedStreamCapability
//

// from 0 size 0 type 0 simple 0
class MultiplexedStreamCapability : public Asn :: Sequence {
	public:
	explicit MultiplexedStreamCapability ( Asn :: istream & is );
	MultiplexedStreamCapability ( );
	enum OptionalFields {
		e_capabilityOnMuxStream
	};

	MultiplexedStreamCapability ( const MultiplexedStreamCapability & s );
	MultiplexedStreamCapability & operator= ( const MultiplexedStreamCapability & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	MultiplexFormat m_multiplexFormat;
	Asn :: Boolean m_controlOnMuxStream;
	protected:
	MultiplexedStreamCapability_capabilityOnMuxStream * m_capabilityOnMuxStream;
	public:
	void encode ( Asn :: ostream & os ) const;
	~MultiplexedStreamCapability ( );
	void printOn ( std :: ostream & os ) const;
	const MultiplexedStreamCapability_capabilityOnMuxStream & get_capabilityOnMuxStream ( ) const {
		return * m_capabilityOnMuxStream;
	}
	MultiplexedStreamCapability_capabilityOnMuxStream & get_capabilityOnMuxStream ( ) {
		return * m_capabilityOnMuxStream;
	}
	MultiplexedStreamCapability * clone ( ) const;
};

//
// H223LogicalChannelParameters
//

// from 0 size 0 type 0 simple 0
class H223LogicalChannelParameters : public Asn :: Sequence {
	public:
	explicit H223LogicalChannelParameters ( Asn :: istream & is );
	H223LogicalChannelParameters ( );
	H223LogicalChannelParameters_adaptationLayerType m_adaptationLayerType;
	Asn :: Boolean m_segmentableFlag;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	H223LogicalChannelParameters * clone ( ) const;
};

//
// RTPPayloadType
//

// from 0 size 0 type 0 simple 0
class RTPPayloadType : public Asn :: Sequence {
	public:
	explicit RTPPayloadType ( Asn :: istream & is );
	RTPPayloadType ( );
	enum OptionalFields {
		e_payloadType
	};

	RTPPayloadType ( const RTPPayloadType & s );
	RTPPayloadType & operator= ( const RTPPayloadType & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	RTPPayloadType_payloadDescriptor m_payloadDescriptor;
	protected:
	RTPPayloadType_payloadType * m_payloadType;
	public:
	void encode ( Asn :: ostream & os ) const;
	~RTPPayloadType ( );
	void printOn ( std :: ostream & os ) const;
	const RTPPayloadType_payloadType & get_payloadType ( ) const {
		return * m_payloadType;
	}
	RTPPayloadType_payloadType & get_payloadType ( ) {
		return * m_payloadType;
	}
	RTPPayloadType * clone ( ) const;
};

//
// TransportAddress
//

// from 0 size 0 type 0 simple 0
class TransportAddress : public Asn :: Choice {
	public:
	explicit TransportAddress ( Asn :: istream & is );
	TransportAddress ( );
	enum Choices {
		e_unicastAddress,
		e_multicastAddress
	};

	operator UnicastAddress & ( ) { return dynamic_cast < UnicastAddress & > ( * choice ); }
	operator const UnicastAddress & ( ) const { return dynamic_cast < const UnicastAddress & > ( * choice ); }
	operator MulticastAddress & ( ) { return dynamic_cast < MulticastAddress & > ( * choice ); }
	operator const MulticastAddress & ( ) const { return dynamic_cast < const MulticastAddress & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	TransportAddress * clone ( ) const;
};

//
// H223ModeParameters
//

// from 0 size 0 type 0 simple 0
class H223ModeParameters : public Asn :: Sequence {
	public:
	explicit H223ModeParameters ( Asn :: istream & is );
	H223ModeParameters ( );
	H223ModeParameters_adaptationLayerType m_adaptationLayerType;
	Asn :: Boolean m_segmentableFlag;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	H223ModeParameters * clone ( ) const;
};

//
// VideoMode
//

// from 0 size 0 type 0 simple 0
class VideoMode : public Asn :: Choice {
	public:
	explicit VideoMode ( Asn :: istream & is );
	VideoMode ( );
	enum Choices {
		e_nonStandard,
		e_h261VideoMode,
		e_h262VideoMode,
		e_h263VideoMode,
		e_is11172VideoMode,
		e_genericVideoMode
	};

	operator NonStandardParameter & ( ) { return dynamic_cast < NonStandardParameter & > ( * choice ); }
	operator const NonStandardParameter & ( ) const { return dynamic_cast < const NonStandardParameter & > ( * choice ); }
	operator H261VideoMode & ( ) { return dynamic_cast < H261VideoMode & > ( * choice ); }
	operator const H261VideoMode & ( ) const { return dynamic_cast < const H261VideoMode & > ( * choice ); }
	operator H262VideoMode & ( ) { return dynamic_cast < H262VideoMode & > ( * choice ); }
	operator const H262VideoMode & ( ) const { return dynamic_cast < const H262VideoMode & > ( * choice ); }
	operator H263VideoMode & ( ) { return dynamic_cast < H263VideoMode & > ( * choice ); }
	operator const H263VideoMode & ( ) const { return dynamic_cast < const H263VideoMode & > ( * choice ); }
	operator IS11172VideoMode & ( ) { return dynamic_cast < IS11172VideoMode & > ( * choice ); }
	operator const IS11172VideoMode & ( ) const { return dynamic_cast < const IS11172VideoMode & > ( * choice ); }
	operator GenericCapability & ( ) { return dynamic_cast < GenericCapability & > ( * choice ); }
	operator const GenericCapability & ( ) const { return dynamic_cast < const GenericCapability & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	VideoMode * clone ( ) const;
};

//
// MultilinkIndication
//

// from 0 size 0 type 0 simple 0
class MultilinkIndication : public Asn :: Choice {
	public:
	explicit MultilinkIndication ( Asn :: istream & is );
	MultilinkIndication ( );
	enum Choices {
		e_nonStandard,
		e_crcDesired,
		e_excessiveError
	};

	operator NonStandardMessage & ( ) { return dynamic_cast < NonStandardMessage & > ( * choice ); }
	operator const NonStandardMessage & ( ) const { return dynamic_cast < const NonStandardMessage & > ( * choice ); }
	operator MultilinkIndication_crcDesired & ( ) { return dynamic_cast < MultilinkIndication_crcDesired & > ( * choice ); }
	operator const MultilinkIndication_crcDesired & ( ) const { return dynamic_cast < const MultilinkIndication_crcDesired & > ( * choice ); }
	operator MultilinkIndication_excessiveError & ( ) { return dynamic_cast < MultilinkIndication_excessiveError & > ( * choice ); }
	operator const MultilinkIndication_excessiveError & ( ) const { return dynamic_cast < const MultilinkIndication_excessiveError & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	MultilinkIndication * clone ( ) const;
};

//
// DialingInformation
//

// from 0 size 0 type 0 simple 0
class DialingInformation : public Asn :: Choice {
	public:
	explicit DialingInformation ( Asn :: istream & is );
	DialingInformation ( );
	enum Choices {
		e_nonStandard,
		e_differential,
		e_infoNotAvailable
	};

	operator NonStandardMessage & ( ) { return dynamic_cast < NonStandardMessage & > ( * choice ); }
	operator const NonStandardMessage & ( ) const { return dynamic_cast < const NonStandardMessage & > ( * choice ); }
	operator DialingInformation_differential & ( ) { return dynamic_cast < DialingInformation_differential & > ( * choice ); }
	operator const DialingInformation_differential & ( ) const { return dynamic_cast < const DialingInformation_differential & > ( * choice ); }
	operator DialingInformation_infoNotAvailable & ( ) { return dynamic_cast < DialingInformation_infoNotAvailable & > ( * choice ); }
	operator const DialingInformation_infoNotAvailable & ( ) const { return dynamic_cast < const DialingInformation_infoNotAvailable & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	DialingInformation * clone ( ) const;
};

//
// DialingInformationNetworkType
//

// from 0 size 0 type 0 simple 0
class DialingInformationNetworkType : public Asn :: Choice {
	public:
	explicit DialingInformationNetworkType ( Asn :: istream & is );
	DialingInformationNetworkType ( );
	enum Choices {
		e_nonStandard,
		e_n_isdn,
		e_gstn,
		e_mobile
	};

	operator NonStandardMessage & ( ) { return dynamic_cast < NonStandardMessage & > ( * choice ); }
	operator const NonStandardMessage & ( ) const { return dynamic_cast < const NonStandardMessage & > ( * choice ); }
	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	DialingInformationNetworkType * clone ( ) const;
};

//
// EncryptionCommand
//

// from 0 size 0 type 0 simple 0
class EncryptionCommand : public Asn :: Choice {
	public:
	explicit EncryptionCommand ( Asn :: istream & is );
	EncryptionCommand ( );
	enum Choices {
		e_encryptionSE,
		e_encryptionIVRequest,
		e_encryptionAlgorithmID
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator EncryptionCommand_encryptionAlgorithmID & ( ) { return dynamic_cast < EncryptionCommand_encryptionAlgorithmID & > ( * choice ); }
	operator const EncryptionCommand_encryptionAlgorithmID & ( ) const { return dynamic_cast < const EncryptionCommand_encryptionAlgorithmID & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	EncryptionCommand * clone ( ) const;
};

//
// MCLocationIndication
//

// from 0 size 0 type 0 simple 0
class MCLocationIndication : public Asn :: Sequence {
	public:
	explicit MCLocationIndication ( Asn :: istream & is );
	MCLocationIndication ( );
	TransportAddress m_signalAddress;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MCLocationIndication * clone ( ) const;
};

//
// UserInputIndication
//

// from 0 size 0 type 0 simple 0
class UserInputIndication : public Asn :: Choice {
	public:
	explicit UserInputIndication ( Asn :: istream & is );
	UserInputIndication ( );
	enum Choices {
		e_nonStandard,
		e_alphanumeric,
		e_userInputSupportIndication,
		e_signal,
		e_signalUpdate,
		e_extendedAlphanumeric,
		e_encryptedAlphanumeric,
		e_genericInformation
	};

	operator NonStandardParameter & ( ) { return dynamic_cast < NonStandardParameter & > ( * choice ); }
	operator const NonStandardParameter & ( ) const { return dynamic_cast < const NonStandardParameter & > ( * choice ); }
	operator UserInputIndication_userInputSupportIndication & ( ) { return dynamic_cast < UserInputIndication_userInputSupportIndication & > ( * choice ); }
	operator const UserInputIndication_userInputSupportIndication & ( ) const { return dynamic_cast < const UserInputIndication_userInputSupportIndication & > ( * choice ); }
	operator UserInputIndication_signal & ( ) { return dynamic_cast < UserInputIndication_signal & > ( * choice ); }
	operator const UserInputIndication_signal & ( ) const { return dynamic_cast < const UserInputIndication_signal & > ( * choice ); }
	operator UserInputIndication_signalUpdate & ( ) { return dynamic_cast < UserInputIndication_signalUpdate & > ( * choice ); }
	operator const UserInputIndication_signalUpdate & ( ) const { return dynamic_cast < const UserInputIndication_signalUpdate & > ( * choice ); }
	operator UserInputIndication_extendedAlphanumeric & ( ) { return dynamic_cast < UserInputIndication_extendedAlphanumeric & > ( * choice ); }
	operator const UserInputIndication_extendedAlphanumeric & ( ) const { return dynamic_cast < const UserInputIndication_extendedAlphanumeric & > ( * choice ); }
	operator UserInputIndication_encryptedAlphanumeric & ( ) { return dynamic_cast < UserInputIndication_encryptedAlphanumeric & > ( * choice ); }
	operator const UserInputIndication_encryptedAlphanumeric & ( ) const { return dynamic_cast < const UserInputIndication_encryptedAlphanumeric & > ( * choice ); }
	operator ArrayOf_GenericInformation & ( ) { return dynamic_cast < ArrayOf_GenericInformation & > ( * choice ); }
	operator const ArrayOf_GenericInformation & ( ) const { return dynamic_cast < const ArrayOf_GenericInformation & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	UserInputIndication * clone ( ) const;
};

//
// DataApplicationCapability_application
//

// from 0 size 0 type 0 simple 0
class DataApplicationCapability_application : public Asn :: Choice {
	public:
	explicit DataApplicationCapability_application ( Asn :: istream & is );
	DataApplicationCapability_application ( );
	enum Choices {
		e_nonStandard,
		e_t120,
		e_dsm_cc,
		e_userData,
		e_t84,
		e_t434,
		e_h224,
		e_nlpid,
		e_dsvdControl,
		e_h222DataPartitioning,
		e_t30fax,
		e_t140,
		e_t38fax,
		e_genericDataCapability
	};

	operator NonStandardParameter & ( ) { return dynamic_cast < NonStandardParameter & > ( * choice ); }
	operator const NonStandardParameter & ( ) const { return dynamic_cast < const NonStandardParameter & > ( * choice ); }
	operator DataProtocolCapability & ( ) { return dynamic_cast < DataProtocolCapability & > ( * choice ); }
	operator const DataProtocolCapability & ( ) const { return dynamic_cast < const DataProtocolCapability & > ( * choice ); }
	operator DataApplicationCapability_application_t84 & ( ) { return dynamic_cast < DataApplicationCapability_application_t84 & > ( * choice ); }
	operator const DataApplicationCapability_application_t84 & ( ) const { return dynamic_cast < const DataApplicationCapability_application_t84 & > ( * choice ); }
	operator DataApplicationCapability_application_nlpid & ( ) { return dynamic_cast < DataApplicationCapability_application_nlpid & > ( * choice ); }
	operator const DataApplicationCapability_application_nlpid & ( ) const { return dynamic_cast < const DataApplicationCapability_application_nlpid & > ( * choice ); }
	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator DataApplicationCapability_application_t38fax & ( ) { return dynamic_cast < DataApplicationCapability_application_t38fax & > ( * choice ); }
	operator const DataApplicationCapability_application_t38fax & ( ) const { return dynamic_cast < const DataApplicationCapability_application_t38fax & > ( * choice ); }
	operator GenericCapability & ( ) { return dynamic_cast < GenericCapability & > ( * choice ); }
	operator const GenericCapability & ( ) const { return dynamic_cast < const GenericCapability & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	DataApplicationCapability_application * clone ( ) const;
};

//
// NetworkAccessParameters_networkAddress
//

// from 0 size 0 type 0 simple 0
class NetworkAccessParameters_networkAddress : public Asn :: Choice {
	public:
	explicit NetworkAccessParameters_networkAddress ( Asn :: istream & is );
	NetworkAccessParameters_networkAddress ( );
	enum Choices {
		e_q2931Address,
		e_e164Address,
		e_localAreaAddress
	};

	operator Q2931Address & ( ) { return dynamic_cast < Q2931Address & > ( * choice ); }
	operator const Q2931Address & ( ) const { return dynamic_cast < const Q2931Address & > ( * choice ); }
	operator NetworkAccessParameters_networkAddress_e164Address & ( ) { return dynamic_cast < NetworkAccessParameters_networkAddress_e164Address & > ( * choice ); }
	operator const NetworkAccessParameters_networkAddress_e164Address & ( ) const { return dynamic_cast < const NetworkAccessParameters_networkAddress_e164Address & > ( * choice ); }
	operator TransportAddress & ( ) { return dynamic_cast < TransportAddress & > ( * choice ); }
	operator const TransportAddress & ( ) const { return dynamic_cast < const TransportAddress & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	NetworkAccessParameters_networkAddress * clone ( ) const;
};

//
// H2250LogicalChannelParameters_mediaPacketization
//

// from 0 size 0 type 0 simple 0
class H2250LogicalChannelParameters_mediaPacketization : public Asn :: Choice {
	public:
	explicit H2250LogicalChannelParameters_mediaPacketization ( Asn :: istream & is );
	H2250LogicalChannelParameters_mediaPacketization ( );
	enum Choices {
		e_h261aVideoPacketization,
		e_rtpPayloadType
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator RTPPayloadType & ( ) { return dynamic_cast < RTPPayloadType & > ( * choice ); }
	operator const RTPPayloadType & ( ) const { return dynamic_cast < const RTPPayloadType & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	H2250LogicalChannelParameters_mediaPacketization * clone ( ) const;
};

//
// DepFECData_rfc2733
//

// from 0 size 0 type 0 simple 0
class DepFECData_rfc2733 : public Asn :: Sequence {
	public:
	explicit DepFECData_rfc2733 ( Asn :: istream & is );
	DepFECData_rfc2733 ( );
	DepFECData_rfc2733_mode m_mode;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	DepFECData_rfc2733 * clone ( ) const;
};

//
// DataMode_application
//

// from 0 size 0 type 0 simple 0
class DataMode_application : public Asn :: Choice {
	public:
	explicit DataMode_application ( Asn :: istream & is );
	DataMode_application ( );
	enum Choices {
		e_nonStandard,
		e_t120,
		e_dsm_cc,
		e_userData,
		e_t84,
		e_t434,
		e_h224,
		e_nlpid,
		e_dsvdControl,
		e_h222DataPartitioning,
		e_t30fax,
		e_t140,
		e_t38fax,
		e_genericDataMode
	};

	operator NonStandardParameter & ( ) { return dynamic_cast < NonStandardParameter & > ( * choice ); }
	operator const NonStandardParameter & ( ) const { return dynamic_cast < const NonStandardParameter & > ( * choice ); }
	operator DataProtocolCapability & ( ) { return dynamic_cast < DataProtocolCapability & > ( * choice ); }
	operator const DataProtocolCapability & ( ) const { return dynamic_cast < const DataProtocolCapability & > ( * choice ); }
	operator DataMode_application_nlpid & ( ) { return dynamic_cast < DataMode_application_nlpid & > ( * choice ); }
	operator const DataMode_application_nlpid & ( ) const { return dynamic_cast < const DataMode_application_nlpid & > ( * choice ); }
	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator DataMode_application_t38fax & ( ) { return dynamic_cast < DataMode_application_t38fax & > ( * choice ); }
	operator const DataMode_application_t38fax & ( ) const { return dynamic_cast < const DataMode_application_t38fax & > ( * choice ); }
	operator GenericCapability & ( ) { return dynamic_cast < GenericCapability & > ( * choice ); }
	operator const GenericCapability & ( ) const { return dynamic_cast < const GenericCapability & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	DataMode_application * clone ( ) const;
};

//
// MultilinkRequest_addConnection
//

// from 0 size 0 type 0 simple 0
class MultilinkRequest_addConnection : public Asn :: Sequence {
	public:
	explicit MultilinkRequest_addConnection ( Asn :: istream & is );
	MultilinkRequest_addConnection ( );
	SequenceNumber m_sequenceNumber;
	DialingInformation m_dialingInformation;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MultilinkRequest_addConnection * clone ( ) const;
};

//
// MultilinkResponse_callInformation
//

// from 0 size 0 type 0 simple 0
class MultilinkResponse_callInformation : public Asn :: Sequence {
	public:
	explicit MultilinkResponse_callInformation ( Asn :: istream & is );
	MultilinkResponse_callInformation ( );
	DialingInformation m_dialingInformation;
	MultilinkResponse_callInformation_callAssociationNumber m_callAssociationNumber;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MultilinkResponse_callInformation * clone ( ) const;
};

//
// OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters
//

// from 0 size 0 type 0 simple 0
class OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters : public Asn :: Choice {
	public:
	explicit OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters ( Asn :: istream & is );
	OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters ( );
	enum Choices {
		e_h222LogicalChannelParameters,
		e_h223LogicalChannelParameters,
		e_v76LogicalChannelParameters,
		e_h2250LogicalChannelParameters,
		e_none
	};

	operator H222LogicalChannelParameters & ( ) { return dynamic_cast < H222LogicalChannelParameters & > ( * choice ); }
	operator const H222LogicalChannelParameters & ( ) const { return dynamic_cast < const H222LogicalChannelParameters & > ( * choice ); }
	operator H223LogicalChannelParameters & ( ) { return dynamic_cast < H223LogicalChannelParameters & > ( * choice ); }
	operator const H223LogicalChannelParameters & ( ) const { return dynamic_cast < const H223LogicalChannelParameters & > ( * choice ); }
	operator V76LogicalChannelParameters & ( ) { return dynamic_cast < V76LogicalChannelParameters & > ( * choice ); }
	operator const V76LogicalChannelParameters & ( ) const { return dynamic_cast < const V76LogicalChannelParameters & > ( * choice ); }
	operator H2250LogicalChannelParameters & ( ) { return dynamic_cast < H2250LogicalChannelParameters & > ( * choice ); }
	operator const H2250LogicalChannelParameters & ( ) const { return dynamic_cast < const H2250LogicalChannelParameters & > ( * choice ); }
	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters * clone ( ) const;
};

//
// OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters
//

// from 0 size 0 type 0 simple 0
class OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters : public Asn :: Choice {
	public:
	explicit OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters ( Asn :: istream & is );
	OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters ( );
	enum Choices {
		e_h223LogicalChannelParameters,
		e_v76LogicalChannelParameters,
		e_h2250LogicalChannelParameters
	};

	operator H223LogicalChannelParameters & ( ) { return dynamic_cast < H223LogicalChannelParameters & > ( * choice ); }
	operator const H223LogicalChannelParameters & ( ) const { return dynamic_cast < const H223LogicalChannelParameters & > ( * choice ); }
	operator V76LogicalChannelParameters & ( ) { return dynamic_cast < V76LogicalChannelParameters & > ( * choice ); }
	operator const V76LogicalChannelParameters & ( ) const { return dynamic_cast < const V76LogicalChannelParameters & > ( * choice ); }
	operator H2250LogicalChannelParameters & ( ) { return dynamic_cast < H2250LogicalChannelParameters & > ( * choice ); }
	operator const H2250LogicalChannelParameters & ( ) const { return dynamic_cast < const H2250LogicalChannelParameters & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters * clone ( ) const;
};

//
// CommandMessage
//

// from 0 size 0 type 0 simple 0
class CommandMessage : public Asn :: Choice {
	public:
	explicit CommandMessage ( Asn :: istream & is );
	CommandMessage ( );
	enum Choices {
		e_nonStandard,
		e_maintenanceLoopOffCommand,
		e_sendTerminalCapabilitySet,
		e_encryptionCommand,
		e_flowControlCommand,
		e_endSessionCommand,
		e_miscellaneousCommand,
		e_communicationModeCommand,
		e_conferenceCommand,
		e_h223MultiplexReconfiguration,
		e_newATMVCCommand,
		e_mobileMultilinkReconfigurationCommand,
		e_genericCommand
	};

	operator NonStandardMessage & ( ) { return dynamic_cast < NonStandardMessage & > ( * choice ); }
	operator const NonStandardMessage & ( ) const { return dynamic_cast < const NonStandardMessage & > ( * choice ); }
	operator MaintenanceLoopOffCommand & ( ) { return dynamic_cast < MaintenanceLoopOffCommand & > ( * choice ); }
	operator const MaintenanceLoopOffCommand & ( ) const { return dynamic_cast < const MaintenanceLoopOffCommand & > ( * choice ); }
	operator SendTerminalCapabilitySet & ( ) { return dynamic_cast < SendTerminalCapabilitySet & > ( * choice ); }
	operator const SendTerminalCapabilitySet & ( ) const { return dynamic_cast < const SendTerminalCapabilitySet & > ( * choice ); }
	operator EncryptionCommand & ( ) { return dynamic_cast < EncryptionCommand & > ( * choice ); }
	operator const EncryptionCommand & ( ) const { return dynamic_cast < const EncryptionCommand & > ( * choice ); }
	operator FlowControlCommand & ( ) { return dynamic_cast < FlowControlCommand & > ( * choice ); }
	operator const FlowControlCommand & ( ) const { return dynamic_cast < const FlowControlCommand & > ( * choice ); }
	operator EndSessionCommand & ( ) { return dynamic_cast < EndSessionCommand & > ( * choice ); }
	operator const EndSessionCommand & ( ) const { return dynamic_cast < const EndSessionCommand & > ( * choice ); }
	operator MiscellaneousCommand & ( ) { return dynamic_cast < MiscellaneousCommand & > ( * choice ); }
	operator const MiscellaneousCommand & ( ) const { return dynamic_cast < const MiscellaneousCommand & > ( * choice ); }
	operator CommunicationModeCommand & ( ) { return dynamic_cast < CommunicationModeCommand & > ( * choice ); }
	operator const CommunicationModeCommand & ( ) const { return dynamic_cast < const CommunicationModeCommand & > ( * choice ); }
	operator ConferenceCommand & ( ) { return dynamic_cast < ConferenceCommand & > ( * choice ); }
	operator const ConferenceCommand & ( ) const { return dynamic_cast < const ConferenceCommand & > ( * choice ); }
	operator H223MultiplexReconfiguration & ( ) { return dynamic_cast < H223MultiplexReconfiguration & > ( * choice ); }
	operator const H223MultiplexReconfiguration & ( ) const { return dynamic_cast < const H223MultiplexReconfiguration & > ( * choice ); }
	operator NewATMVCCommand & ( ) { return dynamic_cast < NewATMVCCommand & > ( * choice ); }
	operator const NewATMVCCommand & ( ) const { return dynamic_cast < const NewATMVCCommand & > ( * choice ); }
	operator MobileMultilinkReconfigurationCommand & ( ) { return dynamic_cast < MobileMultilinkReconfigurationCommand & > ( * choice ); }
	operator const MobileMultilinkReconfigurationCommand & ( ) const { return dynamic_cast < const MobileMultilinkReconfigurationCommand & > ( * choice ); }
	operator GenericMessage & ( ) { return dynamic_cast < GenericMessage & > ( * choice ); }
	operator const GenericMessage & ( ) const { return dynamic_cast < const GenericMessage & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	CommandMessage * clone ( ) const;
};

//
// MultiplexCapability
//

// from 0 size 0 type 0 simple 0
class MultiplexCapability : public Asn :: Choice {
	public:
	explicit MultiplexCapability ( Asn :: istream & is );
	MultiplexCapability ( );
	enum Choices {
		e_nonStandard,
		e_h222Capability,
		e_h223Capability,
		e_v76Capability,
		e_h2250Capability,
		e_genericMultiplexCapability
	};

	operator NonStandardParameter & ( ) { return dynamic_cast < NonStandardParameter & > ( * choice ); }
	operator const NonStandardParameter & ( ) const { return dynamic_cast < const NonStandardParameter & > ( * choice ); }
	operator H222Capability & ( ) { return dynamic_cast < H222Capability & > ( * choice ); }
	operator const H222Capability & ( ) const { return dynamic_cast < const H222Capability & > ( * choice ); }
	operator H223Capability & ( ) { return dynamic_cast < H223Capability & > ( * choice ); }
	operator const H223Capability & ( ) const { return dynamic_cast < const H223Capability & > ( * choice ); }
	operator V76Capability & ( ) { return dynamic_cast < V76Capability & > ( * choice ); }
	operator const V76Capability & ( ) const { return dynamic_cast < const V76Capability & > ( * choice ); }
	operator H2250Capability & ( ) { return dynamic_cast < H2250Capability & > ( * choice ); }
	operator const H2250Capability & ( ) const { return dynamic_cast < const H2250Capability & > ( * choice ); }
	operator GenericCapability & ( ) { return dynamic_cast < GenericCapability & > ( * choice ); }
	operator const GenericCapability & ( ) const { return dynamic_cast < const GenericCapability & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	MultiplexCapability * clone ( ) const;
};

//
// VideoCapability
//

// from 0 size 0 type 0 simple 0
class VideoCapability : public Asn :: Choice {
	public:
	explicit VideoCapability ( Asn :: istream & is );
	VideoCapability ( );
	enum Choices {
		e_nonStandard,
		e_h261VideoCapability,
		e_h262VideoCapability,
		e_h263VideoCapability,
		e_is11172VideoCapability,
		e_genericVideoCapability,
		e_extendedVideoCapability
	};

	operator NonStandardParameter & ( ) { return dynamic_cast < NonStandardParameter & > ( * choice ); }
	operator const NonStandardParameter & ( ) const { return dynamic_cast < const NonStandardParameter & > ( * choice ); }
	operator H261VideoCapability & ( ) { return dynamic_cast < H261VideoCapability & > ( * choice ); }
	operator const H261VideoCapability & ( ) const { return dynamic_cast < const H261VideoCapability & > ( * choice ); }
	operator H262VideoCapability & ( ) { return dynamic_cast < H262VideoCapability & > ( * choice ); }
	operator const H262VideoCapability & ( ) const { return dynamic_cast < const H262VideoCapability & > ( * choice ); }
	operator H263VideoCapability & ( ) { return dynamic_cast < H263VideoCapability & > ( * choice ); }
	operator const H263VideoCapability & ( ) const { return dynamic_cast < const H263VideoCapability & > ( * choice ); }
	operator IS11172VideoCapability & ( ) { return dynamic_cast < IS11172VideoCapability & > ( * choice ); }
	operator const IS11172VideoCapability & ( ) const { return dynamic_cast < const IS11172VideoCapability & > ( * choice ); }
	operator GenericCapability & ( ) { return dynamic_cast < GenericCapability & > ( * choice ); }
	operator const GenericCapability & ( ) const { return dynamic_cast < const GenericCapability & > ( * choice ); }
	operator ExtendedVideoCapability & ( ) { return dynamic_cast < ExtendedVideoCapability & > ( * choice ); }
	operator const ExtendedVideoCapability & ( ) const { return dynamic_cast < const ExtendedVideoCapability & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	VideoCapability * clone ( ) const;
};

//
// DataApplicationCapability
//

// from 0 size 0 type 0 simple 0
class DataApplicationCapability : public Asn :: Sequence {
	public:
	explicit DataApplicationCapability ( Asn :: istream & is );
	DataApplicationCapability ( );
	DataApplicationCapability_application m_application;
	DataApplicationCapability_maxBitRate m_maxBitRate;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	DataApplicationCapability * clone ( ) const;
};

//
// UserInputCapability
//

// from 0 size 0 type 0 simple 0
class UserInputCapability : public Asn :: Choice {
	public:
	explicit UserInputCapability ( Asn :: istream & is );
	UserInputCapability ( );
	enum Choices {
		e_nonStandard,
		e_basicString,
		e_iA5String,
		e_generalString,
		e_dtmf,
		e_hookflash,
		e_extendedAlphanumeric,
		e_encryptedBasicString,
		e_encryptedIA5String,
		e_encryptedGeneralString,
		e_secureDTMF,
		e_genericUserInputCapability
	};

	operator UserInputCapability_nonStandard & ( ) { return dynamic_cast < UserInputCapability_nonStandard & > ( * choice ); }
	operator const UserInputCapability_nonStandard & ( ) const { return dynamic_cast < const UserInputCapability_nonStandard & > ( * choice ); }
	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator GenericCapability & ( ) { return dynamic_cast < GenericCapability & > ( * choice ); }
	operator const GenericCapability & ( ) const { return dynamic_cast < const GenericCapability & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	UserInputCapability * clone ( ) const;
};

//
// NetworkAccessParameters
//

// from 0 size 0 type 0 simple 0
class NetworkAccessParameters : public Asn :: Sequence {
	public:
	explicit NetworkAccessParameters ( Asn :: istream & is );
	NetworkAccessParameters ( );
	enum OptionalFields {
		e_distribution,
		e_externalReference,
		e_t120SetupProcedure
	};

	NetworkAccessParameters ( const NetworkAccessParameters & s );
	NetworkAccessParameters & operator= ( const NetworkAccessParameters & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	NetworkAccessParameters_distribution * m_distribution;
	public:
	NetworkAccessParameters_networkAddress m_networkAddress;
	Asn :: Boolean m_associateConference;
	protected:
	NetworkAccessParameters_externalReference * m_externalReference;
	NetworkAccessParameters_t120SetupProcedure * m_t120SetupProcedure;
	public:
	void encode ( Asn :: ostream & os ) const;
	~NetworkAccessParameters ( );
	void printOn ( std :: ostream & os ) const;
	const NetworkAccessParameters_distribution & get_distribution ( ) const {
		return * m_distribution;
	}
	NetworkAccessParameters_distribution & get_distribution ( ) {
		return * m_distribution;
	}
	const NetworkAccessParameters_externalReference & get_externalReference ( ) const {
		return * m_externalReference;
	}
	NetworkAccessParameters_externalReference & get_externalReference ( ) {
		return * m_externalReference;
	}
	const NetworkAccessParameters_t120SetupProcedure & get_t120SetupProcedure ( ) const {
		return * m_t120SetupProcedure;
	}
	NetworkAccessParameters_t120SetupProcedure & get_t120SetupProcedure ( ) {
		return * m_t120SetupProcedure;
	}
	NetworkAccessParameters * clone ( ) const;
};

//
// DepFECData
//

// from 0 size 0 type 0 simple 0
class DepFECData : public Asn :: Choice {
	public:
	explicit DepFECData ( Asn :: istream & is );
	DepFECData ( );
	enum Choices {
		e_rfc2733
	};

	operator DepFECData_rfc2733 & ( ) { return dynamic_cast < DepFECData_rfc2733 & > ( * choice ); }
	operator const DepFECData_rfc2733 & ( ) const { return dynamic_cast < const DepFECData_rfc2733 & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	DepFECData * clone ( ) const;
};

//
// DataMode
//

// from 0 size 0 type 0 simple 0
class DataMode : public Asn :: Sequence {
	public:
	explicit DataMode ( Asn :: istream & is );
	DataMode ( );
	DataMode_application m_application;
	DataMode_bitRate m_bitRate;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	DataMode * clone ( ) const;
};

//
// MultilinkRequest
//

// from 0 size 0 type 0 simple 0
class MultilinkRequest : public Asn :: Choice {
	public:
	explicit MultilinkRequest ( Asn :: istream & is );
	MultilinkRequest ( );
	enum Choices {
		e_nonStandard,
		e_callInformation,
		e_addConnection,
		e_removeConnection,
		e_maximumHeaderInterval
	};

	operator NonStandardMessage & ( ) { return dynamic_cast < NonStandardMessage & > ( * choice ); }
	operator const NonStandardMessage & ( ) const { return dynamic_cast < const NonStandardMessage & > ( * choice ); }
	operator MultilinkRequest_callInformation & ( ) { return dynamic_cast < MultilinkRequest_callInformation & > ( * choice ); }
	operator const MultilinkRequest_callInformation & ( ) const { return dynamic_cast < const MultilinkRequest_callInformation & > ( * choice ); }
	operator MultilinkRequest_addConnection & ( ) { return dynamic_cast < MultilinkRequest_addConnection & > ( * choice ); }
	operator const MultilinkRequest_addConnection & ( ) const { return dynamic_cast < const MultilinkRequest_addConnection & > ( * choice ); }
	operator MultilinkRequest_removeConnection & ( ) { return dynamic_cast < MultilinkRequest_removeConnection & > ( * choice ); }
	operator const MultilinkRequest_removeConnection & ( ) const { return dynamic_cast < const MultilinkRequest_removeConnection & > ( * choice ); }
	operator MultilinkRequest_maximumHeaderInterval & ( ) { return dynamic_cast < MultilinkRequest_maximumHeaderInterval & > ( * choice ); }
	operator const MultilinkRequest_maximumHeaderInterval & ( ) const { return dynamic_cast < const MultilinkRequest_maximumHeaderInterval & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	MultilinkRequest * clone ( ) const;
};

//
// MultilinkResponse
//

// from 0 size 0 type 0 simple 0
class MultilinkResponse : public Asn :: Choice {
	public:
	explicit MultilinkResponse ( Asn :: istream & is );
	MultilinkResponse ( );
	enum Choices {
		e_nonStandard,
		e_callInformation,
		e_addConnection,
		e_removeConnection,
		e_maximumHeaderInterval
	};

	operator NonStandardMessage & ( ) { return dynamic_cast < NonStandardMessage & > ( * choice ); }
	operator const NonStandardMessage & ( ) const { return dynamic_cast < const NonStandardMessage & > ( * choice ); }
	operator MultilinkResponse_callInformation & ( ) { return dynamic_cast < MultilinkResponse_callInformation & > ( * choice ); }
	operator const MultilinkResponse_callInformation & ( ) const { return dynamic_cast < const MultilinkResponse_callInformation & > ( * choice ); }
	operator MultilinkResponse_addConnection & ( ) { return dynamic_cast < MultilinkResponse_addConnection & > ( * choice ); }
	operator const MultilinkResponse_addConnection & ( ) const { return dynamic_cast < const MultilinkResponse_addConnection & > ( * choice ); }
	operator MultilinkResponse_removeConnection & ( ) { return dynamic_cast < MultilinkResponse_removeConnection & > ( * choice ); }
	operator const MultilinkResponse_removeConnection & ( ) const { return dynamic_cast < const MultilinkResponse_removeConnection & > ( * choice ); }
	operator MultilinkResponse_maximumHeaderInterval & ( ) { return dynamic_cast < MultilinkResponse_maximumHeaderInterval & > ( * choice ); }
	operator const MultilinkResponse_maximumHeaderInterval & ( ) const { return dynamic_cast < const MultilinkResponse_maximumHeaderInterval & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	MultilinkResponse * clone ( ) const;
};

//
// ResponseMessage
//

// from 0 size 0 type 0 simple 0
class ResponseMessage : public Asn :: Choice {
	public:
	explicit ResponseMessage ( Asn :: istream & is );
	ResponseMessage ( );
	enum Choices {
		e_nonStandard,
		e_masterSlaveDeterminationAck,
		e_masterSlaveDeterminationReject,
		e_terminalCapabilitySetAck,
		e_terminalCapabilitySetReject,
		e_openLogicalChannelAck,
		e_openLogicalChannelReject,
		e_closeLogicalChannelAck,
		e_requestChannelCloseAck,
		e_requestChannelCloseReject,
		e_multiplexEntrySendAck,
		e_multiplexEntrySendReject,
		e_requestMultiplexEntryAck,
		e_requestMultiplexEntryReject,
		e_requestModeAck,
		e_requestModeReject,
		e_roundTripDelayResponse,
		e_maintenanceLoopAck,
		e_maintenanceLoopReject,
		e_communicationModeResponse,
		e_conferenceResponse,
		e_multilinkResponse,
		e_logicalChannelRateAcknowledge,
		e_logicalChannelRateReject,
		e_genericResponse
	};

	operator NonStandardMessage & ( ) { return dynamic_cast < NonStandardMessage & > ( * choice ); }
	operator const NonStandardMessage & ( ) const { return dynamic_cast < const NonStandardMessage & > ( * choice ); }
	operator MasterSlaveDeterminationAck & ( ) { return dynamic_cast < MasterSlaveDeterminationAck & > ( * choice ); }
	operator const MasterSlaveDeterminationAck & ( ) const { return dynamic_cast < const MasterSlaveDeterminationAck & > ( * choice ); }
	operator MasterSlaveDeterminationReject & ( ) { return dynamic_cast < MasterSlaveDeterminationReject & > ( * choice ); }
	operator const MasterSlaveDeterminationReject & ( ) const { return dynamic_cast < const MasterSlaveDeterminationReject & > ( * choice ); }
	operator TerminalCapabilitySetAck & ( ) { return dynamic_cast < TerminalCapabilitySetAck & > ( * choice ); }
	operator const TerminalCapabilitySetAck & ( ) const { return dynamic_cast < const TerminalCapabilitySetAck & > ( * choice ); }
	operator TerminalCapabilitySetReject & ( ) { return dynamic_cast < TerminalCapabilitySetReject & > ( * choice ); }
	operator const TerminalCapabilitySetReject & ( ) const { return dynamic_cast < const TerminalCapabilitySetReject & > ( * choice ); }
	operator OpenLogicalChannelAck & ( ) { return dynamic_cast < OpenLogicalChannelAck & > ( * choice ); }
	operator const OpenLogicalChannelAck & ( ) const { return dynamic_cast < const OpenLogicalChannelAck & > ( * choice ); }
	operator OpenLogicalChannelReject & ( ) { return dynamic_cast < OpenLogicalChannelReject & > ( * choice ); }
	operator const OpenLogicalChannelReject & ( ) const { return dynamic_cast < const OpenLogicalChannelReject & > ( * choice ); }
	operator CloseLogicalChannelAck & ( ) { return dynamic_cast < CloseLogicalChannelAck & > ( * choice ); }
	operator const CloseLogicalChannelAck & ( ) const { return dynamic_cast < const CloseLogicalChannelAck & > ( * choice ); }
	operator RequestChannelCloseAck & ( ) { return dynamic_cast < RequestChannelCloseAck & > ( * choice ); }
	operator const RequestChannelCloseAck & ( ) const { return dynamic_cast < const RequestChannelCloseAck & > ( * choice ); }
	operator RequestChannelCloseReject & ( ) { return dynamic_cast < RequestChannelCloseReject & > ( * choice ); }
	operator const RequestChannelCloseReject & ( ) const { return dynamic_cast < const RequestChannelCloseReject & > ( * choice ); }
	operator MultiplexEntrySendAck & ( ) { return dynamic_cast < MultiplexEntrySendAck & > ( * choice ); }
	operator const MultiplexEntrySendAck & ( ) const { return dynamic_cast < const MultiplexEntrySendAck & > ( * choice ); }
	operator MultiplexEntrySendReject & ( ) { return dynamic_cast < MultiplexEntrySendReject & > ( * choice ); }
	operator const MultiplexEntrySendReject & ( ) const { return dynamic_cast < const MultiplexEntrySendReject & > ( * choice ); }
	operator RequestMultiplexEntryAck & ( ) { return dynamic_cast < RequestMultiplexEntryAck & > ( * choice ); }
	operator const RequestMultiplexEntryAck & ( ) const { return dynamic_cast < const RequestMultiplexEntryAck & > ( * choice ); }
	operator RequestMultiplexEntryReject & ( ) { return dynamic_cast < RequestMultiplexEntryReject & > ( * choice ); }
	operator const RequestMultiplexEntryReject & ( ) const { return dynamic_cast < const RequestMultiplexEntryReject & > ( * choice ); }
	operator RequestModeAck & ( ) { return dynamic_cast < RequestModeAck & > ( * choice ); }
	operator const RequestModeAck & ( ) const { return dynamic_cast < const RequestModeAck & > ( * choice ); }
	operator RequestModeReject & ( ) { return dynamic_cast < RequestModeReject & > ( * choice ); }
	operator const RequestModeReject & ( ) const { return dynamic_cast < const RequestModeReject & > ( * choice ); }
	operator RoundTripDelayResponse & ( ) { return dynamic_cast < RoundTripDelayResponse & > ( * choice ); }
	operator const RoundTripDelayResponse & ( ) const { return dynamic_cast < const RoundTripDelayResponse & > ( * choice ); }
	operator MaintenanceLoopAck & ( ) { return dynamic_cast < MaintenanceLoopAck & > ( * choice ); }
	operator const MaintenanceLoopAck & ( ) const { return dynamic_cast < const MaintenanceLoopAck & > ( * choice ); }
	operator MaintenanceLoopReject & ( ) { return dynamic_cast < MaintenanceLoopReject & > ( * choice ); }
	operator const MaintenanceLoopReject & ( ) const { return dynamic_cast < const MaintenanceLoopReject & > ( * choice ); }
	operator CommunicationModeResponse & ( ) { return dynamic_cast < CommunicationModeResponse & > ( * choice ); }
	operator const CommunicationModeResponse & ( ) const { return dynamic_cast < const CommunicationModeResponse & > ( * choice ); }
	operator ConferenceResponse & ( ) { return dynamic_cast < ConferenceResponse & > ( * choice ); }
	operator const ConferenceResponse & ( ) const { return dynamic_cast < const ConferenceResponse & > ( * choice ); }
	operator MultilinkResponse & ( ) { return dynamic_cast < MultilinkResponse & > ( * choice ); }
	operator const MultilinkResponse & ( ) const { return dynamic_cast < const MultilinkResponse & > ( * choice ); }
	operator LogicalChannelRateAcknowledge & ( ) { return dynamic_cast < LogicalChannelRateAcknowledge & > ( * choice ); }
	operator const LogicalChannelRateAcknowledge & ( ) const { return dynamic_cast < const LogicalChannelRateAcknowledge & > ( * choice ); }
	operator LogicalChannelRateReject & ( ) { return dynamic_cast < LogicalChannelRateReject & > ( * choice ); }
	operator const LogicalChannelRateReject & ( ) const { return dynamic_cast < const LogicalChannelRateReject & > ( * choice ); }
	operator GenericMessage & ( ) { return dynamic_cast < GenericMessage & > ( * choice ); }
	operator const GenericMessage & ( ) const { return dynamic_cast < const GenericMessage & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	ResponseMessage * clone ( ) const;
};

//
// DataType
//

// from 0 size 0 type 0 simple 0
class AudioCapability;
class H235Media;

class DataType : public Asn :: Choice {
	public:
	explicit DataType ( Asn :: istream & is );
	DataType ( );
	enum Choices {
		e_nonStandard,
		e_nullData,
		e_videoData,
		e_audioData,
		e_data,
		e_encryptionData,
		e_h235Control,
		e_h235Media,
		e_multiplexedStream,
		e_redundancyEncoding,
		e_multiplePayloadStream,
		e_depFec,
		e_fec
	};

	operator NonStandardParameter & ( );
	operator const NonStandardParameter & ( ) const;
	operator Asn :: Null & ( );
	operator const Asn :: Null & ( ) const;
	operator VideoCapability & ( );
	operator const VideoCapability & ( ) const;
	operator AudioCapability & ( );
	operator const AudioCapability & ( ) const;
	operator DataApplicationCapability & ( );
	operator const DataApplicationCapability & ( ) const;
	operator EncryptionMode & ( );
	operator const EncryptionMode & ( ) const;
	operator H235Media & ( );
	operator const H235Media & ( ) const;
	operator MultiplexedStreamParameter & ( );
	operator const MultiplexedStreamParameter & ( ) const;
	operator RedundancyEncoding & ( );
	operator const RedundancyEncoding & ( ) const;
	operator MultiplePayloadStream & ( );
	operator const MultiplePayloadStream & ( ) const;
	operator DepFECData & ( );
	operator const DepFECData & ( ) const;
	operator FECData & ( );
	operator const FECData & ( ) const;

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	DataType * clone ( ) const;
};

//
// RedundancyEncodingElement
//

// from 0 size 0 type 0 simple 0
class RedundancyEncodingElement : public Asn :: Sequence {
	public:
	explicit RedundancyEncodingElement ( Asn :: istream & is );
	RedundancyEncodingElement ( );
	enum OptionalFields {
		e_payloadType
	};

	RedundancyEncodingElement ( const RedundancyEncodingElement & s );
	RedundancyEncodingElement & operator= ( const RedundancyEncodingElement & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	DataType m_dataType;
	protected:
	RedundancyEncodingElement_payloadType * m_payloadType;
	public:
	void encode ( Asn :: ostream & os ) const;
	~RedundancyEncodingElement ( );
	void printOn ( std :: ostream & os ) const;
	const RedundancyEncodingElement_payloadType & get_payloadType ( ) const {
		return * m_payloadType;
	}
	RedundancyEncodingElement_payloadType & get_payloadType ( ) {
		return * m_payloadType;
	}
	RedundancyEncodingElement * clone ( ) const;
};

//
// MultiplePayloadStreamElement
//

// from 0 size 0 type 0 simple 0
class MultiplePayloadStreamElement : public Asn :: Sequence {
	public:
	explicit MultiplePayloadStreamElement ( Asn :: istream & is );
	MultiplePayloadStreamElement ( );
	enum OptionalFields {
		e_payloadType
	};

	MultiplePayloadStreamElement ( const MultiplePayloadStreamElement & s );
	MultiplePayloadStreamElement & operator= ( const MultiplePayloadStreamElement & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	DataType m_dataType;
	protected:
	MultiplePayloadStreamElement_payloadType * m_payloadType;
	public:
	void encode ( Asn :: ostream & os ) const;
	~MultiplePayloadStreamElement ( );
	void printOn ( std :: ostream & os ) const;
	const MultiplePayloadStreamElement_payloadType & get_payloadType ( ) const {
		return * m_payloadType;
	}
	MultiplePayloadStreamElement_payloadType & get_payloadType ( ) {
		return * m_payloadType;
	}
	MultiplePayloadStreamElement * clone ( ) const;
};

//
// ModeElementType
//

// from 0 size 0 type 0 simple 0
class AudioMode;
class H235Mode;
class RedundancyEncodingDTMode;
class DepFECMode;
class FECMode;

class ModeElementType : public Asn :: Choice {
	public:
	explicit ModeElementType ( Asn :: istream & is );
	ModeElementType ( );
	enum Choices {
		e_nonStandard,
		e_videoMode,
		e_audioMode,
		e_dataMode,
		e_encryptionMode,
		e_h235Mode,
		e_multiplexedStreamMode,
		e_redundancyEncodingDTMode,
		e_multiplePayloadStreamMode,
		e_depFecMode,
		e_fecMode
	};

	operator NonStandardParameter & ( );
	operator const NonStandardParameter & ( ) const;
	operator VideoMode & ( );
	operator const VideoMode & ( ) const;
	operator AudioMode & ( );
	operator const AudioMode & ( ) const;
	operator DataMode & ( );
	operator const DataMode & ( ) const;
	operator EncryptionMode & ( );
	operator const EncryptionMode & ( ) const;
	operator H235Mode & ( );
	operator const H235Mode & ( ) const;
	operator MultiplexedStreamParameter & ( );
	operator const MultiplexedStreamParameter & ( ) const;
	operator RedundancyEncodingDTMode & ( );
	operator const RedundancyEncodingDTMode & ( ) const;
	operator MultiplePayloadStreamMode & ( );
	operator const MultiplePayloadStreamMode & ( ) const;
	operator DepFECMode & ( );
	operator const DepFECMode & ( ) const;
	operator FECMode & ( );
	operator const FECMode & ( ) const;

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	ModeElementType * clone ( ) const;
};

//
// ModeElement
//

// from 0 size 0 type 0 simple 0
class ModeElement : public Asn :: Sequence {
	public:
	explicit ModeElement ( Asn :: istream & is );
	ModeElement ( );
	enum OptionalFields {
		e_h223ModeParameters,
		e_v76ModeParameters,
		e_h2250ModeParameters,
		e_genericModeParameters,
		e_multiplexedStreamModeParameters,
		e_logicalChannelNumber
	};

	ModeElement ( const ModeElement & s );
	ModeElement & operator= ( const ModeElement & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	ModeElementType m_type;
	protected:
	H223ModeParameters * m_h223ModeParameters;
	V76ModeParameters * m_v76ModeParameters;
	H2250ModeParameters * m_h2250ModeParameters;
	GenericCapability * m_genericModeParameters;
	MultiplexedStreamModeParameters * m_multiplexedStreamModeParameters;
	LogicalChannelNumber * m_logicalChannelNumber;
	public:
	void encode ( Asn :: ostream & os ) const;
	~ModeElement ( );
	void printOn ( std :: ostream & os ) const;
	const H223ModeParameters & get_h223ModeParameters ( ) const {
		return * m_h223ModeParameters;
	}
	H223ModeParameters & get_h223ModeParameters ( ) {
		return * m_h223ModeParameters;
	}
	const V76ModeParameters & get_v76ModeParameters ( ) const {
		return * m_v76ModeParameters;
	}
	V76ModeParameters & get_v76ModeParameters ( ) {
		return * m_v76ModeParameters;
	}
	const H2250ModeParameters & get_h2250ModeParameters ( ) const {
		return * m_h2250ModeParameters;
	}
	H2250ModeParameters & get_h2250ModeParameters ( ) {
		return * m_h2250ModeParameters;
	}
	const GenericCapability & get_genericModeParameters ( ) const {
		return * m_genericModeParameters;
	}
	GenericCapability & get_genericModeParameters ( ) {
		return * m_genericModeParameters;
	}
	const MultiplexedStreamModeParameters & get_multiplexedStreamModeParameters ( ) const {
		return * m_multiplexedStreamModeParameters;
	}
	MultiplexedStreamModeParameters & get_multiplexedStreamModeParameters ( ) {
		return * m_multiplexedStreamModeParameters;
	}
	const LogicalChannelNumber & get_logicalChannelNumber ( ) const {
		return * m_logicalChannelNumber;
	}
	LogicalChannelNumber & get_logicalChannelNumber ( ) {
		return * m_logicalChannelNumber;
	}
	ModeElement * clone ( ) const;
};

//
// MultiplePayloadStreamElementMode
//

// from 0 size 0 type 0 simple 0
class MultiplePayloadStreamElementMode : public Asn :: Sequence {
	public:
	explicit MultiplePayloadStreamElementMode ( Asn :: istream & is );
	MultiplePayloadStreamElementMode ( );
	ModeElementType m_type;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	MultiplePayloadStreamElementMode * clone ( ) const;
};

//
// DepFECMode
//

// from 0 size 0 type 0 simple 0
class DepFECMode_rfc2733Mode;

class DepFECMode : public Asn :: Choice {
	public:
	explicit DepFECMode ( Asn :: istream & is );
	DepFECMode ( );
	enum Choices {
		e_rfc2733Mode
	};

	operator DepFECMode_rfc2733Mode & ( );
	operator const DepFECMode_rfc2733Mode & ( ) const;

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	DepFECMode * clone ( ) const;
};

//
// FECMode
//

// from 0 size 0 type 0 simple 0
class FECMode : public Asn :: Sequence {
	public:
	explicit FECMode ( Asn :: istream & is );
	FECMode ( );
	enum OptionalFields {
		e_fecScheme,
		e_rfc2733Format
	};

	FECMode ( const FECMode & s );
	FECMode & operator= ( const FECMode & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	ModeElementType m_protectedElement;
	protected:
	Asn :: ObjectId * m_fecScheme;
	FECMode_rfc2733Format * m_rfc2733Format;
	public:
	void encode ( Asn :: ostream & os ) const;
	~FECMode ( );
	void printOn ( std :: ostream & os ) const;
	const Asn :: ObjectId & get_fecScheme ( ) const {
		return * m_fecScheme;
	}
	Asn :: ObjectId & get_fecScheme ( ) {
		return * m_fecScheme;
	}
	const FECMode_rfc2733Format & get_rfc2733Format ( ) const {
		return * m_rfc2733Format;
	}
	FECMode_rfc2733Format & get_rfc2733Format ( ) {
		return * m_rfc2733Format;
	}
	FECMode * clone ( ) const;
};

//
// AudioMode
//

// from 0 size 0 type 0 simple 0
class VBDMode;

class AudioMode : public Asn :: Choice {
	public:
	explicit AudioMode ( Asn :: istream & is );
	AudioMode ( );
	enum Choices {
		e_nonStandard,
		e_g711Alaw64k,
		e_g711Alaw56k,
		e_g711Ulaw64k,
		e_g711Ulaw56k,
		e_g722_64k,
		e_g722_56k,
		e_g722_48k,
		e_g728,
		e_g729,
		e_g729AnnexA,
		e_g7231,
		e_is11172AudioMode,
		e_is13818AudioMode,
		e_g729wAnnexB,
		e_g729AnnexAwAnnexB,
		e_g7231AnnexCMode,
		e_gsmFullRate,
		e_gsmHalfRate,
		e_gsmEnhancedFullRate,
		e_genericAudioMode,
		e_g729Extensions,
		e_vbd
	};

	operator NonStandardParameter & ( );
	operator const NonStandardParameter & ( ) const;
	operator Asn :: Null & ( );
	operator const Asn :: Null & ( ) const;
	operator AudioMode_g7231 & ( );
	operator const AudioMode_g7231 & ( ) const;
	operator IS11172AudioMode & ( );
	operator const IS11172AudioMode & ( ) const;
	operator IS13818AudioMode & ( );
	operator const IS13818AudioMode & ( ) const;
	operator AudioMode_g729wAnnexB & ( );
	operator const AudioMode_g729wAnnexB & ( ) const;
	operator AudioMode_g729AnnexAwAnnexB & ( );
	operator const AudioMode_g729AnnexAwAnnexB & ( ) const;
	operator G7231AnnexCMode & ( );
	operator const G7231AnnexCMode & ( ) const;
	operator GSMAudioCapability & ( );
	operator const GSMAudioCapability & ( ) const;
	operator GenericCapability & ( );
	operator const GenericCapability & ( ) const;
	operator G729Extensions & ( );
	operator const G729Extensions & ( ) const;
	operator VBDMode & ( );
	operator const VBDMode & ( ) const;

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	AudioMode * clone ( ) const;
};

//
// VBDMode
//

// from 0 size 0 type 0 simple 0
class VBDMode : public Asn :: Sequence {
	public:
	explicit VBDMode ( Asn :: istream & is );
	VBDMode ( );
	AudioMode m_type;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	VBDMode * clone ( ) const;
};

//
// FunctionNotUnderstood
//

// from 0 size 0 type 0 simple 0
class RequestMessage;

class FunctionNotUnderstood : public Asn :: Choice {
	public:
	explicit FunctionNotUnderstood ( Asn :: istream & is );
	FunctionNotUnderstood ( );
	enum Choices {
		e_request,
		e_response,
		e_command
	};

	operator RequestMessage & ( );
	operator const RequestMessage & ( ) const;
	operator ResponseMessage & ( );
	operator const ResponseMessage & ( ) const;
	operator CommandMessage & ( );
	operator const CommandMessage & ( ) const;

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	FunctionNotUnderstood * clone ( ) const;
};

//
// OpenLogicalChannel_forwardLogicalChannelParameters
//

// from 0 size 0 type 0 simple 0
class OpenLogicalChannel_forwardLogicalChannelParameters : public Asn :: Sequence {
	public:
	explicit OpenLogicalChannel_forwardLogicalChannelParameters ( Asn :: istream & is );
	OpenLogicalChannel_forwardLogicalChannelParameters ( );
	enum OptionalFields {
		e_portNumber,
		e_forwardLogicalChannelDependency,
		e_replacementFor
	};

	OpenLogicalChannel_forwardLogicalChannelParameters ( const OpenLogicalChannel_forwardLogicalChannelParameters & s );
	OpenLogicalChannel_forwardLogicalChannelParameters & operator= ( const OpenLogicalChannel_forwardLogicalChannelParameters & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	OpenLogicalChannel_forwardLogicalChannelParameters_portNumber * m_portNumber;
	public:
	DataType m_dataType;
	OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters m_multiplexParameters;
	protected:
	LogicalChannelNumber * m_forwardLogicalChannelDependency;
	LogicalChannelNumber * m_replacementFor;
	public:
	void encode ( Asn :: ostream & os ) const;
	~OpenLogicalChannel_forwardLogicalChannelParameters ( );
	void printOn ( std :: ostream & os ) const;
	const OpenLogicalChannel_forwardLogicalChannelParameters_portNumber & get_portNumber ( ) const {
		return * m_portNumber;
	}
	OpenLogicalChannel_forwardLogicalChannelParameters_portNumber & get_portNumber ( ) {
		return * m_portNumber;
	}
	const LogicalChannelNumber & get_forwardLogicalChannelDependency ( ) const {
		return * m_forwardLogicalChannelDependency;
	}
	LogicalChannelNumber & get_forwardLogicalChannelDependency ( ) {
		return * m_forwardLogicalChannelDependency;
	}
	const LogicalChannelNumber & get_replacementFor ( ) const {
		return * m_replacementFor;
	}
	LogicalChannelNumber & get_replacementFor ( ) {
		return * m_replacementFor;
	}
	OpenLogicalChannel_forwardLogicalChannelParameters * clone ( ) const;
};

//
// OpenLogicalChannel_reverseLogicalChannelParameters
//

// from 0 size 0 type 0 simple 0
class OpenLogicalChannel_reverseLogicalChannelParameters : public Asn :: Sequence {
	public:
	explicit OpenLogicalChannel_reverseLogicalChannelParameters ( Asn :: istream & is );
	OpenLogicalChannel_reverseLogicalChannelParameters ( );
	enum OptionalFields {
		e_multiplexParameters,
		e_reverseLogicalChannelDependency,
		e_replacementFor
	};

	OpenLogicalChannel_reverseLogicalChannelParameters ( const OpenLogicalChannel_reverseLogicalChannelParameters & s );
	OpenLogicalChannel_reverseLogicalChannelParameters & operator= ( const OpenLogicalChannel_reverseLogicalChannelParameters & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	DataType m_dataType;
	protected:
	OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters * m_multiplexParameters;
	LogicalChannelNumber * m_reverseLogicalChannelDependency;
	LogicalChannelNumber * m_replacementFor;
	public:
	void encode ( Asn :: ostream & os ) const;
	~OpenLogicalChannel_reverseLogicalChannelParameters ( );
	void printOn ( std :: ostream & os ) const;
	const OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters & get_multiplexParameters ( ) const {
		return * m_multiplexParameters;
	}
	OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters & get_multiplexParameters ( ) {
		return * m_multiplexParameters;
	}
	const LogicalChannelNumber & get_reverseLogicalChannelDependency ( ) const {
		return * m_reverseLogicalChannelDependency;
	}
	LogicalChannelNumber & get_reverseLogicalChannelDependency ( ) {
		return * m_reverseLogicalChannelDependency;
	}
	const LogicalChannelNumber & get_replacementFor ( ) const {
		return * m_replacementFor;
	}
	LogicalChannelNumber & get_replacementFor ( ) {
		return * m_replacementFor;
	}
	OpenLogicalChannel_reverseLogicalChannelParameters * clone ( ) const;
};

//
// H235Media_mediaType
//

// from 0 size 0 type 0 simple 0
class H235Media_mediaType : public Asn :: Choice {
	public:
	explicit H235Media_mediaType ( Asn :: istream & is );
	H235Media_mediaType ( );
	enum Choices {
		e_nonStandard,
		e_videoData,
		e_audioData,
		e_data,
		e_redundancyEncoding,
		e_multiplePayloadStream,
		e_depFec,
		e_fec
	};

	operator NonStandardParameter & ( );
	operator const NonStandardParameter & ( ) const;
	operator VideoCapability & ( );
	operator const VideoCapability & ( ) const;
	operator AudioCapability & ( );
	operator const AudioCapability & ( ) const;
	operator DataApplicationCapability & ( );
	operator const DataApplicationCapability & ( ) const;
	operator RedundancyEncoding & ( );
	operator const RedundancyEncoding & ( ) const;
	operator MultiplePayloadStream & ( );
	operator const MultiplePayloadStream & ( ) const;
	operator DepFECData & ( );
	operator const DepFECData & ( ) const;
	operator FECData & ( );
	operator const FECData & ( ) const;

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	H235Media_mediaType * clone ( ) const;
};

//
// H235Mode_mediaMode
//

// from 0 size 0 type 0 simple 0
class H235Mode_mediaMode : public Asn :: Choice {
	public:
	explicit H235Mode_mediaMode ( Asn :: istream & is );
	H235Mode_mediaMode ( );
	enum Choices {
		e_nonStandard,
		e_videoMode,
		e_audioMode,
		e_dataMode
	};

	operator NonStandardParameter & ( );
	operator const NonStandardParameter & ( ) const;
	operator VideoMode & ( );
	operator const VideoMode & ( ) const;
	operator AudioMode & ( );
	operator const AudioMode & ( ) const;
	operator DataMode & ( );
	operator const DataMode & ( ) const;

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	H235Mode_mediaMode * clone ( ) const;
};

//
// RedundancyEncodingDTModeElement_type
//

// from 0 size 0 type 0 simple 0
class RedundancyEncodingDTModeElement_type : public Asn :: Choice {
	public:
	explicit RedundancyEncodingDTModeElement_type ( Asn :: istream & is );
	RedundancyEncodingDTModeElement_type ( );
	enum Choices {
		e_nonStandard,
		e_videoMode,
		e_audioMode,
		e_dataMode,
		e_encryptionMode,
		e_h235Mode,
		e_fecMode
	};

	operator NonStandardParameter & ( );
	operator const NonStandardParameter & ( ) const;
	operator VideoMode & ( );
	operator const VideoMode & ( ) const;
	operator AudioMode & ( );
	operator const AudioMode & ( ) const;
	operator DataMode & ( );
	operator const DataMode & ( ) const;
	operator EncryptionMode & ( );
	operator const EncryptionMode & ( ) const;
	operator H235Mode & ( );
	operator const H235Mode & ( ) const;
	operator FECMode & ( );
	operator const FECMode & ( ) const;

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	RedundancyEncodingDTModeElement_type * clone ( ) const;
};

//
// RedundancyEncodingMode_secondaryEncoding
//

// from 0 size 0 type 0 simple 0
class RedundancyEncodingMode_secondaryEncoding : public Asn :: Choice {
	public:
	explicit RedundancyEncodingMode_secondaryEncoding ( Asn :: istream & is );
	RedundancyEncodingMode_secondaryEncoding ( );
	enum Choices {
		e_nonStandard,
		e_audioData
	};

	operator NonStandardParameter & ( );
	operator const NonStandardParameter & ( ) const;
	operator AudioMode & ( );
	operator const AudioMode & ( ) const;

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	RedundancyEncodingMode_secondaryEncoding * clone ( ) const;
};

//
// CommunicationModeTableEntry_dataType
//

// from 0 size 0 type 0 simple 0
class CommunicationModeTableEntry_dataType : public Asn :: Choice {
	public:
	explicit CommunicationModeTableEntry_dataType ( Asn :: istream & is );
	CommunicationModeTableEntry_dataType ( );
	enum Choices {
		e_videoData,
		e_audioData,
		e_data
	};

	operator VideoCapability & ( );
	operator const VideoCapability & ( ) const;
	operator AudioCapability & ( );
	operator const AudioCapability & ( ) const;
	operator DataApplicationCapability & ( );
	operator const DataApplicationCapability & ( ) const;

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	CommunicationModeTableEntry_dataType * clone ( ) const;
};

//
// DepFECMode_rfc2733Mode_mode
//

// from 0 size 0 type 0 simple 0
class DepFECMode_rfc2733Mode_mode_separateStream;

class DepFECMode_rfc2733Mode_mode : public Asn :: Choice {
	public:
	explicit DepFECMode_rfc2733Mode_mode ( Asn :: istream & is );
	DepFECMode_rfc2733Mode_mode ( );
	enum Choices {
		e_redundancyEncoding,
		e_separateStream
	};

	operator Asn :: Null & ( );
	operator const Asn :: Null & ( ) const;
	operator DepFECMode_rfc2733Mode_mode_separateStream & ( );
	operator const DepFECMode_rfc2733Mode_mode_separateStream & ( ) const;

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	DepFECMode_rfc2733Mode_mode * clone ( ) const;
};

//
// DepFECMode_rfc2733Mode_mode_separateStream
//

// from 0 size 0 type 0 simple 0
class DepFECMode_rfc2733Mode_mode_separateStream_samePort;

class DepFECMode_rfc2733Mode_mode_separateStream : public Asn :: Choice {
	public:
	explicit DepFECMode_rfc2733Mode_mode_separateStream ( Asn :: istream & is );
	DepFECMode_rfc2733Mode_mode_separateStream ( );
	enum Choices {
		e_differentPort,
		e_samePort
	};

	operator DepFECMode_rfc2733Mode_mode_separateStream_differentPort & ( );
	operator const DepFECMode_rfc2733Mode_mode_separateStream_differentPort & ( ) const;
	operator DepFECMode_rfc2733Mode_mode_separateStream_samePort & ( );
	operator const DepFECMode_rfc2733Mode_mode_separateStream_samePort & ( ) const;

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	DepFECMode_rfc2733Mode_mode_separateStream * clone ( ) const;
};

//
// DepFECMode_rfc2733Mode_mode_separateStream_samePort
//

// from 0 size 0 type 0 simple 0
class DepFECMode_rfc2733Mode_mode_separateStream_samePort : public Asn :: Sequence {
	public:
	explicit DepFECMode_rfc2733Mode_mode_separateStream_samePort ( Asn :: istream & is );
	DepFECMode_rfc2733Mode_mode_separateStream_samePort ( );
	ModeElementType m_protectedType;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	DepFECMode_rfc2733Mode_mode_separateStream_samePort * clone ( ) const;
};

//
// MultimediaSystemControlMessage
//

// from 0 size 0 type 0 simple 0
class IndicationMessage;

class MultimediaSystemControlMessage : public Asn :: Choice {
	public:
	explicit MultimediaSystemControlMessage ( Asn :: istream & is );
	MultimediaSystemControlMessage ( );
	enum Choices {
		e_request,
		e_response,
		e_command,
		e_indication
	};

	operator RequestMessage & ( );
	operator const RequestMessage & ( ) const;
	operator ResponseMessage & ( );
	operator const ResponseMessage & ( ) const;
	operator CommandMessage & ( );
	operator const CommandMessage & ( ) const;
	operator IndicationMessage & ( );
	operator const IndicationMessage & ( ) const;

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	MultimediaSystemControlMessage * clone ( ) const;
};

//
// RequestMessage
//

// from 0 size 0 type 0 simple 0
class OpenLogicalChannel;

class RequestMessage : public Asn :: Choice {
	public:
	explicit RequestMessage ( Asn :: istream & is );
	RequestMessage ( );
	enum Choices {
		e_nonStandard,
		e_masterSlaveDetermination,
		e_terminalCapabilitySet,
		e_openLogicalChannel,
		e_closeLogicalChannel,
		e_requestChannelClose,
		e_multiplexEntrySend,
		e_requestMultiplexEntry,
		e_requestMode,
		e_roundTripDelayRequest,
		e_maintenanceLoopRequest,
		e_communicationModeRequest,
		e_conferenceRequest,
		e_multilinkRequest,
		e_logicalChannelRateRequest,
		e_genericRequest
	};

	operator NonStandardMessage & ( );
	operator const NonStandardMessage & ( ) const;
	operator MasterSlaveDetermination & ( );
	operator const MasterSlaveDetermination & ( ) const;
	operator TerminalCapabilitySet & ( );
	operator const TerminalCapabilitySet & ( ) const;
	operator OpenLogicalChannel & ( );
	operator const OpenLogicalChannel & ( ) const;
	operator CloseLogicalChannel & ( );
	operator const CloseLogicalChannel & ( ) const;
	operator RequestChannelClose & ( );
	operator const RequestChannelClose & ( ) const;
	operator MultiplexEntrySend & ( );
	operator const MultiplexEntrySend & ( ) const;
	operator RequestMultiplexEntry & ( );
	operator const RequestMultiplexEntry & ( ) const;
	operator RequestMode & ( );
	operator const RequestMode & ( ) const;
	operator RoundTripDelayRequest & ( );
	operator const RoundTripDelayRequest & ( ) const;
	operator MaintenanceLoopRequest & ( );
	operator const MaintenanceLoopRequest & ( ) const;
	operator CommunicationModeRequest & ( );
	operator const CommunicationModeRequest & ( ) const;
	operator ConferenceRequest & ( );
	operator const ConferenceRequest & ( ) const;
	operator MultilinkRequest & ( );
	operator const MultilinkRequest & ( ) const;
	operator LogicalChannelRateRequest & ( );
	operator const LogicalChannelRateRequest & ( ) const;
	operator GenericMessage & ( );
	operator const GenericMessage & ( ) const;

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	RequestMessage * clone ( ) const;
};

//
// IndicationMessage
//

// from 0 size 0 type 0 simple 0
class IndicationMessage : public Asn :: Choice {
	public:
	explicit IndicationMessage ( Asn :: istream & is );
	IndicationMessage ( );
	enum Choices {
		e_nonStandard,
		e_functionNotUnderstood,
		e_masterSlaveDeterminationRelease,
		e_terminalCapabilitySetRelease,
		e_openLogicalChannelConfirm,
		e_requestChannelCloseRelease,
		e_multiplexEntrySendRelease,
		e_requestMultiplexEntryRelease,
		e_requestModeRelease,
		e_miscellaneousIndication,
		e_jitterIndication,
		e_h223SkewIndication,
		e_newATMVCIndication,
		e_userInput,
		e_h2250MaximumSkewIndication,
		e_mcLocationIndication,
		e_conferenceIndication,
		e_vendorIdentification,
		e_functionNotSupported,
		e_multilinkIndication,
		e_logicalChannelRateRelease,
		e_flowControlIndication,
		e_mobileMultilinkReconfigurationIndication,
		e_genericIndication
	};

	operator NonStandardMessage & ( );
	operator const NonStandardMessage & ( ) const;
	operator FunctionNotUnderstood & ( );
	operator const FunctionNotUnderstood & ( ) const;
	operator MasterSlaveDeterminationRelease & ( );
	operator const MasterSlaveDeterminationRelease & ( ) const;
	operator TerminalCapabilitySetRelease & ( );
	operator const TerminalCapabilitySetRelease & ( ) const;
	operator OpenLogicalChannelConfirm & ( );
	operator const OpenLogicalChannelConfirm & ( ) const;
	operator RequestChannelCloseRelease & ( );
	operator const RequestChannelCloseRelease & ( ) const;
	operator MultiplexEntrySendRelease & ( );
	operator const MultiplexEntrySendRelease & ( ) const;
	operator RequestMultiplexEntryRelease & ( );
	operator const RequestMultiplexEntryRelease & ( ) const;
	operator RequestModeRelease & ( );
	operator const RequestModeRelease & ( ) const;
	operator MiscellaneousIndication & ( );
	operator const MiscellaneousIndication & ( ) const;
	operator JitterIndication & ( );
	operator const JitterIndication & ( ) const;
	operator H223SkewIndication & ( );
	operator const H223SkewIndication & ( ) const;
	operator NewATMVCIndication & ( );
	operator const NewATMVCIndication & ( ) const;
	operator UserInputIndication & ( );
	operator const UserInputIndication & ( ) const;
	operator H2250MaximumSkewIndication & ( );
	operator const H2250MaximumSkewIndication & ( ) const;
	operator MCLocationIndication & ( );
	operator const MCLocationIndication & ( ) const;
	operator ConferenceIndication & ( );
	operator const ConferenceIndication & ( ) const;
	operator VendorIdentification & ( );
	operator const VendorIdentification & ( ) const;
	operator FunctionNotSupported & ( );
	operator const FunctionNotSupported & ( ) const;
	operator MultilinkIndication & ( );
	operator const MultilinkIndication & ( ) const;
	operator LogicalChannelRateRelease & ( );
	operator const LogicalChannelRateRelease & ( ) const;
	operator FlowControlIndication & ( );
	operator const FlowControlIndication & ( ) const;
	operator MobileMultilinkReconfigurationIndication & ( );
	operator const MobileMultilinkReconfigurationIndication & ( ) const;
	operator GenericMessage & ( );
	operator const GenericMessage & ( ) const;

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	IndicationMessage * clone ( ) const;
};

//
// Capability
//

// from 0 size 0 type 0 simple 0
class Capability : public Asn :: Choice {
	public:
	explicit Capability ( Asn :: istream & is );
	Capability ( );
	enum Choices {
		e_nonStandard,
		e_receiveVideoCapability,
		e_transmitVideoCapability,
		e_receiveAndTransmitVideoCapability,
		e_receiveAudioCapability,
		e_transmitAudioCapability,
		e_receiveAndTransmitAudioCapability,
		e_receiveDataApplicationCapability,
		e_transmitDataApplicationCapability,
		e_receiveAndTransmitDataApplicationCapability,
		e_h233EncryptionTransmitCapability,
		e_h233EncryptionReceiveCapability,
		e_conferenceCapability,
		e_h235SecurityCapability,
		e_maxPendingReplacementFor,
		e_receiveUserInputCapability,
		e_transmitUserInputCapability,
		e_receiveAndTransmitUserInputCapability,
		e_genericControlCapability,
		e_receiveMultiplexedStreamCapability,
		e_transmitMultiplexedStreamCapability,
		e_receiveAndTransmitMultiplexedStreamCapability,
		e_receiveRTPAudioTelephonyEventCapability,
		e_receiveRTPAudioToneCapability,
		e_depFecCapability,
		e_multiplePayloadStreamCapability,
		e_fecCapability,
		e_redundancyEncodingCap,
		e_oneOfCapabilities
	};

	operator NonStandardParameter & ( );
	operator const NonStandardParameter & ( ) const;
	operator VideoCapability & ( );
	operator const VideoCapability & ( ) const;
	operator AudioCapability & ( );
	operator const AudioCapability & ( ) const;
	operator DataApplicationCapability & ( );
	operator const DataApplicationCapability & ( ) const;
	operator Capability_h233EncryptionReceiveCapability & ( );
	operator const Capability_h233EncryptionReceiveCapability & ( ) const;
	operator ConferenceCapability & ( );
	operator const ConferenceCapability & ( ) const;
	operator H235SecurityCapability & ( );
	operator const H235SecurityCapability & ( ) const;
	operator Capability_maxPendingReplacementFor & ( );
	operator const Capability_maxPendingReplacementFor & ( ) const;
	operator UserInputCapability & ( );
	operator const UserInputCapability & ( ) const;
	operator GenericCapability & ( );
	operator const GenericCapability & ( ) const;
	operator MultiplexedStreamCapability & ( );
	operator const MultiplexedStreamCapability & ( ) const;
	operator AudioTelephonyEventCapability & ( );
	operator const AudioTelephonyEventCapability & ( ) const;
	operator AudioToneCapability & ( );
	operator const AudioToneCapability & ( ) const;
	operator DepFECCapability & ( );
	operator const DepFECCapability & ( ) const;
	operator MultiplePayloadStreamCapability & ( );
	operator const MultiplePayloadStreamCapability & ( ) const;
	operator FECCapability & ( );
	operator const FECCapability & ( ) const;
	operator RedundancyEncodingCapability & ( );
	operator const RedundancyEncodingCapability & ( ) const;
	operator AlternativeCapabilitySet & ( );
	operator const AlternativeCapabilitySet & ( ) const;

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	Capability * clone ( ) const;
};

//
// AudioCapability
//

// from 0 size 0 type 0 simple 0
class VBDCapability;

class AudioCapability : public Asn :: Choice {
	public:
	explicit AudioCapability ( Asn :: istream & is );
	AudioCapability ( );
	enum Choices {
		e_nonStandard,
		e_g711Alaw64k,
		e_g711Alaw56k,
		e_g711Ulaw64k,
		e_g711Ulaw56k,
		e_g722_64k,
		e_g722_56k,
		e_g722_48k,
		e_g7231,
		e_g728,
		e_g729,
		e_g729AnnexA,
		e_is11172AudioCapability,
		e_is13818AudioCapability,
		e_g729wAnnexB,
		e_g729AnnexAwAnnexB,
		e_g7231AnnexCCapability,
		e_gsmFullRate,
		e_gsmHalfRate,
		e_gsmEnhancedFullRate,
		e_genericAudioCapability,
		e_g729Extensions,
		e_vbd,
		e_audioTelephonyEvent,
		e_audioTone
	};

	operator NonStandardParameter & ( );
	operator const NonStandardParameter & ( ) const;
	operator AudioCapability_g711Alaw64k & ( );
	operator const AudioCapability_g711Alaw64k & ( ) const;
	operator AudioCapability_g711Alaw56k & ( );
	operator const AudioCapability_g711Alaw56k & ( ) const;
	operator AudioCapability_g711Ulaw64k & ( );
	operator const AudioCapability_g711Ulaw64k & ( ) const;
	operator AudioCapability_g711Ulaw56k & ( );
	operator const AudioCapability_g711Ulaw56k & ( ) const;
	operator AudioCapability_g722_64k & ( );
	operator const AudioCapability_g722_64k & ( ) const;
	operator AudioCapability_g722_56k & ( );
	operator const AudioCapability_g722_56k & ( ) const;
	operator AudioCapability_g722_48k & ( );
	operator const AudioCapability_g722_48k & ( ) const;
	operator AudioCapability_g7231 & ( );
	operator const AudioCapability_g7231 & ( ) const;
	operator AudioCapability_g728 & ( );
	operator const AudioCapability_g728 & ( ) const;
	operator AudioCapability_g729 & ( );
	operator const AudioCapability_g729 & ( ) const;
	operator AudioCapability_g729AnnexA & ( );
	operator const AudioCapability_g729AnnexA & ( ) const;
	operator IS11172AudioCapability & ( );
	operator const IS11172AudioCapability & ( ) const;
	operator IS13818AudioCapability & ( );
	operator const IS13818AudioCapability & ( ) const;
	operator AudioCapability_g729wAnnexB & ( );
	operator const AudioCapability_g729wAnnexB & ( ) const;
	operator AudioCapability_g729AnnexAwAnnexB & ( );
	operator const AudioCapability_g729AnnexAwAnnexB & ( ) const;
	operator G7231AnnexCCapability & ( );
	operator const G7231AnnexCCapability & ( ) const;
	operator GSMAudioCapability & ( );
	operator const GSMAudioCapability & ( ) const;
	operator GenericCapability & ( );
	operator const GenericCapability & ( ) const;
	operator G729Extensions & ( );
	operator const G729Extensions & ( ) const;
	operator VBDCapability & ( );
	operator const VBDCapability & ( ) const;
	operator NoPTAudioTelephonyEventCapability & ( );
	operator const NoPTAudioTelephonyEventCapability & ( ) const;
	operator NoPTAudioToneCapability & ( );
	operator const NoPTAudioToneCapability & ( ) const;

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	AudioCapability * clone ( ) const;
};

//
// VBDCapability
//

// from 0 size 0 type 0 simple 0
class VBDCapability : public Asn :: Sequence {
	public:
	explicit VBDCapability ( Asn :: istream & is );
	VBDCapability ( );
	AudioCapability m_type;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	VBDCapability * clone ( ) const;
};

//
// OpenLogicalChannel
//

// from 0 size 0 type 0 simple 0
class OpenLogicalChannel : public Asn :: Sequence {
	public:
	explicit OpenLogicalChannel ( Asn :: istream & is );
	OpenLogicalChannel ( );
	enum OptionalFields {
		e_reverseLogicalChannelParameters,
		e_separateStack,
		e_encryptionSync,
		e_genericInformation
	};

	OpenLogicalChannel ( const OpenLogicalChannel & s );
	OpenLogicalChannel & operator= ( const OpenLogicalChannel & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	LogicalChannelNumber m_forwardLogicalChannelNumber;
	OpenLogicalChannel_forwardLogicalChannelParameters m_forwardLogicalChannelParameters;
	protected:
	OpenLogicalChannel_reverseLogicalChannelParameters * m_reverseLogicalChannelParameters;
	NetworkAccessParameters * m_separateStack;
	EncryptionSync * m_encryptionSync;
	ArrayOf_GenericInformation * m_genericInformation;
	public:
	void encode ( Asn :: ostream & os ) const;
	~OpenLogicalChannel ( );
	void printOn ( std :: ostream & os ) const;
	const OpenLogicalChannel_reverseLogicalChannelParameters & get_reverseLogicalChannelParameters ( ) const {
		return * m_reverseLogicalChannelParameters;
	}
	OpenLogicalChannel_reverseLogicalChannelParameters & get_reverseLogicalChannelParameters ( ) {
		return * m_reverseLogicalChannelParameters;
	}
	const NetworkAccessParameters & get_separateStack ( ) const {
		return * m_separateStack;
	}
	NetworkAccessParameters & get_separateStack ( ) {
		return * m_separateStack;
	}
	const EncryptionSync & get_encryptionSync ( ) const {
		return * m_encryptionSync;
	}
	EncryptionSync & get_encryptionSync ( ) {
		return * m_encryptionSync;
	}
	const ArrayOf_GenericInformation & get_genericInformation ( ) const {
		return * m_genericInformation;
	}
	ArrayOf_GenericInformation & get_genericInformation ( ) {
		return * m_genericInformation;
	}
	OpenLogicalChannel * clone ( ) const;
};

//
// H235Media
//

// from 0 size 0 type 0 simple 0
class H235Media : public Asn :: Sequence {
	public:
	explicit H235Media ( Asn :: istream & is );
	H235Media ( );
	EncryptionAuthenticationAndIntegrity m_encryptionAuthenticationAndIntegrity;
	H235Media_mediaType m_mediaType;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	H235Media * clone ( ) const;
};

//
// H235Mode
//

// from 0 size 0 type 0 simple 0
class H235Mode : public Asn :: Sequence {
	public:
	explicit H235Mode ( Asn :: istream & is );
	H235Mode ( );
	EncryptionAuthenticationAndIntegrity m_encryptionAuthenticationAndIntegrity;
	H235Mode_mediaMode m_mediaMode;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	H235Mode * clone ( ) const;
};

//
// RedundancyEncodingDTModeElement
//

// from 0 size 0 type 0 simple 0
class RedundancyEncodingDTModeElement : public Asn :: Sequence {
	public:
	explicit RedundancyEncodingDTModeElement ( Asn :: istream & is );
	RedundancyEncodingDTModeElement ( );
	RedundancyEncodingDTModeElement_type m_type;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	RedundancyEncodingDTModeElement * clone ( ) const;
};

//
// CommunicationModeTableEntry
//

// from 0 size 0 type 0 simple 0
class CommunicationModeTableEntry : public Asn :: Sequence {
	public:
	explicit CommunicationModeTableEntry ( Asn :: istream & is );
	CommunicationModeTableEntry ( );
	enum OptionalFields {
		e_nonStandard,
		e_associatedSessionID,
		e_terminalLabel,
		e_mediaChannel,
		e_mediaGuaranteedDelivery,
		e_mediaControlChannel,
		e_mediaControlGuaranteedDelivery,
		e_redundancyEncoding,
		e_sessionDependency,
		e_destination
	};

	CommunicationModeTableEntry ( const CommunicationModeTableEntry & s );
	CommunicationModeTableEntry & operator= ( const CommunicationModeTableEntry & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	ArrayOf_NonStandardParameter * m_nonStandard;
	public:
	CommunicationModeTableEntry_sessionID m_sessionID;
	protected:
	CommunicationModeTableEntry_associatedSessionID * m_associatedSessionID;
	TerminalLabel * m_terminalLabel;
	public:
	CommunicationModeTableEntry_sessionDescription m_sessionDescription;
	CommunicationModeTableEntry_dataType m_dataType;
	protected:
	TransportAddress * m_mediaChannel;
	Asn :: Boolean * m_mediaGuaranteedDelivery;
	TransportAddress * m_mediaControlChannel;
	Asn :: Boolean * m_mediaControlGuaranteedDelivery;
	RedundancyEncoding * m_redundancyEncoding;
	CommunicationModeTableEntry_sessionDependency * m_sessionDependency;
	TerminalLabel * m_destination;
	public:
	void encode ( Asn :: ostream & os ) const;
	~CommunicationModeTableEntry ( );
	void printOn ( std :: ostream & os ) const;
	const ArrayOf_NonStandardParameter & get_nonStandard ( ) const {
		return * m_nonStandard;
	}
	ArrayOf_NonStandardParameter & get_nonStandard ( ) {
		return * m_nonStandard;
	}
	const CommunicationModeTableEntry_associatedSessionID & get_associatedSessionID ( ) const {
		return * m_associatedSessionID;
	}
	CommunicationModeTableEntry_associatedSessionID & get_associatedSessionID ( ) {
		return * m_associatedSessionID;
	}
	const TerminalLabel & get_terminalLabel ( ) const {
		return * m_terminalLabel;
	}
	TerminalLabel & get_terminalLabel ( ) {
		return * m_terminalLabel;
	}
	const TransportAddress & get_mediaChannel ( ) const {
		return * m_mediaChannel;
	}
	TransportAddress & get_mediaChannel ( ) {
		return * m_mediaChannel;
	}
	const Asn :: Boolean & get_mediaGuaranteedDelivery ( ) const {
		return * m_mediaGuaranteedDelivery;
	}
	Asn :: Boolean & get_mediaGuaranteedDelivery ( ) {
		return * m_mediaGuaranteedDelivery;
	}
	const TransportAddress & get_mediaControlChannel ( ) const {
		return * m_mediaControlChannel;
	}
	TransportAddress & get_mediaControlChannel ( ) {
		return * m_mediaControlChannel;
	}
	const Asn :: Boolean & get_mediaControlGuaranteedDelivery ( ) const {
		return * m_mediaControlGuaranteedDelivery;
	}
	Asn :: Boolean & get_mediaControlGuaranteedDelivery ( ) {
		return * m_mediaControlGuaranteedDelivery;
	}
	const RedundancyEncoding & get_redundancyEncoding ( ) const {
		return * m_redundancyEncoding;
	}
	RedundancyEncoding & get_redundancyEncoding ( ) {
		return * m_redundancyEncoding;
	}
	const CommunicationModeTableEntry_sessionDependency & get_sessionDependency ( ) const {
		return * m_sessionDependency;
	}
	CommunicationModeTableEntry_sessionDependency & get_sessionDependency ( ) {
		return * m_sessionDependency;
	}
	const TerminalLabel & get_destination ( ) const {
		return * m_destination;
	}
	TerminalLabel & get_destination ( ) {
		return * m_destination;
	}
	CommunicationModeTableEntry * clone ( ) const;
};

//
// DepFECMode_rfc2733Mode
//

// from 0 size 0 type 0 simple 0
class DepFECMode_rfc2733Mode : public Asn :: Sequence {
	public:
	explicit DepFECMode_rfc2733Mode ( Asn :: istream & is );
	DepFECMode_rfc2733Mode ( );
	DepFECMode_rfc2733Mode_mode m_mode;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	DepFECMode_rfc2733Mode * clone ( ) const;
};

//
// RedundancyEncodingDTMode
//

// from 0 size 0 type 0 simple 0
class RedundancyEncodingDTMode : public Asn :: Sequence {
	public:
	explicit RedundancyEncodingDTMode ( Asn :: istream & is );
	RedundancyEncodingDTMode ( );
	RedundancyEncodingMethod m_redundancyEncodingMethod;
	RedundancyEncodingDTModeElement m_primary;
	ArrayOf_RedundancyEncodingDTModeElement m_secondary;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	RedundancyEncodingDTMode * clone ( ) const;
};

};

#endif // __H245_HPP


// End of h245.hpp
