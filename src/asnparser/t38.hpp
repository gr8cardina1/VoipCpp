//
// t38.hpp
//
// Code automatically generated by asnparse.
//

#ifndef __T38_HPP
#define __T38_HPP

#ifdef __GNUC__
#pragma interface
#endif

namespace T38 {

//
// Data-Field
//

// from 0 size 0 type 0 simple 0
class Data_Field_subtype;

class Data_Field : public Asn :: Array {
	public:
	explicit Data_Field ( Asn :: istream & is );
	Data_Field ( );
	explicit Data_Field ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const Data_Field_subtype & o );
	const Data_Field_subtype & operator[] ( std :: size_t i ) const;
	Data_Field_subtype & operator[] ( std :: size_t i );
	Data_Field * clone ( ) const;
};

//
// PreCorrigendum-Data-Field
//

// from 0 size 0 type 0 simple 0
class PreCorrigendum_Data_Field_subtype;

class PreCorrigendum_Data_Field : public Asn :: Array {
	public:
	explicit PreCorrigendum_Data_Field ( Asn :: istream & is );
	PreCorrigendum_Data_Field ( );
	explicit PreCorrigendum_Data_Field ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const PreCorrigendum_Data_Field_subtype & o );
	const PreCorrigendum_Data_Field_subtype & operator[] ( std :: size_t i ) const;
	PreCorrigendum_Data_Field_subtype & operator[] ( std :: size_t i );
	PreCorrigendum_Data_Field * clone ( ) const;
};

//
// Type-of-msg_t30-indicator
//

// from 0 size 0 type 0 simple 0
class Type_of_msg_t30_indicator : public Asn :: Enumeration {
	public:
	explicit Type_of_msg_t30_indicator ( Asn :: istream & is );
	Type_of_msg_t30_indicator ( );
	enum Enumerations {
		e_no_signal,
		e_cng,
		e_ced,
		e_v21_preamble,
		e_v27_2400_training,
		e_v27_4800_training,
		e_v29_7200_training,
		e_v29_9600_training,
		e_v17_7200_short_training,
		e_v17_7200_long_training,
		e_v17_9600_short_training,
		e_v17_9600_long_training,
		e_v17_12000_short_training,
		e_v17_12000_long_training,
		e_v17_14400_short_training,
		e_v17_14400_long_training
	};

	protected:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	Type_of_msg_t30_indicator & operator= ( unsigned v ) {
		Asn :: Enumeration :: operator= ( v );
		return * this;
	}
	Type_of_msg_t30_indicator * clone ( ) const;
};

//
// Type-of-msg_data
//

// from 0 size 0 type 0 simple 0
class Type_of_msg_data : public Asn :: Enumeration {
	public:
	explicit Type_of_msg_data ( Asn :: istream & is );
	Type_of_msg_data ( );
	enum Enumerations {
		e_v21,
		e_v27_2400,
		e_v27_4800,
		e_v29_7200,
		e_v29_9600,
		e_v17_7200,
		e_v17_9600,
		e_v17_12000,
		e_v17_14400
	};

	protected:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	Type_of_msg_data & operator= ( unsigned v ) {
		Asn :: Enumeration :: operator= ( v );
		return * this;
	}
	Type_of_msg_data * clone ( ) const;
};

//
// UDPTLPacket_seq-number
//

// from 0 size 0 type 0 simple 1
class UDPTLPacket_seq_number : public Asn :: Integer {
	public:
	explicit UDPTLPacket_seq_number ( Asn :: istream & is );
	UDPTLPacket_seq_number ( unsigned v = 0 );
	UDPTLPacket_seq_number & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	UDPTLPacket_seq_number & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	UDPTLPacket_seq_number * clone ( ) const;
};

//
// UDPTLPacket_primary-ifp-packet
//

// from 0 size 0 type 1 simple 0
class UDPTLPacket_primary_ifp_packet : public Asn :: OctetString {
	public:
	explicit UDPTLPacket_primary_ifp_packet ( Asn :: istream & is );
	UDPTLPacket_primary_ifp_packet ( );
	UDPTLPacket_primary_ifp_packet * clone ( ) const;
};

//
// Data-Field_subtype_field-type
//

// from 0 size 0 type 0 simple 0
class Data_Field_subtype_field_type : public Asn :: Enumeration {
	public:
	explicit Data_Field_subtype_field_type ( Asn :: istream & is );
	Data_Field_subtype_field_type ( );
	enum Enumerations {
		e_hdlc_data,
		e_hdlc_sig_end,
		e_hdlc_fcs_OK,
		e_hdlc_fcs_BAD,
		e_hdlc_fcs_OK_sig_end,
		e_hdlc_fcs_BAD_sig_end,
		e_t4_non_ecm_data,
		e_t4_non_ecm_sig_end
	};

	protected:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	Data_Field_subtype_field_type & operator= ( unsigned v ) {
		Asn :: Enumeration :: operator= ( v );
		return * this;
	}
	Data_Field_subtype_field_type * clone ( ) const;
};

//
// Data-Field_subtype_field-data
//

// from 0 size 1 type 0 simple 0
class Data_Field_subtype_field_data : public Asn :: OctetString {
	public:
	explicit Data_Field_subtype_field_data ( Asn :: istream & is );
	Data_Field_subtype_field_data ( const Asn :: string & v = Asn :: string ( ) );
	Data_Field_subtype_field_data & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	Data_Field_subtype_field_data * clone ( ) const;
};

//
// PreCorrigendum-Data-Field_subtype_field-type
//

// from 0 size 0 type 0 simple 0
class PreCorrigendum_Data_Field_subtype_field_type : public Asn :: Enumeration {
	public:
	explicit PreCorrigendum_Data_Field_subtype_field_type ( Asn :: istream & is );
	PreCorrigendum_Data_Field_subtype_field_type ( );
	enum Enumerations {
		e_hdlc_data,
		e_hdlc_sig_end,
		e_hdlc_fcs_OK,
		e_hdlc_fcs_BAD,
		e_hdlc_fcs_OK_sig_end,
		e_hdlc_fcs_BAD_sig_end,
		e_t4_non_ecm_data,
		e_t4_non_ecm_sig_end
	};

	protected:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	PreCorrigendum_Data_Field_subtype_field_type & operator= ( unsigned v ) {
		Asn :: Enumeration :: operator= ( v );
		return * this;
	}
	PreCorrigendum_Data_Field_subtype_field_type * clone ( ) const;
};

//
// PreCorrigendum-Data-Field_subtype_field-data
//

// from 0 size 1 type 0 simple 0
class PreCorrigendum_Data_Field_subtype_field_data : public Asn :: OctetString {
	public:
	explicit PreCorrigendum_Data_Field_subtype_field_data ( Asn :: istream & is );
	PreCorrigendum_Data_Field_subtype_field_data ( const Asn :: string & v = Asn :: string ( ) );
	PreCorrigendum_Data_Field_subtype_field_data & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	PreCorrigendum_Data_Field_subtype_field_data * clone ( ) const;
};

//
// UDPTLPacket_error-recovery_secondary-ifp-packets
//

// from 0 size 0 type 0 simple 0
class UDPTLPacket_error_recovery_secondary_ifp_packets_subtype;

class UDPTLPacket_error_recovery_secondary_ifp_packets : public Asn :: Array {
	public:
	explicit UDPTLPacket_error_recovery_secondary_ifp_packets ( Asn :: istream & is );
	UDPTLPacket_error_recovery_secondary_ifp_packets ( );
	explicit UDPTLPacket_error_recovery_secondary_ifp_packets ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const UDPTLPacket_error_recovery_secondary_ifp_packets_subtype & o );
	const UDPTLPacket_error_recovery_secondary_ifp_packets_subtype & operator[] ( std :: size_t i ) const;
	UDPTLPacket_error_recovery_secondary_ifp_packets_subtype & operator[] ( std :: size_t i );
	UDPTLPacket_error_recovery_secondary_ifp_packets * clone ( ) const;
};

//
// UDPTLPacket_error-recovery_secondary-ifp-packets_subtype
//

// from 0 size 0 type 1 simple 0
class UDPTLPacket_error_recovery_secondary_ifp_packets_subtype : public Asn :: OctetString {
	public:
	explicit UDPTLPacket_error_recovery_secondary_ifp_packets_subtype ( Asn :: istream & is );
	UDPTLPacket_error_recovery_secondary_ifp_packets_subtype ( );
	UDPTLPacket_error_recovery_secondary_ifp_packets_subtype * clone ( ) const;
};

//
// ArrayOf_Asn_OctetString
//

// from 0 size 0 type 0 simple 0
class ArrayOf_Asn_OctetString : public Asn :: Array {
	public:
	explicit ArrayOf_Asn_OctetString ( Asn :: istream & is );
	ArrayOf_Asn_OctetString ( );
	explicit ArrayOf_Asn_OctetString ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const Asn :: OctetString & o );
	const Asn :: OctetString & operator[] ( std :: size_t i ) const;
	Asn :: OctetString & operator[] ( std :: size_t i );
	ArrayOf_Asn_OctetString * clone ( ) const;
};

//
// Type-of-msg
//

// from 0 size 0 type 0 simple 0
class Type_of_msg : public Asn :: Choice {
	public:
	explicit Type_of_msg ( Asn :: istream & is );
	Type_of_msg ( );
	enum Choices {
		e_t30_indicator,
		e_data
	};

	operator Type_of_msg_t30_indicator & ( ) { return dynamic_cast < Type_of_msg_t30_indicator & > ( * choice ); }
	operator const Type_of_msg_t30_indicator & ( ) const { return dynamic_cast < const Type_of_msg_t30_indicator & > ( * choice ); }
	operator Type_of_msg_data & ( ) { return dynamic_cast < Type_of_msg_data & > ( * choice ); }
	operator const Type_of_msg_data & ( ) const { return dynamic_cast < const Type_of_msg_data & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	Type_of_msg * clone ( ) const;
};

//
// Data-Field_subtype
//

// from 0 size 0 type 0 simple 0
class Data_Field_subtype : public Asn :: Sequence {
	public:
	explicit Data_Field_subtype ( Asn :: istream & is );
	Data_Field_subtype ( );
	enum OptionalFields {
		e_field_data
	};

	Data_Field_subtype ( const Data_Field_subtype & s );
	Data_Field_subtype & operator= ( const Data_Field_subtype & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	Data_Field_subtype_field_type m_field_type;
	protected:
	Data_Field_subtype_field_data * m_field_data;
	public:
	void encode ( Asn :: ostream & os ) const;
	~Data_Field_subtype ( );
	void printOn ( std :: ostream & os ) const;
	const Data_Field_subtype_field_data & get_field_data ( ) const {
		return * m_field_data;
	}
	Data_Field_subtype_field_data & get_field_data ( ) {
		return * m_field_data;
	}
	Data_Field_subtype * clone ( ) const;
};

//
// PreCorrigendum-Data-Field_subtype
//

// from 0 size 0 type 0 simple 0
class PreCorrigendum_Data_Field_subtype : public Asn :: Sequence {
	public:
	explicit PreCorrigendum_Data_Field_subtype ( Asn :: istream & is );
	PreCorrigendum_Data_Field_subtype ( );
	enum OptionalFields {
		e_field_data
	};

	PreCorrigendum_Data_Field_subtype ( const PreCorrigendum_Data_Field_subtype & s );
	PreCorrigendum_Data_Field_subtype & operator= ( const PreCorrigendum_Data_Field_subtype & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	PreCorrigendum_Data_Field_subtype_field_type m_field_type;
	protected:
	PreCorrigendum_Data_Field_subtype_field_data * m_field_data;
	public:
	void encode ( Asn :: ostream & os ) const;
	~PreCorrigendum_Data_Field_subtype ( );
	void printOn ( std :: ostream & os ) const;
	const PreCorrigendum_Data_Field_subtype_field_data & get_field_data ( ) const {
		return * m_field_data;
	}
	PreCorrigendum_Data_Field_subtype_field_data & get_field_data ( ) {
		return * m_field_data;
	}
	PreCorrigendum_Data_Field_subtype * clone ( ) const;
};

//
// UDPTLPacket_error-recovery_fec-info
//

// from 0 size 0 type 0 simple 0
class UDPTLPacket_error_recovery_fec_info : public Asn :: Sequence {
	public:
	explicit UDPTLPacket_error_recovery_fec_info ( Asn :: istream & is );
	UDPTLPacket_error_recovery_fec_info ( );
	Asn :: Integer m_fec_npackets;
	ArrayOf_Asn_OctetString m_fec_data;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	UDPTLPacket_error_recovery_fec_info * clone ( ) const;
};

//
// IFPPacket
//

// from 0 size 0 type 0 simple 0
class IFPPacket : public Asn :: Sequence {
	public:
	explicit IFPPacket ( Asn :: istream & is );
	IFPPacket ( );
	enum OptionalFields {
		e_data_field
	};

	IFPPacket ( const IFPPacket & s );
	IFPPacket & operator= ( const IFPPacket & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	Type_of_msg m_type_of_msg;
	protected:
	Data_Field * m_data_field;
	public:
	void encode ( Asn :: ostream & os ) const;
	~IFPPacket ( );
	void printOn ( std :: ostream & os ) const;
	const Data_Field & get_data_field ( ) const {
		return * m_data_field;
	}
	Data_Field & get_data_field ( ) {
		return * m_data_field;
	}
	IFPPacket * clone ( ) const;
};

//
// PreCorrigendum-IFPPacket
//

// from 0 size 0 type 0 simple 0
class PreCorrigendum_IFPPacket : public Asn :: Sequence {
	public:
	explicit PreCorrigendum_IFPPacket ( Asn :: istream & is );
	PreCorrigendum_IFPPacket ( );
	enum OptionalFields {
		e_data_field
	};

	PreCorrigendum_IFPPacket ( const PreCorrigendum_IFPPacket & s );
	PreCorrigendum_IFPPacket & operator= ( const PreCorrigendum_IFPPacket & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	Type_of_msg m_type_of_msg;
	protected:
	PreCorrigendum_Data_Field * m_data_field;
	public:
	void encode ( Asn :: ostream & os ) const;
	~PreCorrigendum_IFPPacket ( );
	void printOn ( std :: ostream & os ) const;
	const PreCorrigendum_Data_Field & get_data_field ( ) const {
		return * m_data_field;
	}
	PreCorrigendum_Data_Field & get_data_field ( ) {
		return * m_data_field;
	}
	PreCorrigendum_IFPPacket * clone ( ) const;
};

//
// UDPTLPacket_error-recovery
//

// from 0 size 0 type 0 simple 0
class UDPTLPacket_error_recovery : public Asn :: Choice {
	public:
	explicit UDPTLPacket_error_recovery ( Asn :: istream & is );
	UDPTLPacket_error_recovery ( );
	enum Choices {
		e_secondary_ifp_packets,
		e_fec_info
	};

	operator UDPTLPacket_error_recovery_secondary_ifp_packets & ( ) { return dynamic_cast < UDPTLPacket_error_recovery_secondary_ifp_packets & > ( * choice ); }
	operator const UDPTLPacket_error_recovery_secondary_ifp_packets & ( ) const { return dynamic_cast < const UDPTLPacket_error_recovery_secondary_ifp_packets & > ( * choice ); }
	operator UDPTLPacket_error_recovery_fec_info & ( ) { return dynamic_cast < UDPTLPacket_error_recovery_fec_info & > ( * choice ); }
	operator const UDPTLPacket_error_recovery_fec_info & ( ) const { return dynamic_cast < const UDPTLPacket_error_recovery_fec_info & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	UDPTLPacket_error_recovery * clone ( ) const;
};

//
// UDPTLPacket
//

// from 0 size 0 type 0 simple 0
class UDPTLPacket : public Asn :: Sequence {
	public:
	explicit UDPTLPacket ( Asn :: istream & is );
	UDPTLPacket ( );
	UDPTLPacket_seq_number m_seq_number;
	UDPTLPacket_primary_ifp_packet m_primary_ifp_packet;
	UDPTLPacket_error_recovery m_error_recovery;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	UDPTLPacket * clone ( ) const;
};

};

#endif // __T38_HPP


// End of t38.hpp
