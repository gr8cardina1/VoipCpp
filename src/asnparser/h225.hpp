//
// h225.hpp
//
// Code automatically generated by asnparse.
//

#ifndef __H225_HPP
#define __H225_HPP

#ifdef __GNUC__
#pragma interface
#endif

#include "h235.hpp"

#include "h245.hpp"



namespace H225 {

//
// StimulusControl
//

// from 0 size 0 type 0 simple 0
class NonStandardParameter;

class StimulusControl : public Asn :: Sequence {
	public:
	explicit StimulusControl ( Asn :: istream & is );
	StimulusControl ( );
	enum OptionalFields {
		e_nonStandard,
		e_isText,
		e_h248Message
	};

	StimulusControl ( const StimulusControl & s );
	StimulusControl & operator= ( const StimulusControl & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	NonStandardParameter * m_nonStandard;
	Asn :: Null * m_isText;
	Asn :: OctetString * m_h248Message;
	public:
	void encode ( Asn :: ostream & os ) const;
	~StimulusControl ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandard ( ) const {
		return * m_nonStandard;
	}
	NonStandardParameter & get_nonStandard ( ) {
		return * m_nonStandard;
	}
	const Asn :: Null & get_isText ( ) const {
		return * m_isText;
	}
	Asn :: Null & get_isText ( ) {
		return * m_isText;
	}
	const Asn :: OctetString & get_h248Message ( ) const {
		return * m_h248Message;
	}
	Asn :: OctetString & get_h248Message ( ) {
		return * m_h248Message;
	}
	StimulusControl * clone ( ) const;
};

//
// ScnConnectionType
//

// from 0 size 0 type 0 simple 0
class ScnConnectionType : public Asn :: Choice {
	public:
	explicit ScnConnectionType ( Asn :: istream & is );
	ScnConnectionType ( );
	enum Choices {
		e_unknown,
		e_bChannel,
		e_hybrid2x64,
		e_hybrid384,
		e_hybrid1536,
		e_hybrid1920,
		e_multirate
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	ScnConnectionType * clone ( ) const;
};

//
// ScnConnectionAggregation
//

// from 0 size 0 type 0 simple 0
class ScnConnectionAggregation : public Asn :: Choice {
	public:
	explicit ScnConnectionAggregation ( Asn :: istream & is );
	ScnConnectionAggregation ( );
	enum Choices {
		e_auto,
		e_none,
		e_h221,
		e_bonded_mode1,
		e_bonded_mode2,
		e_bonded_mode3
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	ScnConnectionAggregation * clone ( ) const;
};

//
// PresentationIndicator
//

// from 0 size 0 type 0 simple 0
class PresentationIndicator : public Asn :: Choice {
	public:
	explicit PresentationIndicator ( Asn :: istream & is );
	PresentationIndicator ( );
	enum Choices {
		e_presentationAllowed,
		e_presentationRestricted,
		e_addressNotAvailable
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	PresentationIndicator * clone ( ) const;
};

//
// ScreeningIndicator
//

// from 0 size 0 type 0 simple 0
class ScreeningIndicator : public Asn :: Enumeration {
	public:
	explicit ScreeningIndicator ( Asn :: istream & is );
	ScreeningIndicator ( );
	enum Enumerations {
		e_userProvidedNotScreened,
		e_userProvidedVerifiedAndPassed,
		e_userProvidedVerifiedAndFailed,
		e_networkProvided
	};

	protected:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	ScreeningIndicator & operator= ( unsigned v ) {
		Asn :: Enumeration :: operator= ( v );
		return * this;
	}
	ScreeningIndicator * clone ( ) const;
};

//
// ConferenceList
//

// from 0 size 0 type 0 simple 0
class ConferenceIdentifier;
class AliasAddress;

class ConferenceList : public Asn :: Sequence {
	public:
	explicit ConferenceList ( Asn :: istream & is );
	ConferenceList ( );
	enum OptionalFields {
		e_conferenceID,
		e_conferenceAlias,
		e_nonStandardData
	};

	ConferenceList ( const ConferenceList & s );
	ConferenceList & operator= ( const ConferenceList & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	ConferenceIdentifier * m_conferenceID;
	AliasAddress * m_conferenceAlias;
	NonStandardParameter * m_nonStandardData;
	public:
	void encode ( Asn :: ostream & os ) const;
	~ConferenceList ( );
	void printOn ( std :: ostream & os ) const;
	const ConferenceIdentifier & get_conferenceID ( ) const {
		return * m_conferenceID;
	}
	ConferenceIdentifier & get_conferenceID ( ) {
		return * m_conferenceID;
	}
	const AliasAddress & get_conferenceAlias ( ) const {
		return * m_conferenceAlias;
	}
	AliasAddress & get_conferenceAlias ( ) {
		return * m_conferenceAlias;
	}
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	ConferenceList * clone ( ) const;
};

//
// FacilityReason
//

// from 0 size 0 type 0 simple 0
class FacilityReason : public Asn :: Choice {
	public:
	explicit FacilityReason ( Asn :: istream & is );
	FacilityReason ( );
	enum Choices {
		e_routeCallToGatekeeper,
		e_callForwarded,
		e_routeCallToMC,
		e_undefinedReason,
		e_conferenceListChoice,
		e_startH245,
		e_noH245,
		e_newTokens,
		e_featureSetUpdate,
		e_forwardedElements,
		e_transportedInformation
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	FacilityReason * clone ( ) const;
};

//
// EndpointType
//

// from 0 size 0 type 0 simple 0
class VendorIdentifier;
class GatekeeperInfo;
class GatewayInfo;
class McuInfo;
class TerminalInfo;
class EndpointType_set;
class ArrayOf_TunnelledProtocol;

class EndpointType : public Asn :: Sequence {
	public:
	explicit EndpointType ( Asn :: istream & is );
	EndpointType ( );
	enum OptionalFields {
		e_nonStandardData,
		e_vendor,
		e_gatekeeper,
		e_gateway,
		e_mcu,
		e_terminal,
		e_set,
		e_supportedTunnelledProtocols
	};

	EndpointType ( const EndpointType & s );
	EndpointType & operator= ( const EndpointType & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	NonStandardParameter * m_nonStandardData;
	VendorIdentifier * m_vendor;
	GatekeeperInfo * m_gatekeeper;
	GatewayInfo * m_gateway;
	McuInfo * m_mcu;
	TerminalInfo * m_terminal;
	public:
	Asn :: Boolean m_mc;
	Asn :: Boolean m_undefinedNode;
	protected:
	EndpointType_set * m_set;
	ArrayOf_TunnelledProtocol * m_supportedTunnelledProtocols;
	public:
	void encode ( Asn :: ostream & os ) const;
	~EndpointType ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const VendorIdentifier & get_vendor ( ) const {
		return * m_vendor;
	}
	VendorIdentifier & get_vendor ( ) {
		return * m_vendor;
	}
	const GatekeeperInfo & get_gatekeeper ( ) const {
		return * m_gatekeeper;
	}
	GatekeeperInfo & get_gatekeeper ( ) {
		return * m_gatekeeper;
	}
	const GatewayInfo & get_gateway ( ) const {
		return * m_gateway;
	}
	GatewayInfo & get_gateway ( ) {
		return * m_gateway;
	}
	const McuInfo & get_mcu ( ) const {
		return * m_mcu;
	}
	McuInfo & get_mcu ( ) {
		return * m_mcu;
	}
	const TerminalInfo & get_terminal ( ) const {
		return * m_terminal;
	}
	TerminalInfo & get_terminal ( ) {
		return * m_terminal;
	}
	const EndpointType_set & get_set ( ) const {
		return * m_set;
	}
	EndpointType_set & get_set ( ) {
		return * m_set;
	}
	const ArrayOf_TunnelledProtocol & get_supportedTunnelledProtocols ( ) const {
		return * m_supportedTunnelledProtocols;
	}
	ArrayOf_TunnelledProtocol & get_supportedTunnelledProtocols ( ) {
		return * m_supportedTunnelledProtocols;
	}
	EndpointType * clone ( ) const;
};

//
// GatewayInfo
//

// from 0 size 0 type 0 simple 0
class ArrayOf_SupportedProtocols;

class GatewayInfo : public Asn :: Sequence {
	public:
	explicit GatewayInfo ( Asn :: istream & is );
	GatewayInfo ( );
	enum OptionalFields {
		e_protocol,
		e_nonStandardData
	};

	GatewayInfo ( const GatewayInfo & s );
	GatewayInfo & operator= ( const GatewayInfo & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	ArrayOf_SupportedProtocols * m_protocol;
	NonStandardParameter * m_nonStandardData;
	public:
	void encode ( Asn :: ostream & os ) const;
	~GatewayInfo ( );
	void printOn ( std :: ostream & os ) const;
	const ArrayOf_SupportedProtocols & get_protocol ( ) const {
		return * m_protocol;
	}
	ArrayOf_SupportedProtocols & get_protocol ( ) {
		return * m_protocol;
	}
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	GatewayInfo * clone ( ) const;
};

//
// H310Caps
//

// from 0 size 0 type 0 simple 0
class ArrayOf_DataRate;
class ArrayOf_SupportedPrefix;

class H310Caps : public Asn :: Sequence {
	public:
	explicit H310Caps ( Asn :: istream & is );
	H310Caps ( );
	enum OptionalFields {
		e_nonStandardData,
		e_dataRatesSupported,
		e_supportedPrefixes
	};

	H310Caps ( const H310Caps & s );
	H310Caps & operator= ( const H310Caps & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	NonStandardParameter * m_nonStandardData;
	ArrayOf_DataRate * m_dataRatesSupported;
	ArrayOf_SupportedPrefix * m_supportedPrefixes;
	public:
	void encode ( Asn :: ostream & os ) const;
	~H310Caps ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const ArrayOf_DataRate & get_dataRatesSupported ( ) const {
		return * m_dataRatesSupported;
	}
	ArrayOf_DataRate & get_dataRatesSupported ( ) {
		return * m_dataRatesSupported;
	}
	const ArrayOf_SupportedPrefix & get_supportedPrefixes ( ) const {
		return * m_supportedPrefixes;
	}
	ArrayOf_SupportedPrefix & get_supportedPrefixes ( ) {
		return * m_supportedPrefixes;
	}
	H310Caps * clone ( ) const;
};

//
// H320Caps
//

// from 0 size 0 type 0 simple 0
class H320Caps : public Asn :: Sequence {
	public:
	explicit H320Caps ( Asn :: istream & is );
	H320Caps ( );
	enum OptionalFields {
		e_nonStandardData,
		e_dataRatesSupported,
		e_supportedPrefixes
	};

	H320Caps ( const H320Caps & s );
	H320Caps & operator= ( const H320Caps & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	NonStandardParameter * m_nonStandardData;
	ArrayOf_DataRate * m_dataRatesSupported;
	ArrayOf_SupportedPrefix * m_supportedPrefixes;
	public:
	void encode ( Asn :: ostream & os ) const;
	~H320Caps ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const ArrayOf_DataRate & get_dataRatesSupported ( ) const {
		return * m_dataRatesSupported;
	}
	ArrayOf_DataRate & get_dataRatesSupported ( ) {
		return * m_dataRatesSupported;
	}
	const ArrayOf_SupportedPrefix & get_supportedPrefixes ( ) const {
		return * m_supportedPrefixes;
	}
	ArrayOf_SupportedPrefix & get_supportedPrefixes ( ) {
		return * m_supportedPrefixes;
	}
	H320Caps * clone ( ) const;
};

//
// H321Caps
//

// from 0 size 0 type 0 simple 0
class H321Caps : public Asn :: Sequence {
	public:
	explicit H321Caps ( Asn :: istream & is );
	H321Caps ( );
	enum OptionalFields {
		e_nonStandardData,
		e_dataRatesSupported,
		e_supportedPrefixes
	};

	H321Caps ( const H321Caps & s );
	H321Caps & operator= ( const H321Caps & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	NonStandardParameter * m_nonStandardData;
	ArrayOf_DataRate * m_dataRatesSupported;
	ArrayOf_SupportedPrefix * m_supportedPrefixes;
	public:
	void encode ( Asn :: ostream & os ) const;
	~H321Caps ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const ArrayOf_DataRate & get_dataRatesSupported ( ) const {
		return * m_dataRatesSupported;
	}
	ArrayOf_DataRate & get_dataRatesSupported ( ) {
		return * m_dataRatesSupported;
	}
	const ArrayOf_SupportedPrefix & get_supportedPrefixes ( ) const {
		return * m_supportedPrefixes;
	}
	ArrayOf_SupportedPrefix & get_supportedPrefixes ( ) {
		return * m_supportedPrefixes;
	}
	H321Caps * clone ( ) const;
};

//
// H322Caps
//

// from 0 size 0 type 0 simple 0
class H322Caps : public Asn :: Sequence {
	public:
	explicit H322Caps ( Asn :: istream & is );
	H322Caps ( );
	enum OptionalFields {
		e_nonStandardData,
		e_dataRatesSupported,
		e_supportedPrefixes
	};

	H322Caps ( const H322Caps & s );
	H322Caps & operator= ( const H322Caps & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	NonStandardParameter * m_nonStandardData;
	ArrayOf_DataRate * m_dataRatesSupported;
	ArrayOf_SupportedPrefix * m_supportedPrefixes;
	public:
	void encode ( Asn :: ostream & os ) const;
	~H322Caps ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const ArrayOf_DataRate & get_dataRatesSupported ( ) const {
		return * m_dataRatesSupported;
	}
	ArrayOf_DataRate & get_dataRatesSupported ( ) {
		return * m_dataRatesSupported;
	}
	const ArrayOf_SupportedPrefix & get_supportedPrefixes ( ) const {
		return * m_supportedPrefixes;
	}
	ArrayOf_SupportedPrefix & get_supportedPrefixes ( ) {
		return * m_supportedPrefixes;
	}
	H322Caps * clone ( ) const;
};

//
// H323Caps
//

// from 0 size 0 type 0 simple 0
class H323Caps : public Asn :: Sequence {
	public:
	explicit H323Caps ( Asn :: istream & is );
	H323Caps ( );
	enum OptionalFields {
		e_nonStandardData,
		e_dataRatesSupported,
		e_supportedPrefixes
	};

	H323Caps ( const H323Caps & s );
	H323Caps & operator= ( const H323Caps & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	NonStandardParameter * m_nonStandardData;
	ArrayOf_DataRate * m_dataRatesSupported;
	ArrayOf_SupportedPrefix * m_supportedPrefixes;
	public:
	void encode ( Asn :: ostream & os ) const;
	~H323Caps ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const ArrayOf_DataRate & get_dataRatesSupported ( ) const {
		return * m_dataRatesSupported;
	}
	ArrayOf_DataRate & get_dataRatesSupported ( ) {
		return * m_dataRatesSupported;
	}
	const ArrayOf_SupportedPrefix & get_supportedPrefixes ( ) const {
		return * m_supportedPrefixes;
	}
	ArrayOf_SupportedPrefix & get_supportedPrefixes ( ) {
		return * m_supportedPrefixes;
	}
	H323Caps * clone ( ) const;
};

//
// H324Caps
//

// from 0 size 0 type 0 simple 0
class H324Caps : public Asn :: Sequence {
	public:
	explicit H324Caps ( Asn :: istream & is );
	H324Caps ( );
	enum OptionalFields {
		e_nonStandardData,
		e_dataRatesSupported,
		e_supportedPrefixes
	};

	H324Caps ( const H324Caps & s );
	H324Caps & operator= ( const H324Caps & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	NonStandardParameter * m_nonStandardData;
	ArrayOf_DataRate * m_dataRatesSupported;
	ArrayOf_SupportedPrefix * m_supportedPrefixes;
	public:
	void encode ( Asn :: ostream & os ) const;
	~H324Caps ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const ArrayOf_DataRate & get_dataRatesSupported ( ) const {
		return * m_dataRatesSupported;
	}
	ArrayOf_DataRate & get_dataRatesSupported ( ) {
		return * m_dataRatesSupported;
	}
	const ArrayOf_SupportedPrefix & get_supportedPrefixes ( ) const {
		return * m_supportedPrefixes;
	}
	ArrayOf_SupportedPrefix & get_supportedPrefixes ( ) {
		return * m_supportedPrefixes;
	}
	H324Caps * clone ( ) const;
};

//
// VoiceCaps
//

// from 0 size 0 type 0 simple 0
class VoiceCaps : public Asn :: Sequence {
	public:
	explicit VoiceCaps ( Asn :: istream & is );
	VoiceCaps ( );
	enum OptionalFields {
		e_nonStandardData,
		e_dataRatesSupported,
		e_supportedPrefixes
	};

	VoiceCaps ( const VoiceCaps & s );
	VoiceCaps & operator= ( const VoiceCaps & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	NonStandardParameter * m_nonStandardData;
	ArrayOf_DataRate * m_dataRatesSupported;
	ArrayOf_SupportedPrefix * m_supportedPrefixes;
	public:
	void encode ( Asn :: ostream & os ) const;
	~VoiceCaps ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const ArrayOf_DataRate & get_dataRatesSupported ( ) const {
		return * m_dataRatesSupported;
	}
	ArrayOf_DataRate & get_dataRatesSupported ( ) {
		return * m_dataRatesSupported;
	}
	const ArrayOf_SupportedPrefix & get_supportedPrefixes ( ) const {
		return * m_supportedPrefixes;
	}
	ArrayOf_SupportedPrefix & get_supportedPrefixes ( ) {
		return * m_supportedPrefixes;
	}
	VoiceCaps * clone ( ) const;
};

//
// T120OnlyCaps
//

// from 0 size 0 type 0 simple 0
class T120OnlyCaps : public Asn :: Sequence {
	public:
	explicit T120OnlyCaps ( Asn :: istream & is );
	T120OnlyCaps ( );
	enum OptionalFields {
		e_nonStandardData,
		e_dataRatesSupported,
		e_supportedPrefixes
	};

	T120OnlyCaps ( const T120OnlyCaps & s );
	T120OnlyCaps & operator= ( const T120OnlyCaps & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	NonStandardParameter * m_nonStandardData;
	ArrayOf_DataRate * m_dataRatesSupported;
	ArrayOf_SupportedPrefix * m_supportedPrefixes;
	public:
	void encode ( Asn :: ostream & os ) const;
	~T120OnlyCaps ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const ArrayOf_DataRate & get_dataRatesSupported ( ) const {
		return * m_dataRatesSupported;
	}
	ArrayOf_DataRate & get_dataRatesSupported ( ) {
		return * m_dataRatesSupported;
	}
	const ArrayOf_SupportedPrefix & get_supportedPrefixes ( ) const {
		return * m_supportedPrefixes;
	}
	ArrayOf_SupportedPrefix & get_supportedPrefixes ( ) {
		return * m_supportedPrefixes;
	}
	T120OnlyCaps * clone ( ) const;
};

//
// SIPCaps
//

// from 0 size 0 type 0 simple 0
class SIPCaps : public Asn :: Sequence {
	public:
	explicit SIPCaps ( Asn :: istream & is );
	SIPCaps ( );
	enum OptionalFields {
		e_nonStandardData,
		e_dataRatesSupported,
		e_supportedPrefixes
	};

	SIPCaps ( const SIPCaps & s );
	SIPCaps & operator= ( const SIPCaps & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	NonStandardParameter * m_nonStandardData;
	ArrayOf_DataRate * m_dataRatesSupported;
	ArrayOf_SupportedPrefix * m_supportedPrefixes;
	public:
	void encode ( Asn :: ostream & os ) const;
	~SIPCaps ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const ArrayOf_DataRate & get_dataRatesSupported ( ) const {
		return * m_dataRatesSupported;
	}
	ArrayOf_DataRate & get_dataRatesSupported ( ) {
		return * m_dataRatesSupported;
	}
	const ArrayOf_SupportedPrefix & get_supportedPrefixes ( ) const {
		return * m_supportedPrefixes;
	}
	ArrayOf_SupportedPrefix & get_supportedPrefixes ( ) {
		return * m_supportedPrefixes;
	}
	SIPCaps * clone ( ) const;
};

//
// McuInfo
//

// from 0 size 0 type 0 simple 0
class McuInfo : public Asn :: Sequence {
	public:
	explicit McuInfo ( Asn :: istream & is );
	McuInfo ( );
	enum OptionalFields {
		e_nonStandardData,
		e_protocol
	};

	McuInfo ( const McuInfo & s );
	McuInfo & operator= ( const McuInfo & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	NonStandardParameter * m_nonStandardData;
	ArrayOf_SupportedProtocols * m_protocol;
	public:
	void encode ( Asn :: ostream & os ) const;
	~McuInfo ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const ArrayOf_SupportedProtocols & get_protocol ( ) const {
		return * m_protocol;
	}
	ArrayOf_SupportedProtocols & get_protocol ( ) {
		return * m_protocol;
	}
	McuInfo * clone ( ) const;
};

//
// TerminalInfo
//

// from 0 size 0 type 0 simple 0
class TerminalInfo : public Asn :: Sequence {
	public:
	explicit TerminalInfo ( Asn :: istream & is );
	TerminalInfo ( );
	enum OptionalFields {
		e_nonStandardData
	};

	TerminalInfo ( const TerminalInfo & s );
	TerminalInfo & operator= ( const TerminalInfo & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	NonStandardParameter * m_nonStandardData;
	public:
	void encode ( Asn :: ostream & os ) const;
	~TerminalInfo ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	TerminalInfo * clone ( ) const;
};

//
// GatekeeperInfo
//

// from 0 size 0 type 0 simple 0
class GatekeeperInfo : public Asn :: Sequence {
	public:
	explicit GatekeeperInfo ( Asn :: istream & is );
	GatekeeperInfo ( );
	enum OptionalFields {
		e_nonStandardData
	};

	GatekeeperInfo ( const GatekeeperInfo & s );
	GatekeeperInfo & operator= ( const GatekeeperInfo & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	NonStandardParameter * m_nonStandardData;
	public:
	void encode ( Asn :: ostream & os ) const;
	~GatekeeperInfo ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	GatekeeperInfo * clone ( ) const;
};

//
// NumberDigits
//

// from 1 size 1 type 0 simple 0
class NumberDigits : public Asn :: IA5String {
	public:
	explicit NumberDigits ( Asn :: istream & is );
	NumberDigits ( const Asn :: string & v = Asn :: string ( ) );
	NumberDigits & operator= ( const Asn :: string & v ) {
		Asn :: IA5String :: operator= ( v );
		return * this;
	}
	NumberDigits * clone ( ) const;
};

//
// PublicTypeOfNumber
//

// from 0 size 0 type 0 simple 0
class PublicTypeOfNumber : public Asn :: Choice {
	public:
	explicit PublicTypeOfNumber ( Asn :: istream & is );
	PublicTypeOfNumber ( );
	enum Choices {
		e_unknown,
		e_internationalNumber,
		e_nationalNumber,
		e_networkSpecificNumber,
		e_subscriberNumber,
		e_abbreviatedNumber
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	PublicTypeOfNumber * clone ( ) const;
};

//
// PrivateTypeOfNumber
//

// from 0 size 0 type 0 simple 0
class PrivateTypeOfNumber : public Asn :: Choice {
	public:
	explicit PrivateTypeOfNumber ( Asn :: istream & is );
	PrivateTypeOfNumber ( );
	enum Choices {
		e_unknown,
		e_level2RegionalNumber,
		e_level1RegionalNumber,
		e_pISNSpecificNumber,
		e_localNumber,
		e_abbreviatedNumber
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	PrivateTypeOfNumber * clone ( ) const;
};

//
// TBCD-STRING
//

// from 1 size 0 type 0 simple 0
class TBCD_STRING : public Asn :: IA5String {
	public:
	explicit TBCD_STRING ( Asn :: istream & is );
	TBCD_STRING ( const Asn :: string & v = Asn :: string ( ) );
	TBCD_STRING & operator= ( const Asn :: string & v ) {
		Asn :: IA5String :: operator= ( v );
		return * this;
	}
	TBCD_STRING * clone ( ) const;
};

//
// NatureOfAddress
//

// from 0 size 0 type 0 simple 0
class NatureOfAddress : public Asn :: Choice {
	public:
	explicit NatureOfAddress ( Asn :: istream & is );
	NatureOfAddress ( );
	enum Choices {
		e_unknown,
		e_subscriberNumber,
		e_nationalNumber,
		e_internationalNumber,
		e_networkSpecificNumber,
		e_routingNumberNationalFormat,
		e_routingNumberNetworkSpecificFormat,
		e_routingNumberWithCalledDirectoryNumber
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	NatureOfAddress * clone ( ) const;
};

//
// IsupDigits
//

// from 1 size 1 type 0 simple 0
class IsupDigits : public Asn :: IA5String {
	public:
	explicit IsupDigits ( Asn :: istream & is );
	IsupDigits ( const Asn :: string & v = Asn :: string ( ) );
	IsupDigits & operator= ( const Asn :: string & v ) {
		Asn :: IA5String :: operator= ( v );
		return * this;
	}
	IsupDigits * clone ( ) const;
};

//
// Endpoint
//

// from 0 size 0 type 0 simple 0
class ArrayOf_AliasAddress;
class ArrayOf_TransportAddress;
class ArrayOf_ClearToken;
class ArrayOf_CryptoH323Token;
class Endpoint_priority;
class AlternateTransportAddresses;
class CircuitInfo;
class FeatureSet;

class Endpoint : public Asn :: Sequence {
	public:
	explicit Endpoint ( Asn :: istream & is );
	Endpoint ( );
	enum OptionalFields {
		e_nonStandardData,
		e_aliasAddress,
		e_callSignalAddress,
		e_rasAddress,
		e_endpointType,
		e_tokens,
		e_cryptoTokens,
		e_priority,
		e_remoteExtensionAddress,
		e_destExtraCallInfo,
		e_alternateTransportAddresses,
		e_circuitInfo,
		e_featureSet
	};

	Endpoint ( const Endpoint & s );
	Endpoint & operator= ( const Endpoint & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	NonStandardParameter * m_nonStandardData;
	ArrayOf_AliasAddress * m_aliasAddress;
	ArrayOf_TransportAddress * m_callSignalAddress;
	ArrayOf_TransportAddress * m_rasAddress;
	EndpointType * m_endpointType;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	Endpoint_priority * m_priority;
	ArrayOf_AliasAddress * m_remoteExtensionAddress;
	ArrayOf_AliasAddress * m_destExtraCallInfo;
	AlternateTransportAddresses * m_alternateTransportAddresses;
	CircuitInfo * m_circuitInfo;
	FeatureSet * m_featureSet;
	public:
	void encode ( Asn :: ostream & os ) const;
	~Endpoint ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const ArrayOf_AliasAddress & get_aliasAddress ( ) const {
		return * m_aliasAddress;
	}
	ArrayOf_AliasAddress & get_aliasAddress ( ) {
		return * m_aliasAddress;
	}
	const ArrayOf_TransportAddress & get_callSignalAddress ( ) const {
		return * m_callSignalAddress;
	}
	ArrayOf_TransportAddress & get_callSignalAddress ( ) {
		return * m_callSignalAddress;
	}
	const ArrayOf_TransportAddress & get_rasAddress ( ) const {
		return * m_rasAddress;
	}
	ArrayOf_TransportAddress & get_rasAddress ( ) {
		return * m_rasAddress;
	}
	const EndpointType & get_endpointType ( ) const {
		return * m_endpointType;
	}
	EndpointType & get_endpointType ( ) {
		return * m_endpointType;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const Endpoint_priority & get_priority ( ) const {
		return * m_priority;
	}
	Endpoint_priority & get_priority ( ) {
		return * m_priority;
	}
	const ArrayOf_AliasAddress & get_remoteExtensionAddress ( ) const {
		return * m_remoteExtensionAddress;
	}
	ArrayOf_AliasAddress & get_remoteExtensionAddress ( ) {
		return * m_remoteExtensionAddress;
	}
	const ArrayOf_AliasAddress & get_destExtraCallInfo ( ) const {
		return * m_destExtraCallInfo;
	}
	ArrayOf_AliasAddress & get_destExtraCallInfo ( ) {
		return * m_destExtraCallInfo;
	}
	const AlternateTransportAddresses & get_alternateTransportAddresses ( ) const {
		return * m_alternateTransportAddresses;
	}
	AlternateTransportAddresses & get_alternateTransportAddresses ( ) {
		return * m_alternateTransportAddresses;
	}
	const CircuitInfo & get_circuitInfo ( ) const {
		return * m_circuitInfo;
	}
	CircuitInfo & get_circuitInfo ( ) {
		return * m_circuitInfo;
	}
	const FeatureSet & get_featureSet ( ) const {
		return * m_featureSet;
	}
	FeatureSet & get_featureSet ( ) {
		return * m_featureSet;
	}
	Endpoint * clone ( ) const;
};

//
// AlternateTransportAddresses
//

// from 0 size 0 type 0 simple 0
class AlternateTransportAddresses : public Asn :: Sequence {
	public:
	explicit AlternateTransportAddresses ( Asn :: istream & is );
	AlternateTransportAddresses ( );
	enum OptionalFields {
		e_annexE,
		e_sctp
	};

	AlternateTransportAddresses ( const AlternateTransportAddresses & s );
	AlternateTransportAddresses & operator= ( const AlternateTransportAddresses & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	ArrayOf_TransportAddress * m_annexE;
	ArrayOf_TransportAddress * m_sctp;
	public:
	void encode ( Asn :: ostream & os ) const;
	~AlternateTransportAddresses ( );
	void printOn ( std :: ostream & os ) const;
	const ArrayOf_TransportAddress & get_annexE ( ) const {
		return * m_annexE;
	}
	ArrayOf_TransportAddress & get_annexE ( ) {
		return * m_annexE;
	}
	const ArrayOf_TransportAddress & get_sctp ( ) const {
		return * m_sctp;
	}
	ArrayOf_TransportAddress & get_sctp ( ) {
		return * m_sctp;
	}
	AlternateTransportAddresses * clone ( ) const;
};

//
// UseSpecifiedTransport
//

// from 0 size 0 type 0 simple 0
class UseSpecifiedTransport : public Asn :: Choice {
	public:
	explicit UseSpecifiedTransport ( Asn :: istream & is );
	UseSpecifiedTransport ( );
	enum Choices {
		e_tcp,
		e_annexE,
		e_sctp
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	UseSpecifiedTransport * clone ( ) const;
};

//
// SecurityErrors
//

// from 0 size 0 type 0 simple 0
class SecurityErrors : public Asn :: Choice {
	public:
	explicit SecurityErrors ( Asn :: istream & is );
	SecurityErrors ( );
	enum Choices {
		e_securityWrongSyncTime,
		e_securityReplay,
		e_securityWrongGeneralID,
		e_securityWrongSendersID,
		e_securityIntegrityFailed,
		e_securityWrongOID,
		e_securityDHmismatch,
		e_securityCertificateExpired,
		e_securityCertificateDateInvalid,
		e_securityCertificateRevoked,
		e_securityCertificateNotReadable,
		e_securityCertificateSignatureInvalid,
		e_securityCertificateMissing,
		e_securityCertificateIncomplete,
		e_securityUnsupportedCertificateAlgOID,
		e_securityUnknownCA
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	SecurityErrors * clone ( ) const;
};

//
// SecurityErrors2
//

// from 0 size 0 type 0 simple 0
class SecurityErrors2 : public Asn :: Choice {
	public:
	explicit SecurityErrors2 ( Asn :: istream & is );
	SecurityErrors2 ( );
	enum Choices {
		e_securityWrongSyncTime,
		e_securityReplay,
		e_securityWrongGeneralID,
		e_securityWrongSendersID,
		e_securityIntegrityFailed,
		e_securityWrongOID
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	SecurityErrors2 * clone ( ) const;
};

//
// Q954Details
//

// from 0 size 0 type 0 simple 0
class Q954Details : public Asn :: Sequence {
	public:
	explicit Q954Details ( Asn :: istream & is );
	Q954Details ( );
	Asn :: Boolean m_conferenceCalling;
	Asn :: Boolean m_threePartyService;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	Q954Details * clone ( ) const;
};

//
// GloballyUniqueID
//

// from 0 size 1 type 0 simple 0
class GloballyUniqueID : public Asn :: OctetString {
	public:
	explicit GloballyUniqueID ( Asn :: istream & is );
	GloballyUniqueID ( const Asn :: string & v = Asn :: string ( ) );
	GloballyUniqueID & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	GloballyUniqueID * clone ( ) const;
};

//
// ConferenceIdentifier
//

// from 0 size 0 type 0 simple 0
class ConferenceIdentifier : public GloballyUniqueID {
	public:
	explicit ConferenceIdentifier ( Asn :: istream & is );
	ConferenceIdentifier ( );
	ConferenceIdentifier & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	ConferenceIdentifier * clone ( ) const;
};

//
// RequestSeqNum
//

// from 0 size 0 type 0 simple 1
class RequestSeqNum : public Asn :: Integer {
	public:
	explicit RequestSeqNum ( Asn :: istream & is );
	RequestSeqNum ( unsigned v = 0 );
	RequestSeqNum & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RequestSeqNum & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RequestSeqNum * clone ( ) const;
};

//
// GatekeeperIdentifier
//

// from 0 size 1 type 0 simple 0
class GatekeeperIdentifier : public Asn :: BMPString {
	public:
	explicit GatekeeperIdentifier ( Asn :: istream & is );
	GatekeeperIdentifier ( const Asn :: string & v = Asn :: string ( ) );
	GatekeeperIdentifier & operator= ( const Asn :: string & v ) {
		Asn :: BMPString :: operator= ( v );
		return * this;
	}
	GatekeeperIdentifier * clone ( ) const;
};

//
// BandWidth
//

// from 0 size 0 type 0 simple 1
class BandWidth : public Asn :: Integer {
	public:
	explicit BandWidth ( Asn :: istream & is );
	BandWidth ( unsigned v = 0 );
	BandWidth & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	BandWidth & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	BandWidth * clone ( ) const;
};

//
// CallReferenceValue
//

// from 0 size 0 type 0 simple 1
class CallReferenceValue : public Asn :: Integer {
	public:
	explicit CallReferenceValue ( Asn :: istream & is );
	CallReferenceValue ( unsigned v = 0 );
	CallReferenceValue & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CallReferenceValue & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CallReferenceValue * clone ( ) const;
};

//
// EndpointIdentifier
//

// from 0 size 1 type 0 simple 0
class EndpointIdentifier : public Asn :: BMPString {
	public:
	explicit EndpointIdentifier ( Asn :: istream & is );
	EndpointIdentifier ( const Asn :: string & v = Asn :: string ( ) );
	EndpointIdentifier & operator= ( const Asn :: string & v ) {
		Asn :: BMPString :: operator= ( v );
		return * this;
	}
	EndpointIdentifier * clone ( ) const;
};

//
// ProtocolIdentifier
//

// from 0 size 0 type 0 simple 0
class ProtocolIdentifier : public Asn :: ObjectId {
	public:
	explicit ProtocolIdentifier ( Asn :: istream & is );
	ProtocolIdentifier ( );
	explicit ProtocolIdentifier ( const Asn :: string & s ) : Asn :: ObjectId ( s ) { }
	ProtocolIdentifier & operator= ( const Asn :: string & v ) {
		Asn :: ObjectId :: operator= ( v );
		return * this;
	}
	ProtocolIdentifier * clone ( ) const;
};

//
// TimeToLive
//

// from 0 size 0 type 0 simple 1
class TimeToLive : public Asn :: Integer {
	public:
	explicit TimeToLive ( Asn :: istream & is );
	TimeToLive ( unsigned v = 0 );
	TimeToLive & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	TimeToLive & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	TimeToLive * clone ( ) const;
};

//
// H248PackagesDescriptor
//

// from 0 size 0 type 0 simple 0
class H248PackagesDescriptor : public Asn :: OctetString {
	public:
	explicit H248PackagesDescriptor ( Asn :: istream & is );
	H248PackagesDescriptor ( const Asn :: string & v = Asn :: string ( ) );
	H248PackagesDescriptor & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	H248PackagesDescriptor * clone ( ) const;
};

//
// H248SignalsDescriptor
//

// from 0 size 0 type 0 simple 0
class H248SignalsDescriptor : public Asn :: OctetString {
	public:
	explicit H248SignalsDescriptor ( Asn :: istream & is );
	H248SignalsDescriptor ( const Asn :: string & v = Asn :: string ( ) );
	H248SignalsDescriptor & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	H248SignalsDescriptor * clone ( ) const;
};

//
// CallIdentifier
//

// from 0 size 0 type 0 simple 0
class CallIdentifier : public Asn :: Sequence {
	public:
	explicit CallIdentifier ( Asn :: istream & is );
	CallIdentifier ( );
	GloballyUniqueID m_guid;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	CallIdentifier * clone ( ) const;
};

//
// ICV
//

// from 0 size 0 type 0 simple 0
class ICV : public Asn :: Sequence {
	public:
	explicit ICV ( Asn :: istream & is );
	ICV ( );
	Asn :: ObjectId m_algorithmOID;
	Asn :: BitString m_icv;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	ICV * clone ( ) const;
};

//
// FastStartToken
//

// from 0 size 0 type 3 simple 0
class FastStartToken : public H235 :: ClearToken {
	public:
	explicit FastStartToken ( Asn :: istream & is );
	FastStartToken ( );
	FastStartToken * clone ( ) const;
};

//
// EncodedFastStartToken
//

// from 0 size 0 type 1 simple 0
class EncodedFastStartToken : public Asn :: OctetString {
	public:
	explicit EncodedFastStartToken ( Asn :: istream & is );
	EncodedFastStartToken ( );
	EncodedFastStartToken * clone ( ) const;
};

//
// DataRate
//

// from 0 size 0 type 0 simple 0
class DataRate_channelMultiplier;

class DataRate : public Asn :: Sequence {
	public:
	explicit DataRate ( Asn :: istream & is );
	DataRate ( );
	enum OptionalFields {
		e_nonStandardData,
		e_channelMultiplier
	};

	DataRate ( const DataRate & s );
	DataRate & operator= ( const DataRate & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	NonStandardParameter * m_nonStandardData;
	public:
	BandWidth m_channelRate;
	protected:
	DataRate_channelMultiplier * m_channelMultiplier;
	public:
	void encode ( Asn :: ostream & os ) const;
	~DataRate ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const DataRate_channelMultiplier & get_channelMultiplier ( ) const {
		return * m_channelMultiplier;
	}
	DataRate_channelMultiplier & get_channelMultiplier ( ) {
		return * m_channelMultiplier;
	}
	DataRate * clone ( ) const;
};

//
// CallLinkage
//

// from 0 size 0 type 0 simple 0
class CallLinkage : public Asn :: Sequence {
	public:
	explicit CallLinkage ( Asn :: istream & is );
	CallLinkage ( );
	enum OptionalFields {
		e_globalCallId,
		e_threadId
	};

	CallLinkage ( const CallLinkage & s );
	CallLinkage & operator= ( const CallLinkage & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	GloballyUniqueID * m_globalCallId;
	GloballyUniqueID * m_threadId;
	public:
	void encode ( Asn :: ostream & os ) const;
	~CallLinkage ( );
	void printOn ( std :: ostream & os ) const;
	const GloballyUniqueID & get_globalCallId ( ) const {
		return * m_globalCallId;
	}
	GloballyUniqueID & get_globalCallId ( ) {
		return * m_globalCallId;
	}
	const GloballyUniqueID & get_threadId ( ) const {
		return * m_threadId;
	}
	GloballyUniqueID & get_threadId ( ) {
		return * m_threadId;
	}
	CallLinkage * clone ( ) const;
};

//
// CapacityReportingCapability
//

// from 0 size 0 type 0 simple 0
class CapacityReportingCapability : public Asn :: Sequence {
	public:
	explicit CapacityReportingCapability ( Asn :: istream & is );
	CapacityReportingCapability ( );
	Asn :: Boolean m_canReportCallCapacity;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	CapacityReportingCapability * clone ( ) const;
};

//
// CallCapacity
//

// from 0 size 0 type 0 simple 0
class CallCapacityInfo;

class CallCapacity : public Asn :: Sequence {
	public:
	explicit CallCapacity ( Asn :: istream & is );
	CallCapacity ( );
	enum OptionalFields {
		e_maximumCallCapacity,
		e_currentCallCapacity
	};

	CallCapacity ( const CallCapacity & s );
	CallCapacity & operator= ( const CallCapacity & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	CallCapacityInfo * m_maximumCallCapacity;
	CallCapacityInfo * m_currentCallCapacity;
	public:
	void encode ( Asn :: ostream & os ) const;
	~CallCapacity ( );
	void printOn ( std :: ostream & os ) const;
	const CallCapacityInfo & get_maximumCallCapacity ( ) const {
		return * m_maximumCallCapacity;
	}
	CallCapacityInfo & get_maximumCallCapacity ( ) {
		return * m_maximumCallCapacity;
	}
	const CallCapacityInfo & get_currentCallCapacity ( ) const {
		return * m_currentCallCapacity;
	}
	CallCapacityInfo & get_currentCallCapacity ( ) {
		return * m_currentCallCapacity;
	}
	CallCapacity * clone ( ) const;
};

//
// CallCapacityInfo
//

// from 0 size 0 type 0 simple 0
class ArrayOf_CallsAvailable;

class CallCapacityInfo : public Asn :: Sequence {
	public:
	explicit CallCapacityInfo ( Asn :: istream & is );
	CallCapacityInfo ( );
	enum OptionalFields {
		e_voiceGwCallsAvailable,
		e_h310GwCallsAvailable,
		e_h320GwCallsAvailable,
		e_h321GwCallsAvailable,
		e_h322GwCallsAvailable,
		e_h323GwCallsAvailable,
		e_h324GwCallsAvailable,
		e_t120OnlyGwCallsAvailable,
		e_t38FaxAnnexbOnlyGwCallsAvailable,
		e_terminalCallsAvailable,
		e_mcuCallsAvailable,
		e_sipGwCallsAvailable
	};

	CallCapacityInfo ( const CallCapacityInfo & s );
	CallCapacityInfo & operator= ( const CallCapacityInfo & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	ArrayOf_CallsAvailable * m_voiceGwCallsAvailable;
	ArrayOf_CallsAvailable * m_h310GwCallsAvailable;
	ArrayOf_CallsAvailable * m_h320GwCallsAvailable;
	ArrayOf_CallsAvailable * m_h321GwCallsAvailable;
	ArrayOf_CallsAvailable * m_h322GwCallsAvailable;
	ArrayOf_CallsAvailable * m_h323GwCallsAvailable;
	ArrayOf_CallsAvailable * m_h324GwCallsAvailable;
	ArrayOf_CallsAvailable * m_t120OnlyGwCallsAvailable;
	ArrayOf_CallsAvailable * m_t38FaxAnnexbOnlyGwCallsAvailable;
	ArrayOf_CallsAvailable * m_terminalCallsAvailable;
	ArrayOf_CallsAvailable * m_mcuCallsAvailable;
	ArrayOf_CallsAvailable * m_sipGwCallsAvailable;
	public:
	void encode ( Asn :: ostream & os ) const;
	~CallCapacityInfo ( );
	void printOn ( std :: ostream & os ) const;
	const ArrayOf_CallsAvailable & get_voiceGwCallsAvailable ( ) const {
		return * m_voiceGwCallsAvailable;
	}
	ArrayOf_CallsAvailable & get_voiceGwCallsAvailable ( ) {
		return * m_voiceGwCallsAvailable;
	}
	const ArrayOf_CallsAvailable & get_h310GwCallsAvailable ( ) const {
		return * m_h310GwCallsAvailable;
	}
	ArrayOf_CallsAvailable & get_h310GwCallsAvailable ( ) {
		return * m_h310GwCallsAvailable;
	}
	const ArrayOf_CallsAvailable & get_h320GwCallsAvailable ( ) const {
		return * m_h320GwCallsAvailable;
	}
	ArrayOf_CallsAvailable & get_h320GwCallsAvailable ( ) {
		return * m_h320GwCallsAvailable;
	}
	const ArrayOf_CallsAvailable & get_h321GwCallsAvailable ( ) const {
		return * m_h321GwCallsAvailable;
	}
	ArrayOf_CallsAvailable & get_h321GwCallsAvailable ( ) {
		return * m_h321GwCallsAvailable;
	}
	const ArrayOf_CallsAvailable & get_h322GwCallsAvailable ( ) const {
		return * m_h322GwCallsAvailable;
	}
	ArrayOf_CallsAvailable & get_h322GwCallsAvailable ( ) {
		return * m_h322GwCallsAvailable;
	}
	const ArrayOf_CallsAvailable & get_h323GwCallsAvailable ( ) const {
		return * m_h323GwCallsAvailable;
	}
	ArrayOf_CallsAvailable & get_h323GwCallsAvailable ( ) {
		return * m_h323GwCallsAvailable;
	}
	const ArrayOf_CallsAvailable & get_h324GwCallsAvailable ( ) const {
		return * m_h324GwCallsAvailable;
	}
	ArrayOf_CallsAvailable & get_h324GwCallsAvailable ( ) {
		return * m_h324GwCallsAvailable;
	}
	const ArrayOf_CallsAvailable & get_t120OnlyGwCallsAvailable ( ) const {
		return * m_t120OnlyGwCallsAvailable;
	}
	ArrayOf_CallsAvailable & get_t120OnlyGwCallsAvailable ( ) {
		return * m_t120OnlyGwCallsAvailable;
	}
	const ArrayOf_CallsAvailable & get_t38FaxAnnexbOnlyGwCallsAvailable ( ) const {
		return * m_t38FaxAnnexbOnlyGwCallsAvailable;
	}
	ArrayOf_CallsAvailable & get_t38FaxAnnexbOnlyGwCallsAvailable ( ) {
		return * m_t38FaxAnnexbOnlyGwCallsAvailable;
	}
	const ArrayOf_CallsAvailable & get_terminalCallsAvailable ( ) const {
		return * m_terminalCallsAvailable;
	}
	ArrayOf_CallsAvailable & get_terminalCallsAvailable ( ) {
		return * m_terminalCallsAvailable;
	}
	const ArrayOf_CallsAvailable & get_mcuCallsAvailable ( ) const {
		return * m_mcuCallsAvailable;
	}
	ArrayOf_CallsAvailable & get_mcuCallsAvailable ( ) {
		return * m_mcuCallsAvailable;
	}
	const ArrayOf_CallsAvailable & get_sipGwCallsAvailable ( ) const {
		return * m_sipGwCallsAvailable;
	}
	ArrayOf_CallsAvailable & get_sipGwCallsAvailable ( ) {
		return * m_sipGwCallsAvailable;
	}
	CallCapacityInfo * clone ( ) const;
};

//
// CircuitInfo
//

// from 0 size 0 type 0 simple 0
class CircuitIdentifier;
class ArrayOf_GenericData;

class CircuitInfo : public Asn :: Sequence {
	public:
	explicit CircuitInfo ( Asn :: istream & is );
	CircuitInfo ( );
	enum OptionalFields {
		e_sourceCircuitID,
		e_destinationCircuitID,
		e_genericData
	};

	CircuitInfo ( const CircuitInfo & s );
	CircuitInfo & operator= ( const CircuitInfo & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	CircuitIdentifier * m_sourceCircuitID;
	CircuitIdentifier * m_destinationCircuitID;
	ArrayOf_GenericData * m_genericData;
	public:
	void encode ( Asn :: ostream & os ) const;
	~CircuitInfo ( );
	void printOn ( std :: ostream & os ) const;
	const CircuitIdentifier & get_sourceCircuitID ( ) const {
		return * m_sourceCircuitID;
	}
	CircuitIdentifier & get_sourceCircuitID ( ) {
		return * m_sourceCircuitID;
	}
	const CircuitIdentifier & get_destinationCircuitID ( ) const {
		return * m_destinationCircuitID;
	}
	CircuitIdentifier & get_destinationCircuitID ( ) {
		return * m_destinationCircuitID;
	}
	const ArrayOf_GenericData & get_genericData ( ) const {
		return * m_genericData;
	}
	ArrayOf_GenericData & get_genericData ( ) {
		return * m_genericData;
	}
	CircuitInfo * clone ( ) const;
};

//
// CircuitIdentifier
//

// from 0 size 0 type 0 simple 0
class CicInfo;
class GroupID;
class CarrierInfo;

class CircuitIdentifier : public Asn :: Sequence {
	public:
	explicit CircuitIdentifier ( Asn :: istream & is );
	CircuitIdentifier ( );
	enum OptionalFields {
		e_cic,
		e_group,
		e_carrier
	};

	CircuitIdentifier ( const CircuitIdentifier & s );
	CircuitIdentifier & operator= ( const CircuitIdentifier & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	CicInfo * m_cic;
	GroupID * m_group;
	CarrierInfo * m_carrier;
	public:
	void encode ( Asn :: ostream & os ) const;
	~CircuitIdentifier ( );
	void printOn ( std :: ostream & os ) const;
	const CicInfo & get_cic ( ) const {
		return * m_cic;
	}
	CicInfo & get_cic ( ) {
		return * m_cic;
	}
	const GroupID & get_group ( ) const {
		return * m_group;
	}
	GroupID & get_group ( ) {
		return * m_group;
	}
	const CarrierInfo & get_carrier ( ) const {
		return * m_carrier;
	}
	CarrierInfo & get_carrier ( ) {
		return * m_carrier;
	}
	CircuitIdentifier * clone ( ) const;
};

//
// CarrierInfo
//

// from 0 size 0 type 0 simple 0
class CarrierInfo_carrierIdentificationCode;
class CarrierInfo_carrierName;

class CarrierInfo : public Asn :: Sequence {
	public:
	explicit CarrierInfo ( Asn :: istream & is );
	CarrierInfo ( );
	enum OptionalFields {
		e_carrierIdentificationCode,
		e_carrierName
	};

	CarrierInfo ( const CarrierInfo & s );
	CarrierInfo & operator= ( const CarrierInfo & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	CarrierInfo_carrierIdentificationCode * m_carrierIdentificationCode;
	CarrierInfo_carrierName * m_carrierName;
	public:
	void encode ( Asn :: ostream & os ) const;
	~CarrierInfo ( );
	void printOn ( std :: ostream & os ) const;
	const CarrierInfo_carrierIdentificationCode & get_carrierIdentificationCode ( ) const {
		return * m_carrierIdentificationCode;
	}
	CarrierInfo_carrierIdentificationCode & get_carrierIdentificationCode ( ) {
		return * m_carrierIdentificationCode;
	}
	const CarrierInfo_carrierName & get_carrierName ( ) const {
		return * m_carrierName;
	}
	CarrierInfo_carrierName & get_carrierName ( ) {
		return * m_carrierName;
	}
	CarrierInfo * clone ( ) const;
};

//
// CallCreditCapability
//

// from 0 size 0 type 0 simple 0
class CallCreditCapability : public Asn :: Sequence {
	public:
	explicit CallCreditCapability ( Asn :: istream & is );
	CallCreditCapability ( );
	enum OptionalFields {
		e_canDisplayAmountString,
		e_canEnforceDurationLimit
	};

	CallCreditCapability ( const CallCreditCapability & s );
	CallCreditCapability & operator= ( const CallCreditCapability & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	Asn :: Boolean * m_canDisplayAmountString;
	Asn :: Boolean * m_canEnforceDurationLimit;
	public:
	void encode ( Asn :: ostream & os ) const;
	~CallCreditCapability ( );
	void printOn ( std :: ostream & os ) const;
	const Asn :: Boolean & get_canDisplayAmountString ( ) const {
		return * m_canDisplayAmountString;
	}
	Asn :: Boolean & get_canDisplayAmountString ( ) {
		return * m_canDisplayAmountString;
	}
	const Asn :: Boolean & get_canEnforceDurationLimit ( ) const {
		return * m_canEnforceDurationLimit;
	}
	Asn :: Boolean & get_canEnforceDurationLimit ( ) {
		return * m_canEnforceDurationLimit;
	}
	CallCreditCapability * clone ( ) const;
};

//
// CallCreditServiceControl
//

// from 0 size 0 type 0 simple 0
class CallCreditServiceControl_amountString;
class CallCreditServiceControl_billingMode;
class CallCreditServiceControl_callDurationLimit;
class CallCreditServiceControl_callStartingPoint;

class CallCreditServiceControl : public Asn :: Sequence {
	public:
	explicit CallCreditServiceControl ( Asn :: istream & is );
	CallCreditServiceControl ( );
	enum OptionalFields {
		e_amountString,
		e_billingMode,
		e_callDurationLimit,
		e_enforceCallDurationLimit,
		e_callStartingPoint
	};

	CallCreditServiceControl ( const CallCreditServiceControl & s );
	CallCreditServiceControl & operator= ( const CallCreditServiceControl & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	CallCreditServiceControl_amountString * m_amountString;
	CallCreditServiceControl_billingMode * m_billingMode;
	CallCreditServiceControl_callDurationLimit * m_callDurationLimit;
	Asn :: Boolean * m_enforceCallDurationLimit;
	CallCreditServiceControl_callStartingPoint * m_callStartingPoint;
	public:
	void encode ( Asn :: ostream & os ) const;
	~CallCreditServiceControl ( );
	void printOn ( std :: ostream & os ) const;
	const CallCreditServiceControl_amountString & get_amountString ( ) const {
		return * m_amountString;
	}
	CallCreditServiceControl_amountString & get_amountString ( ) {
		return * m_amountString;
	}
	const CallCreditServiceControl_billingMode & get_billingMode ( ) const {
		return * m_billingMode;
	}
	CallCreditServiceControl_billingMode & get_billingMode ( ) {
		return * m_billingMode;
	}
	const CallCreditServiceControl_callDurationLimit & get_callDurationLimit ( ) const {
		return * m_callDurationLimit;
	}
	CallCreditServiceControl_callDurationLimit & get_callDurationLimit ( ) {
		return * m_callDurationLimit;
	}
	const Asn :: Boolean & get_enforceCallDurationLimit ( ) const {
		return * m_enforceCallDurationLimit;
	}
	Asn :: Boolean & get_enforceCallDurationLimit ( ) {
		return * m_enforceCallDurationLimit;
	}
	const CallCreditServiceControl_callStartingPoint & get_callStartingPoint ( ) const {
		return * m_callStartingPoint;
	}
	CallCreditServiceControl_callStartingPoint & get_callStartingPoint ( ) {
		return * m_callStartingPoint;
	}
	CallCreditServiceControl * clone ( ) const;
};

//
// FeatureSet
//

// from 0 size 0 type 0 simple 0
class ArrayOf_FeatureDescriptor;

class FeatureSet : public Asn :: Sequence {
	public:
	explicit FeatureSet ( Asn :: istream & is );
	FeatureSet ( );
	enum OptionalFields {
		e_neededFeatures,
		e_desiredFeatures,
		e_supportedFeatures
	};

	FeatureSet ( const FeatureSet & s );
	FeatureSet & operator= ( const FeatureSet & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	Asn :: Boolean m_replacementFeatureSet;
	protected:
	ArrayOf_FeatureDescriptor * m_neededFeatures;
	ArrayOf_FeatureDescriptor * m_desiredFeatures;
	ArrayOf_FeatureDescriptor * m_supportedFeatures;
	public:
	void encode ( Asn :: ostream & os ) const;
	~FeatureSet ( );
	void printOn ( std :: ostream & os ) const;
	const ArrayOf_FeatureDescriptor & get_neededFeatures ( ) const {
		return * m_neededFeatures;
	}
	ArrayOf_FeatureDescriptor & get_neededFeatures ( ) {
		return * m_neededFeatures;
	}
	const ArrayOf_FeatureDescriptor & get_desiredFeatures ( ) const {
		return * m_desiredFeatures;
	}
	ArrayOf_FeatureDescriptor & get_desiredFeatures ( ) {
		return * m_desiredFeatures;
	}
	const ArrayOf_FeatureDescriptor & get_supportedFeatures ( ) const {
		return * m_supportedFeatures;
	}
	ArrayOf_FeatureDescriptor & get_supportedFeatures ( ) {
		return * m_supportedFeatures;
	}
	FeatureSet * clone ( ) const;
};

//
// TransportChannelInfo
//

// from 0 size 0 type 0 simple 0
class TransportAddress;

class TransportChannelInfo : public Asn :: Sequence {
	public:
	explicit TransportChannelInfo ( Asn :: istream & is );
	TransportChannelInfo ( );
	enum OptionalFields {
		e_sendAddress,
		e_recvAddress
	};

	TransportChannelInfo ( const TransportChannelInfo & s );
	TransportChannelInfo & operator= ( const TransportChannelInfo & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	TransportAddress * m_sendAddress;
	TransportAddress * m_recvAddress;
	public:
	void encode ( Asn :: ostream & os ) const;
	~TransportChannelInfo ( );
	void printOn ( std :: ostream & os ) const;
	const TransportAddress & get_sendAddress ( ) const {
		return * m_sendAddress;
	}
	TransportAddress & get_sendAddress ( ) {
		return * m_sendAddress;
	}
	const TransportAddress & get_recvAddress ( ) const {
		return * m_recvAddress;
	}
	TransportAddress & get_recvAddress ( ) {
		return * m_recvAddress;
	}
	TransportChannelInfo * clone ( ) const;
};

//
// RehomingModel
//

// from 0 size 0 type 0 simple 0
class RehomingModel : public Asn :: Choice {
	public:
	explicit RehomingModel ( Asn :: istream & is );
	RehomingModel ( );
	enum Choices {
		e_gatekeeperBased,
		e_endpointBased
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	RehomingModel * clone ( ) const;
};

//
// GatekeeperRejectReason
//

// from 0 size 0 type 0 simple 0
class GatekeeperRejectReason : public Asn :: Choice {
	public:
	explicit GatekeeperRejectReason ( Asn :: istream & is );
	GatekeeperRejectReason ( );
	enum Choices {
		e_resourceUnavailable,
		e_terminalExcluded,
		e_invalidRevision,
		e_undefinedReason,
		e_securityDenial,
		e_genericDataReason,
		e_neededFeatureNotSupported,
		e_securityError
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator SecurityErrors & ( ) { return dynamic_cast < SecurityErrors & > ( * choice ); }
	operator const SecurityErrors & ( ) const { return dynamic_cast < const SecurityErrors & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	GatekeeperRejectReason * clone ( ) const;
};

//
// UnregRequestReason
//

// from 0 size 0 type 0 simple 0
class UnregRequestReason : public Asn :: Choice {
	public:
	explicit UnregRequestReason ( Asn :: istream & is );
	UnregRequestReason ( );
	enum Choices {
		e_reregistrationRequired,
		e_ttlExpired,
		e_securityDenial,
		e_undefinedReason,
		e_maintenance,
		e_securityError,
		e_registerWithAssignedGK
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator SecurityErrors2 & ( ) { return dynamic_cast < SecurityErrors2 & > ( * choice ); }
	operator const SecurityErrors2 & ( ) const { return dynamic_cast < const SecurityErrors2 & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	UnregRequestReason * clone ( ) const;
};

//
// UnregistrationConfirm
//

// from 0 size 0 type 0 simple 0
class AlternateGK;

class UnregistrationConfirm : public Asn :: Sequence {
	public:
	explicit UnregistrationConfirm ( Asn :: istream & is );
	UnregistrationConfirm ( );
	enum OptionalFields {
		e_nonStandardData,
		e_tokens,
		e_cryptoTokens,
		e_integrityCheckValue,
		e_genericData,
		e_assignedGatekeeper
	};

	UnregistrationConfirm ( const UnregistrationConfirm & s );
	UnregistrationConfirm & operator= ( const UnregistrationConfirm & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	RequestSeqNum m_requestSeqNum;
	protected:
	NonStandardParameter * m_nonStandardData;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ICV * m_integrityCheckValue;
	ArrayOf_GenericData * m_genericData;
	AlternateGK * m_assignedGatekeeper;
	public:
	void encode ( Asn :: ostream & os ) const;
	~UnregistrationConfirm ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ICV & get_integrityCheckValue ( ) const {
		return * m_integrityCheckValue;
	}
	ICV & get_integrityCheckValue ( ) {
		return * m_integrityCheckValue;
	}
	const ArrayOf_GenericData & get_genericData ( ) const {
		return * m_genericData;
	}
	ArrayOf_GenericData & get_genericData ( ) {
		return * m_genericData;
	}
	const AlternateGK & get_assignedGatekeeper ( ) const {
		return * m_assignedGatekeeper;
	}
	AlternateGK & get_assignedGatekeeper ( ) {
		return * m_assignedGatekeeper;
	}
	UnregistrationConfirm * clone ( ) const;
};

//
// UnregRejectReason
//

// from 0 size 0 type 0 simple 0
class UnregRejectReason : public Asn :: Choice {
	public:
	explicit UnregRejectReason ( Asn :: istream & is );
	UnregRejectReason ( );
	enum Choices {
		e_notCurrentlyRegistered,
		e_callInProgress,
		e_undefinedReason,
		e_permissionDenied,
		e_securityDenial,
		e_securityError
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator SecurityErrors2 & ( ) { return dynamic_cast < SecurityErrors2 & > ( * choice ); }
	operator const SecurityErrors2 & ( ) const { return dynamic_cast < const SecurityErrors2 & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	UnregRejectReason * clone ( ) const;
};

//
// CallType
//

// from 0 size 0 type 0 simple 0
class CallType : public Asn :: Choice {
	public:
	explicit CallType ( Asn :: istream & is );
	CallType ( );
	enum Choices {
		e_pointToPoint,
		e_oneToN,
		e_nToOne,
		e_nToN
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	CallType * clone ( ) const;
};

//
// CallModel
//

// from 0 size 0 type 0 simple 0
class CallModel : public Asn :: Choice {
	public:
	explicit CallModel ( Asn :: istream & is );
	CallModel ( );
	enum Choices {
		e_direct,
		e_gatekeeperRouted
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	CallModel * clone ( ) const;
};

//
// UUIEsRequested
//

// from 0 size 0 type 0 simple 0
class UUIEsRequested : public Asn :: Sequence {
	public:
	explicit UUIEsRequested ( Asn :: istream & is );
	UUIEsRequested ( );
	enum OptionalFields {
		e_status,
		e_statusInquiry,
		e_setupAcknowledge,
		e_notify
	};

	UUIEsRequested ( const UUIEsRequested & s );
	UUIEsRequested & operator= ( const UUIEsRequested & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	Asn :: Boolean m_setup;
	Asn :: Boolean m_callProceeding;
	Asn :: Boolean m_connect;
	Asn :: Boolean m_alerting;
	Asn :: Boolean m_information;
	Asn :: Boolean m_releaseComplete;
	Asn :: Boolean m_facility;
	Asn :: Boolean m_progress;
	Asn :: Boolean m_empty;
	protected:
	Asn :: Boolean * m_status;
	Asn :: Boolean * m_statusInquiry;
	Asn :: Boolean * m_setupAcknowledge;
	Asn :: Boolean * m_notify;
	public:
	void encode ( Asn :: ostream & os ) const;
	~UUIEsRequested ( );
	void printOn ( std :: ostream & os ) const;
	const Asn :: Boolean & get_status ( ) const {
		return * m_status;
	}
	Asn :: Boolean & get_status ( ) {
		return * m_status;
	}
	const Asn :: Boolean & get_statusInquiry ( ) const {
		return * m_statusInquiry;
	}
	Asn :: Boolean & get_statusInquiry ( ) {
		return * m_statusInquiry;
	}
	const Asn :: Boolean & get_setupAcknowledge ( ) const {
		return * m_setupAcknowledge;
	}
	Asn :: Boolean & get_setupAcknowledge ( ) {
		return * m_setupAcknowledge;
	}
	const Asn :: Boolean & get_notify ( ) const {
		return * m_notify;
	}
	Asn :: Boolean & get_notify ( ) {
		return * m_notify;
	}
	UUIEsRequested * clone ( ) const;
};

//
// BandwidthRequest
//

// from 0 size 0 type 0 simple 0
class RasUsageInformation;
class ArrayOf_BandwidthDetails;
class TransportQOS;

class BandwidthRequest : public Asn :: Sequence {
	public:
	explicit BandwidthRequest ( Asn :: istream & is );
	BandwidthRequest ( );
	enum OptionalFields {
		e_callType,
		e_nonStandardData,
		e_callIdentifier,
		e_gatekeeperIdentifier,
		e_tokens,
		e_cryptoTokens,
		e_integrityCheckValue,
		e_answeredCall,
		e_callLinkage,
		e_capacity,
		e_usageInformation,
		e_bandwidthDetails,
		e_genericData,
		e_transportQOS
	};

	BandwidthRequest ( const BandwidthRequest & s );
	BandwidthRequest & operator= ( const BandwidthRequest & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	RequestSeqNum m_requestSeqNum;
	EndpointIdentifier m_endpointIdentifier;
	ConferenceIdentifier m_conferenceID;
	CallReferenceValue m_callReferenceValue;
	protected:
	CallType * m_callType;
	public:
	BandWidth m_bandWidth;
	protected:
	NonStandardParameter * m_nonStandardData;
	CallIdentifier * m_callIdentifier;
	GatekeeperIdentifier * m_gatekeeperIdentifier;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ICV * m_integrityCheckValue;
	Asn :: Boolean * m_answeredCall;
	CallLinkage * m_callLinkage;
	CallCapacity * m_capacity;
	RasUsageInformation * m_usageInformation;
	ArrayOf_BandwidthDetails * m_bandwidthDetails;
	ArrayOf_GenericData * m_genericData;
	TransportQOS * m_transportQOS;
	public:
	void encode ( Asn :: ostream & os ) const;
	~BandwidthRequest ( );
	void printOn ( std :: ostream & os ) const;
	const CallType & get_callType ( ) const {
		return * m_callType;
	}
	CallType & get_callType ( ) {
		return * m_callType;
	}
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const CallIdentifier & get_callIdentifier ( ) const {
		return * m_callIdentifier;
	}
	CallIdentifier & get_callIdentifier ( ) {
		return * m_callIdentifier;
	}
	const GatekeeperIdentifier & get_gatekeeperIdentifier ( ) const {
		return * m_gatekeeperIdentifier;
	}
	GatekeeperIdentifier & get_gatekeeperIdentifier ( ) {
		return * m_gatekeeperIdentifier;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ICV & get_integrityCheckValue ( ) const {
		return * m_integrityCheckValue;
	}
	ICV & get_integrityCheckValue ( ) {
		return * m_integrityCheckValue;
	}
	const Asn :: Boolean & get_answeredCall ( ) const {
		return * m_answeredCall;
	}
	Asn :: Boolean & get_answeredCall ( ) {
		return * m_answeredCall;
	}
	const CallLinkage & get_callLinkage ( ) const {
		return * m_callLinkage;
	}
	CallLinkage & get_callLinkage ( ) {
		return * m_callLinkage;
	}
	const CallCapacity & get_capacity ( ) const {
		return * m_capacity;
	}
	CallCapacity & get_capacity ( ) {
		return * m_capacity;
	}
	const RasUsageInformation & get_usageInformation ( ) const {
		return * m_usageInformation;
	}
	RasUsageInformation & get_usageInformation ( ) {
		return * m_usageInformation;
	}
	const ArrayOf_BandwidthDetails & get_bandwidthDetails ( ) const {
		return * m_bandwidthDetails;
	}
	ArrayOf_BandwidthDetails & get_bandwidthDetails ( ) {
		return * m_bandwidthDetails;
	}
	const ArrayOf_GenericData & get_genericData ( ) const {
		return * m_genericData;
	}
	ArrayOf_GenericData & get_genericData ( ) {
		return * m_genericData;
	}
	const TransportQOS & get_transportQOS ( ) const {
		return * m_transportQOS;
	}
	TransportQOS & get_transportQOS ( ) {
		return * m_transportQOS;
	}
	BandwidthRequest * clone ( ) const;
};

//
// BandwidthConfirm
//

// from 0 size 0 type 0 simple 0
class BandwidthConfirm : public Asn :: Sequence {
	public:
	explicit BandwidthConfirm ( Asn :: istream & is );
	BandwidthConfirm ( );
	enum OptionalFields {
		e_nonStandardData,
		e_tokens,
		e_cryptoTokens,
		e_integrityCheckValue,
		e_capacity,
		e_genericData,
		e_transportQOS
	};

	BandwidthConfirm ( const BandwidthConfirm & s );
	BandwidthConfirm & operator= ( const BandwidthConfirm & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	RequestSeqNum m_requestSeqNum;
	BandWidth m_bandWidth;
	protected:
	NonStandardParameter * m_nonStandardData;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ICV * m_integrityCheckValue;
	CallCapacity * m_capacity;
	ArrayOf_GenericData * m_genericData;
	TransportQOS * m_transportQOS;
	public:
	void encode ( Asn :: ostream & os ) const;
	~BandwidthConfirm ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ICV & get_integrityCheckValue ( ) const {
		return * m_integrityCheckValue;
	}
	ICV & get_integrityCheckValue ( ) {
		return * m_integrityCheckValue;
	}
	const CallCapacity & get_capacity ( ) const {
		return * m_capacity;
	}
	CallCapacity & get_capacity ( ) {
		return * m_capacity;
	}
	const ArrayOf_GenericData & get_genericData ( ) const {
		return * m_genericData;
	}
	ArrayOf_GenericData & get_genericData ( ) {
		return * m_genericData;
	}
	const TransportQOS & get_transportQOS ( ) const {
		return * m_transportQOS;
	}
	TransportQOS & get_transportQOS ( ) {
		return * m_transportQOS;
	}
	BandwidthConfirm * clone ( ) const;
};

//
// BandRejectReason
//

// from 0 size 0 type 0 simple 0
class BandRejectReason : public Asn :: Choice {
	public:
	explicit BandRejectReason ( Asn :: istream & is );
	BandRejectReason ( );
	enum Choices {
		e_notBound,
		e_invalidConferenceID,
		e_invalidPermission,
		e_insufficientResources,
		e_invalidRevision,
		e_undefinedReason,
		e_securityDenial,
		e_securityError
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator SecurityErrors2 & ( ) { return dynamic_cast < SecurityErrors2 & > ( * choice ); }
	operator const SecurityErrors2 & ( ) const { return dynamic_cast < const SecurityErrors2 & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	BandRejectReason * clone ( ) const;
};

//
// DisengageReason
//

// from 0 size 0 type 0 simple 0
class DisengageReason : public Asn :: Choice {
	public:
	explicit DisengageReason ( Asn :: istream & is );
	DisengageReason ( );
	enum Choices {
		e_forcedDrop,
		e_normalDrop,
		e_undefinedReason
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	DisengageReason * clone ( ) const;
};

//
// DisengageConfirm
//

// from 0 size 0 type 0 simple 0
class DisengageConfirm : public Asn :: Sequence {
	public:
	explicit DisengageConfirm ( Asn :: istream & is );
	DisengageConfirm ( );
	enum OptionalFields {
		e_nonStandardData,
		e_tokens,
		e_cryptoTokens,
		e_integrityCheckValue,
		e_capacity,
		e_circuitInfo,
		e_usageInformation,
		e_genericData,
		e_assignedGatekeeper
	};

	DisengageConfirm ( const DisengageConfirm & s );
	DisengageConfirm & operator= ( const DisengageConfirm & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	RequestSeqNum m_requestSeqNum;
	protected:
	NonStandardParameter * m_nonStandardData;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ICV * m_integrityCheckValue;
	CallCapacity * m_capacity;
	CircuitInfo * m_circuitInfo;
	RasUsageInformation * m_usageInformation;
	ArrayOf_GenericData * m_genericData;
	AlternateGK * m_assignedGatekeeper;
	public:
	void encode ( Asn :: ostream & os ) const;
	~DisengageConfirm ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ICV & get_integrityCheckValue ( ) const {
		return * m_integrityCheckValue;
	}
	ICV & get_integrityCheckValue ( ) {
		return * m_integrityCheckValue;
	}
	const CallCapacity & get_capacity ( ) const {
		return * m_capacity;
	}
	CallCapacity & get_capacity ( ) {
		return * m_capacity;
	}
	const CircuitInfo & get_circuitInfo ( ) const {
		return * m_circuitInfo;
	}
	CircuitInfo & get_circuitInfo ( ) {
		return * m_circuitInfo;
	}
	const RasUsageInformation & get_usageInformation ( ) const {
		return * m_usageInformation;
	}
	RasUsageInformation & get_usageInformation ( ) {
		return * m_usageInformation;
	}
	const ArrayOf_GenericData & get_genericData ( ) const {
		return * m_genericData;
	}
	ArrayOf_GenericData & get_genericData ( ) {
		return * m_genericData;
	}
	const AlternateGK & get_assignedGatekeeper ( ) const {
		return * m_assignedGatekeeper;
	}
	AlternateGK & get_assignedGatekeeper ( ) {
		return * m_assignedGatekeeper;
	}
	DisengageConfirm * clone ( ) const;
};

//
// DisengageRejectReason
//

// from 0 size 0 type 0 simple 0
class DisengageRejectReason : public Asn :: Choice {
	public:
	explicit DisengageRejectReason ( Asn :: istream & is );
	DisengageRejectReason ( );
	enum Choices {
		e_notRegistered,
		e_requestToDropOther,
		e_securityDenial,
		e_securityError
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator SecurityErrors2 & ( ) { return dynamic_cast < SecurityErrors2 & > ( * choice ); }
	operator const SecurityErrors2 & ( ) const { return dynamic_cast < const SecurityErrors2 & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	DisengageRejectReason * clone ( ) const;
};

//
// InfoRequest
//

// from 0 size 0 type 0 simple 0
class RasUsageInfoTypes;
class InfoRequest_nextSegmentRequested;

class InfoRequest : public Asn :: Sequence {
	public:
	explicit InfoRequest ( Asn :: istream & is );
	InfoRequest ( );
	enum OptionalFields {
		e_nonStandardData,
		e_replyAddress,
		e_callIdentifier,
		e_tokens,
		e_cryptoTokens,
		e_integrityCheckValue,
		e_uuiesRequested,
		e_callLinkage,
		e_usageInfoRequested,
		e_segmentedResponseSupported,
		e_nextSegmentRequested,
		e_capacityInfoRequested,
		e_genericData,
		e_assignedGatekeeper
	};

	InfoRequest ( const InfoRequest & s );
	InfoRequest & operator= ( const InfoRequest & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	RequestSeqNum m_requestSeqNum;
	CallReferenceValue m_callReferenceValue;
	protected:
	NonStandardParameter * m_nonStandardData;
	TransportAddress * m_replyAddress;
	CallIdentifier * m_callIdentifier;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ICV * m_integrityCheckValue;
	UUIEsRequested * m_uuiesRequested;
	CallLinkage * m_callLinkage;
	RasUsageInfoTypes * m_usageInfoRequested;
	Asn :: Null * m_segmentedResponseSupported;
	InfoRequest_nextSegmentRequested * m_nextSegmentRequested;
	Asn :: Null * m_capacityInfoRequested;
	ArrayOf_GenericData * m_genericData;
	AlternateGK * m_assignedGatekeeper;
	public:
	void encode ( Asn :: ostream & os ) const;
	~InfoRequest ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const TransportAddress & get_replyAddress ( ) const {
		return * m_replyAddress;
	}
	TransportAddress & get_replyAddress ( ) {
		return * m_replyAddress;
	}
	const CallIdentifier & get_callIdentifier ( ) const {
		return * m_callIdentifier;
	}
	CallIdentifier & get_callIdentifier ( ) {
		return * m_callIdentifier;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ICV & get_integrityCheckValue ( ) const {
		return * m_integrityCheckValue;
	}
	ICV & get_integrityCheckValue ( ) {
		return * m_integrityCheckValue;
	}
	const UUIEsRequested & get_uuiesRequested ( ) const {
		return * m_uuiesRequested;
	}
	UUIEsRequested & get_uuiesRequested ( ) {
		return * m_uuiesRequested;
	}
	const CallLinkage & get_callLinkage ( ) const {
		return * m_callLinkage;
	}
	CallLinkage & get_callLinkage ( ) {
		return * m_callLinkage;
	}
	const RasUsageInfoTypes & get_usageInfoRequested ( ) const {
		return * m_usageInfoRequested;
	}
	RasUsageInfoTypes & get_usageInfoRequested ( ) {
		return * m_usageInfoRequested;
	}
	const Asn :: Null & get_segmentedResponseSupported ( ) const {
		return * m_segmentedResponseSupported;
	}
	Asn :: Null & get_segmentedResponseSupported ( ) {
		return * m_segmentedResponseSupported;
	}
	const InfoRequest_nextSegmentRequested & get_nextSegmentRequested ( ) const {
		return * m_nextSegmentRequested;
	}
	InfoRequest_nextSegmentRequested & get_nextSegmentRequested ( ) {
		return * m_nextSegmentRequested;
	}
	const Asn :: Null & get_capacityInfoRequested ( ) const {
		return * m_capacityInfoRequested;
	}
	Asn :: Null & get_capacityInfoRequested ( ) {
		return * m_capacityInfoRequested;
	}
	const ArrayOf_GenericData & get_genericData ( ) const {
		return * m_genericData;
	}
	ArrayOf_GenericData & get_genericData ( ) {
		return * m_genericData;
	}
	const AlternateGK & get_assignedGatekeeper ( ) const {
		return * m_assignedGatekeeper;
	}
	AlternateGK & get_assignedGatekeeper ( ) {
		return * m_assignedGatekeeper;
	}
	InfoRequest * clone ( ) const;
};

//
// InfoRequestAck
//

// from 0 size 0 type 0 simple 0
class InfoRequestAck : public Asn :: Sequence {
	public:
	explicit InfoRequestAck ( Asn :: istream & is );
	InfoRequestAck ( );
	enum OptionalFields {
		e_nonStandardData,
		e_tokens,
		e_cryptoTokens,
		e_integrityCheckValue
	};

	InfoRequestAck ( const InfoRequestAck & s );
	InfoRequestAck & operator= ( const InfoRequestAck & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	RequestSeqNum m_requestSeqNum;
	protected:
	NonStandardParameter * m_nonStandardData;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ICV * m_integrityCheckValue;
	public:
	void encode ( Asn :: ostream & os ) const;
	~InfoRequestAck ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ICV & get_integrityCheckValue ( ) const {
		return * m_integrityCheckValue;
	}
	ICV & get_integrityCheckValue ( ) {
		return * m_integrityCheckValue;
	}
	InfoRequestAck * clone ( ) const;
};

//
// InfoRequestNakReason
//

// from 0 size 0 type 0 simple 0
class InfoRequestNakReason : public Asn :: Choice {
	public:
	explicit InfoRequestNakReason ( Asn :: istream & is );
	InfoRequestNakReason ( );
	enum Choices {
		e_notRegistered,
		e_securityDenial,
		e_undefinedReason,
		e_securityError
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator SecurityErrors2 & ( ) { return dynamic_cast < SecurityErrors2 & > ( * choice ); }
	operator const SecurityErrors2 & ( ) const { return dynamic_cast < const SecurityErrors2 & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	InfoRequestNakReason * clone ( ) const;
};

//
// UnknownMessageResponse
//

// from 0 size 0 type 0 simple 0
class UnknownMessageResponse : public Asn :: Sequence {
	public:
	explicit UnknownMessageResponse ( Asn :: istream & is );
	UnknownMessageResponse ( );
	enum OptionalFields {
		e_tokens,
		e_cryptoTokens,
		e_integrityCheckValue,
		e_messageNotUnderstood
	};

	UnknownMessageResponse ( const UnknownMessageResponse & s );
	UnknownMessageResponse & operator= ( const UnknownMessageResponse & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	RequestSeqNum m_requestSeqNum;
	protected:
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ICV * m_integrityCheckValue;
	Asn :: OctetString * m_messageNotUnderstood;
	public:
	void encode ( Asn :: ostream & os ) const;
	~UnknownMessageResponse ( );
	void printOn ( std :: ostream & os ) const;
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ICV & get_integrityCheckValue ( ) const {
		return * m_integrityCheckValue;
	}
	ICV & get_integrityCheckValue ( ) {
		return * m_integrityCheckValue;
	}
	const Asn :: OctetString & get_messageNotUnderstood ( ) const {
		return * m_messageNotUnderstood;
	}
	Asn :: OctetString & get_messageNotUnderstood ( ) {
		return * m_messageNotUnderstood;
	}
	UnknownMessageResponse * clone ( ) const;
};

//
// ResourcesAvailableConfirm
//

// from 0 size 0 type 0 simple 0
class ResourcesAvailableConfirm : public Asn :: Sequence {
	public:
	explicit ResourcesAvailableConfirm ( Asn :: istream & is );
	ResourcesAvailableConfirm ( );
	enum OptionalFields {
		e_nonStandardData,
		e_tokens,
		e_cryptoTokens,
		e_integrityCheckValue,
		e_genericData
	};

	ResourcesAvailableConfirm ( const ResourcesAvailableConfirm & s );
	ResourcesAvailableConfirm & operator= ( const ResourcesAvailableConfirm & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	RequestSeqNum m_requestSeqNum;
	ProtocolIdentifier m_protocolIdentifier;
	protected:
	NonStandardParameter * m_nonStandardData;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ICV * m_integrityCheckValue;
	ArrayOf_GenericData * m_genericData;
	public:
	void encode ( Asn :: ostream & os ) const;
	~ResourcesAvailableConfirm ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ICV & get_integrityCheckValue ( ) const {
		return * m_integrityCheckValue;
	}
	ICV & get_integrityCheckValue ( ) {
		return * m_integrityCheckValue;
	}
	const ArrayOf_GenericData & get_genericData ( ) const {
		return * m_genericData;
	}
	ArrayOf_GenericData & get_genericData ( ) {
		return * m_genericData;
	}
	ResourcesAvailableConfirm * clone ( ) const;
};

//
// ServiceControlResponse
//

// from 0 size 0 type 0 simple 0
class ServiceControlResponse_result;

class ServiceControlResponse : public Asn :: Sequence {
	public:
	explicit ServiceControlResponse ( Asn :: istream & is );
	ServiceControlResponse ( );
	enum OptionalFields {
		e_result,
		e_nonStandardData,
		e_tokens,
		e_cryptoTokens,
		e_integrityCheckValue,
		e_featureSet,
		e_genericData
	};

	ServiceControlResponse ( const ServiceControlResponse & s );
	ServiceControlResponse & operator= ( const ServiceControlResponse & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	RequestSeqNum m_requestSeqNum;
	protected:
	ServiceControlResponse_result * m_result;
	NonStandardParameter * m_nonStandardData;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ICV * m_integrityCheckValue;
	FeatureSet * m_featureSet;
	ArrayOf_GenericData * m_genericData;
	public:
	void encode ( Asn :: ostream & os ) const;
	~ServiceControlResponse ( );
	void printOn ( std :: ostream & os ) const;
	const ServiceControlResponse_result & get_result ( ) const {
		return * m_result;
	}
	ServiceControlResponse_result & get_result ( ) {
		return * m_result;
	}
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ICV & get_integrityCheckValue ( ) const {
		return * m_integrityCheckValue;
	}
	ICV & get_integrityCheckValue ( ) {
		return * m_integrityCheckValue;
	}
	const FeatureSet & get_featureSet ( ) const {
		return * m_featureSet;
	}
	FeatureSet & get_featureSet ( ) {
		return * m_featureSet;
	}
	const ArrayOf_GenericData & get_genericData ( ) const {
		return * m_genericData;
	}
	ArrayOf_GenericData & get_genericData ( ) {
		return * m_genericData;
	}
	ServiceControlResponse * clone ( ) const;
};

//
// ArrayOf_Asn_OctetString
//

// from 0 size 0 type 0 simple 0
class ArrayOf_Asn_OctetString : public Asn :: Array {
	public:
	explicit ArrayOf_Asn_OctetString ( Asn :: istream & is );
	ArrayOf_Asn_OctetString ( );
	explicit ArrayOf_Asn_OctetString ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const Asn :: OctetString & o );
	const Asn :: OctetString & operator[] ( std :: size_t i ) const;
	Asn :: OctetString & operator[] ( std :: size_t i );
	ArrayOf_Asn_OctetString * clone ( ) const;
};

//
// ArrayOf_NonStandardParameter
//

// from 0 size 0 type 0 simple 0
class ArrayOf_NonStandardParameter : public Asn :: Array {
	public:
	explicit ArrayOf_NonStandardParameter ( Asn :: istream & is );
	ArrayOf_NonStandardParameter ( );
	explicit ArrayOf_NonStandardParameter ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const NonStandardParameter & o );
	const NonStandardParameter & operator[] ( std :: size_t i ) const;
	NonStandardParameter & operator[] ( std :: size_t i );
	ArrayOf_NonStandardParameter * clone ( ) const;
};

//
// ArrayOf_GenericData
//

// from 0 size 0 type 0 simple 0
class GenericData;

class ArrayOf_GenericData : public Asn :: Array {
	public:
	explicit ArrayOf_GenericData ( Asn :: istream & is );
	ArrayOf_GenericData ( );
	explicit ArrayOf_GenericData ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const GenericData & o );
	const GenericData & operator[] ( std :: size_t i ) const;
	GenericData & operator[] ( std :: size_t i );
	ArrayOf_GenericData * clone ( ) const;
};

//
// ArrayOf_ClearToken
//

// from 0 size 0 type 0 simple 0
class ArrayOf_ClearToken : public Asn :: Array {
	public:
	explicit ArrayOf_ClearToken ( Asn :: istream & is );
	ArrayOf_ClearToken ( );
	explicit ArrayOf_ClearToken ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const H235 :: ClearToken & o );
	const H235 :: ClearToken & operator[] ( std :: size_t i ) const;
	H235 :: ClearToken & operator[] ( std :: size_t i );
	ArrayOf_ClearToken * clone ( ) const;
};

//
// ArrayOf_CryptoH323Token
//

// from 0 size 0 type 0 simple 0
class CryptoH323Token;

class ArrayOf_CryptoH323Token : public Asn :: Array {
	public:
	explicit ArrayOf_CryptoH323Token ( Asn :: istream & is );
	ArrayOf_CryptoH323Token ( );
	explicit ArrayOf_CryptoH323Token ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const CryptoH323Token & o );
	const CryptoH323Token & operator[] ( std :: size_t i ) const;
	CryptoH323Token & operator[] ( std :: size_t i );
	ArrayOf_CryptoH323Token * clone ( ) const;
};

//
// ArrayOf_AliasAddress
//

// from 0 size 0 type 0 simple 0
class ArrayOf_AliasAddress : public Asn :: Array {
	public:
	explicit ArrayOf_AliasAddress ( Asn :: istream & is );
	ArrayOf_AliasAddress ( );
	explicit ArrayOf_AliasAddress ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const AliasAddress & o );
	const AliasAddress & operator[] ( std :: size_t i ) const;
	AliasAddress & operator[] ( std :: size_t i );
	ArrayOf_AliasAddress * clone ( ) const;
};

//
// ArrayOf_ServiceControlSession
//

// from 0 size 0 type 0 simple 0
class ServiceControlSession;

class ArrayOf_ServiceControlSession : public Asn :: Array {
	public:
	explicit ArrayOf_ServiceControlSession ( Asn :: istream & is );
	ArrayOf_ServiceControlSession ( );
	explicit ArrayOf_ServiceControlSession ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const ServiceControlSession & o );
	const ServiceControlSession & operator[] ( std :: size_t i ) const;
	ServiceControlSession & operator[] ( std :: size_t i );
	ArrayOf_ServiceControlSession * clone ( ) const;
};

//
// Connect-UUIE_language
//

// from 0 size 0 type 0 simple 0
class Connect_UUIE_language_subtype;

class Connect_UUIE_language : public Asn :: Array {
	public:
	explicit Connect_UUIE_language ( Asn :: istream & is );
	Connect_UUIE_language ( );
	explicit Connect_UUIE_language ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const Connect_UUIE_language_subtype & o );
	const Connect_UUIE_language_subtype & operator[] ( std :: size_t i ) const;
	Connect_UUIE_language_subtype & operator[] ( std :: size_t i );
	Connect_UUIE_language * clone ( ) const;
};

//
// ArrayOf_CallReferenceValue
//

// from 0 size 0 type 0 simple 0
class ArrayOf_CallReferenceValue : public Asn :: Array {
	public:
	explicit ArrayOf_CallReferenceValue ( Asn :: istream & is );
	ArrayOf_CallReferenceValue ( );
	explicit ArrayOf_CallReferenceValue ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const CallReferenceValue & o );
	const CallReferenceValue & operator[] ( std :: size_t i ) const;
	CallReferenceValue & operator[] ( std :: size_t i );
	ArrayOf_CallReferenceValue * clone ( ) const;
};

//
// Setup-UUIE_conferenceGoal
//

// from 0 size 0 type 0 simple 0
class Setup_UUIE_conferenceGoal : public Asn :: Choice {
	public:
	explicit Setup_UUIE_conferenceGoal ( Asn :: istream & is );
	Setup_UUIE_conferenceGoal ( );
	enum Choices {
		e_create,
		e_join,
		e_invite,
		e_capability_negotiation,
		e_callIndependentSupplementaryService
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	Setup_UUIE_conferenceGoal * clone ( ) const;
};

//
// ArrayOf_H245Security
//

// from 0 size 0 type 0 simple 0
class H245Security;

class ArrayOf_H245Security : public Asn :: Array {
	public:
	explicit ArrayOf_H245Security ( Asn :: istream & is );
	ArrayOf_H245Security ( );
	explicit ArrayOf_H245Security ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const H245Security & o );
	const H245Security & operator[] ( std :: size_t i ) const;
	H245Security & operator[] ( std :: size_t i );
	ArrayOf_H245Security * clone ( ) const;
};

//
// Setup-UUIE_language
//

// from 0 size 0 type 0 simple 0
class Setup_UUIE_language_subtype;

class Setup_UUIE_language : public Asn :: Array {
	public:
	explicit Setup_UUIE_language ( Asn :: istream & is );
	Setup_UUIE_language ( );
	explicit Setup_UUIE_language ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const Setup_UUIE_language_subtype & o );
	const Setup_UUIE_language_subtype & operator[] ( std :: size_t i ) const;
	Setup_UUIE_language_subtype & operator[] ( std :: size_t i );
	Setup_UUIE_language * clone ( ) const;
};

//
// ArrayOf_SupportedProtocols
//

// from 0 size 0 type 0 simple 0
class SupportedProtocols;

class ArrayOf_SupportedProtocols : public Asn :: Array {
	public:
	explicit ArrayOf_SupportedProtocols ( Asn :: istream & is );
	ArrayOf_SupportedProtocols ( );
	explicit ArrayOf_SupportedProtocols ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const SupportedProtocols & o );
	const SupportedProtocols & operator[] ( std :: size_t i ) const;
	SupportedProtocols & operator[] ( std :: size_t i );
	ArrayOf_SupportedProtocols * clone ( ) const;
};

//
// ArrayOf_FeatureDescriptor
//

// from 0 size 0 type 0 simple 0
class FeatureDescriptor;

class ArrayOf_FeatureDescriptor : public Asn :: Array {
	public:
	explicit ArrayOf_FeatureDescriptor ( Asn :: istream & is );
	ArrayOf_FeatureDescriptor ( );
	explicit ArrayOf_FeatureDescriptor ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const FeatureDescriptor & o );
	const FeatureDescriptor & operator[] ( std :: size_t i ) const;
	FeatureDescriptor & operator[] ( std :: size_t i );
	ArrayOf_FeatureDescriptor * clone ( ) const;
};

//
// ArrayOf_ExtendedAliasAddress
//

// from 0 size 0 type 0 simple 0
class ExtendedAliasAddress;

class ArrayOf_ExtendedAliasAddress : public Asn :: Array {
	public:
	explicit ArrayOf_ExtendedAliasAddress ( Asn :: istream & is );
	ArrayOf_ExtendedAliasAddress ( );
	explicit ArrayOf_ExtendedAliasAddress ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const ExtendedAliasAddress & o );
	const ExtendedAliasAddress & operator[] ( std :: size_t i ) const;
	ExtendedAliasAddress & operator[] ( std :: size_t i );
	ArrayOf_ExtendedAliasAddress * clone ( ) const;
};

//
// Setup-UUIE_hopCount
//

// from 0 size 0 type 0 simple 1
class Setup_UUIE_hopCount : public Asn :: Integer {
	public:
	explicit Setup_UUIE_hopCount ( Asn :: istream & is );
	Setup_UUIE_hopCount ( unsigned v = 0 );
	Setup_UUIE_hopCount & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	Setup_UUIE_hopCount & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	Setup_UUIE_hopCount * clone ( ) const;
};

//
// ArrayOf_ConferenceList
//

// from 0 size 0 type 0 simple 0
class ArrayOf_ConferenceList : public Asn :: Array {
	public:
	explicit ArrayOf_ConferenceList ( Asn :: istream & is );
	ArrayOf_ConferenceList ( );
	explicit ArrayOf_ConferenceList ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const ConferenceList & o );
	const ConferenceList & operator[] ( std :: size_t i ) const;
	ConferenceList & operator[] ( std :: size_t i );
	ArrayOf_ConferenceList * clone ( ) const;
};

//
// TransportAddress_netBios
//

// from 0 size 1 type 0 simple 0
class TransportAddress_netBios : public Asn :: OctetString {
	public:
	explicit TransportAddress_netBios ( Asn :: istream & is );
	TransportAddress_netBios ( const Asn :: string & v = Asn :: string ( ) );
	TransportAddress_netBios & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	TransportAddress_netBios * clone ( ) const;
};

//
// TransportAddress_nsap
//

// from 0 size 1 type 0 simple 0
class TransportAddress_nsap : public Asn :: OctetString {
	public:
	explicit TransportAddress_nsap ( Asn :: istream & is );
	TransportAddress_nsap ( const Asn :: string & v = Asn :: string ( ) );
	TransportAddress_nsap & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	TransportAddress_nsap * clone ( ) const;
};

//
// EndpointType_set
//

// from 0 size 1 type 0 simple 0
class EndpointType_set : public Asn :: BitString {
	public:
	explicit EndpointType_set ( Asn :: istream & is );
	EndpointType_set ( const Asn :: string & v = Asn :: string ( ), unsigned b = 0 );
	EndpointType_set * clone ( ) const;
};

//
// ArrayOf_TunnelledProtocol
//

// from 0 size 0 type 0 simple 0
class TunnelledProtocol;

class ArrayOf_TunnelledProtocol : public Asn :: Array {
	public:
	explicit ArrayOf_TunnelledProtocol ( Asn :: istream & is );
	ArrayOf_TunnelledProtocol ( );
	explicit ArrayOf_TunnelledProtocol ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const TunnelledProtocol & o );
	const TunnelledProtocol & operator[] ( std :: size_t i ) const;
	TunnelledProtocol & operator[] ( std :: size_t i );
	ArrayOf_TunnelledProtocol * clone ( ) const;
};

//
// ArrayOf_DataRate
//

// from 0 size 0 type 0 simple 0
class ArrayOf_DataRate : public Asn :: Array {
	public:
	explicit ArrayOf_DataRate ( Asn :: istream & is );
	ArrayOf_DataRate ( );
	explicit ArrayOf_DataRate ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const DataRate & o );
	const DataRate & operator[] ( std :: size_t i ) const;
	DataRate & operator[] ( std :: size_t i );
	ArrayOf_DataRate * clone ( ) const;
};

//
// ArrayOf_SupportedPrefix
//

// from 0 size 0 type 0 simple 0
class SupportedPrefix;

class ArrayOf_SupportedPrefix : public Asn :: Array {
	public:
	explicit ArrayOf_SupportedPrefix ( Asn :: istream & is );
	ArrayOf_SupportedPrefix ( );
	explicit ArrayOf_SupportedPrefix ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const SupportedPrefix & o );
	const SupportedPrefix & operator[] ( std :: size_t i ) const;
	SupportedPrefix & operator[] ( std :: size_t i );
	ArrayOf_SupportedPrefix * clone ( ) const;
};

//
// VendorIdentifier_productId
//

// from 0 size 1 type 0 simple 0
class VendorIdentifier_productId : public Asn :: OctetString {
	public:
	explicit VendorIdentifier_productId ( Asn :: istream & is );
	VendorIdentifier_productId ( const Asn :: string & v = Asn :: string ( ) );
	VendorIdentifier_productId & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	VendorIdentifier_productId * clone ( ) const;
};

//
// VendorIdentifier_versionId
//

// from 0 size 1 type 0 simple 0
class VendorIdentifier_versionId : public Asn :: OctetString {
	public:
	explicit VendorIdentifier_versionId ( Asn :: istream & is );
	VendorIdentifier_versionId ( const Asn :: string & v = Asn :: string ( ) );
	VendorIdentifier_versionId & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	VendorIdentifier_versionId * clone ( ) const;
};

//
// H221NonStandard_t35CountryCode
//

// from 0 size 0 type 0 simple 1
class H221NonStandard_t35CountryCode : public Asn :: Integer {
	public:
	explicit H221NonStandard_t35CountryCode ( Asn :: istream & is );
	H221NonStandard_t35CountryCode ( unsigned v = 0 );
	H221NonStandard_t35CountryCode & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H221NonStandard_t35CountryCode & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H221NonStandard_t35CountryCode * clone ( ) const;
};

//
// H221NonStandard_t35Extension
//

// from 0 size 0 type 0 simple 1
class H221NonStandard_t35Extension : public Asn :: Integer {
	public:
	explicit H221NonStandard_t35Extension ( Asn :: istream & is );
	H221NonStandard_t35Extension ( unsigned v = 0 );
	H221NonStandard_t35Extension & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H221NonStandard_t35Extension & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H221NonStandard_t35Extension * clone ( ) const;
};

//
// H221NonStandard_manufacturerCode
//

// from 0 size 0 type 0 simple 1
class H221NonStandard_manufacturerCode : public Asn :: Integer {
	public:
	explicit H221NonStandard_manufacturerCode ( Asn :: istream & is );
	H221NonStandard_manufacturerCode ( unsigned v = 0 );
	H221NonStandard_manufacturerCode & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H221NonStandard_manufacturerCode & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H221NonStandard_manufacturerCode * clone ( ) const;
};

//
// TunnelledProtocol_subIdentifier
//

// from 0 size 1 type 0 simple 0
class TunnelledProtocol_subIdentifier : public Asn :: IA5String {
	public:
	explicit TunnelledProtocol_subIdentifier ( Asn :: istream & is );
	TunnelledProtocol_subIdentifier ( const Asn :: string & v = Asn :: string ( ) );
	TunnelledProtocol_subIdentifier & operator= ( const Asn :: string & v ) {
		Asn :: IA5String :: operator= ( v );
		return * this;
	}
	TunnelledProtocol_subIdentifier * clone ( ) const;
};

//
// TunnelledProtocolAlternateIdentifier_protocolType
//

// from 0 size 1 type 0 simple 0
class TunnelledProtocolAlternateIdentifier_protocolType : public Asn :: IA5String {
	public:
	explicit TunnelledProtocolAlternateIdentifier_protocolType ( Asn :: istream & is );
	TunnelledProtocolAlternateIdentifier_protocolType ( const Asn :: string & v = Asn :: string ( ) );
	TunnelledProtocolAlternateIdentifier_protocolType & operator= ( const Asn :: string & v ) {
		Asn :: IA5String :: operator= ( v );
		return * this;
	}
	TunnelledProtocolAlternateIdentifier_protocolType * clone ( ) const;
};

//
// TunnelledProtocolAlternateIdentifier_protocolVariant
//

// from 0 size 1 type 0 simple 0
class TunnelledProtocolAlternateIdentifier_protocolVariant : public Asn :: IA5String {
	public:
	explicit TunnelledProtocolAlternateIdentifier_protocolVariant ( Asn :: istream & is );
	TunnelledProtocolAlternateIdentifier_protocolVariant ( const Asn :: string & v = Asn :: string ( ) );
	TunnelledProtocolAlternateIdentifier_protocolVariant & operator= ( const Asn :: string & v ) {
		Asn :: IA5String :: operator= ( v );
		return * this;
	}
	TunnelledProtocolAlternateIdentifier_protocolVariant * clone ( ) const;
};

//
// AliasAddress_dialedDigits
//

// from 1 size 1 type 0 simple 0
class AliasAddress_dialedDigits : public Asn :: IA5String {
	public:
	explicit AliasAddress_dialedDigits ( Asn :: istream & is );
	AliasAddress_dialedDigits ( const Asn :: string & v = Asn :: string ( ) );
	AliasAddress_dialedDigits & operator= ( const Asn :: string & v ) {
		Asn :: IA5String :: operator= ( v );
		return * this;
	}
	AliasAddress_dialedDigits * clone ( ) const;
};

//
// AliasAddress_h323-ID
//

// from 0 size 1 type 0 simple 0
class AliasAddress_h323_ID : public Asn :: BMPString {
	public:
	explicit AliasAddress_h323_ID ( Asn :: istream & is );
	AliasAddress_h323_ID ( const Asn :: string & v = Asn :: string ( ) );
	AliasAddress_h323_ID & operator= ( const Asn :: string & v ) {
		Asn :: BMPString :: operator= ( v );
		return * this;
	}
	AliasAddress_h323_ID * clone ( ) const;
};

//
// AliasAddress_url-ID
//

// from 0 size 1 type 0 simple 0
class AliasAddress_url_ID : public Asn :: IA5String {
	public:
	explicit AliasAddress_url_ID ( Asn :: istream & is );
	AliasAddress_url_ID ( const Asn :: string & v = Asn :: string ( ) );
	AliasAddress_url_ID & operator= ( const Asn :: string & v ) {
		Asn :: IA5String :: operator= ( v );
		return * this;
	}
	AliasAddress_url_ID * clone ( ) const;
};

//
// AliasAddress_email-ID
//

// from 0 size 1 type 0 simple 0
class AliasAddress_email_ID : public Asn :: IA5String {
	public:
	explicit AliasAddress_email_ID ( Asn :: istream & is );
	AliasAddress_email_ID ( const Asn :: string & v = Asn :: string ( ) );
	AliasAddress_email_ID & operator= ( const Asn :: string & v ) {
		Asn :: IA5String :: operator= ( v );
		return * this;
	}
	AliasAddress_email_ID * clone ( ) const;
};

//
// ANSI-41-UIM_imsi
//

// from 1 size 1 type 0 simple 0
class ANSI_41_UIM_imsi : public Asn :: IA5String {
	public:
	explicit ANSI_41_UIM_imsi ( Asn :: istream & is );
	ANSI_41_UIM_imsi ( const Asn :: string & v = Asn :: string ( ) );
	ANSI_41_UIM_imsi & operator= ( const Asn :: string & v ) {
		Asn :: IA5String :: operator= ( v );
		return * this;
	}
	ANSI_41_UIM_imsi * clone ( ) const;
};

//
// ANSI-41-UIM_min
//

// from 1 size 1 type 0 simple 0
class ANSI_41_UIM_min : public Asn :: IA5String {
	public:
	explicit ANSI_41_UIM_min ( Asn :: istream & is );
	ANSI_41_UIM_min ( const Asn :: string & v = Asn :: string ( ) );
	ANSI_41_UIM_min & operator= ( const Asn :: string & v ) {
		Asn :: IA5String :: operator= ( v );
		return * this;
	}
	ANSI_41_UIM_min * clone ( ) const;
};

//
// ANSI-41-UIM_mdn
//

// from 1 size 1 type 0 simple 0
class ANSI_41_UIM_mdn : public Asn :: IA5String {
	public:
	explicit ANSI_41_UIM_mdn ( Asn :: istream & is );
	ANSI_41_UIM_mdn ( const Asn :: string & v = Asn :: string ( ) );
	ANSI_41_UIM_mdn & operator= ( const Asn :: string & v ) {
		Asn :: IA5String :: operator= ( v );
		return * this;
	}
	ANSI_41_UIM_mdn * clone ( ) const;
};

//
// ANSI-41-UIM_msisdn
//

// from 1 size 1 type 0 simple 0
class ANSI_41_UIM_msisdn : public Asn :: IA5String {
	public:
	explicit ANSI_41_UIM_msisdn ( Asn :: istream & is );
	ANSI_41_UIM_msisdn ( const Asn :: string & v = Asn :: string ( ) );
	ANSI_41_UIM_msisdn & operator= ( const Asn :: string & v ) {
		Asn :: IA5String :: operator= ( v );
		return * this;
	}
	ANSI_41_UIM_msisdn * clone ( ) const;
};

//
// ANSI-41-UIM_esn
//

// from 1 size 1 type 0 simple 0
class ANSI_41_UIM_esn : public Asn :: IA5String {
	public:
	explicit ANSI_41_UIM_esn ( Asn :: istream & is );
	ANSI_41_UIM_esn ( const Asn :: string & v = Asn :: string ( ) );
	ANSI_41_UIM_esn & operator= ( const Asn :: string & v ) {
		Asn :: IA5String :: operator= ( v );
		return * this;
	}
	ANSI_41_UIM_esn * clone ( ) const;
};

//
// ANSI-41-UIM_mscid
//

// from 1 size 1 type 0 simple 0
class ANSI_41_UIM_mscid : public Asn :: IA5String {
	public:
	explicit ANSI_41_UIM_mscid ( Asn :: istream & is );
	ANSI_41_UIM_mscid ( const Asn :: string & v = Asn :: string ( ) );
	ANSI_41_UIM_mscid & operator= ( const Asn :: string & v ) {
		Asn :: IA5String :: operator= ( v );
		return * this;
	}
	ANSI_41_UIM_mscid * clone ( ) const;
};

//
// ANSI-41-UIM_systemMyTypeCode
//

// from 0 size 1 type 0 simple 0
class ANSI_41_UIM_systemMyTypeCode : public Asn :: OctetString {
	public:
	explicit ANSI_41_UIM_systemMyTypeCode ( Asn :: istream & is );
	ANSI_41_UIM_systemMyTypeCode ( const Asn :: string & v = Asn :: string ( ) );
	ANSI_41_UIM_systemMyTypeCode & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	ANSI_41_UIM_systemMyTypeCode * clone ( ) const;
};

//
// ANSI-41-UIM_systemAccessType
//

// from 0 size 1 type 0 simple 0
class ANSI_41_UIM_systemAccessType : public Asn :: OctetString {
	public:
	explicit ANSI_41_UIM_systemAccessType ( Asn :: istream & is );
	ANSI_41_UIM_systemAccessType ( const Asn :: string & v = Asn :: string ( ) );
	ANSI_41_UIM_systemAccessType & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	ANSI_41_UIM_systemAccessType * clone ( ) const;
};

//
// ANSI-41-UIM_qualificationInformationCode
//

// from 0 size 1 type 0 simple 0
class ANSI_41_UIM_qualificationInformationCode : public Asn :: OctetString {
	public:
	explicit ANSI_41_UIM_qualificationInformationCode ( Asn :: istream & is );
	ANSI_41_UIM_qualificationInformationCode ( const Asn :: string & v = Asn :: string ( ) );
	ANSI_41_UIM_qualificationInformationCode & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	ANSI_41_UIM_qualificationInformationCode * clone ( ) const;
};

//
// ANSI-41-UIM_sesn
//

// from 1 size 1 type 0 simple 0
class ANSI_41_UIM_sesn : public Asn :: IA5String {
	public:
	explicit ANSI_41_UIM_sesn ( Asn :: istream & is );
	ANSI_41_UIM_sesn ( const Asn :: string & v = Asn :: string ( ) );
	ANSI_41_UIM_sesn & operator= ( const Asn :: string & v ) {
		Asn :: IA5String :: operator= ( v );
		return * this;
	}
	ANSI_41_UIM_sesn * clone ( ) const;
};

//
// ANSI-41-UIM_soc
//

// from 1 size 1 type 0 simple 0
class ANSI_41_UIM_soc : public Asn :: IA5String {
	public:
	explicit ANSI_41_UIM_soc ( Asn :: istream & is );
	ANSI_41_UIM_soc ( const Asn :: string & v = Asn :: string ( ) );
	ANSI_41_UIM_soc & operator= ( const Asn :: string & v ) {
		Asn :: IA5String :: operator= ( v );
		return * this;
	}
	ANSI_41_UIM_soc * clone ( ) const;
};

//
// GSM-UIM_imsi
//

// from 1 size 1 type 0 simple 0
class GSM_UIM_imsi : public Asn :: IA5String {
	public:
	explicit GSM_UIM_imsi ( Asn :: istream & is );
	GSM_UIM_imsi ( const Asn :: string & v = Asn :: string ( ) );
	GSM_UIM_imsi & operator= ( const Asn :: string & v ) {
		Asn :: IA5String :: operator= ( v );
		return * this;
	}
	GSM_UIM_imsi * clone ( ) const;
};

//
// GSM-UIM_tmsi
//

// from 0 size 1 type 0 simple 0
class GSM_UIM_tmsi : public Asn :: OctetString {
	public:
	explicit GSM_UIM_tmsi ( Asn :: istream & is );
	GSM_UIM_tmsi ( const Asn :: string & v = Asn :: string ( ) );
	GSM_UIM_tmsi & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	GSM_UIM_tmsi * clone ( ) const;
};

//
// GSM-UIM_msisdn
//

// from 1 size 1 type 0 simple 0
class GSM_UIM_msisdn : public Asn :: IA5String {
	public:
	explicit GSM_UIM_msisdn ( Asn :: istream & is );
	GSM_UIM_msisdn ( const Asn :: string & v = Asn :: string ( ) );
	GSM_UIM_msisdn & operator= ( const Asn :: string & v ) {
		Asn :: IA5String :: operator= ( v );
		return * this;
	}
	GSM_UIM_msisdn * clone ( ) const;
};

//
// GSM-UIM_imei
//

// from 1 size 1 type 0 simple 0
class GSM_UIM_imei : public Asn :: IA5String {
	public:
	explicit GSM_UIM_imei ( Asn :: istream & is );
	GSM_UIM_imei ( const Asn :: string & v = Asn :: string ( ) );
	GSM_UIM_imei & operator= ( const Asn :: string & v ) {
		Asn :: IA5String :: operator= ( v );
		return * this;
	}
	GSM_UIM_imei * clone ( ) const;
};

//
// GSM-UIM_hplmn
//

// from 1 size 1 type 0 simple 0
class GSM_UIM_hplmn : public Asn :: IA5String {
	public:
	explicit GSM_UIM_hplmn ( Asn :: istream & is );
	GSM_UIM_hplmn ( const Asn :: string & v = Asn :: string ( ) );
	GSM_UIM_hplmn & operator= ( const Asn :: string & v ) {
		Asn :: IA5String :: operator= ( v );
		return * this;
	}
	GSM_UIM_hplmn * clone ( ) const;
};

//
// GSM-UIM_vplmn
//

// from 1 size 1 type 0 simple 0
class GSM_UIM_vplmn : public Asn :: IA5String {
	public:
	explicit GSM_UIM_vplmn ( Asn :: istream & is );
	GSM_UIM_vplmn ( const Asn :: string & v = Asn :: string ( ) );
	GSM_UIM_vplmn & operator= ( const Asn :: string & v ) {
		Asn :: IA5String :: operator= ( v );
		return * this;
	}
	GSM_UIM_vplmn * clone ( ) const;
};

//
// ArrayOf_TransportAddress
//

// from 0 size 0 type 0 simple 0
class ArrayOf_TransportAddress : public Asn :: Array {
	public:
	explicit ArrayOf_TransportAddress ( Asn :: istream & is );
	ArrayOf_TransportAddress ( );
	explicit ArrayOf_TransportAddress ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const TransportAddress & o );
	const TransportAddress & operator[] ( std :: size_t i ) const;
	TransportAddress & operator[] ( std :: size_t i );
	ArrayOf_TransportAddress * clone ( ) const;
};

//
// Endpoint_priority
//

// from 0 size 0 type 0 simple 1
class Endpoint_priority : public Asn :: Integer {
	public:
	explicit Endpoint_priority ( Asn :: istream & is );
	Endpoint_priority ( unsigned v = 0 );
	Endpoint_priority & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	Endpoint_priority & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	Endpoint_priority * clone ( ) const;
};

//
// AlternateGK_priority
//

// from 0 size 0 type 0 simple 1
class AlternateGK_priority : public Asn :: Integer {
	public:
	explicit AlternateGK_priority ( Asn :: istream & is );
	AlternateGK_priority ( unsigned v = 0 );
	AlternateGK_priority & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	AlternateGK_priority & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	AlternateGK_priority * clone ( ) const;
};

//
// ArrayOf_AlternateGK
//

// from 0 size 0 type 0 simple 0
class ArrayOf_AlternateGK : public Asn :: Array {
	public:
	explicit ArrayOf_AlternateGK ( Asn :: istream & is );
	ArrayOf_AlternateGK ( );
	explicit ArrayOf_AlternateGK ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const AlternateGK & o );
	const AlternateGK & operator[] ( std :: size_t i ) const;
	AlternateGK & operator[] ( std :: size_t i );
	ArrayOf_AlternateGK * clone ( ) const;
};

//
// CryptoH323Token_cryptoGKPwdHash
//

// from 0 size 0 type 0 simple 0
class CryptoH323Token_cryptoGKPwdHash : public Asn :: Sequence {
	public:
	explicit CryptoH323Token_cryptoGKPwdHash ( Asn :: istream & is );
	CryptoH323Token_cryptoGKPwdHash ( );
	GatekeeperIdentifier m_gatekeeperId;
	H235 :: TimeStamp m_timeStamp;
	H235 :: HASHED < H235 :: EncodedPwdCertToken > m_token;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	CryptoH323Token_cryptoGKPwdHash * clone ( ) const;
};

//
// DataRate_channelMultiplier
//

// from 0 size 0 type 0 simple 1
class DataRate_channelMultiplier : public Asn :: Integer {
	public:
	explicit DataRate_channelMultiplier ( Asn :: istream & is );
	DataRate_channelMultiplier ( unsigned v = 0 );
	DataRate_channelMultiplier & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	DataRate_channelMultiplier & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	DataRate_channelMultiplier * clone ( ) const;
};

//
// CapacityReportingSpecification_when
//

// from 0 size 0 type 0 simple 0
class CapacityReportingSpecification_when : public Asn :: Sequence {
	public:
	explicit CapacityReportingSpecification_when ( Asn :: istream & is );
	CapacityReportingSpecification_when ( );
	enum OptionalFields {
		e_callStart,
		e_callEnd
	};

	CapacityReportingSpecification_when ( const CapacityReportingSpecification_when & s );
	CapacityReportingSpecification_when & operator= ( const CapacityReportingSpecification_when & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	Asn :: Null * m_callStart;
	Asn :: Null * m_callEnd;
	public:
	void encode ( Asn :: ostream & os ) const;
	~CapacityReportingSpecification_when ( );
	void printOn ( std :: ostream & os ) const;
	const Asn :: Null & get_callStart ( ) const {
		return * m_callStart;
	}
	Asn :: Null & get_callStart ( ) {
		return * m_callStart;
	}
	const Asn :: Null & get_callEnd ( ) const {
		return * m_callEnd;
	}
	Asn :: Null & get_callEnd ( ) {
		return * m_callEnd;
	}
	CapacityReportingSpecification_when * clone ( ) const;
};

//
// ArrayOf_CallsAvailable
//

// from 0 size 0 type 0 simple 0
class CallsAvailable;

class ArrayOf_CallsAvailable : public Asn :: Array {
	public:
	explicit ArrayOf_CallsAvailable ( Asn :: istream & is );
	ArrayOf_CallsAvailable ( );
	explicit ArrayOf_CallsAvailable ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const CallsAvailable & o );
	const CallsAvailable & operator[] ( std :: size_t i ) const;
	CallsAvailable & operator[] ( std :: size_t i );
	ArrayOf_CallsAvailable * clone ( ) const;
};

//
// CallsAvailable_calls
//

// from 0 size 0 type 0 simple 1
class CallsAvailable_calls : public Asn :: Integer {
	public:
	explicit CallsAvailable_calls ( Asn :: istream & is );
	CallsAvailable_calls ( unsigned v = 0 );
	CallsAvailable_calls & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CallsAvailable_calls & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CallsAvailable_calls * clone ( ) const;
};

//
// CallsAvailable_group
//

// from 0 size 1 type 0 simple 0
class CallsAvailable_group : public Asn :: IA5String {
	public:
	explicit CallsAvailable_group ( Asn :: istream & is );
	CallsAvailable_group ( const Asn :: string & v = Asn :: string ( ) );
	CallsAvailable_group & operator= ( const Asn :: string & v ) {
		Asn :: IA5String :: operator= ( v );
		return * this;
	}
	CallsAvailable_group * clone ( ) const;
};

//
// CicInfo_cic
//

// from 0 size 0 type 0 simple 0
class CicInfo_cic_subtype;

class CicInfo_cic : public Asn :: Array {
	public:
	explicit CicInfo_cic ( Asn :: istream & is );
	CicInfo_cic ( );
	explicit CicInfo_cic ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const CicInfo_cic_subtype & o );
	const CicInfo_cic_subtype & operator[] ( std :: size_t i ) const;
	CicInfo_cic_subtype & operator[] ( std :: size_t i );
	CicInfo_cic * clone ( ) const;
};

//
// CicInfo_pointCode
//

// from 0 size 1 type 0 simple 0
class CicInfo_pointCode : public Asn :: OctetString {
	public:
	explicit CicInfo_pointCode ( Asn :: istream & is );
	CicInfo_pointCode ( const Asn :: string & v = Asn :: string ( ) );
	CicInfo_pointCode & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	CicInfo_pointCode * clone ( ) const;
};

//
// GroupID_member
//

// from 0 size 0 type 0 simple 0
class GroupID_member_subtype;

class GroupID_member : public Asn :: Array {
	public:
	explicit GroupID_member ( Asn :: istream & is );
	GroupID_member ( );
	explicit GroupID_member ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const GroupID_member_subtype & o );
	const GroupID_member_subtype & operator[] ( std :: size_t i ) const;
	GroupID_member_subtype & operator[] ( std :: size_t i );
	GroupID_member * clone ( ) const;
};

//
// GroupID_group
//

// from 0 size 1 type 0 simple 0
class GroupID_group : public Asn :: IA5String {
	public:
	explicit GroupID_group ( Asn :: istream & is );
	GroupID_group ( const Asn :: string & v = Asn :: string ( ) );
	GroupID_group & operator= ( const Asn :: string & v ) {
		Asn :: IA5String :: operator= ( v );
		return * this;
	}
	GroupID_group * clone ( ) const;
};

//
// CarrierInfo_carrierIdentificationCode
//

// from 0 size 1 type 0 simple 0
class CarrierInfo_carrierIdentificationCode : public Asn :: OctetString {
	public:
	explicit CarrierInfo_carrierIdentificationCode ( Asn :: istream & is );
	CarrierInfo_carrierIdentificationCode ( const Asn :: string & v = Asn :: string ( ) );
	CarrierInfo_carrierIdentificationCode & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	CarrierInfo_carrierIdentificationCode * clone ( ) const;
};

//
// CarrierInfo_carrierName
//

// from 0 size 1 type 0 simple 0
class CarrierInfo_carrierName : public Asn :: IA5String {
	public:
	explicit CarrierInfo_carrierName ( Asn :: istream & is );
	CarrierInfo_carrierName ( const Asn :: string & v = Asn :: string ( ) );
	CarrierInfo_carrierName & operator= ( const Asn :: string & v ) {
		Asn :: IA5String :: operator= ( v );
		return * this;
	}
	CarrierInfo_carrierName * clone ( ) const;
};

//
// ServiceControlDescriptor_url
//

// from 0 size 1 type 0 simple 0
class ServiceControlDescriptor_url : public Asn :: IA5String {
	public:
	explicit ServiceControlDescriptor_url ( Asn :: istream & is );
	ServiceControlDescriptor_url ( const Asn :: string & v = Asn :: string ( ) );
	ServiceControlDescriptor_url & operator= ( const Asn :: string & v ) {
		Asn :: IA5String :: operator= ( v );
		return * this;
	}
	ServiceControlDescriptor_url * clone ( ) const;
};

//
// ServiceControlSession_sessionId
//

// from 0 size 0 type 0 simple 1
class ServiceControlSession_sessionId : public Asn :: Integer {
	public:
	explicit ServiceControlSession_sessionId ( Asn :: istream & is );
	ServiceControlSession_sessionId ( unsigned v = 0 );
	ServiceControlSession_sessionId & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	ServiceControlSession_sessionId & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	ServiceControlSession_sessionId * clone ( ) const;
};

//
// ServiceControlSession_reason
//

// from 0 size 0 type 0 simple 0
class ServiceControlSession_reason : public Asn :: Choice {
	public:
	explicit ServiceControlSession_reason ( Asn :: istream & is );
	ServiceControlSession_reason ( );
	enum Choices {
		e_open,
		e_refresh,
		e_close
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	ServiceControlSession_reason * clone ( ) const;
};

//
// RasUsageSpecification_when
//

// from 0 size 0 type 0 simple 0
class RasUsageSpecification_when : public Asn :: Sequence {
	public:
	explicit RasUsageSpecification_when ( Asn :: istream & is );
	RasUsageSpecification_when ( );
	enum OptionalFields {
		e_start,
		e_end,
		e_inIrr
	};

	RasUsageSpecification_when ( const RasUsageSpecification_when & s );
	RasUsageSpecification_when & operator= ( const RasUsageSpecification_when & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	Asn :: Null * m_start;
	Asn :: Null * m_end;
	Asn :: Null * m_inIrr;
	public:
	void encode ( Asn :: ostream & os ) const;
	~RasUsageSpecification_when ( );
	void printOn ( std :: ostream & os ) const;
	const Asn :: Null & get_start ( ) const {
		return * m_start;
	}
	Asn :: Null & get_start ( ) {
		return * m_start;
	}
	const Asn :: Null & get_end ( ) const {
		return * m_end;
	}
	Asn :: Null & get_end ( ) {
		return * m_end;
	}
	const Asn :: Null & get_inIrr ( ) const {
		return * m_inIrr;
	}
	Asn :: Null & get_inIrr ( ) {
		return * m_inIrr;
	}
	RasUsageSpecification_when * clone ( ) const;
};

//
// RasUsageSpecification_callStartingPoint
//

// from 0 size 0 type 0 simple 0
class RasUsageSpecification_callStartingPoint : public Asn :: Sequence {
	public:
	explicit RasUsageSpecification_callStartingPoint ( Asn :: istream & is );
	RasUsageSpecification_callStartingPoint ( );
	enum OptionalFields {
		e_alerting,
		e_connect
	};

	RasUsageSpecification_callStartingPoint ( const RasUsageSpecification_callStartingPoint & s );
	RasUsageSpecification_callStartingPoint & operator= ( const RasUsageSpecification_callStartingPoint & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	Asn :: Null * m_alerting;
	Asn :: Null * m_connect;
	public:
	void encode ( Asn :: ostream & os ) const;
	~RasUsageSpecification_callStartingPoint ( );
	void printOn ( std :: ostream & os ) const;
	const Asn :: Null & get_alerting ( ) const {
		return * m_alerting;
	}
	Asn :: Null & get_alerting ( ) {
		return * m_alerting;
	}
	const Asn :: Null & get_connect ( ) const {
		return * m_connect;
	}
	Asn :: Null & get_connect ( ) {
		return * m_connect;
	}
	RasUsageSpecification_callStartingPoint * clone ( ) const;
};

//
// CallTerminationCause_releaseCompleteCauseIE
//

// from 0 size 1 type 0 simple 0
class CallTerminationCause_releaseCompleteCauseIE : public Asn :: OctetString {
	public:
	explicit CallTerminationCause_releaseCompleteCauseIE ( Asn :: istream & is );
	CallTerminationCause_releaseCompleteCauseIE ( const Asn :: string & v = Asn :: string ( ) );
	CallTerminationCause_releaseCompleteCauseIE & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	CallTerminationCause_releaseCompleteCauseIE * clone ( ) const;
};

//
// CallCreditServiceControl_amountString
//

// from 0 size 1 type 0 simple 0
class CallCreditServiceControl_amountString : public Asn :: BMPString {
	public:
	explicit CallCreditServiceControl_amountString ( Asn :: istream & is );
	CallCreditServiceControl_amountString ( const Asn :: string & v = Asn :: string ( ) );
	CallCreditServiceControl_amountString & operator= ( const Asn :: string & v ) {
		Asn :: BMPString :: operator= ( v );
		return * this;
	}
	CallCreditServiceControl_amountString * clone ( ) const;
};

//
// CallCreditServiceControl_billingMode
//

// from 0 size 0 type 0 simple 0
class CallCreditServiceControl_billingMode : public Asn :: Choice {
	public:
	explicit CallCreditServiceControl_billingMode ( Asn :: istream & is );
	CallCreditServiceControl_billingMode ( );
	enum Choices {
		e_credit,
		e_debit
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	CallCreditServiceControl_billingMode * clone ( ) const;
};

//
// CallCreditServiceControl_callDurationLimit
//

// from 0 size 0 type 0 simple 1
class CallCreditServiceControl_callDurationLimit : public Asn :: Integer {
	public:
	explicit CallCreditServiceControl_callDurationLimit ( Asn :: istream & is );
	CallCreditServiceControl_callDurationLimit ( unsigned v = 0 );
	CallCreditServiceControl_callDurationLimit & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CallCreditServiceControl_callDurationLimit & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	CallCreditServiceControl_callDurationLimit * clone ( ) const;
};

//
// CallCreditServiceControl_callStartingPoint
//

// from 0 size 0 type 0 simple 0
class CallCreditServiceControl_callStartingPoint : public Asn :: Choice {
	public:
	explicit CallCreditServiceControl_callStartingPoint ( Asn :: istream & is );
	CallCreditServiceControl_callStartingPoint ( );
	enum Choices {
		e_alerting,
		e_connect
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	CallCreditServiceControl_callStartingPoint * clone ( ) const;
};

//
// GenericData_parameters
//

// from 0 size 1 type 0 simple 0
class EnumeratedParameter;

class GenericData_parameters : public Asn :: Array {
	public:
	explicit GenericData_parameters ( Asn :: istream & is );
	GenericData_parameters ( );
	explicit GenericData_parameters ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const EnumeratedParameter & o );
	const EnumeratedParameter & operator[] ( std :: size_t i ) const;
	EnumeratedParameter & operator[] ( std :: size_t i );
	GenericData_parameters * clone ( ) const;
};

//
// GenericIdentifier_standard
//

// from 0 size 0 type 0 simple 1
class GenericIdentifier_standard : public Asn :: Integer {
	public:
	explicit GenericIdentifier_standard ( Asn :: istream & is );
	GenericIdentifier_standard ( unsigned v = 0 );
	GenericIdentifier_standard & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	GenericIdentifier_standard & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	GenericIdentifier_standard * clone ( ) const;
};

//
// Content_number8
//

// from 0 size 0 type 0 simple 1
class Content_number8 : public Asn :: Integer {
	public:
	explicit Content_number8 ( Asn :: istream & is );
	Content_number8 ( unsigned v = 0 );
	Content_number8 & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	Content_number8 & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	Content_number8 * clone ( ) const;
};

//
// Content_number16
//

// from 0 size 0 type 0 simple 1
class Content_number16 : public Asn :: Integer {
	public:
	explicit Content_number16 ( Asn :: istream & is );
	Content_number16 ( unsigned v = 0 );
	Content_number16 & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	Content_number16 & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	Content_number16 * clone ( ) const;
};

//
// Content_number32
//

// from 0 size 0 type 0 simple 1
class Content_number32 : public Asn :: Integer {
	public:
	explicit Content_number32 ( Asn :: istream & is );
	Content_number32 ( unsigned v = 0 );
	Content_number32 & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	Content_number32 & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	Content_number32 * clone ( ) const;
};

//
// Content_compound
//

// from 0 size 1 type 0 simple 0
class Content_compound : public Asn :: Array {
	public:
	explicit Content_compound ( Asn :: istream & is );
	Content_compound ( );
	explicit Content_compound ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const EnumeratedParameter & o );
	const EnumeratedParameter & operator[] ( std :: size_t i ) const;
	EnumeratedParameter & operator[] ( std :: size_t i );
	Content_compound * clone ( ) const;
};

//
// Content_nested
//

// from 0 size 1 type 0 simple 0
class Content_nested : public Asn :: Array {
	public:
	explicit Content_nested ( Asn :: istream & is );
	Content_nested ( );
	explicit Content_nested ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const GenericData & o );
	const GenericData & operator[] ( std :: size_t i ) const;
	GenericData & operator[] ( std :: size_t i );
	Content_nested * clone ( ) const;
};

//
// RTPSession_ssrc
//

// from 0 size 0 type 0 simple 1
class RTPSession_ssrc : public Asn :: Integer {
	public:
	explicit RTPSession_ssrc ( Asn :: istream & is );
	RTPSession_ssrc ( unsigned v = 0 );
	RTPSession_ssrc & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RTPSession_ssrc & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RTPSession_ssrc * clone ( ) const;
};

//
// RTPSession_sessionId
//

// from 0 size 0 type 0 simple 1
class RTPSession_sessionId : public Asn :: Integer {
	public:
	explicit RTPSession_sessionId ( Asn :: istream & is );
	RTPSession_sessionId ( unsigned v = 0 );
	RTPSession_sessionId & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RTPSession_sessionId & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RTPSession_sessionId * clone ( ) const;
};

//
// RTPSession_associatedSessionIds
//

// from 0 size 0 type 0 simple 0
class RTPSession_associatedSessionIds_subtype;

class RTPSession_associatedSessionIds : public Asn :: Array {
	public:
	explicit RTPSession_associatedSessionIds ( Asn :: istream & is );
	RTPSession_associatedSessionIds ( );
	explicit RTPSession_associatedSessionIds ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const RTPSession_associatedSessionIds_subtype & o );
	const RTPSession_associatedSessionIds_subtype & operator[] ( std :: size_t i ) const;
	RTPSession_associatedSessionIds_subtype & operator[] ( std :: size_t i );
	RTPSession_associatedSessionIds * clone ( ) const;
};

//
// ArrayOf_AdmissionConfirm
//

// from 0 size 0 type 0 simple 0
class AdmissionConfirm;

class ArrayOf_AdmissionConfirm : public Asn :: Array {
	public:
	explicit ArrayOf_AdmissionConfirm ( Asn :: istream & is );
	ArrayOf_AdmissionConfirm ( );
	explicit ArrayOf_AdmissionConfirm ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const AdmissionConfirm & o );
	const AdmissionConfirm & operator[] ( std :: size_t i ) const;
	AdmissionConfirm & operator[] ( std :: size_t i );
	ArrayOf_AdmissionConfirm * clone ( ) const;
};

//
// ArrayOf_Endpoint
//

// from 0 size 0 type 0 simple 0
class ArrayOf_Endpoint : public Asn :: Array {
	public:
	explicit ArrayOf_Endpoint ( Asn :: istream & is );
	ArrayOf_Endpoint ( );
	explicit ArrayOf_Endpoint ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const Endpoint & o );
	const Endpoint & operator[] ( std :: size_t i ) const;
	Endpoint & operator[] ( std :: size_t i );
	ArrayOf_Endpoint * clone ( ) const;
};

//
// ArrayOf_AuthenticationMechanism
//

// from 0 size 0 type 0 simple 0
class ArrayOf_AuthenticationMechanism : public Asn :: Array {
	public:
	explicit ArrayOf_AuthenticationMechanism ( Asn :: istream & is );
	ArrayOf_AuthenticationMechanism ( );
	explicit ArrayOf_AuthenticationMechanism ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const H235 :: AuthenticationMechanism & o );
	const H235 :: AuthenticationMechanism & operator[] ( std :: size_t i ) const;
	H235 :: AuthenticationMechanism & operator[] ( std :: size_t i );
	ArrayOf_AuthenticationMechanism * clone ( ) const;
};

//
// ArrayOf_Asn_ObjectId
//

// from 0 size 0 type 0 simple 0
class ArrayOf_Asn_ObjectId : public Asn :: Array {
	public:
	explicit ArrayOf_Asn_ObjectId ( Asn :: istream & is );
	ArrayOf_Asn_ObjectId ( );
	explicit ArrayOf_Asn_ObjectId ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const Asn :: ObjectId & o );
	const Asn :: ObjectId & operator[] ( std :: size_t i ) const;
	Asn :: ObjectId & operator[] ( std :: size_t i );
	ArrayOf_Asn_ObjectId * clone ( ) const;
};

//
// ArrayOf_IntegrityMechanism
//

// from 0 size 0 type 0 simple 0
class IntegrityMechanism;

class ArrayOf_IntegrityMechanism : public Asn :: Array {
	public:
	explicit ArrayOf_IntegrityMechanism ( Asn :: istream & is );
	ArrayOf_IntegrityMechanism ( );
	explicit ArrayOf_IntegrityMechanism ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const IntegrityMechanism & o );
	const IntegrityMechanism & operator[] ( std :: size_t i ) const;
	IntegrityMechanism & operator[] ( std :: size_t i );
	ArrayOf_IntegrityMechanism * clone ( ) const;
};

//
// ArrayOf_AddressPattern
//

// from 0 size 0 type 0 simple 0
class AddressPattern;

class ArrayOf_AddressPattern : public Asn :: Array {
	public:
	explicit ArrayOf_AddressPattern ( Asn :: istream & is );
	ArrayOf_AddressPattern ( );
	explicit ArrayOf_AddressPattern ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const AddressPattern & o );
	const AddressPattern & operator[] ( std :: size_t i ) const;
	AddressPattern & operator[] ( std :: size_t i );
	ArrayOf_AddressPattern * clone ( ) const;
};

//
// ArrayOf_H248PackagesDescriptor
//

// from 0 size 0 type 0 simple 0
class ArrayOf_H248PackagesDescriptor : public Asn :: Array {
	public:
	explicit ArrayOf_H248PackagesDescriptor ( Asn :: istream & is );
	ArrayOf_H248PackagesDescriptor ( );
	explicit ArrayOf_H248PackagesDescriptor ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const H248PackagesDescriptor & o );
	const H248PackagesDescriptor & operator[] ( std :: size_t i ) const;
	H248PackagesDescriptor & operator[] ( std :: size_t i );
	ArrayOf_H248PackagesDescriptor * clone ( ) const;
};

//
// RegistrationRequest_language
//

// from 0 size 0 type 0 simple 0
class RegistrationRequest_language_subtype;

class RegistrationRequest_language : public Asn :: Array {
	public:
	explicit RegistrationRequest_language ( Asn :: istream & is );
	RegistrationRequest_language ( );
	explicit RegistrationRequest_language ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const RegistrationRequest_language_subtype & o );
	const RegistrationRequest_language_subtype & operator[] ( std :: size_t i ) const;
	RegistrationRequest_language_subtype & operator[] ( std :: size_t i );
	RegistrationRequest_language * clone ( ) const;
};

//
// RegistrationConfirm_preGrantedARQ
//

// from 0 size 0 type 0 simple 0
class RegistrationConfirm_preGrantedARQ_irrFrequencyInCall;

class RegistrationConfirm_preGrantedARQ : public Asn :: Sequence {
	public:
	explicit RegistrationConfirm_preGrantedARQ ( Asn :: istream & is );
	RegistrationConfirm_preGrantedARQ ( );
	enum OptionalFields {
		e_irrFrequencyInCall,
		e_totalBandwidthRestriction,
		e_alternateTransportAddresses,
		e_useSpecifiedTransport
	};

	RegistrationConfirm_preGrantedARQ ( const RegistrationConfirm_preGrantedARQ & s );
	RegistrationConfirm_preGrantedARQ & operator= ( const RegistrationConfirm_preGrantedARQ & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	Asn :: Boolean m_makeCall;
	Asn :: Boolean m_useGKCallSignalAddressToMakeCall;
	Asn :: Boolean m_answerCall;
	Asn :: Boolean m_useGKCallSignalAddressToAnswer;
	protected:
	RegistrationConfirm_preGrantedARQ_irrFrequencyInCall * m_irrFrequencyInCall;
	BandWidth * m_totalBandwidthRestriction;
	AlternateTransportAddresses * m_alternateTransportAddresses;
	UseSpecifiedTransport * m_useSpecifiedTransport;
	public:
	void encode ( Asn :: ostream & os ) const;
	~RegistrationConfirm_preGrantedARQ ( );
	void printOn ( std :: ostream & os ) const;
	const RegistrationConfirm_preGrantedARQ_irrFrequencyInCall & get_irrFrequencyInCall ( ) const {
		return * m_irrFrequencyInCall;
	}
	RegistrationConfirm_preGrantedARQ_irrFrequencyInCall & get_irrFrequencyInCall ( ) {
		return * m_irrFrequencyInCall;
	}
	const BandWidth & get_totalBandwidthRestriction ( ) const {
		return * m_totalBandwidthRestriction;
	}
	BandWidth & get_totalBandwidthRestriction ( ) {
		return * m_totalBandwidthRestriction;
	}
	const AlternateTransportAddresses & get_alternateTransportAddresses ( ) const {
		return * m_alternateTransportAddresses;
	}
	AlternateTransportAddresses & get_alternateTransportAddresses ( ) {
		return * m_alternateTransportAddresses;
	}
	const UseSpecifiedTransport & get_useSpecifiedTransport ( ) const {
		return * m_useSpecifiedTransport;
	}
	UseSpecifiedTransport & get_useSpecifiedTransport ( ) {
		return * m_useSpecifiedTransport;
	}
	RegistrationConfirm_preGrantedARQ * clone ( ) const;
};

//
// ArrayOf_RasUsageSpecification
//

// from 0 size 0 type 0 simple 0
class RasUsageSpecification;

class ArrayOf_RasUsageSpecification : public Asn :: Array {
	public:
	explicit ArrayOf_RasUsageSpecification ( Asn :: istream & is );
	ArrayOf_RasUsageSpecification ( );
	explicit ArrayOf_RasUsageSpecification ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const RasUsageSpecification & o );
	const RasUsageSpecification & operator[] ( std :: size_t i ) const;
	RasUsageSpecification & operator[] ( std :: size_t i );
	ArrayOf_RasUsageSpecification * clone ( ) const;
};

//
// RegistrationRejectReason_invalidTerminalAliases
//

// from 0 size 0 type 0 simple 0
class RegistrationRejectReason_invalidTerminalAliases : public Asn :: Sequence {
	public:
	explicit RegistrationRejectReason_invalidTerminalAliases ( Asn :: istream & is );
	RegistrationRejectReason_invalidTerminalAliases ( );
	enum OptionalFields {
		e_terminalAlias,
		e_terminalAliasPattern,
		e_supportedPrefixes
	};

	RegistrationRejectReason_invalidTerminalAliases ( const RegistrationRejectReason_invalidTerminalAliases & s );
	RegistrationRejectReason_invalidTerminalAliases & operator= ( const RegistrationRejectReason_invalidTerminalAliases & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	ArrayOf_AliasAddress * m_terminalAlias;
	ArrayOf_AddressPattern * m_terminalAliasPattern;
	ArrayOf_SupportedPrefix * m_supportedPrefixes;
	public:
	void encode ( Asn :: ostream & os ) const;
	~RegistrationRejectReason_invalidTerminalAliases ( );
	void printOn ( std :: ostream & os ) const;
	const ArrayOf_AliasAddress & get_terminalAlias ( ) const {
		return * m_terminalAlias;
	}
	ArrayOf_AliasAddress & get_terminalAlias ( ) {
		return * m_terminalAlias;
	}
	const ArrayOf_AddressPattern & get_terminalAliasPattern ( ) const {
		return * m_terminalAliasPattern;
	}
	ArrayOf_AddressPattern & get_terminalAliasPattern ( ) {
		return * m_terminalAliasPattern;
	}
	const ArrayOf_SupportedPrefix & get_supportedPrefixes ( ) const {
		return * m_supportedPrefixes;
	}
	ArrayOf_SupportedPrefix & get_supportedPrefixes ( ) {
		return * m_supportedPrefixes;
	}
	RegistrationRejectReason_invalidTerminalAliases * clone ( ) const;
};

//
// TransportQOS_qOSCapabilities
//

// from 0 size 1 type 0 simple 0
class TransportQOS_qOSCapabilities : public Asn :: Array {
	public:
	explicit TransportQOS_qOSCapabilities ( Asn :: istream & is );
	TransportQOS_qOSCapabilities ( );
	explicit TransportQOS_qOSCapabilities ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const H245 :: QOSCapability & o );
	const H245 :: QOSCapability & operator[] ( std :: size_t i ) const;
	H245 :: QOSCapability & operator[] ( std :: size_t i );
	TransportQOS_qOSCapabilities * clone ( ) const;
};

//
// AdmissionConfirm_irrFrequency
//

// from 0 size 0 type 0 simple 1
class AdmissionConfirm_irrFrequency : public Asn :: Integer {
	public:
	explicit AdmissionConfirm_irrFrequency ( Asn :: istream & is );
	AdmissionConfirm_irrFrequency ( unsigned v = 0 );
	AdmissionConfirm_irrFrequency & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	AdmissionConfirm_irrFrequency & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	AdmissionConfirm_irrFrequency * clone ( ) const;
};

//
// AdmissionConfirm_language
//

// from 0 size 0 type 0 simple 0
class AdmissionConfirm_language_subtype;

class AdmissionConfirm_language : public Asn :: Array {
	public:
	explicit AdmissionConfirm_language ( Asn :: istream & is );
	AdmissionConfirm_language ( );
	explicit AdmissionConfirm_language ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const AdmissionConfirm_language_subtype & o );
	const AdmissionConfirm_language_subtype & operator[] ( std :: size_t i ) const;
	AdmissionConfirm_language_subtype & operator[] ( std :: size_t i );
	AdmissionConfirm_language * clone ( ) const;
};

//
// ArrayOf_PartyNumber
//

// from 0 size 0 type 0 simple 0
class PartyNumber;

class ArrayOf_PartyNumber : public Asn :: Array {
	public:
	explicit ArrayOf_PartyNumber ( Asn :: istream & is );
	ArrayOf_PartyNumber ( );
	explicit ArrayOf_PartyNumber ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const PartyNumber & o );
	const PartyNumber & operator[] ( std :: size_t i ) const;
	PartyNumber & operator[] ( std :: size_t i );
	ArrayOf_PartyNumber * clone ( ) const;
};

//
// ArrayOf_BandwidthDetails
//

// from 0 size 0 type 0 simple 0
class BandwidthDetails;

class ArrayOf_BandwidthDetails : public Asn :: Array {
	public:
	explicit ArrayOf_BandwidthDetails ( Asn :: istream & is );
	ArrayOf_BandwidthDetails ( );
	explicit ArrayOf_BandwidthDetails ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const BandwidthDetails & o );
	const BandwidthDetails & operator[] ( std :: size_t i ) const;
	BandwidthDetails & operator[] ( std :: size_t i );
	ArrayOf_BandwidthDetails * clone ( ) const;
};

//
// LocationRequest_hopCount
//

// from 0 size 0 type 0 simple 1
class LocationRequest_hopCount : public Asn :: Integer {
	public:
	explicit LocationRequest_hopCount ( Asn :: istream & is );
	LocationRequest_hopCount ( unsigned v = 0 );
	LocationRequest_hopCount & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	LocationRequest_hopCount & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	LocationRequest_hopCount * clone ( ) const;
};

//
// LocationRequest_language
//

// from 0 size 0 type 0 simple 0
class LocationRequest_language_subtype;

class LocationRequest_language : public Asn :: Array {
	public:
	explicit LocationRequest_language ( Asn :: istream & is );
	LocationRequest_language ( );
	explicit LocationRequest_language ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const LocationRequest_language_subtype & o );
	const LocationRequest_language_subtype & operator[] ( std :: size_t i ) const;
	LocationRequest_language_subtype & operator[] ( std :: size_t i );
	LocationRequest_language * clone ( ) const;
};

//
// InfoRequest_nextSegmentRequested
//

// from 0 size 0 type 0 simple 1
class InfoRequest_nextSegmentRequested : public Asn :: Integer {
	public:
	explicit InfoRequest_nextSegmentRequested ( Asn :: istream & is );
	InfoRequest_nextSegmentRequested ( unsigned v = 0 );
	InfoRequest_nextSegmentRequested & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	InfoRequest_nextSegmentRequested & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	InfoRequest_nextSegmentRequested * clone ( ) const;
};

//
// InfoRequestResponse_perCallInfo
//

// from 0 size 0 type 0 simple 0
class InfoRequestResponse_perCallInfo_subtype;

class InfoRequestResponse_perCallInfo : public Asn :: Array {
	public:
	explicit InfoRequestResponse_perCallInfo ( Asn :: istream & is );
	InfoRequestResponse_perCallInfo ( );
	explicit InfoRequestResponse_perCallInfo ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const InfoRequestResponse_perCallInfo_subtype & o );
	const InfoRequestResponse_perCallInfo_subtype & operator[] ( std :: size_t i ) const;
	InfoRequestResponse_perCallInfo_subtype & operator[] ( std :: size_t i );
	InfoRequestResponse_perCallInfo * clone ( ) const;
};

//
// InfoRequestResponseStatus_segment
//

// from 0 size 0 type 0 simple 1
class InfoRequestResponseStatus_segment : public Asn :: Integer {
	public:
	explicit InfoRequestResponseStatus_segment ( Asn :: istream & is );
	InfoRequestResponseStatus_segment ( unsigned v = 0 );
	InfoRequestResponseStatus_segment & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	InfoRequestResponseStatus_segment & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	InfoRequestResponseStatus_segment * clone ( ) const;
};

//
// RequestInProgress_delay
//

// from 0 size 0 type 0 simple 1
class RequestInProgress_delay : public Asn :: Integer {
	public:
	explicit RequestInProgress_delay ( Asn :: istream & is );
	RequestInProgress_delay ( unsigned v = 0 );
	RequestInProgress_delay & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RequestInProgress_delay & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RequestInProgress_delay * clone ( ) const;
};

//
// ServiceControlIndication_callSpecific
//

// from 0 size 0 type 0 simple 0
class ServiceControlIndication_callSpecific : public Asn :: Sequence {
	public:
	explicit ServiceControlIndication_callSpecific ( Asn :: istream & is );
	ServiceControlIndication_callSpecific ( );
	CallIdentifier m_callIdentifier;
	ConferenceIdentifier m_conferenceID;
	Asn :: Boolean m_answeredCall;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	ServiceControlIndication_callSpecific * clone ( ) const;
};

//
// ServiceControlResponse_result
//

// from 0 size 0 type 0 simple 0
class ServiceControlResponse_result : public Asn :: Choice {
	public:
	explicit ServiceControlResponse_result ( Asn :: istream & is );
	ServiceControlResponse_result ( );
	enum Choices {
		e_started,
		e_failed,
		e_stopped,
		e_notAvailable,
		e_neededFeatureNotSupported
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	ServiceControlResponse_result * clone ( ) const;
};

//
// H323-UserInformation_user-data_protocol-discriminator
//

// from 0 size 0 type 0 simple 1
class H323_UserInformation_user_data_protocol_discriminator : public Asn :: Integer {
	public:
	explicit H323_UserInformation_user_data_protocol_discriminator ( Asn :: istream & is );
	H323_UserInformation_user_data_protocol_discriminator ( unsigned v = 0 );
	H323_UserInformation_user_data_protocol_discriminator & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H323_UserInformation_user_data_protocol_discriminator & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	H323_UserInformation_user_data_protocol_discriminator * clone ( ) const;
};

//
// H323-UserInformation_user-data_user-information
//

// from 0 size 1 type 0 simple 0
class H323_UserInformation_user_data_user_information : public Asn :: OctetString {
	public:
	explicit H323_UserInformation_user_data_user_information ( Asn :: istream & is );
	H323_UserInformation_user_data_user_information ( const Asn :: string & v = Asn :: string ( ) );
	H323_UserInformation_user_data_user_information & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	H323_UserInformation_user_data_user_information * clone ( ) const;
};

//
// Connect-UUIE_language_subtype
//

// from 0 size 1 type 0 simple 0
class Connect_UUIE_language_subtype : public Asn :: IA5String {
	public:
	explicit Connect_UUIE_language_subtype ( Asn :: istream & is );
	Connect_UUIE_language_subtype ( const Asn :: string & v = Asn :: string ( ) );
	Connect_UUIE_language_subtype & operator= ( const Asn :: string & v ) {
		Asn :: IA5String :: operator= ( v );
		return * this;
	}
	Connect_UUIE_language_subtype * clone ( ) const;
};

//
// Setup-UUIE_connectionParameters_numberOfScnConnections
//

// from 0 size 0 type 0 simple 1
class Setup_UUIE_connectionParameters_numberOfScnConnections : public Asn :: Integer {
	public:
	explicit Setup_UUIE_connectionParameters_numberOfScnConnections ( Asn :: istream & is );
	Setup_UUIE_connectionParameters_numberOfScnConnections ( unsigned v = 0 );
	Setup_UUIE_connectionParameters_numberOfScnConnections & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	Setup_UUIE_connectionParameters_numberOfScnConnections & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	Setup_UUIE_connectionParameters_numberOfScnConnections * clone ( ) const;
};

//
// Setup-UUIE_language_subtype
//

// from 0 size 1 type 0 simple 0
class Setup_UUIE_language_subtype : public Asn :: IA5String {
	public:
	explicit Setup_UUIE_language_subtype ( Asn :: istream & is );
	Setup_UUIE_language_subtype ( const Asn :: string & v = Asn :: string ( ) );
	Setup_UUIE_language_subtype & operator= ( const Asn :: string & v ) {
		Asn :: IA5String :: operator= ( v );
		return * this;
	}
	Setup_UUIE_language_subtype * clone ( ) const;
};

//
// TransportAddress_ipAddress_ip
//

// from 0 size 1 type 0 simple 0
class TransportAddress_ipAddress_ip : public Asn :: OctetString {
	public:
	explicit TransportAddress_ipAddress_ip ( Asn :: istream & is );
	TransportAddress_ipAddress_ip ( const Asn :: string & v = Asn :: string ( ) );
	TransportAddress_ipAddress_ip & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	TransportAddress_ipAddress_ip * clone ( ) const;
};

//
// TransportAddress_ipAddress_port
//

// from 0 size 0 type 0 simple 1
class TransportAddress_ipAddress_port : public Asn :: Integer {
	public:
	explicit TransportAddress_ipAddress_port ( Asn :: istream & is );
	TransportAddress_ipAddress_port ( unsigned v = 0 );
	TransportAddress_ipAddress_port & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	TransportAddress_ipAddress_port & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	TransportAddress_ipAddress_port * clone ( ) const;
};

//
// TransportAddress_ipSourceRoute_ip
//

// from 0 size 1 type 0 simple 0
class TransportAddress_ipSourceRoute_ip : public Asn :: OctetString {
	public:
	explicit TransportAddress_ipSourceRoute_ip ( Asn :: istream & is );
	TransportAddress_ipSourceRoute_ip ( const Asn :: string & v = Asn :: string ( ) );
	TransportAddress_ipSourceRoute_ip & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	TransportAddress_ipSourceRoute_ip * clone ( ) const;
};

//
// TransportAddress_ipSourceRoute_port
//

// from 0 size 0 type 0 simple 1
class TransportAddress_ipSourceRoute_port : public Asn :: Integer {
	public:
	explicit TransportAddress_ipSourceRoute_port ( Asn :: istream & is );
	TransportAddress_ipSourceRoute_port ( unsigned v = 0 );
	TransportAddress_ipSourceRoute_port & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	TransportAddress_ipSourceRoute_port & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	TransportAddress_ipSourceRoute_port * clone ( ) const;
};

//
// TransportAddress_ipSourceRoute_route
//

// from 0 size 0 type 0 simple 0
class TransportAddress_ipSourceRoute_route_subtype;

class TransportAddress_ipSourceRoute_route : public Asn :: Array {
	public:
	explicit TransportAddress_ipSourceRoute_route ( Asn :: istream & is );
	TransportAddress_ipSourceRoute_route ( );
	explicit TransportAddress_ipSourceRoute_route ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const TransportAddress_ipSourceRoute_route_subtype & o );
	const TransportAddress_ipSourceRoute_route_subtype & operator[] ( std :: size_t i ) const;
	TransportAddress_ipSourceRoute_route_subtype & operator[] ( std :: size_t i );
	TransportAddress_ipSourceRoute_route * clone ( ) const;
};

//
// TransportAddress_ipSourceRoute_routing
//

// from 0 size 0 type 0 simple 0
class TransportAddress_ipSourceRoute_routing : public Asn :: Choice {
	public:
	explicit TransportAddress_ipSourceRoute_routing ( Asn :: istream & is );
	TransportAddress_ipSourceRoute_routing ( );
	enum Choices {
		e_strict,
		e_loose
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	TransportAddress_ipSourceRoute_routing * clone ( ) const;
};

//
// TransportAddress_ipxAddress_node
//

// from 0 size 1 type 0 simple 0
class TransportAddress_ipxAddress_node : public Asn :: OctetString {
	public:
	explicit TransportAddress_ipxAddress_node ( Asn :: istream & is );
	TransportAddress_ipxAddress_node ( const Asn :: string & v = Asn :: string ( ) );
	TransportAddress_ipxAddress_node & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	TransportAddress_ipxAddress_node * clone ( ) const;
};

//
// TransportAddress_ipxAddress_netnum
//

// from 0 size 1 type 0 simple 0
class TransportAddress_ipxAddress_netnum : public Asn :: OctetString {
	public:
	explicit TransportAddress_ipxAddress_netnum ( Asn :: istream & is );
	TransportAddress_ipxAddress_netnum ( const Asn :: string & v = Asn :: string ( ) );
	TransportAddress_ipxAddress_netnum & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	TransportAddress_ipxAddress_netnum * clone ( ) const;
};

//
// TransportAddress_ipxAddress_port
//

// from 0 size 1 type 0 simple 0
class TransportAddress_ipxAddress_port : public Asn :: OctetString {
	public:
	explicit TransportAddress_ipxAddress_port ( Asn :: istream & is );
	TransportAddress_ipxAddress_port ( const Asn :: string & v = Asn :: string ( ) );
	TransportAddress_ipxAddress_port & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	TransportAddress_ipxAddress_port * clone ( ) const;
};

//
// TransportAddress_ip6Address_ip
//

// from 0 size 1 type 0 simple 0
class TransportAddress_ip6Address_ip : public Asn :: OctetString {
	public:
	explicit TransportAddress_ip6Address_ip ( Asn :: istream & is );
	TransportAddress_ip6Address_ip ( const Asn :: string & v = Asn :: string ( ) );
	TransportAddress_ip6Address_ip & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	TransportAddress_ip6Address_ip * clone ( ) const;
};

//
// TransportAddress_ip6Address_port
//

// from 0 size 0 type 0 simple 1
class TransportAddress_ip6Address_port : public Asn :: Integer {
	public:
	explicit TransportAddress_ip6Address_port ( Asn :: istream & is );
	TransportAddress_ip6Address_port ( unsigned v = 0 );
	TransportAddress_ip6Address_port & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	TransportAddress_ip6Address_port & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	TransportAddress_ip6Address_port * clone ( ) const;
};

//
// ANSI-41-UIM_system-id_sid
//

// from 1 size 1 type 0 simple 0
class ANSI_41_UIM_system_id_sid : public Asn :: IA5String {
	public:
	explicit ANSI_41_UIM_system_id_sid ( Asn :: istream & is );
	ANSI_41_UIM_system_id_sid ( const Asn :: string & v = Asn :: string ( ) );
	ANSI_41_UIM_system_id_sid & operator= ( const Asn :: string & v ) {
		Asn :: IA5String :: operator= ( v );
		return * this;
	}
	ANSI_41_UIM_system_id_sid * clone ( ) const;
};

//
// ANSI-41-UIM_system-id_mid
//

// from 1 size 1 type 0 simple 0
class ANSI_41_UIM_system_id_mid : public Asn :: IA5String {
	public:
	explicit ANSI_41_UIM_system_id_mid ( Asn :: istream & is );
	ANSI_41_UIM_system_id_mid ( const Asn :: string & v = Asn :: string ( ) );
	ANSI_41_UIM_system_id_mid & operator= ( const Asn :: string & v ) {
		Asn :: IA5String :: operator= ( v );
		return * this;
	}
	ANSI_41_UIM_system_id_mid * clone ( ) const;
};

//
// CicInfo_cic_subtype
//

// from 0 size 1 type 0 simple 0
class CicInfo_cic_subtype : public Asn :: OctetString {
	public:
	explicit CicInfo_cic_subtype ( Asn :: istream & is );
	CicInfo_cic_subtype ( const Asn :: string & v = Asn :: string ( ) );
	CicInfo_cic_subtype & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	CicInfo_cic_subtype * clone ( ) const;
};

//
// GroupID_member_subtype
//

// from 0 size 0 type 0 simple 1
class GroupID_member_subtype : public Asn :: Integer {
	public:
	explicit GroupID_member_subtype ( Asn :: istream & is );
	GroupID_member_subtype ( unsigned v = 0 );
	GroupID_member_subtype & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	GroupID_member_subtype & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	GroupID_member_subtype * clone ( ) const;
};

//
// RTPSession_associatedSessionIds_subtype
//

// from 0 size 0 type 0 simple 1
class RTPSession_associatedSessionIds_subtype : public Asn :: Integer {
	public:
	explicit RTPSession_associatedSessionIds_subtype ( Asn :: istream & is );
	RTPSession_associatedSessionIds_subtype ( unsigned v = 0 );
	RTPSession_associatedSessionIds_subtype & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RTPSession_associatedSessionIds_subtype & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RTPSession_associatedSessionIds_subtype * clone ( ) const;
};

//
// RegistrationRequest_language_subtype
//

// from 0 size 1 type 0 simple 0
class RegistrationRequest_language_subtype : public Asn :: IA5String {
	public:
	explicit RegistrationRequest_language_subtype ( Asn :: istream & is );
	RegistrationRequest_language_subtype ( const Asn :: string & v = Asn :: string ( ) );
	RegistrationRequest_language_subtype & operator= ( const Asn :: string & v ) {
		Asn :: IA5String :: operator= ( v );
		return * this;
	}
	RegistrationRequest_language_subtype * clone ( ) const;
};

//
// RegistrationConfirm_preGrantedARQ_irrFrequencyInCall
//

// from 0 size 0 type 0 simple 1
class RegistrationConfirm_preGrantedARQ_irrFrequencyInCall : public Asn :: Integer {
	public:
	explicit RegistrationConfirm_preGrantedARQ_irrFrequencyInCall ( Asn :: istream & is );
	RegistrationConfirm_preGrantedARQ_irrFrequencyInCall ( unsigned v = 0 );
	RegistrationConfirm_preGrantedARQ_irrFrequencyInCall & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RegistrationConfirm_preGrantedARQ_irrFrequencyInCall & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RegistrationConfirm_preGrantedARQ_irrFrequencyInCall * clone ( ) const;
};

//
// AdmissionConfirm_language_subtype
//

// from 0 size 1 type 0 simple 0
class AdmissionConfirm_language_subtype : public Asn :: IA5String {
	public:
	explicit AdmissionConfirm_language_subtype ( Asn :: istream & is );
	AdmissionConfirm_language_subtype ( const Asn :: string & v = Asn :: string ( ) );
	AdmissionConfirm_language_subtype & operator= ( const Asn :: string & v ) {
		Asn :: IA5String :: operator= ( v );
		return * this;
	}
	AdmissionConfirm_language_subtype * clone ( ) const;
};

//
// LocationRequest_language_subtype
//

// from 0 size 1 type 0 simple 0
class LocationRequest_language_subtype : public Asn :: IA5String {
	public:
	explicit LocationRequest_language_subtype ( Asn :: istream & is );
	LocationRequest_language_subtype ( const Asn :: string & v = Asn :: string ( ) );
	LocationRequest_language_subtype & operator= ( const Asn :: string & v ) {
		Asn :: IA5String :: operator= ( v );
		return * this;
	}
	LocationRequest_language_subtype * clone ( ) const;
};

//
// InfoRequestResponse_perCallInfo_subtype
//

// from 0 size 0 type 0 simple 0
class ArrayOf_RTPSession;
class ArrayOf_TransportChannelInfo;
class ArrayOf_ConferenceIdentifier;
class InfoRequestResponse_perCallInfo_subtype_pdu;

class InfoRequestResponse_perCallInfo_subtype : public Asn :: Sequence {
	public:
	explicit InfoRequestResponse_perCallInfo_subtype ( Asn :: istream & is );
	InfoRequestResponse_perCallInfo_subtype ( );
	enum OptionalFields {
		e_nonStandardData,
		e_originator,
		e_audio,
		e_video,
		e_data,
		e_callIdentifier,
		e_tokens,
		e_cryptoTokens,
		e_substituteConfIDs,
		e_pdu,
		e_callLinkage,
		e_usageInformation,
		e_circuitInfo
	};

	InfoRequestResponse_perCallInfo_subtype ( const InfoRequestResponse_perCallInfo_subtype & s );
	InfoRequestResponse_perCallInfo_subtype & operator= ( const InfoRequestResponse_perCallInfo_subtype & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	NonStandardParameter * m_nonStandardData;
	public:
	CallReferenceValue m_callReferenceValue;
	ConferenceIdentifier m_conferenceID;
	protected:
	Asn :: Boolean * m_originator;
	ArrayOf_RTPSession * m_audio;
	ArrayOf_RTPSession * m_video;
	ArrayOf_TransportChannelInfo * m_data;
	public:
	TransportChannelInfo m_h245;
	TransportChannelInfo m_callSignaling;
	CallType m_callType;
	BandWidth m_bandWidth;
	CallModel m_callModel;
	protected:
	CallIdentifier * m_callIdentifier;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ArrayOf_ConferenceIdentifier * m_substituteConfIDs;
	InfoRequestResponse_perCallInfo_subtype_pdu * m_pdu;
	CallLinkage * m_callLinkage;
	RasUsageInformation * m_usageInformation;
	CircuitInfo * m_circuitInfo;
	public:
	void encode ( Asn :: ostream & os ) const;
	~InfoRequestResponse_perCallInfo_subtype ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const Asn :: Boolean & get_originator ( ) const {
		return * m_originator;
	}
	Asn :: Boolean & get_originator ( ) {
		return * m_originator;
	}
	const ArrayOf_RTPSession & get_audio ( ) const {
		return * m_audio;
	}
	ArrayOf_RTPSession & get_audio ( ) {
		return * m_audio;
	}
	const ArrayOf_RTPSession & get_video ( ) const {
		return * m_video;
	}
	ArrayOf_RTPSession & get_video ( ) {
		return * m_video;
	}
	const ArrayOf_TransportChannelInfo & get_data ( ) const {
		return * m_data;
	}
	ArrayOf_TransportChannelInfo & get_data ( ) {
		return * m_data;
	}
	const CallIdentifier & get_callIdentifier ( ) const {
		return * m_callIdentifier;
	}
	CallIdentifier & get_callIdentifier ( ) {
		return * m_callIdentifier;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ArrayOf_ConferenceIdentifier & get_substituteConfIDs ( ) const {
		return * m_substituteConfIDs;
	}
	ArrayOf_ConferenceIdentifier & get_substituteConfIDs ( ) {
		return * m_substituteConfIDs;
	}
	const InfoRequestResponse_perCallInfo_subtype_pdu & get_pdu ( ) const {
		return * m_pdu;
	}
	InfoRequestResponse_perCallInfo_subtype_pdu & get_pdu ( ) {
		return * m_pdu;
	}
	const CallLinkage & get_callLinkage ( ) const {
		return * m_callLinkage;
	}
	CallLinkage & get_callLinkage ( ) {
		return * m_callLinkage;
	}
	const RasUsageInformation & get_usageInformation ( ) const {
		return * m_usageInformation;
	}
	RasUsageInformation & get_usageInformation ( ) {
		return * m_usageInformation;
	}
	const CircuitInfo & get_circuitInfo ( ) const {
		return * m_circuitInfo;
	}
	CircuitInfo & get_circuitInfo ( ) {
		return * m_circuitInfo;
	}
	InfoRequestResponse_perCallInfo_subtype * clone ( ) const;
};

//
// TransportAddress_ipSourceRoute_route_subtype
//

// from 0 size 1 type 0 simple 0
class TransportAddress_ipSourceRoute_route_subtype : public Asn :: OctetString {
	public:
	explicit TransportAddress_ipSourceRoute_route_subtype ( Asn :: istream & is );
	TransportAddress_ipSourceRoute_route_subtype ( const Asn :: string & v = Asn :: string ( ) );
	TransportAddress_ipSourceRoute_route_subtype & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	TransportAddress_ipSourceRoute_route_subtype * clone ( ) const;
};

//
// ArrayOf_RTPSession
//

// from 0 size 0 type 0 simple 0
class RTPSession;

class ArrayOf_RTPSession : public Asn :: Array {
	public:
	explicit ArrayOf_RTPSession ( Asn :: istream & is );
	ArrayOf_RTPSession ( );
	explicit ArrayOf_RTPSession ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const RTPSession & o );
	const RTPSession & operator[] ( std :: size_t i ) const;
	RTPSession & operator[] ( std :: size_t i );
	ArrayOf_RTPSession * clone ( ) const;
};

//
// ArrayOf_TransportChannelInfo
//

// from 0 size 0 type 0 simple 0
class ArrayOf_TransportChannelInfo : public Asn :: Array {
	public:
	explicit ArrayOf_TransportChannelInfo ( Asn :: istream & is );
	ArrayOf_TransportChannelInfo ( );
	explicit ArrayOf_TransportChannelInfo ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const TransportChannelInfo & o );
	const TransportChannelInfo & operator[] ( std :: size_t i ) const;
	TransportChannelInfo & operator[] ( std :: size_t i );
	ArrayOf_TransportChannelInfo * clone ( ) const;
};

//
// ArrayOf_ConferenceIdentifier
//

// from 0 size 0 type 0 simple 0
class ArrayOf_ConferenceIdentifier : public Asn :: Array {
	public:
	explicit ArrayOf_ConferenceIdentifier ( Asn :: istream & is );
	ArrayOf_ConferenceIdentifier ( );
	explicit ArrayOf_ConferenceIdentifier ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const ConferenceIdentifier & o );
	const ConferenceIdentifier & operator[] ( std :: size_t i ) const;
	ConferenceIdentifier & operator[] ( std :: size_t i );
	ArrayOf_ConferenceIdentifier * clone ( ) const;
};

//
// InfoRequestResponse_perCallInfo_subtype_pdu
//

// from 0 size 0 type 0 simple 0
class InfoRequestResponse_perCallInfo_subtype_pdu_subtype;

class InfoRequestResponse_perCallInfo_subtype_pdu : public Asn :: Array {
	public:
	explicit InfoRequestResponse_perCallInfo_subtype_pdu ( Asn :: istream & is );
	InfoRequestResponse_perCallInfo_subtype_pdu ( );
	explicit InfoRequestResponse_perCallInfo_subtype_pdu ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const InfoRequestResponse_perCallInfo_subtype_pdu_subtype & o );
	const InfoRequestResponse_perCallInfo_subtype_pdu_subtype & operator[] ( std :: size_t i ) const;
	InfoRequestResponse_perCallInfo_subtype_pdu_subtype & operator[] ( std :: size_t i );
	InfoRequestResponse_perCallInfo_subtype_pdu * clone ( ) const;
};

//
// Alerting-UUIE
//

// from 0 size 0 type 0 simple 0
class Alerting_UUIE : public Asn :: Sequence {
	public:
	explicit Alerting_UUIE ( Asn :: istream & is );
	Alerting_UUIE ( );
	enum OptionalFields {
		e_h245Address,
		e_callIdentifier,
		e_h245SecurityMode,
		e_tokens,
		e_cryptoTokens,
		e_fastStart,
		e_multipleCalls,
		e_maintainConnection,
		e_alertingAddress,
		e_presentationIndicator,
		e_screeningIndicator,
		e_fastConnectRefused,
		e_serviceControl,
		e_capacity,
		e_featureSet
	};

	Alerting_UUIE ( const Alerting_UUIE & s );
	Alerting_UUIE & operator= ( const Alerting_UUIE & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	ProtocolIdentifier m_protocolIdentifier;
	EndpointType m_destinationInfo;
	protected:
	TransportAddress * m_h245Address;
	CallIdentifier * m_callIdentifier;
	H245Security * m_h245SecurityMode;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ArrayOf_Asn_OctetString * m_fastStart;
	Asn :: Boolean * m_multipleCalls;
	Asn :: Boolean * m_maintainConnection;
	ArrayOf_AliasAddress * m_alertingAddress;
	PresentationIndicator * m_presentationIndicator;
	ScreeningIndicator * m_screeningIndicator;
	Asn :: Null * m_fastConnectRefused;
	ArrayOf_ServiceControlSession * m_serviceControl;
	CallCapacity * m_capacity;
	FeatureSet * m_featureSet;
	public:
	void encode ( Asn :: ostream & os ) const;
	~Alerting_UUIE ( );
	void printOn ( std :: ostream & os ) const;
	const TransportAddress & get_h245Address ( ) const {
		return * m_h245Address;
	}
	TransportAddress & get_h245Address ( ) {
		return * m_h245Address;
	}
	const CallIdentifier & get_callIdentifier ( ) const {
		return * m_callIdentifier;
	}
	CallIdentifier & get_callIdentifier ( ) {
		return * m_callIdentifier;
	}
	const H245Security & get_h245SecurityMode ( ) const {
		return * m_h245SecurityMode;
	}
	H245Security & get_h245SecurityMode ( ) {
		return * m_h245SecurityMode;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ArrayOf_Asn_OctetString & get_fastStart ( ) const {
		return * m_fastStart;
	}
	ArrayOf_Asn_OctetString & get_fastStart ( ) {
		return * m_fastStart;
	}
	const Asn :: Boolean & get_multipleCalls ( ) const {
		return * m_multipleCalls;
	}
	Asn :: Boolean & get_multipleCalls ( ) {
		return * m_multipleCalls;
	}
	const Asn :: Boolean & get_maintainConnection ( ) const {
		return * m_maintainConnection;
	}
	Asn :: Boolean & get_maintainConnection ( ) {
		return * m_maintainConnection;
	}
	const ArrayOf_AliasAddress & get_alertingAddress ( ) const {
		return * m_alertingAddress;
	}
	ArrayOf_AliasAddress & get_alertingAddress ( ) {
		return * m_alertingAddress;
	}
	const PresentationIndicator & get_presentationIndicator ( ) const {
		return * m_presentationIndicator;
	}
	PresentationIndicator & get_presentationIndicator ( ) {
		return * m_presentationIndicator;
	}
	const ScreeningIndicator & get_screeningIndicator ( ) const {
		return * m_screeningIndicator;
	}
	ScreeningIndicator & get_screeningIndicator ( ) {
		return * m_screeningIndicator;
	}
	const Asn :: Null & get_fastConnectRefused ( ) const {
		return * m_fastConnectRefused;
	}
	Asn :: Null & get_fastConnectRefused ( ) {
		return * m_fastConnectRefused;
	}
	const ArrayOf_ServiceControlSession & get_serviceControl ( ) const {
		return * m_serviceControl;
	}
	ArrayOf_ServiceControlSession & get_serviceControl ( ) {
		return * m_serviceControl;
	}
	const CallCapacity & get_capacity ( ) const {
		return * m_capacity;
	}
	CallCapacity & get_capacity ( ) {
		return * m_capacity;
	}
	const FeatureSet & get_featureSet ( ) const {
		return * m_featureSet;
	}
	FeatureSet & get_featureSet ( ) {
		return * m_featureSet;
	}
	Alerting_UUIE * clone ( ) const;
};

//
// CallProceeding-UUIE
//

// from 0 size 0 type 0 simple 0
class CallProceeding_UUIE : public Asn :: Sequence {
	public:
	explicit CallProceeding_UUIE ( Asn :: istream & is );
	CallProceeding_UUIE ( );
	enum OptionalFields {
		e_h245Address,
		e_callIdentifier,
		e_h245SecurityMode,
		e_tokens,
		e_cryptoTokens,
		e_fastStart,
		e_multipleCalls,
		e_maintainConnection,
		e_fastConnectRefused,
		e_featureSet
	};

	CallProceeding_UUIE ( const CallProceeding_UUIE & s );
	CallProceeding_UUIE & operator= ( const CallProceeding_UUIE & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	ProtocolIdentifier m_protocolIdentifier;
	EndpointType m_destinationInfo;
	protected:
	TransportAddress * m_h245Address;
	CallIdentifier * m_callIdentifier;
	H245Security * m_h245SecurityMode;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ArrayOf_Asn_OctetString * m_fastStart;
	Asn :: Boolean * m_multipleCalls;
	Asn :: Boolean * m_maintainConnection;
	Asn :: Null * m_fastConnectRefused;
	FeatureSet * m_featureSet;
	public:
	void encode ( Asn :: ostream & os ) const;
	~CallProceeding_UUIE ( );
	void printOn ( std :: ostream & os ) const;
	const TransportAddress & get_h245Address ( ) const {
		return * m_h245Address;
	}
	TransportAddress & get_h245Address ( ) {
		return * m_h245Address;
	}
	const CallIdentifier & get_callIdentifier ( ) const {
		return * m_callIdentifier;
	}
	CallIdentifier & get_callIdentifier ( ) {
		return * m_callIdentifier;
	}
	const H245Security & get_h245SecurityMode ( ) const {
		return * m_h245SecurityMode;
	}
	H245Security & get_h245SecurityMode ( ) {
		return * m_h245SecurityMode;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ArrayOf_Asn_OctetString & get_fastStart ( ) const {
		return * m_fastStart;
	}
	ArrayOf_Asn_OctetString & get_fastStart ( ) {
		return * m_fastStart;
	}
	const Asn :: Boolean & get_multipleCalls ( ) const {
		return * m_multipleCalls;
	}
	Asn :: Boolean & get_multipleCalls ( ) {
		return * m_multipleCalls;
	}
	const Asn :: Boolean & get_maintainConnection ( ) const {
		return * m_maintainConnection;
	}
	Asn :: Boolean & get_maintainConnection ( ) {
		return * m_maintainConnection;
	}
	const Asn :: Null & get_fastConnectRefused ( ) const {
		return * m_fastConnectRefused;
	}
	Asn :: Null & get_fastConnectRefused ( ) {
		return * m_fastConnectRefused;
	}
	const FeatureSet & get_featureSet ( ) const {
		return * m_featureSet;
	}
	FeatureSet & get_featureSet ( ) {
		return * m_featureSet;
	}
	CallProceeding_UUIE * clone ( ) const;
};

//
// Connect-UUIE
//

// from 0 size 0 type 0 simple 0
class Connect_UUIE : public Asn :: Sequence {
	public:
	explicit Connect_UUIE ( Asn :: istream & is );
	Connect_UUIE ( );
	enum OptionalFields {
		e_h245Address,
		e_callIdentifier,
		e_h245SecurityMode,
		e_tokens,
		e_cryptoTokens,
		e_fastStart,
		e_multipleCalls,
		e_maintainConnection,
		e_language,
		e_connectedAddress,
		e_presentationIndicator,
		e_screeningIndicator,
		e_fastConnectRefused,
		e_serviceControl,
		e_capacity,
		e_featureSet
	};

	Connect_UUIE ( const Connect_UUIE & s );
	Connect_UUIE & operator= ( const Connect_UUIE & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	ProtocolIdentifier m_protocolIdentifier;
	protected:
	TransportAddress * m_h245Address;
	public:
	EndpointType m_destinationInfo;
	ConferenceIdentifier m_conferenceID;
	protected:
	CallIdentifier * m_callIdentifier;
	H245Security * m_h245SecurityMode;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ArrayOf_Asn_OctetString * m_fastStart;
	Asn :: Boolean * m_multipleCalls;
	Asn :: Boolean * m_maintainConnection;
	Connect_UUIE_language * m_language;
	ArrayOf_AliasAddress * m_connectedAddress;
	PresentationIndicator * m_presentationIndicator;
	ScreeningIndicator * m_screeningIndicator;
	Asn :: Null * m_fastConnectRefused;
	ArrayOf_ServiceControlSession * m_serviceControl;
	CallCapacity * m_capacity;
	FeatureSet * m_featureSet;
	public:
	void encode ( Asn :: ostream & os ) const;
	~Connect_UUIE ( );
	void printOn ( std :: ostream & os ) const;
	const TransportAddress & get_h245Address ( ) const {
		return * m_h245Address;
	}
	TransportAddress & get_h245Address ( ) {
		return * m_h245Address;
	}
	const CallIdentifier & get_callIdentifier ( ) const {
		return * m_callIdentifier;
	}
	CallIdentifier & get_callIdentifier ( ) {
		return * m_callIdentifier;
	}
	const H245Security & get_h245SecurityMode ( ) const {
		return * m_h245SecurityMode;
	}
	H245Security & get_h245SecurityMode ( ) {
		return * m_h245SecurityMode;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ArrayOf_Asn_OctetString & get_fastStart ( ) const {
		return * m_fastStart;
	}
	ArrayOf_Asn_OctetString & get_fastStart ( ) {
		return * m_fastStart;
	}
	const Asn :: Boolean & get_multipleCalls ( ) const {
		return * m_multipleCalls;
	}
	Asn :: Boolean & get_multipleCalls ( ) {
		return * m_multipleCalls;
	}
	const Asn :: Boolean & get_maintainConnection ( ) const {
		return * m_maintainConnection;
	}
	Asn :: Boolean & get_maintainConnection ( ) {
		return * m_maintainConnection;
	}
	const Connect_UUIE_language & get_language ( ) const {
		return * m_language;
	}
	Connect_UUIE_language & get_language ( ) {
		return * m_language;
	}
	const ArrayOf_AliasAddress & get_connectedAddress ( ) const {
		return * m_connectedAddress;
	}
	ArrayOf_AliasAddress & get_connectedAddress ( ) {
		return * m_connectedAddress;
	}
	const PresentationIndicator & get_presentationIndicator ( ) const {
		return * m_presentationIndicator;
	}
	PresentationIndicator & get_presentationIndicator ( ) {
		return * m_presentationIndicator;
	}
	const ScreeningIndicator & get_screeningIndicator ( ) const {
		return * m_screeningIndicator;
	}
	ScreeningIndicator & get_screeningIndicator ( ) {
		return * m_screeningIndicator;
	}
	const Asn :: Null & get_fastConnectRefused ( ) const {
		return * m_fastConnectRefused;
	}
	Asn :: Null & get_fastConnectRefused ( ) {
		return * m_fastConnectRefused;
	}
	const ArrayOf_ServiceControlSession & get_serviceControl ( ) const {
		return * m_serviceControl;
	}
	ArrayOf_ServiceControlSession & get_serviceControl ( ) {
		return * m_serviceControl;
	}
	const CallCapacity & get_capacity ( ) const {
		return * m_capacity;
	}
	CallCapacity & get_capacity ( ) {
		return * m_capacity;
	}
	const FeatureSet & get_featureSet ( ) const {
		return * m_featureSet;
	}
	FeatureSet & get_featureSet ( ) {
		return * m_featureSet;
	}
	Connect_UUIE * clone ( ) const;
};

//
// Information-UUIE
//

// from 0 size 0 type 0 simple 0
class Information_UUIE : public Asn :: Sequence {
	public:
	explicit Information_UUIE ( Asn :: istream & is );
	Information_UUIE ( );
	enum OptionalFields {
		e_callIdentifier,
		e_tokens,
		e_cryptoTokens,
		e_fastStart,
		e_fastConnectRefused,
		e_circuitInfo
	};

	Information_UUIE ( const Information_UUIE & s );
	Information_UUIE & operator= ( const Information_UUIE & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	ProtocolIdentifier m_protocolIdentifier;
	protected:
	CallIdentifier * m_callIdentifier;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ArrayOf_Asn_OctetString * m_fastStart;
	Asn :: Null * m_fastConnectRefused;
	CircuitInfo * m_circuitInfo;
	public:
	void encode ( Asn :: ostream & os ) const;
	~Information_UUIE ( );
	void printOn ( std :: ostream & os ) const;
	const CallIdentifier & get_callIdentifier ( ) const {
		return * m_callIdentifier;
	}
	CallIdentifier & get_callIdentifier ( ) {
		return * m_callIdentifier;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ArrayOf_Asn_OctetString & get_fastStart ( ) const {
		return * m_fastStart;
	}
	ArrayOf_Asn_OctetString & get_fastStart ( ) {
		return * m_fastStart;
	}
	const Asn :: Null & get_fastConnectRefused ( ) const {
		return * m_fastConnectRefused;
	}
	Asn :: Null & get_fastConnectRefused ( ) {
		return * m_fastConnectRefused;
	}
	const CircuitInfo & get_circuitInfo ( ) const {
		return * m_circuitInfo;
	}
	CircuitInfo & get_circuitInfo ( ) {
		return * m_circuitInfo;
	}
	Information_UUIE * clone ( ) const;
};

//
// ReleaseComplete-UUIE
//

// from 0 size 0 type 0 simple 0
class ReleaseCompleteReason;

class ReleaseComplete_UUIE : public Asn :: Sequence {
	public:
	explicit ReleaseComplete_UUIE ( Asn :: istream & is );
	ReleaseComplete_UUIE ( );
	enum OptionalFields {
		e_reason,
		e_callIdentifier,
		e_tokens,
		e_cryptoTokens,
		e_busyAddress,
		e_presentationIndicator,
		e_screeningIndicator,
		e_capacity,
		e_serviceControl,
		e_featureSet
	};

	ReleaseComplete_UUIE ( const ReleaseComplete_UUIE & s );
	ReleaseComplete_UUIE & operator= ( const ReleaseComplete_UUIE & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	ProtocolIdentifier m_protocolIdentifier;
	protected:
	ReleaseCompleteReason * m_reason;
	CallIdentifier * m_callIdentifier;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ArrayOf_AliasAddress * m_busyAddress;
	PresentationIndicator * m_presentationIndicator;
	ScreeningIndicator * m_screeningIndicator;
	CallCapacity * m_capacity;
	ArrayOf_ServiceControlSession * m_serviceControl;
	FeatureSet * m_featureSet;
	public:
	void encode ( Asn :: ostream & os ) const;
	~ReleaseComplete_UUIE ( );
	void printOn ( std :: ostream & os ) const;
	const ReleaseCompleteReason & get_reason ( ) const {
		return * m_reason;
	}
	ReleaseCompleteReason & get_reason ( ) {
		return * m_reason;
	}
	const CallIdentifier & get_callIdentifier ( ) const {
		return * m_callIdentifier;
	}
	CallIdentifier & get_callIdentifier ( ) {
		return * m_callIdentifier;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ArrayOf_AliasAddress & get_busyAddress ( ) const {
		return * m_busyAddress;
	}
	ArrayOf_AliasAddress & get_busyAddress ( ) {
		return * m_busyAddress;
	}
	const PresentationIndicator & get_presentationIndicator ( ) const {
		return * m_presentationIndicator;
	}
	PresentationIndicator & get_presentationIndicator ( ) {
		return * m_presentationIndicator;
	}
	const ScreeningIndicator & get_screeningIndicator ( ) const {
		return * m_screeningIndicator;
	}
	ScreeningIndicator & get_screeningIndicator ( ) {
		return * m_screeningIndicator;
	}
	const CallCapacity & get_capacity ( ) const {
		return * m_capacity;
	}
	CallCapacity & get_capacity ( ) {
		return * m_capacity;
	}
	const ArrayOf_ServiceControlSession & get_serviceControl ( ) const {
		return * m_serviceControl;
	}
	ArrayOf_ServiceControlSession & get_serviceControl ( ) {
		return * m_serviceControl;
	}
	const FeatureSet & get_featureSet ( ) const {
		return * m_featureSet;
	}
	FeatureSet & get_featureSet ( ) {
		return * m_featureSet;
	}
	ReleaseComplete_UUIE * clone ( ) const;
};

//
// Setup-UUIE
//

// from 0 size 0 type 0 simple 0
class QseriesOptions;
class Setup_UUIE_connectionParameters;

class Setup_UUIE : public Asn :: Sequence {
	public:
	explicit Setup_UUIE ( Asn :: istream & is );
	Setup_UUIE ( );
	enum OptionalFields {
		e_h245Address,
		e_sourceAddress,
		e_destinationAddress,
		e_destCallSignalAddress,
		e_destExtraCallInfo,
		e_destExtraCRV,
		e_callServices,
		e_sourceCallSignalAddress,
		e_remoteExtensionAddress,
		e_callIdentifier,
		e_h245SecurityCapability,
		e_tokens,
		e_cryptoTokens,
		e_fastStart,
		e_mediaWaitForConnect,
		e_canOverlapSend,
		e_endpointIdentifier,
		e_multipleCalls,
		e_maintainConnection,
		e_connectionParameters,
		e_language,
		e_presentationIndicator,
		e_screeningIndicator,
		e_serviceControl,
		e_symmetricOperationRequired,
		e_capacity,
		e_circuitInfo,
		e_desiredProtocols,
		e_neededFeatures,
		e_desiredFeatures,
		e_supportedFeatures,
		e_parallelH245Control,
		e_additionalSourceAddresses,
		e_hopCount
	};

	Setup_UUIE ( const Setup_UUIE & s );
	Setup_UUIE & operator= ( const Setup_UUIE & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	ProtocolIdentifier m_protocolIdentifier;
	protected:
	TransportAddress * m_h245Address;
	ArrayOf_AliasAddress * m_sourceAddress;
	public:
	EndpointType m_sourceInfo;
	protected:
	ArrayOf_AliasAddress * m_destinationAddress;
	TransportAddress * m_destCallSignalAddress;
	ArrayOf_AliasAddress * m_destExtraCallInfo;
	ArrayOf_CallReferenceValue * m_destExtraCRV;
	public:
	Asn :: Boolean m_activeMC;
	ConferenceIdentifier m_conferenceID;
	Setup_UUIE_conferenceGoal m_conferenceGoal;
	protected:
	QseriesOptions * m_callServices;
	public:
	CallType m_callType;
	protected:
	TransportAddress * m_sourceCallSignalAddress;
	AliasAddress * m_remoteExtensionAddress;
	CallIdentifier * m_callIdentifier;
	ArrayOf_H245Security * m_h245SecurityCapability;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ArrayOf_Asn_OctetString * m_fastStart;
	Asn :: Boolean * m_mediaWaitForConnect;
	Asn :: Boolean * m_canOverlapSend;
	EndpointIdentifier * m_endpointIdentifier;
	Asn :: Boolean * m_multipleCalls;
	Asn :: Boolean * m_maintainConnection;
	Setup_UUIE_connectionParameters * m_connectionParameters;
	Setup_UUIE_language * m_language;
	PresentationIndicator * m_presentationIndicator;
	ScreeningIndicator * m_screeningIndicator;
	ArrayOf_ServiceControlSession * m_serviceControl;
	Asn :: Null * m_symmetricOperationRequired;
	CallCapacity * m_capacity;
	CircuitInfo * m_circuitInfo;
	ArrayOf_SupportedProtocols * m_desiredProtocols;
	ArrayOf_FeatureDescriptor * m_neededFeatures;
	ArrayOf_FeatureDescriptor * m_desiredFeatures;
	ArrayOf_FeatureDescriptor * m_supportedFeatures;
	ArrayOf_Asn_OctetString * m_parallelH245Control;
	ArrayOf_ExtendedAliasAddress * m_additionalSourceAddresses;
	Setup_UUIE_hopCount * m_hopCount;
	public:
	void encode ( Asn :: ostream & os ) const;
	~Setup_UUIE ( );
	void printOn ( std :: ostream & os ) const;
	const TransportAddress & get_h245Address ( ) const {
		return * m_h245Address;
	}
	TransportAddress & get_h245Address ( ) {
		return * m_h245Address;
	}
	const ArrayOf_AliasAddress & get_sourceAddress ( ) const {
		return * m_sourceAddress;
	}
	ArrayOf_AliasAddress & get_sourceAddress ( ) {
		return * m_sourceAddress;
	}
	const ArrayOf_AliasAddress & get_destinationAddress ( ) const {
		return * m_destinationAddress;
	}
	ArrayOf_AliasAddress & get_destinationAddress ( ) {
		return * m_destinationAddress;
	}
	const TransportAddress & get_destCallSignalAddress ( ) const {
		return * m_destCallSignalAddress;
	}
	TransportAddress & get_destCallSignalAddress ( ) {
		return * m_destCallSignalAddress;
	}
	const ArrayOf_AliasAddress & get_destExtraCallInfo ( ) const {
		return * m_destExtraCallInfo;
	}
	ArrayOf_AliasAddress & get_destExtraCallInfo ( ) {
		return * m_destExtraCallInfo;
	}
	const ArrayOf_CallReferenceValue & get_destExtraCRV ( ) const {
		return * m_destExtraCRV;
	}
	ArrayOf_CallReferenceValue & get_destExtraCRV ( ) {
		return * m_destExtraCRV;
	}
	const QseriesOptions & get_callServices ( ) const {
		return * m_callServices;
	}
	QseriesOptions & get_callServices ( ) {
		return * m_callServices;
	}
	const TransportAddress & get_sourceCallSignalAddress ( ) const {
		return * m_sourceCallSignalAddress;
	}
	TransportAddress & get_sourceCallSignalAddress ( ) {
		return * m_sourceCallSignalAddress;
	}
	const AliasAddress & get_remoteExtensionAddress ( ) const {
		return * m_remoteExtensionAddress;
	}
	AliasAddress & get_remoteExtensionAddress ( ) {
		return * m_remoteExtensionAddress;
	}
	const CallIdentifier & get_callIdentifier ( ) const {
		return * m_callIdentifier;
	}
	CallIdentifier & get_callIdentifier ( ) {
		return * m_callIdentifier;
	}
	const ArrayOf_H245Security & get_h245SecurityCapability ( ) const {
		return * m_h245SecurityCapability;
	}
	ArrayOf_H245Security & get_h245SecurityCapability ( ) {
		return * m_h245SecurityCapability;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ArrayOf_Asn_OctetString & get_fastStart ( ) const {
		return * m_fastStart;
	}
	ArrayOf_Asn_OctetString & get_fastStart ( ) {
		return * m_fastStart;
	}
	const Asn :: Boolean & get_mediaWaitForConnect ( ) const {
		return * m_mediaWaitForConnect;
	}
	Asn :: Boolean & get_mediaWaitForConnect ( ) {
		return * m_mediaWaitForConnect;
	}
	const Asn :: Boolean & get_canOverlapSend ( ) const {
		return * m_canOverlapSend;
	}
	Asn :: Boolean & get_canOverlapSend ( ) {
		return * m_canOverlapSend;
	}
	const EndpointIdentifier & get_endpointIdentifier ( ) const {
		return * m_endpointIdentifier;
	}
	EndpointIdentifier & get_endpointIdentifier ( ) {
		return * m_endpointIdentifier;
	}
	const Asn :: Boolean & get_multipleCalls ( ) const {
		return * m_multipleCalls;
	}
	Asn :: Boolean & get_multipleCalls ( ) {
		return * m_multipleCalls;
	}
	const Asn :: Boolean & get_maintainConnection ( ) const {
		return * m_maintainConnection;
	}
	Asn :: Boolean & get_maintainConnection ( ) {
		return * m_maintainConnection;
	}
	const Setup_UUIE_connectionParameters & get_connectionParameters ( ) const {
		return * m_connectionParameters;
	}
	Setup_UUIE_connectionParameters & get_connectionParameters ( ) {
		return * m_connectionParameters;
	}
	const Setup_UUIE_language & get_language ( ) const {
		return * m_language;
	}
	Setup_UUIE_language & get_language ( ) {
		return * m_language;
	}
	const PresentationIndicator & get_presentationIndicator ( ) const {
		return * m_presentationIndicator;
	}
	PresentationIndicator & get_presentationIndicator ( ) {
		return * m_presentationIndicator;
	}
	const ScreeningIndicator & get_screeningIndicator ( ) const {
		return * m_screeningIndicator;
	}
	ScreeningIndicator & get_screeningIndicator ( ) {
		return * m_screeningIndicator;
	}
	const ArrayOf_ServiceControlSession & get_serviceControl ( ) const {
		return * m_serviceControl;
	}
	ArrayOf_ServiceControlSession & get_serviceControl ( ) {
		return * m_serviceControl;
	}
	const Asn :: Null & get_symmetricOperationRequired ( ) const {
		return * m_symmetricOperationRequired;
	}
	Asn :: Null & get_symmetricOperationRequired ( ) {
		return * m_symmetricOperationRequired;
	}
	const CallCapacity & get_capacity ( ) const {
		return * m_capacity;
	}
	CallCapacity & get_capacity ( ) {
		return * m_capacity;
	}
	const CircuitInfo & get_circuitInfo ( ) const {
		return * m_circuitInfo;
	}
	CircuitInfo & get_circuitInfo ( ) {
		return * m_circuitInfo;
	}
	const ArrayOf_SupportedProtocols & get_desiredProtocols ( ) const {
		return * m_desiredProtocols;
	}
	ArrayOf_SupportedProtocols & get_desiredProtocols ( ) {
		return * m_desiredProtocols;
	}
	const ArrayOf_FeatureDescriptor & get_neededFeatures ( ) const {
		return * m_neededFeatures;
	}
	ArrayOf_FeatureDescriptor & get_neededFeatures ( ) {
		return * m_neededFeatures;
	}
	const ArrayOf_FeatureDescriptor & get_desiredFeatures ( ) const {
		return * m_desiredFeatures;
	}
	ArrayOf_FeatureDescriptor & get_desiredFeatures ( ) {
		return * m_desiredFeatures;
	}
	const ArrayOf_FeatureDescriptor & get_supportedFeatures ( ) const {
		return * m_supportedFeatures;
	}
	ArrayOf_FeatureDescriptor & get_supportedFeatures ( ) {
		return * m_supportedFeatures;
	}
	const ArrayOf_Asn_OctetString & get_parallelH245Control ( ) const {
		return * m_parallelH245Control;
	}
	ArrayOf_Asn_OctetString & get_parallelH245Control ( ) {
		return * m_parallelH245Control;
	}
	const ArrayOf_ExtendedAliasAddress & get_additionalSourceAddresses ( ) const {
		return * m_additionalSourceAddresses;
	}
	ArrayOf_ExtendedAliasAddress & get_additionalSourceAddresses ( ) {
		return * m_additionalSourceAddresses;
	}
	const Setup_UUIE_hopCount & get_hopCount ( ) const {
		return * m_hopCount;
	}
	Setup_UUIE_hopCount & get_hopCount ( ) {
		return * m_hopCount;
	}
	Setup_UUIE * clone ( ) const;
};

//
// Facility-UUIE
//

// from 0 size 0 type 0 simple 0
class Facility_UUIE : public Asn :: Sequence {
	public:
	explicit Facility_UUIE ( Asn :: istream & is );
	Facility_UUIE ( );
	enum OptionalFields {
		e_alternativeAddress,
		e_alternativeAliasAddress,
		e_conferenceID,
		e_callIdentifier,
		e_destExtraCallInfo,
		e_remoteExtensionAddress,
		e_tokens,
		e_cryptoTokens,
		e_conferences,
		e_h245Address,
		e_fastStart,
		e_multipleCalls,
		e_maintainConnection,
		e_fastConnectRefused,
		e_serviceControl,
		e_circuitInfo,
		e_featureSet,
		e_destinationInfo,
		e_h245SecurityMode
	};

	Facility_UUIE ( const Facility_UUIE & s );
	Facility_UUIE & operator= ( const Facility_UUIE & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	ProtocolIdentifier m_protocolIdentifier;
	protected:
	TransportAddress * m_alternativeAddress;
	ArrayOf_AliasAddress * m_alternativeAliasAddress;
	ConferenceIdentifier * m_conferenceID;
	public:
	FacilityReason m_reason;
	protected:
	CallIdentifier * m_callIdentifier;
	ArrayOf_AliasAddress * m_destExtraCallInfo;
	AliasAddress * m_remoteExtensionAddress;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ArrayOf_ConferenceList * m_conferences;
	TransportAddress * m_h245Address;
	ArrayOf_Asn_OctetString * m_fastStart;
	Asn :: Boolean * m_multipleCalls;
	Asn :: Boolean * m_maintainConnection;
	Asn :: Null * m_fastConnectRefused;
	ArrayOf_ServiceControlSession * m_serviceControl;
	CircuitInfo * m_circuitInfo;
	FeatureSet * m_featureSet;
	EndpointType * m_destinationInfo;
	H245Security * m_h245SecurityMode;
	public:
	void encode ( Asn :: ostream & os ) const;
	~Facility_UUIE ( );
	void printOn ( std :: ostream & os ) const;
	const TransportAddress & get_alternativeAddress ( ) const {
		return * m_alternativeAddress;
	}
	TransportAddress & get_alternativeAddress ( ) {
		return * m_alternativeAddress;
	}
	const ArrayOf_AliasAddress & get_alternativeAliasAddress ( ) const {
		return * m_alternativeAliasAddress;
	}
	ArrayOf_AliasAddress & get_alternativeAliasAddress ( ) {
		return * m_alternativeAliasAddress;
	}
	const ConferenceIdentifier & get_conferenceID ( ) const {
		return * m_conferenceID;
	}
	ConferenceIdentifier & get_conferenceID ( ) {
		return * m_conferenceID;
	}
	const CallIdentifier & get_callIdentifier ( ) const {
		return * m_callIdentifier;
	}
	CallIdentifier & get_callIdentifier ( ) {
		return * m_callIdentifier;
	}
	const ArrayOf_AliasAddress & get_destExtraCallInfo ( ) const {
		return * m_destExtraCallInfo;
	}
	ArrayOf_AliasAddress & get_destExtraCallInfo ( ) {
		return * m_destExtraCallInfo;
	}
	const AliasAddress & get_remoteExtensionAddress ( ) const {
		return * m_remoteExtensionAddress;
	}
	AliasAddress & get_remoteExtensionAddress ( ) {
		return * m_remoteExtensionAddress;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ArrayOf_ConferenceList & get_conferences ( ) const {
		return * m_conferences;
	}
	ArrayOf_ConferenceList & get_conferences ( ) {
		return * m_conferences;
	}
	const TransportAddress & get_h245Address ( ) const {
		return * m_h245Address;
	}
	TransportAddress & get_h245Address ( ) {
		return * m_h245Address;
	}
	const ArrayOf_Asn_OctetString & get_fastStart ( ) const {
		return * m_fastStart;
	}
	ArrayOf_Asn_OctetString & get_fastStart ( ) {
		return * m_fastStart;
	}
	const Asn :: Boolean & get_multipleCalls ( ) const {
		return * m_multipleCalls;
	}
	Asn :: Boolean & get_multipleCalls ( ) {
		return * m_multipleCalls;
	}
	const Asn :: Boolean & get_maintainConnection ( ) const {
		return * m_maintainConnection;
	}
	Asn :: Boolean & get_maintainConnection ( ) {
		return * m_maintainConnection;
	}
	const Asn :: Null & get_fastConnectRefused ( ) const {
		return * m_fastConnectRefused;
	}
	Asn :: Null & get_fastConnectRefused ( ) {
		return * m_fastConnectRefused;
	}
	const ArrayOf_ServiceControlSession & get_serviceControl ( ) const {
		return * m_serviceControl;
	}
	ArrayOf_ServiceControlSession & get_serviceControl ( ) {
		return * m_serviceControl;
	}
	const CircuitInfo & get_circuitInfo ( ) const {
		return * m_circuitInfo;
	}
	CircuitInfo & get_circuitInfo ( ) {
		return * m_circuitInfo;
	}
	const FeatureSet & get_featureSet ( ) const {
		return * m_featureSet;
	}
	FeatureSet & get_featureSet ( ) {
		return * m_featureSet;
	}
	const EndpointType & get_destinationInfo ( ) const {
		return * m_destinationInfo;
	}
	EndpointType & get_destinationInfo ( ) {
		return * m_destinationInfo;
	}
	const H245Security & get_h245SecurityMode ( ) const {
		return * m_h245SecurityMode;
	}
	H245Security & get_h245SecurityMode ( ) {
		return * m_h245SecurityMode;
	}
	Facility_UUIE * clone ( ) const;
};

//
// Progress-UUIE
//

// from 0 size 0 type 0 simple 0
class Progress_UUIE : public Asn :: Sequence {
	public:
	explicit Progress_UUIE ( Asn :: istream & is );
	Progress_UUIE ( );
	enum OptionalFields {
		e_h245Address,
		e_h245SecurityMode,
		e_tokens,
		e_cryptoTokens,
		e_fastStart,
		e_multipleCalls,
		e_maintainConnection,
		e_fastConnectRefused
	};

	Progress_UUIE ( const Progress_UUIE & s );
	Progress_UUIE & operator= ( const Progress_UUIE & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	ProtocolIdentifier m_protocolIdentifier;
	EndpointType m_destinationInfo;
	protected:
	TransportAddress * m_h245Address;
	public:
	CallIdentifier m_callIdentifier;
	protected:
	H245Security * m_h245SecurityMode;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ArrayOf_Asn_OctetString * m_fastStart;
	Asn :: Boolean * m_multipleCalls;
	Asn :: Boolean * m_maintainConnection;
	Asn :: Null * m_fastConnectRefused;
	public:
	void encode ( Asn :: ostream & os ) const;
	~Progress_UUIE ( );
	void printOn ( std :: ostream & os ) const;
	const TransportAddress & get_h245Address ( ) const {
		return * m_h245Address;
	}
	TransportAddress & get_h245Address ( ) {
		return * m_h245Address;
	}
	const H245Security & get_h245SecurityMode ( ) const {
		return * m_h245SecurityMode;
	}
	H245Security & get_h245SecurityMode ( ) {
		return * m_h245SecurityMode;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ArrayOf_Asn_OctetString & get_fastStart ( ) const {
		return * m_fastStart;
	}
	ArrayOf_Asn_OctetString & get_fastStart ( ) {
		return * m_fastStart;
	}
	const Asn :: Boolean & get_multipleCalls ( ) const {
		return * m_multipleCalls;
	}
	Asn :: Boolean & get_multipleCalls ( ) {
		return * m_multipleCalls;
	}
	const Asn :: Boolean & get_maintainConnection ( ) const {
		return * m_maintainConnection;
	}
	Asn :: Boolean & get_maintainConnection ( ) {
		return * m_maintainConnection;
	}
	const Asn :: Null & get_fastConnectRefused ( ) const {
		return * m_fastConnectRefused;
	}
	Asn :: Null & get_fastConnectRefused ( ) {
		return * m_fastConnectRefused;
	}
	Progress_UUIE * clone ( ) const;
};

//
// Status-UUIE
//

// from 0 size 0 type 0 simple 0
class Status_UUIE : public Asn :: Sequence {
	public:
	explicit Status_UUIE ( Asn :: istream & is );
	Status_UUIE ( );
	enum OptionalFields {
		e_tokens,
		e_cryptoTokens
	};

	Status_UUIE ( const Status_UUIE & s );
	Status_UUIE & operator= ( const Status_UUIE & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	ProtocolIdentifier m_protocolIdentifier;
	CallIdentifier m_callIdentifier;
	protected:
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	public:
	void encode ( Asn :: ostream & os ) const;
	~Status_UUIE ( );
	void printOn ( std :: ostream & os ) const;
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	Status_UUIE * clone ( ) const;
};

//
// StatusInquiry-UUIE
//

// from 0 size 0 type 0 simple 0
class StatusInquiry_UUIE : public Asn :: Sequence {
	public:
	explicit StatusInquiry_UUIE ( Asn :: istream & is );
	StatusInquiry_UUIE ( );
	enum OptionalFields {
		e_tokens,
		e_cryptoTokens
	};

	StatusInquiry_UUIE ( const StatusInquiry_UUIE & s );
	StatusInquiry_UUIE & operator= ( const StatusInquiry_UUIE & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	ProtocolIdentifier m_protocolIdentifier;
	CallIdentifier m_callIdentifier;
	protected:
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	public:
	void encode ( Asn :: ostream & os ) const;
	~StatusInquiry_UUIE ( );
	void printOn ( std :: ostream & os ) const;
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	StatusInquiry_UUIE * clone ( ) const;
};

//
// SetupAcknowledge-UUIE
//

// from 0 size 0 type 0 simple 0
class SetupAcknowledge_UUIE : public Asn :: Sequence {
	public:
	explicit SetupAcknowledge_UUIE ( Asn :: istream & is );
	SetupAcknowledge_UUIE ( );
	enum OptionalFields {
		e_tokens,
		e_cryptoTokens
	};

	SetupAcknowledge_UUIE ( const SetupAcknowledge_UUIE & s );
	SetupAcknowledge_UUIE & operator= ( const SetupAcknowledge_UUIE & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	ProtocolIdentifier m_protocolIdentifier;
	CallIdentifier m_callIdentifier;
	protected:
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	public:
	void encode ( Asn :: ostream & os ) const;
	~SetupAcknowledge_UUIE ( );
	void printOn ( std :: ostream & os ) const;
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	SetupAcknowledge_UUIE * clone ( ) const;
};

//
// Notify-UUIE
//

// from 0 size 0 type 0 simple 0
class Notify_UUIE : public Asn :: Sequence {
	public:
	explicit Notify_UUIE ( Asn :: istream & is );
	Notify_UUIE ( );
	enum OptionalFields {
		e_tokens,
		e_cryptoTokens
	};

	Notify_UUIE ( const Notify_UUIE & s );
	Notify_UUIE & operator= ( const Notify_UUIE & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	ProtocolIdentifier m_protocolIdentifier;
	CallIdentifier m_callIdentifier;
	protected:
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	public:
	void encode ( Asn :: ostream & os ) const;
	~Notify_UUIE ( );
	void printOn ( std :: ostream & os ) const;
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	Notify_UUIE * clone ( ) const;
};

//
// NonStandardProtocol
//

// from 0 size 0 type 0 simple 0
class NonStandardProtocol : public Asn :: Sequence {
	public:
	explicit NonStandardProtocol ( Asn :: istream & is );
	NonStandardProtocol ( );
	enum OptionalFields {
		e_nonStandardData,
		e_dataRatesSupported
	};

	NonStandardProtocol ( const NonStandardProtocol & s );
	NonStandardProtocol & operator= ( const NonStandardProtocol & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	NonStandardParameter * m_nonStandardData;
	ArrayOf_DataRate * m_dataRatesSupported;
	public:
	ArrayOf_SupportedPrefix m_supportedPrefixes;
	void encode ( Asn :: ostream & os ) const;
	~NonStandardProtocol ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const ArrayOf_DataRate & get_dataRatesSupported ( ) const {
		return * m_dataRatesSupported;
	}
	ArrayOf_DataRate & get_dataRatesSupported ( ) {
		return * m_dataRatesSupported;
	}
	NonStandardProtocol * clone ( ) const;
};

//
// T38FaxAnnexbOnlyCaps
//

// from 0 size 0 type 0 simple 0
class T38FaxAnnexbOnlyCaps : public Asn :: Sequence {
	public:
	explicit T38FaxAnnexbOnlyCaps ( Asn :: istream & is );
	T38FaxAnnexbOnlyCaps ( );
	enum OptionalFields {
		e_nonStandardData,
		e_dataRatesSupported
	};

	T38FaxAnnexbOnlyCaps ( const T38FaxAnnexbOnlyCaps & s );
	T38FaxAnnexbOnlyCaps & operator= ( const T38FaxAnnexbOnlyCaps & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	NonStandardParameter * m_nonStandardData;
	ArrayOf_DataRate * m_dataRatesSupported;
	public:
	ArrayOf_SupportedPrefix m_supportedPrefixes;
	H245 :: DataProtocolCapability m_t38FaxProtocol;
	H245 :: T38FaxProfile m_t38FaxProfile;
	void encode ( Asn :: ostream & os ) const;
	~T38FaxAnnexbOnlyCaps ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const ArrayOf_DataRate & get_dataRatesSupported ( ) const {
		return * m_dataRatesSupported;
	}
	ArrayOf_DataRate & get_dataRatesSupported ( ) {
		return * m_dataRatesSupported;
	}
	T38FaxAnnexbOnlyCaps * clone ( ) const;
};

//
// H221NonStandard
//

// from 0 size 0 type 0 simple 0
class H221NonStandard : public Asn :: Sequence {
	public:
	explicit H221NonStandard ( Asn :: istream & is );
	H221NonStandard ( );
	H221NonStandard_t35CountryCode m_t35CountryCode;
	H221NonStandard_t35Extension m_t35Extension;
	H221NonStandard_manufacturerCode m_manufacturerCode;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	H221NonStandard * clone ( ) const;
};

//
// TunnelledProtocolAlternateIdentifier
//

// from 0 size 0 type 0 simple 0
class TunnelledProtocolAlternateIdentifier : public Asn :: Sequence {
	public:
	explicit TunnelledProtocolAlternateIdentifier ( Asn :: istream & is );
	TunnelledProtocolAlternateIdentifier ( );
	enum OptionalFields {
		e_protocolVariant
	};

	TunnelledProtocolAlternateIdentifier ( const TunnelledProtocolAlternateIdentifier & s );
	TunnelledProtocolAlternateIdentifier & operator= ( const TunnelledProtocolAlternateIdentifier & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	TunnelledProtocolAlternateIdentifier_protocolType m_protocolType;
	protected:
	TunnelledProtocolAlternateIdentifier_protocolVariant * m_protocolVariant;
	public:
	void encode ( Asn :: ostream & os ) const;
	~TunnelledProtocolAlternateIdentifier ( );
	void printOn ( std :: ostream & os ) const;
	const TunnelledProtocolAlternateIdentifier_protocolVariant & get_protocolVariant ( ) const {
		return * m_protocolVariant;
	}
	TunnelledProtocolAlternateIdentifier_protocolVariant & get_protocolVariant ( ) {
		return * m_protocolVariant;
	}
	TunnelledProtocolAlternateIdentifier * clone ( ) const;
};

//
// NonStandardIdentifier
//

// from 0 size 0 type 0 simple 0
class NonStandardIdentifier : public Asn :: Choice {
	public:
	explicit NonStandardIdentifier ( Asn :: istream & is );
	NonStandardIdentifier ( );
	enum Choices {
		e_object,
		e_h221NonStandard
	};

	operator Asn :: ObjectId & ( ) { return dynamic_cast < Asn :: ObjectId & > ( * choice ); }
	operator const Asn :: ObjectId & ( ) const { return dynamic_cast < const Asn :: ObjectId & > ( * choice ); }
	operator H221NonStandard & ( ) { return dynamic_cast < H221NonStandard & > ( * choice ); }
	operator const H221NonStandard & ( ) const { return dynamic_cast < const H221NonStandard & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	NonStandardIdentifier * clone ( ) const;
};

//
// PublicPartyNumber
//

// from 0 size 0 type 0 simple 0
class PublicPartyNumber : public Asn :: Sequence {
	public:
	explicit PublicPartyNumber ( Asn :: istream & is );
	PublicPartyNumber ( );
	PublicTypeOfNumber m_publicTypeOfNumber;
	NumberDigits m_publicNumberDigits;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	PublicPartyNumber * clone ( ) const;
};

//
// PrivatePartyNumber
//

// from 0 size 0 type 0 simple 0
class PrivatePartyNumber : public Asn :: Sequence {
	public:
	explicit PrivatePartyNumber ( Asn :: istream & is );
	PrivatePartyNumber ( );
	PrivateTypeOfNumber m_privateTypeOfNumber;
	NumberDigits m_privateNumberDigits;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	PrivatePartyNumber * clone ( ) const;
};

//
// GSM-UIM
//

// from 0 size 0 type 0 simple 0
class GSM_UIM : public Asn :: Sequence {
	public:
	explicit GSM_UIM ( Asn :: istream & is );
	GSM_UIM ( );
	enum OptionalFields {
		e_tmsi
	};

	GSM_UIM ( const GSM_UIM & s );
	GSM_UIM & operator= ( const GSM_UIM & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	GSM_UIM_imsi m_imsi;
	protected:
	GSM_UIM_tmsi * m_tmsi;
	public:
	GSM_UIM_msisdn m_msisdn;
	GSM_UIM_imei m_imei;
	GSM_UIM_hplmn m_hplmn;
	GSM_UIM_vplmn m_vplmn;
	void encode ( Asn :: ostream & os ) const;
	~GSM_UIM ( );
	void printOn ( std :: ostream & os ) const;
	const GSM_UIM_tmsi & get_tmsi ( ) const {
		return * m_tmsi;
	}
	GSM_UIM_tmsi & get_tmsi ( ) {
		return * m_tmsi;
	}
	GSM_UIM * clone ( ) const;
};

//
// IsupPublicPartyNumber
//

// from 0 size 0 type 0 simple 0
class IsupPublicPartyNumber : public Asn :: Sequence {
	public:
	explicit IsupPublicPartyNumber ( Asn :: istream & is );
	IsupPublicPartyNumber ( );
	NatureOfAddress m_natureOfAddress;
	IsupDigits m_address;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	IsupPublicPartyNumber * clone ( ) const;
};

//
// IsupPrivatePartyNumber
//

// from 0 size 0 type 0 simple 0
class IsupPrivatePartyNumber : public Asn :: Sequence {
	public:
	explicit IsupPrivatePartyNumber ( Asn :: istream & is );
	IsupPrivatePartyNumber ( );
	PrivateTypeOfNumber m_privateTypeOfNumber;
	IsupDigits m_address;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	IsupPrivatePartyNumber * clone ( ) const;
};

//
// AltGKInfo
//

// from 0 size 0 type 0 simple 0
class AltGKInfo : public Asn :: Sequence {
	public:
	explicit AltGKInfo ( Asn :: istream & is );
	AltGKInfo ( );
	ArrayOf_AlternateGK m_alternateGatekeeper;
	Asn :: Boolean m_altGKisPermanent;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	AltGKInfo * clone ( ) const;
};

//
// QseriesOptions
//

// from 0 size 0 type 0 simple 0
class QseriesOptions : public Asn :: Sequence {
	public:
	explicit QseriesOptions ( Asn :: istream & is );
	QseriesOptions ( );
	Asn :: Boolean m_q932Full;
	Asn :: Boolean m_q951Full;
	Asn :: Boolean m_q952Full;
	Asn :: Boolean m_q953Full;
	Asn :: Boolean m_q955Full;
	Asn :: Boolean m_q956Full;
	Asn :: Boolean m_q957Full;
	Q954Details m_q954Info;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	QseriesOptions * clone ( ) const;
};

//
// CapacityReportingSpecification
//

// from 0 size 0 type 0 simple 0
class CapacityReportingSpecification : public Asn :: Sequence {
	public:
	explicit CapacityReportingSpecification ( Asn :: istream & is );
	CapacityReportingSpecification ( );
	CapacityReportingSpecification_when m_when;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	CapacityReportingSpecification * clone ( ) const;
};

//
// CallsAvailable
//

// from 0 size 0 type 0 simple 0
class CallsAvailable : public Asn :: Sequence {
	public:
	explicit CallsAvailable ( Asn :: istream & is );
	CallsAvailable ( );
	enum OptionalFields {
		e_group,
		e_carrier
	};

	CallsAvailable ( const CallsAvailable & s );
	CallsAvailable & operator= ( const CallsAvailable & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	CallsAvailable_calls m_calls;
	protected:
	CallsAvailable_group * m_group;
	CarrierInfo * m_carrier;
	public:
	void encode ( Asn :: ostream & os ) const;
	~CallsAvailable ( );
	void printOn ( std :: ostream & os ) const;
	const CallsAvailable_group & get_group ( ) const {
		return * m_group;
	}
	CallsAvailable_group & get_group ( ) {
		return * m_group;
	}
	const CarrierInfo & get_carrier ( ) const {
		return * m_carrier;
	}
	CarrierInfo & get_carrier ( ) {
		return * m_carrier;
	}
	CallsAvailable * clone ( ) const;
};

//
// CicInfo
//

// from 0 size 0 type 0 simple 0
class CicInfo : public Asn :: Sequence {
	public:
	explicit CicInfo ( Asn :: istream & is );
	CicInfo ( );
	CicInfo_cic m_cic;
	CicInfo_pointCode m_pointCode;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	CicInfo * clone ( ) const;
};

//
// GroupID
//

// from 0 size 0 type 0 simple 0
class GroupID : public Asn :: Sequence {
	public:
	explicit GroupID ( Asn :: istream & is );
	GroupID ( );
	enum OptionalFields {
		e_member
	};

	GroupID ( const GroupID & s );
	GroupID & operator= ( const GroupID & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	GroupID_member * m_member;
	public:
	GroupID_group m_group;
	void encode ( Asn :: ostream & os ) const;
	~GroupID ( );
	void printOn ( std :: ostream & os ) const;
	const GroupID_member & get_member ( ) const {
		return * m_member;
	}
	GroupID_member & get_member ( ) {
		return * m_member;
	}
	GroupID * clone ( ) const;
};

//
// ServiceControlSession
//

// from 0 size 0 type 0 simple 0
class ServiceControlDescriptor;

class ServiceControlSession : public Asn :: Sequence {
	public:
	explicit ServiceControlSession ( Asn :: istream & is );
	ServiceControlSession ( );
	enum OptionalFields {
		e_contents
	};

	ServiceControlSession ( const ServiceControlSession & s );
	ServiceControlSession & operator= ( const ServiceControlSession & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	ServiceControlSession_sessionId m_sessionId;
	protected:
	ServiceControlDescriptor * m_contents;
	public:
	ServiceControlSession_reason m_reason;
	void encode ( Asn :: ostream & os ) const;
	~ServiceControlSession ( );
	void printOn ( std :: ostream & os ) const;
	const ServiceControlDescriptor & get_contents ( ) const {
		return * m_contents;
	}
	ServiceControlDescriptor & get_contents ( ) {
		return * m_contents;
	}
	ServiceControlSession * clone ( ) const;
};

//
// RasUsageInfoTypes
//

// from 0 size 0 type 0 simple 0
class RasUsageInfoTypes : public Asn :: Sequence {
	public:
	explicit RasUsageInfoTypes ( Asn :: istream & is );
	RasUsageInfoTypes ( );
	enum OptionalFields {
		e_startTime,
		e_endTime,
		e_terminationCause
	};

	RasUsageInfoTypes ( const RasUsageInfoTypes & s );
	RasUsageInfoTypes & operator= ( const RasUsageInfoTypes & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	ArrayOf_NonStandardParameter m_nonStandardUsageTypes;
	protected:
	Asn :: Null * m_startTime;
	Asn :: Null * m_endTime;
	Asn :: Null * m_terminationCause;
	public:
	void encode ( Asn :: ostream & os ) const;
	~RasUsageInfoTypes ( );
	void printOn ( std :: ostream & os ) const;
	const Asn :: Null & get_startTime ( ) const {
		return * m_startTime;
	}
	Asn :: Null & get_startTime ( ) {
		return * m_startTime;
	}
	const Asn :: Null & get_endTime ( ) const {
		return * m_endTime;
	}
	Asn :: Null & get_endTime ( ) {
		return * m_endTime;
	}
	const Asn :: Null & get_terminationCause ( ) const {
		return * m_terminationCause;
	}
	Asn :: Null & get_terminationCause ( ) {
		return * m_terminationCause;
	}
	RasUsageInfoTypes * clone ( ) const;
};

//
// RasUsageSpecification
//

// from 0 size 0 type 0 simple 0
class RasUsageSpecification : public Asn :: Sequence {
	public:
	explicit RasUsageSpecification ( Asn :: istream & is );
	RasUsageSpecification ( );
	enum OptionalFields {
		e_callStartingPoint
	};

	RasUsageSpecification ( const RasUsageSpecification & s );
	RasUsageSpecification & operator= ( const RasUsageSpecification & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	RasUsageSpecification_when m_when;
	protected:
	RasUsageSpecification_callStartingPoint * m_callStartingPoint;
	public:
	RasUsageInfoTypes m_required;
	void encode ( Asn :: ostream & os ) const;
	~RasUsageSpecification ( );
	void printOn ( std :: ostream & os ) const;
	const RasUsageSpecification_callStartingPoint & get_callStartingPoint ( ) const {
		return * m_callStartingPoint;
	}
	RasUsageSpecification_callStartingPoint & get_callStartingPoint ( ) {
		return * m_callStartingPoint;
	}
	RasUsageSpecification * clone ( ) const;
};

//
// RasUsageInformation
//

// from 0 size 0 type 0 simple 0
class RasUsageInformation : public Asn :: Sequence {
	public:
	explicit RasUsageInformation ( Asn :: istream & is );
	RasUsageInformation ( );
	enum OptionalFields {
		e_alertingTime,
		e_connectTime,
		e_endTime
	};

	RasUsageInformation ( const RasUsageInformation & s );
	RasUsageInformation & operator= ( const RasUsageInformation & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	ArrayOf_NonStandardParameter m_nonStandardUsageFields;
	protected:
	H235 :: TimeStamp * m_alertingTime;
	H235 :: TimeStamp * m_connectTime;
	H235 :: TimeStamp * m_endTime;
	public:
	void encode ( Asn :: ostream & os ) const;
	~RasUsageInformation ( );
	void printOn ( std :: ostream & os ) const;
	const H235 :: TimeStamp & get_alertingTime ( ) const {
		return * m_alertingTime;
	}
	H235 :: TimeStamp & get_alertingTime ( ) {
		return * m_alertingTime;
	}
	const H235 :: TimeStamp & get_connectTime ( ) const {
		return * m_connectTime;
	}
	H235 :: TimeStamp & get_connectTime ( ) {
		return * m_connectTime;
	}
	const H235 :: TimeStamp & get_endTime ( ) const {
		return * m_endTime;
	}
	H235 :: TimeStamp & get_endTime ( ) {
		return * m_endTime;
	}
	RasUsageInformation * clone ( ) const;
};

//
// BandwidthDetails
//

// from 0 size 0 type 0 simple 0
class BandwidthDetails : public Asn :: Sequence {
	public:
	explicit BandwidthDetails ( Asn :: istream & is );
	BandwidthDetails ( );
	Asn :: Boolean m_sender;
	Asn :: Boolean m_multicast;
	BandWidth m_bandwidth;
	TransportChannelInfo m_rtcpAddresses;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	BandwidthDetails * clone ( ) const;
};

//
// GenericIdentifier
//

// from 0 size 0 type 0 simple 0
class GenericIdentifier : public Asn :: Choice {
	public:
	explicit GenericIdentifier ( Asn :: istream & is );
	GenericIdentifier ( );
	enum Choices {
		e_standard,
		e_oid,
		e_nonStandard
	};

	operator GenericIdentifier_standard & ( ) { return dynamic_cast < GenericIdentifier_standard & > ( * choice ); }
	operator const GenericIdentifier_standard & ( ) const { return dynamic_cast < const GenericIdentifier_standard & > ( * choice ); }
	operator Asn :: ObjectId & ( ) { return dynamic_cast < Asn :: ObjectId & > ( * choice ); }
	operator const Asn :: ObjectId & ( ) const { return dynamic_cast < const Asn :: ObjectId & > ( * choice ); }
	operator GloballyUniqueID & ( ) { return dynamic_cast < GloballyUniqueID & > ( * choice ); }
	operator const GloballyUniqueID & ( ) const { return dynamic_cast < const GloballyUniqueID & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	GenericIdentifier * clone ( ) const;
};

//
// EnumeratedParameter
//

// from 0 size 0 type 0 simple 0
class Content;

class EnumeratedParameter : public Asn :: Sequence {
	public:
	explicit EnumeratedParameter ( Asn :: istream & is );
	EnumeratedParameter ( );
	enum OptionalFields {
		e_content
	};

	EnumeratedParameter ( const EnumeratedParameter & s );
	EnumeratedParameter & operator= ( const EnumeratedParameter & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	GenericIdentifier m_id;
	protected:
	Content * m_content;
	public:
	void encode ( Asn :: ostream & os ) const;
	~EnumeratedParameter ( );
	void printOn ( std :: ostream & os ) const;
	const Content & get_content ( ) const {
		return * m_content;
	}
	Content & get_content ( ) {
		return * m_content;
	}
	EnumeratedParameter * clone ( ) const;
};

//
// RTPSession
//

// from 0 size 0 type 0 simple 0
class RTPSession : public Asn :: Sequence {
	public:
	explicit RTPSession ( Asn :: istream & is );
	RTPSession ( );
	enum OptionalFields {
		e_multicast,
		e_bandwidth
	};

	RTPSession ( const RTPSession & s );
	RTPSession & operator= ( const RTPSession & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	TransportChannelInfo m_rtpAddress;
	TransportChannelInfo m_rtcpAddress;
	Asn :: PrintableString m_cname;
	RTPSession_ssrc m_ssrc;
	RTPSession_sessionId m_sessionId;
	RTPSession_associatedSessionIds m_associatedSessionIds;
	protected:
	Asn :: Null * m_multicast;
	BandWidth * m_bandwidth;
	public:
	void encode ( Asn :: ostream & os ) const;
	~RTPSession ( );
	void printOn ( std :: ostream & os ) const;
	const Asn :: Null & get_multicast ( ) const {
		return * m_multicast;
	}
	Asn :: Null & get_multicast ( ) {
		return * m_multicast;
	}
	const BandWidth & get_bandwidth ( ) const {
		return * m_bandwidth;
	}
	BandWidth & get_bandwidth ( ) {
		return * m_bandwidth;
	}
	RTPSession * clone ( ) const;
};

//
// GatekeeperReject
//

// from 0 size 0 type 0 simple 0
class GatekeeperReject : public Asn :: Sequence {
	public:
	explicit GatekeeperReject ( Asn :: istream & is );
	GatekeeperReject ( );
	enum OptionalFields {
		e_nonStandardData,
		e_gatekeeperIdentifier,
		e_altGKInfo,
		e_tokens,
		e_cryptoTokens,
		e_integrityCheckValue,
		e_featureSet,
		e_genericData
	};

	GatekeeperReject ( const GatekeeperReject & s );
	GatekeeperReject & operator= ( const GatekeeperReject & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	RequestSeqNum m_requestSeqNum;
	ProtocolIdentifier m_protocolIdentifier;
	protected:
	NonStandardParameter * m_nonStandardData;
	GatekeeperIdentifier * m_gatekeeperIdentifier;
	public:
	GatekeeperRejectReason m_rejectReason;
	protected:
	AltGKInfo * m_altGKInfo;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ICV * m_integrityCheckValue;
	FeatureSet * m_featureSet;
	ArrayOf_GenericData * m_genericData;
	public:
	void encode ( Asn :: ostream & os ) const;
	~GatekeeperReject ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const GatekeeperIdentifier & get_gatekeeperIdentifier ( ) const {
		return * m_gatekeeperIdentifier;
	}
	GatekeeperIdentifier & get_gatekeeperIdentifier ( ) {
		return * m_gatekeeperIdentifier;
	}
	const AltGKInfo & get_altGKInfo ( ) const {
		return * m_altGKInfo;
	}
	AltGKInfo & get_altGKInfo ( ) {
		return * m_altGKInfo;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ICV & get_integrityCheckValue ( ) const {
		return * m_integrityCheckValue;
	}
	ICV & get_integrityCheckValue ( ) {
		return * m_integrityCheckValue;
	}
	const FeatureSet & get_featureSet ( ) const {
		return * m_featureSet;
	}
	FeatureSet & get_featureSet ( ) {
		return * m_featureSet;
	}
	const ArrayOf_GenericData & get_genericData ( ) const {
		return * m_genericData;
	}
	ArrayOf_GenericData & get_genericData ( ) {
		return * m_genericData;
	}
	GatekeeperReject * clone ( ) const;
};

//
// RegistrationConfirm
//

// from 0 size 0 type 0 simple 0
class RegistrationConfirm : public Asn :: Sequence {
	public:
	explicit RegistrationConfirm ( Asn :: istream & is );
	RegistrationConfirm ( );
	enum OptionalFields {
		e_nonStandardData,
		e_terminalAlias,
		e_gatekeeperIdentifier,
		e_alternateGatekeeper,
		e_timeToLive,
		e_tokens,
		e_cryptoTokens,
		e_integrityCheckValue,
		e_willRespondToIRR,
		e_preGrantedARQ,
		e_maintainConnection,
		e_serviceControl,
		e_supportsAdditiveRegistration,
		e_terminalAliasPattern,
		e_supportedPrefixes,
		e_usageSpec,
		e_featureServerAlias,
		e_capacityReportingSpec,
		e_featureSet,
		e_genericData,
		e_assignedGatekeeper,
		e_rehomingModel,
		e_transportQOS
	};

	RegistrationConfirm ( const RegistrationConfirm & s );
	RegistrationConfirm & operator= ( const RegistrationConfirm & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	RequestSeqNum m_requestSeqNum;
	ProtocolIdentifier m_protocolIdentifier;
	protected:
	NonStandardParameter * m_nonStandardData;
	public:
	ArrayOf_TransportAddress m_callSignalAddress;
	protected:
	ArrayOf_AliasAddress * m_terminalAlias;
	GatekeeperIdentifier * m_gatekeeperIdentifier;
	public:
	EndpointIdentifier m_endpointIdentifier;
	protected:
	ArrayOf_AlternateGK * m_alternateGatekeeper;
	TimeToLive * m_timeToLive;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ICV * m_integrityCheckValue;
	Asn :: Boolean * m_willRespondToIRR;
	RegistrationConfirm_preGrantedARQ * m_preGrantedARQ;
	Asn :: Boolean * m_maintainConnection;
	ArrayOf_ServiceControlSession * m_serviceControl;
	Asn :: Null * m_supportsAdditiveRegistration;
	ArrayOf_AddressPattern * m_terminalAliasPattern;
	ArrayOf_SupportedPrefix * m_supportedPrefixes;
	ArrayOf_RasUsageSpecification * m_usageSpec;
	AliasAddress * m_featureServerAlias;
	CapacityReportingSpecification * m_capacityReportingSpec;
	FeatureSet * m_featureSet;
	ArrayOf_GenericData * m_genericData;
	AlternateGK * m_assignedGatekeeper;
	RehomingModel * m_rehomingModel;
	TransportQOS * m_transportQOS;
	public:
	void encode ( Asn :: ostream & os ) const;
	~RegistrationConfirm ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const ArrayOf_AliasAddress & get_terminalAlias ( ) const {
		return * m_terminalAlias;
	}
	ArrayOf_AliasAddress & get_terminalAlias ( ) {
		return * m_terminalAlias;
	}
	const GatekeeperIdentifier & get_gatekeeperIdentifier ( ) const {
		return * m_gatekeeperIdentifier;
	}
	GatekeeperIdentifier & get_gatekeeperIdentifier ( ) {
		return * m_gatekeeperIdentifier;
	}
	const ArrayOf_AlternateGK & get_alternateGatekeeper ( ) const {
		return * m_alternateGatekeeper;
	}
	ArrayOf_AlternateGK & get_alternateGatekeeper ( ) {
		return * m_alternateGatekeeper;
	}
	const TimeToLive & get_timeToLive ( ) const {
		return * m_timeToLive;
	}
	TimeToLive & get_timeToLive ( ) {
		return * m_timeToLive;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ICV & get_integrityCheckValue ( ) const {
		return * m_integrityCheckValue;
	}
	ICV & get_integrityCheckValue ( ) {
		return * m_integrityCheckValue;
	}
	const Asn :: Boolean & get_willRespondToIRR ( ) const {
		return * m_willRespondToIRR;
	}
	Asn :: Boolean & get_willRespondToIRR ( ) {
		return * m_willRespondToIRR;
	}
	const RegistrationConfirm_preGrantedARQ & get_preGrantedARQ ( ) const {
		return * m_preGrantedARQ;
	}
	RegistrationConfirm_preGrantedARQ & get_preGrantedARQ ( ) {
		return * m_preGrantedARQ;
	}
	const Asn :: Boolean & get_maintainConnection ( ) const {
		return * m_maintainConnection;
	}
	Asn :: Boolean & get_maintainConnection ( ) {
		return * m_maintainConnection;
	}
	const ArrayOf_ServiceControlSession & get_serviceControl ( ) const {
		return * m_serviceControl;
	}
	ArrayOf_ServiceControlSession & get_serviceControl ( ) {
		return * m_serviceControl;
	}
	const Asn :: Null & get_supportsAdditiveRegistration ( ) const {
		return * m_supportsAdditiveRegistration;
	}
	Asn :: Null & get_supportsAdditiveRegistration ( ) {
		return * m_supportsAdditiveRegistration;
	}
	const ArrayOf_AddressPattern & get_terminalAliasPattern ( ) const {
		return * m_terminalAliasPattern;
	}
	ArrayOf_AddressPattern & get_terminalAliasPattern ( ) {
		return * m_terminalAliasPattern;
	}
	const ArrayOf_SupportedPrefix & get_supportedPrefixes ( ) const {
		return * m_supportedPrefixes;
	}
	ArrayOf_SupportedPrefix & get_supportedPrefixes ( ) {
		return * m_supportedPrefixes;
	}
	const ArrayOf_RasUsageSpecification & get_usageSpec ( ) const {
		return * m_usageSpec;
	}
	ArrayOf_RasUsageSpecification & get_usageSpec ( ) {
		return * m_usageSpec;
	}
	const AliasAddress & get_featureServerAlias ( ) const {
		return * m_featureServerAlias;
	}
	AliasAddress & get_featureServerAlias ( ) {
		return * m_featureServerAlias;
	}
	const CapacityReportingSpecification & get_capacityReportingSpec ( ) const {
		return * m_capacityReportingSpec;
	}
	CapacityReportingSpecification & get_capacityReportingSpec ( ) {
		return * m_capacityReportingSpec;
	}
	const FeatureSet & get_featureSet ( ) const {
		return * m_featureSet;
	}
	FeatureSet & get_featureSet ( ) {
		return * m_featureSet;
	}
	const ArrayOf_GenericData & get_genericData ( ) const {
		return * m_genericData;
	}
	ArrayOf_GenericData & get_genericData ( ) {
		return * m_genericData;
	}
	const AlternateGK & get_assignedGatekeeper ( ) const {
		return * m_assignedGatekeeper;
	}
	AlternateGK & get_assignedGatekeeper ( ) {
		return * m_assignedGatekeeper;
	}
	const RehomingModel & get_rehomingModel ( ) const {
		return * m_rehomingModel;
	}
	RehomingModel & get_rehomingModel ( ) {
		return * m_rehomingModel;
	}
	const TransportQOS & get_transportQOS ( ) const {
		return * m_transportQOS;
	}
	TransportQOS & get_transportQOS ( ) {
		return * m_transportQOS;
	}
	RegistrationConfirm * clone ( ) const;
};

//
// RegistrationRejectReason
//

// from 0 size 0 type 0 simple 0
class RegistrationRejectReason : public Asn :: Choice {
	public:
	explicit RegistrationRejectReason ( Asn :: istream & is );
	RegistrationRejectReason ( );
	enum Choices {
		e_discoveryRequired,
		e_invalidRevision,
		e_invalidCallSignalAddress,
		e_invalidRASAddress,
		e_duplicateAlias,
		e_invalidTerminalType,
		e_undefinedReason,
		e_transportNotSupported,
		e_transportQOSNotSupported,
		e_resourceUnavailable,
		e_invalidAlias,
		e_securityDenial,
		e_fullRegistrationRequired,
		e_additiveRegistrationNotSupported,
		e_invalidTerminalAliases,
		e_genericDataReason,
		e_neededFeatureNotSupported,
		e_securityError,
		e_registerWithAssignedGK
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator ArrayOf_AliasAddress & ( ) { return dynamic_cast < ArrayOf_AliasAddress & > ( * choice ); }
	operator const ArrayOf_AliasAddress & ( ) const { return dynamic_cast < const ArrayOf_AliasAddress & > ( * choice ); }
	operator RegistrationRejectReason_invalidTerminalAliases & ( ) { return dynamic_cast < RegistrationRejectReason_invalidTerminalAliases & > ( * choice ); }
	operator const RegistrationRejectReason_invalidTerminalAliases & ( ) const { return dynamic_cast < const RegistrationRejectReason_invalidTerminalAliases & > ( * choice ); }
	operator SecurityErrors & ( ) { return dynamic_cast < SecurityErrors & > ( * choice ); }
	operator const SecurityErrors & ( ) const { return dynamic_cast < const SecurityErrors & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	RegistrationRejectReason * clone ( ) const;
};

//
// UnregistrationRequest
//

// from 0 size 0 type 0 simple 0
class UnregistrationRequest : public Asn :: Sequence {
	public:
	explicit UnregistrationRequest ( Asn :: istream & is );
	UnregistrationRequest ( );
	enum OptionalFields {
		e_endpointAlias,
		e_nonStandardData,
		e_endpointIdentifier,
		e_alternateEndpoints,
		e_gatekeeperIdentifier,
		e_tokens,
		e_cryptoTokens,
		e_integrityCheckValue,
		e_reason,
		e_endpointAliasPattern,
		e_supportedPrefixes,
		e_alternateGatekeeper,
		e_genericData,
		e_assignedGatekeeper
	};

	UnregistrationRequest ( const UnregistrationRequest & s );
	UnregistrationRequest & operator= ( const UnregistrationRequest & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	RequestSeqNum m_requestSeqNum;
	ArrayOf_TransportAddress m_callSignalAddress;
	protected:
	ArrayOf_AliasAddress * m_endpointAlias;
	NonStandardParameter * m_nonStandardData;
	EndpointIdentifier * m_endpointIdentifier;
	ArrayOf_Endpoint * m_alternateEndpoints;
	GatekeeperIdentifier * m_gatekeeperIdentifier;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ICV * m_integrityCheckValue;
	UnregRequestReason * m_reason;
	ArrayOf_AddressPattern * m_endpointAliasPattern;
	ArrayOf_SupportedPrefix * m_supportedPrefixes;
	ArrayOf_AlternateGK * m_alternateGatekeeper;
	ArrayOf_GenericData * m_genericData;
	AlternateGK * m_assignedGatekeeper;
	public:
	void encode ( Asn :: ostream & os ) const;
	~UnregistrationRequest ( );
	void printOn ( std :: ostream & os ) const;
	const ArrayOf_AliasAddress & get_endpointAlias ( ) const {
		return * m_endpointAlias;
	}
	ArrayOf_AliasAddress & get_endpointAlias ( ) {
		return * m_endpointAlias;
	}
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const EndpointIdentifier & get_endpointIdentifier ( ) const {
		return * m_endpointIdentifier;
	}
	EndpointIdentifier & get_endpointIdentifier ( ) {
		return * m_endpointIdentifier;
	}
	const ArrayOf_Endpoint & get_alternateEndpoints ( ) const {
		return * m_alternateEndpoints;
	}
	ArrayOf_Endpoint & get_alternateEndpoints ( ) {
		return * m_alternateEndpoints;
	}
	const GatekeeperIdentifier & get_gatekeeperIdentifier ( ) const {
		return * m_gatekeeperIdentifier;
	}
	GatekeeperIdentifier & get_gatekeeperIdentifier ( ) {
		return * m_gatekeeperIdentifier;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ICV & get_integrityCheckValue ( ) const {
		return * m_integrityCheckValue;
	}
	ICV & get_integrityCheckValue ( ) {
		return * m_integrityCheckValue;
	}
	const UnregRequestReason & get_reason ( ) const {
		return * m_reason;
	}
	UnregRequestReason & get_reason ( ) {
		return * m_reason;
	}
	const ArrayOf_AddressPattern & get_endpointAliasPattern ( ) const {
		return * m_endpointAliasPattern;
	}
	ArrayOf_AddressPattern & get_endpointAliasPattern ( ) {
		return * m_endpointAliasPattern;
	}
	const ArrayOf_SupportedPrefix & get_supportedPrefixes ( ) const {
		return * m_supportedPrefixes;
	}
	ArrayOf_SupportedPrefix & get_supportedPrefixes ( ) {
		return * m_supportedPrefixes;
	}
	const ArrayOf_AlternateGK & get_alternateGatekeeper ( ) const {
		return * m_alternateGatekeeper;
	}
	ArrayOf_AlternateGK & get_alternateGatekeeper ( ) {
		return * m_alternateGatekeeper;
	}
	const ArrayOf_GenericData & get_genericData ( ) const {
		return * m_genericData;
	}
	ArrayOf_GenericData & get_genericData ( ) {
		return * m_genericData;
	}
	const AlternateGK & get_assignedGatekeeper ( ) const {
		return * m_assignedGatekeeper;
	}
	AlternateGK & get_assignedGatekeeper ( ) {
		return * m_assignedGatekeeper;
	}
	UnregistrationRequest * clone ( ) const;
};

//
// UnregistrationReject
//

// from 0 size 0 type 0 simple 0
class UnregistrationReject : public Asn :: Sequence {
	public:
	explicit UnregistrationReject ( Asn :: istream & is );
	UnregistrationReject ( );
	enum OptionalFields {
		e_nonStandardData,
		e_altGKInfo,
		e_tokens,
		e_cryptoTokens,
		e_integrityCheckValue,
		e_genericData
	};

	UnregistrationReject ( const UnregistrationReject & s );
	UnregistrationReject & operator= ( const UnregistrationReject & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	RequestSeqNum m_requestSeqNum;
	UnregRejectReason m_rejectReason;
	protected:
	NonStandardParameter * m_nonStandardData;
	AltGKInfo * m_altGKInfo;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ICV * m_integrityCheckValue;
	ArrayOf_GenericData * m_genericData;
	public:
	void encode ( Asn :: ostream & os ) const;
	~UnregistrationReject ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const AltGKInfo & get_altGKInfo ( ) const {
		return * m_altGKInfo;
	}
	AltGKInfo & get_altGKInfo ( ) {
		return * m_altGKInfo;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ICV & get_integrityCheckValue ( ) const {
		return * m_integrityCheckValue;
	}
	ICV & get_integrityCheckValue ( ) {
		return * m_integrityCheckValue;
	}
	const ArrayOf_GenericData & get_genericData ( ) const {
		return * m_genericData;
	}
	ArrayOf_GenericData & get_genericData ( ) {
		return * m_genericData;
	}
	UnregistrationReject * clone ( ) const;
};

//
// AdmissionRequest
//

// from 0 size 0 type 0 simple 0
class AdmissionRequest : public Asn :: Sequence {
	public:
	explicit AdmissionRequest ( Asn :: istream & is );
	AdmissionRequest ( );
	enum OptionalFields {
		e_callModel,
		e_destinationInfo,
		e_destCallSignalAddress,
		e_destExtraCallInfo,
		e_srcCallSignalAddress,
		e_nonStandardData,
		e_callServices,
		e_canMapAlias,
		e_callIdentifier,
		e_srcAlternatives,
		e_destAlternatives,
		e_gatekeeperIdentifier,
		e_tokens,
		e_cryptoTokens,
		e_integrityCheckValue,
		e_transportQOS,
		e_willSupplyUUIEs,
		e_callLinkage,
		e_gatewayDataRate,
		e_capacity,
		e_circuitInfo,
		e_desiredProtocols,
		e_desiredTunnelledProtocol,
		e_featureSet,
		e_genericData,
		e_canMapSrcAlias
	};

	AdmissionRequest ( const AdmissionRequest & s );
	AdmissionRequest & operator= ( const AdmissionRequest & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	RequestSeqNum m_requestSeqNum;
	CallType m_callType;
	protected:
	CallModel * m_callModel;
	public:
	EndpointIdentifier m_endpointIdentifier;
	protected:
	ArrayOf_AliasAddress * m_destinationInfo;
	TransportAddress * m_destCallSignalAddress;
	ArrayOf_AliasAddress * m_destExtraCallInfo;
	public:
	ArrayOf_AliasAddress m_srcInfo;
	protected:
	TransportAddress * m_srcCallSignalAddress;
	public:
	BandWidth m_bandWidth;
	CallReferenceValue m_callReferenceValue;
	protected:
	NonStandardParameter * m_nonStandardData;
	QseriesOptions * m_callServices;
	public:
	ConferenceIdentifier m_conferenceID;
	Asn :: Boolean m_activeMC;
	Asn :: Boolean m_answerCall;
	protected:
	Asn :: Boolean * m_canMapAlias;
	CallIdentifier * m_callIdentifier;
	ArrayOf_Endpoint * m_srcAlternatives;
	ArrayOf_Endpoint * m_destAlternatives;
	GatekeeperIdentifier * m_gatekeeperIdentifier;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ICV * m_integrityCheckValue;
	TransportQOS * m_transportQOS;
	Asn :: Boolean * m_willSupplyUUIEs;
	CallLinkage * m_callLinkage;
	DataRate * m_gatewayDataRate;
	CallCapacity * m_capacity;
	CircuitInfo * m_circuitInfo;
	ArrayOf_SupportedProtocols * m_desiredProtocols;
	TunnelledProtocol * m_desiredTunnelledProtocol;
	FeatureSet * m_featureSet;
	ArrayOf_GenericData * m_genericData;
	Asn :: Boolean * m_canMapSrcAlias;
	public:
	void encode ( Asn :: ostream & os ) const;
	~AdmissionRequest ( );
	void printOn ( std :: ostream & os ) const;
	const CallModel & get_callModel ( ) const {
		return * m_callModel;
	}
	CallModel & get_callModel ( ) {
		return * m_callModel;
	}
	const ArrayOf_AliasAddress & get_destinationInfo ( ) const {
		return * m_destinationInfo;
	}
	ArrayOf_AliasAddress & get_destinationInfo ( ) {
		return * m_destinationInfo;
	}
	const TransportAddress & get_destCallSignalAddress ( ) const {
		return * m_destCallSignalAddress;
	}
	TransportAddress & get_destCallSignalAddress ( ) {
		return * m_destCallSignalAddress;
	}
	const ArrayOf_AliasAddress & get_destExtraCallInfo ( ) const {
		return * m_destExtraCallInfo;
	}
	ArrayOf_AliasAddress & get_destExtraCallInfo ( ) {
		return * m_destExtraCallInfo;
	}
	const TransportAddress & get_srcCallSignalAddress ( ) const {
		return * m_srcCallSignalAddress;
	}
	TransportAddress & get_srcCallSignalAddress ( ) {
		return * m_srcCallSignalAddress;
	}
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const QseriesOptions & get_callServices ( ) const {
		return * m_callServices;
	}
	QseriesOptions & get_callServices ( ) {
		return * m_callServices;
	}
	const Asn :: Boolean & get_canMapAlias ( ) const {
		return * m_canMapAlias;
	}
	Asn :: Boolean & get_canMapAlias ( ) {
		return * m_canMapAlias;
	}
	const CallIdentifier & get_callIdentifier ( ) const {
		return * m_callIdentifier;
	}
	CallIdentifier & get_callIdentifier ( ) {
		return * m_callIdentifier;
	}
	const ArrayOf_Endpoint & get_srcAlternatives ( ) const {
		return * m_srcAlternatives;
	}
	ArrayOf_Endpoint & get_srcAlternatives ( ) {
		return * m_srcAlternatives;
	}
	const ArrayOf_Endpoint & get_destAlternatives ( ) const {
		return * m_destAlternatives;
	}
	ArrayOf_Endpoint & get_destAlternatives ( ) {
		return * m_destAlternatives;
	}
	const GatekeeperIdentifier & get_gatekeeperIdentifier ( ) const {
		return * m_gatekeeperIdentifier;
	}
	GatekeeperIdentifier & get_gatekeeperIdentifier ( ) {
		return * m_gatekeeperIdentifier;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ICV & get_integrityCheckValue ( ) const {
		return * m_integrityCheckValue;
	}
	ICV & get_integrityCheckValue ( ) {
		return * m_integrityCheckValue;
	}
	const TransportQOS & get_transportQOS ( ) const {
		return * m_transportQOS;
	}
	TransportQOS & get_transportQOS ( ) {
		return * m_transportQOS;
	}
	const Asn :: Boolean & get_willSupplyUUIEs ( ) const {
		return * m_willSupplyUUIEs;
	}
	Asn :: Boolean & get_willSupplyUUIEs ( ) {
		return * m_willSupplyUUIEs;
	}
	const CallLinkage & get_callLinkage ( ) const {
		return * m_callLinkage;
	}
	CallLinkage & get_callLinkage ( ) {
		return * m_callLinkage;
	}
	const DataRate & get_gatewayDataRate ( ) const {
		return * m_gatewayDataRate;
	}
	DataRate & get_gatewayDataRate ( ) {
		return * m_gatewayDataRate;
	}
	const CallCapacity & get_capacity ( ) const {
		return * m_capacity;
	}
	CallCapacity & get_capacity ( ) {
		return * m_capacity;
	}
	const CircuitInfo & get_circuitInfo ( ) const {
		return * m_circuitInfo;
	}
	CircuitInfo & get_circuitInfo ( ) {
		return * m_circuitInfo;
	}
	const ArrayOf_SupportedProtocols & get_desiredProtocols ( ) const {
		return * m_desiredProtocols;
	}
	ArrayOf_SupportedProtocols & get_desiredProtocols ( ) {
		return * m_desiredProtocols;
	}
	const TunnelledProtocol & get_desiredTunnelledProtocol ( ) const {
		return * m_desiredTunnelledProtocol;
	}
	TunnelledProtocol & get_desiredTunnelledProtocol ( ) {
		return * m_desiredTunnelledProtocol;
	}
	const FeatureSet & get_featureSet ( ) const {
		return * m_featureSet;
	}
	FeatureSet & get_featureSet ( ) {
		return * m_featureSet;
	}
	const ArrayOf_GenericData & get_genericData ( ) const {
		return * m_genericData;
	}
	ArrayOf_GenericData & get_genericData ( ) {
		return * m_genericData;
	}
	const Asn :: Boolean & get_canMapSrcAlias ( ) const {
		return * m_canMapSrcAlias;
	}
	Asn :: Boolean & get_canMapSrcAlias ( ) {
		return * m_canMapSrcAlias;
	}
	AdmissionRequest * clone ( ) const;
};

//
// TransportQOS
//

// from 0 size 0 type 0 simple 0
class TransportQOS : public Asn :: Choice {
	public:
	explicit TransportQOS ( Asn :: istream & is );
	TransportQOS ( );
	enum Choices {
		e_endpointControlled,
		e_gatekeeperControlled,
		e_noControl,
		e_qOSCapabilities
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator TransportQOS_qOSCapabilities & ( ) { return dynamic_cast < TransportQOS_qOSCapabilities & > ( * choice ); }
	operator const TransportQOS_qOSCapabilities & ( ) const { return dynamic_cast < const TransportQOS_qOSCapabilities & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	TransportQOS * clone ( ) const;
};

//
// AdmissionRejectReason
//

// from 0 size 0 type 0 simple 0
class AdmissionRejectReason : public Asn :: Choice {
	public:
	explicit AdmissionRejectReason ( Asn :: istream & is );
	AdmissionRejectReason ( );
	enum Choices {
		e_calledPartyNotRegistered,
		e_invalidPermission,
		e_requestDenied,
		e_undefinedReason,
		e_callerNotRegistered,
		e_routeCallToGatekeeper,
		e_invalidEndpointIdentifier,
		e_resourceUnavailable,
		e_securityDenial,
		e_qosControlNotSupported,
		e_incompleteAddress,
		e_aliasesInconsistent,
		e_routeCallToSCN,
		e_exceedsCallCapacity,
		e_collectDestination,
		e_collectPIN,
		e_genericDataReason,
		e_neededFeatureNotSupported,
		e_securityErrors,
		e_securityDHmismatch,
		e_noRouteToDestination,
		e_unallocatedNumber,
		e_registerWithAssignedGK
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator ArrayOf_PartyNumber & ( ) { return dynamic_cast < ArrayOf_PartyNumber & > ( * choice ); }
	operator const ArrayOf_PartyNumber & ( ) const { return dynamic_cast < const ArrayOf_PartyNumber & > ( * choice ); }
	operator SecurityErrors2 & ( ) { return dynamic_cast < SecurityErrors2 & > ( * choice ); }
	operator const SecurityErrors2 & ( ) const { return dynamic_cast < const SecurityErrors2 & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	AdmissionRejectReason * clone ( ) const;
};

//
// BandwidthReject
//

// from 0 size 0 type 0 simple 0
class BandwidthReject : public Asn :: Sequence {
	public:
	explicit BandwidthReject ( Asn :: istream & is );
	BandwidthReject ( );
	enum OptionalFields {
		e_nonStandardData,
		e_altGKInfo,
		e_tokens,
		e_cryptoTokens,
		e_integrityCheckValue,
		e_genericData
	};

	BandwidthReject ( const BandwidthReject & s );
	BandwidthReject & operator= ( const BandwidthReject & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	RequestSeqNum m_requestSeqNum;
	BandRejectReason m_rejectReason;
	BandWidth m_allowedBandWidth;
	protected:
	NonStandardParameter * m_nonStandardData;
	AltGKInfo * m_altGKInfo;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ICV * m_integrityCheckValue;
	ArrayOf_GenericData * m_genericData;
	public:
	void encode ( Asn :: ostream & os ) const;
	~BandwidthReject ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const AltGKInfo & get_altGKInfo ( ) const {
		return * m_altGKInfo;
	}
	AltGKInfo & get_altGKInfo ( ) {
		return * m_altGKInfo;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ICV & get_integrityCheckValue ( ) const {
		return * m_integrityCheckValue;
	}
	ICV & get_integrityCheckValue ( ) {
		return * m_integrityCheckValue;
	}
	const ArrayOf_GenericData & get_genericData ( ) const {
		return * m_genericData;
	}
	ArrayOf_GenericData & get_genericData ( ) {
		return * m_genericData;
	}
	BandwidthReject * clone ( ) const;
};

//
// LocationRejectReason
//

// from 0 size 0 type 0 simple 0
class LocationRejectReason : public Asn :: Choice {
	public:
	explicit LocationRejectReason ( Asn :: istream & is );
	LocationRejectReason ( );
	enum Choices {
		e_notRegistered,
		e_invalidPermission,
		e_requestDenied,
		e_undefinedReason,
		e_securityDenial,
		e_aliasesInconsistent,
		e_routeCalltoSCN,
		e_resourceUnavailable,
		e_genericDataReason,
		e_neededFeatureNotSupported,
		e_hopCountExceeded,
		e_incompleteAddress,
		e_securityError,
		e_securityDHmismatch,
		e_noRouteToDestination,
		e_unallocatedNumber
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator ArrayOf_PartyNumber & ( ) { return dynamic_cast < ArrayOf_PartyNumber & > ( * choice ); }
	operator const ArrayOf_PartyNumber & ( ) const { return dynamic_cast < const ArrayOf_PartyNumber & > ( * choice ); }
	operator SecurityErrors2 & ( ) { return dynamic_cast < SecurityErrors2 & > ( * choice ); }
	operator const SecurityErrors2 & ( ) const { return dynamic_cast < const SecurityErrors2 & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	LocationRejectReason * clone ( ) const;
};

//
// DisengageRequest
//

// from 0 size 0 type 0 simple 0
class CallTerminationCause;

class DisengageRequest : public Asn :: Sequence {
	public:
	explicit DisengageRequest ( Asn :: istream & is );
	DisengageRequest ( );
	enum OptionalFields {
		e_nonStandardData,
		e_callIdentifier,
		e_gatekeeperIdentifier,
		e_tokens,
		e_cryptoTokens,
		e_integrityCheckValue,
		e_answeredCall,
		e_callLinkage,
		e_capacity,
		e_circuitInfo,
		e_usageInformation,
		e_terminationCause,
		e_serviceControl,
		e_genericData
	};

	DisengageRequest ( const DisengageRequest & s );
	DisengageRequest & operator= ( const DisengageRequest & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	RequestSeqNum m_requestSeqNum;
	EndpointIdentifier m_endpointIdentifier;
	ConferenceIdentifier m_conferenceID;
	CallReferenceValue m_callReferenceValue;
	DisengageReason m_disengageReason;
	protected:
	NonStandardParameter * m_nonStandardData;
	CallIdentifier * m_callIdentifier;
	GatekeeperIdentifier * m_gatekeeperIdentifier;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ICV * m_integrityCheckValue;
	Asn :: Boolean * m_answeredCall;
	CallLinkage * m_callLinkage;
	CallCapacity * m_capacity;
	CircuitInfo * m_circuitInfo;
	RasUsageInformation * m_usageInformation;
	CallTerminationCause * m_terminationCause;
	ArrayOf_ServiceControlSession * m_serviceControl;
	ArrayOf_GenericData * m_genericData;
	public:
	void encode ( Asn :: ostream & os ) const;
	~DisengageRequest ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const CallIdentifier & get_callIdentifier ( ) const {
		return * m_callIdentifier;
	}
	CallIdentifier & get_callIdentifier ( ) {
		return * m_callIdentifier;
	}
	const GatekeeperIdentifier & get_gatekeeperIdentifier ( ) const {
		return * m_gatekeeperIdentifier;
	}
	GatekeeperIdentifier & get_gatekeeperIdentifier ( ) {
		return * m_gatekeeperIdentifier;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ICV & get_integrityCheckValue ( ) const {
		return * m_integrityCheckValue;
	}
	ICV & get_integrityCheckValue ( ) {
		return * m_integrityCheckValue;
	}
	const Asn :: Boolean & get_answeredCall ( ) const {
		return * m_answeredCall;
	}
	Asn :: Boolean & get_answeredCall ( ) {
		return * m_answeredCall;
	}
	const CallLinkage & get_callLinkage ( ) const {
		return * m_callLinkage;
	}
	CallLinkage & get_callLinkage ( ) {
		return * m_callLinkage;
	}
	const CallCapacity & get_capacity ( ) const {
		return * m_capacity;
	}
	CallCapacity & get_capacity ( ) {
		return * m_capacity;
	}
	const CircuitInfo & get_circuitInfo ( ) const {
		return * m_circuitInfo;
	}
	CircuitInfo & get_circuitInfo ( ) {
		return * m_circuitInfo;
	}
	const RasUsageInformation & get_usageInformation ( ) const {
		return * m_usageInformation;
	}
	RasUsageInformation & get_usageInformation ( ) {
		return * m_usageInformation;
	}
	const CallTerminationCause & get_terminationCause ( ) const {
		return * m_terminationCause;
	}
	CallTerminationCause & get_terminationCause ( ) {
		return * m_terminationCause;
	}
	const ArrayOf_ServiceControlSession & get_serviceControl ( ) const {
		return * m_serviceControl;
	}
	ArrayOf_ServiceControlSession & get_serviceControl ( ) {
		return * m_serviceControl;
	}
	const ArrayOf_GenericData & get_genericData ( ) const {
		return * m_genericData;
	}
	ArrayOf_GenericData & get_genericData ( ) {
		return * m_genericData;
	}
	DisengageRequest * clone ( ) const;
};

//
// DisengageReject
//

// from 0 size 0 type 0 simple 0
class DisengageReject : public Asn :: Sequence {
	public:
	explicit DisengageReject ( Asn :: istream & is );
	DisengageReject ( );
	enum OptionalFields {
		e_nonStandardData,
		e_altGKInfo,
		e_tokens,
		e_cryptoTokens,
		e_integrityCheckValue,
		e_genericData
	};

	DisengageReject ( const DisengageReject & s );
	DisengageReject & operator= ( const DisengageReject & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	RequestSeqNum m_requestSeqNum;
	DisengageRejectReason m_rejectReason;
	protected:
	NonStandardParameter * m_nonStandardData;
	AltGKInfo * m_altGKInfo;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ICV * m_integrityCheckValue;
	ArrayOf_GenericData * m_genericData;
	public:
	void encode ( Asn :: ostream & os ) const;
	~DisengageReject ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const AltGKInfo & get_altGKInfo ( ) const {
		return * m_altGKInfo;
	}
	AltGKInfo & get_altGKInfo ( ) {
		return * m_altGKInfo;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ICV & get_integrityCheckValue ( ) const {
		return * m_integrityCheckValue;
	}
	ICV & get_integrityCheckValue ( ) {
		return * m_integrityCheckValue;
	}
	const ArrayOf_GenericData & get_genericData ( ) const {
		return * m_genericData;
	}
	ArrayOf_GenericData & get_genericData ( ) {
		return * m_genericData;
	}
	DisengageReject * clone ( ) const;
};

//
// InfoRequestResponseStatus
//

// from 0 size 0 type 0 simple 0
class InfoRequestResponseStatus : public Asn :: Choice {
	public:
	explicit InfoRequestResponseStatus ( Asn :: istream & is );
	InfoRequestResponseStatus ( );
	enum Choices {
		e_complete,
		e_incomplete,
		e_segment,
		e_invalidCall
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator InfoRequestResponseStatus_segment & ( ) { return dynamic_cast < InfoRequestResponseStatus_segment & > ( * choice ); }
	operator const InfoRequestResponseStatus_segment & ( ) const { return dynamic_cast < const InfoRequestResponseStatus_segment & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	InfoRequestResponseStatus * clone ( ) const;
};

//
// InfoRequestNak
//

// from 0 size 0 type 0 simple 0
class InfoRequestNak : public Asn :: Sequence {
	public:
	explicit InfoRequestNak ( Asn :: istream & is );
	InfoRequestNak ( );
	enum OptionalFields {
		e_nonStandardData,
		e_altGKInfo,
		e_tokens,
		e_cryptoTokens,
		e_integrityCheckValue
	};

	InfoRequestNak ( const InfoRequestNak & s );
	InfoRequestNak & operator= ( const InfoRequestNak & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	RequestSeqNum m_requestSeqNum;
	protected:
	NonStandardParameter * m_nonStandardData;
	public:
	InfoRequestNakReason m_nakReason;
	protected:
	AltGKInfo * m_altGKInfo;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ICV * m_integrityCheckValue;
	public:
	void encode ( Asn :: ostream & os ) const;
	~InfoRequestNak ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const AltGKInfo & get_altGKInfo ( ) const {
		return * m_altGKInfo;
	}
	AltGKInfo & get_altGKInfo ( ) {
		return * m_altGKInfo;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ICV & get_integrityCheckValue ( ) const {
		return * m_integrityCheckValue;
	}
	ICV & get_integrityCheckValue ( ) {
		return * m_integrityCheckValue;
	}
	InfoRequestNak * clone ( ) const;
};

//
// RequestInProgress
//

// from 0 size 0 type 0 simple 0
class RequestInProgress : public Asn :: Sequence {
	public:
	explicit RequestInProgress ( Asn :: istream & is );
	RequestInProgress ( );
	enum OptionalFields {
		e_nonStandardData,
		e_tokens,
		e_cryptoTokens,
		e_integrityCheckValue
	};

	RequestInProgress ( const RequestInProgress & s );
	RequestInProgress & operator= ( const RequestInProgress & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	RequestSeqNum m_requestSeqNum;
	protected:
	NonStandardParameter * m_nonStandardData;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ICV * m_integrityCheckValue;
	public:
	RequestInProgress_delay m_delay;
	void encode ( Asn :: ostream & os ) const;
	~RequestInProgress ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ICV & get_integrityCheckValue ( ) const {
		return * m_integrityCheckValue;
	}
	ICV & get_integrityCheckValue ( ) {
		return * m_integrityCheckValue;
	}
	RequestInProgress * clone ( ) const;
};

//
// ResourcesAvailableIndicate
//

// from 0 size 0 type 0 simple 0
class ResourcesAvailableIndicate : public Asn :: Sequence {
	public:
	explicit ResourcesAvailableIndicate ( Asn :: istream & is );
	ResourcesAvailableIndicate ( );
	enum OptionalFields {
		e_nonStandardData,
		e_tokens,
		e_cryptoTokens,
		e_integrityCheckValue,
		e_capacity,
		e_genericData
	};

	ResourcesAvailableIndicate ( const ResourcesAvailableIndicate & s );
	ResourcesAvailableIndicate & operator= ( const ResourcesAvailableIndicate & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	RequestSeqNum m_requestSeqNum;
	ProtocolIdentifier m_protocolIdentifier;
	protected:
	NonStandardParameter * m_nonStandardData;
	public:
	EndpointIdentifier m_endpointIdentifier;
	ArrayOf_SupportedProtocols m_protocols;
	Asn :: Boolean m_almostOutOfResources;
	protected:
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ICV * m_integrityCheckValue;
	CallCapacity * m_capacity;
	ArrayOf_GenericData * m_genericData;
	public:
	void encode ( Asn :: ostream & os ) const;
	~ResourcesAvailableIndicate ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ICV & get_integrityCheckValue ( ) const {
		return * m_integrityCheckValue;
	}
	ICV & get_integrityCheckValue ( ) {
		return * m_integrityCheckValue;
	}
	const CallCapacity & get_capacity ( ) const {
		return * m_capacity;
	}
	CallCapacity & get_capacity ( ) {
		return * m_capacity;
	}
	const ArrayOf_GenericData & get_genericData ( ) const {
		return * m_genericData;
	}
	ArrayOf_GenericData & get_genericData ( ) {
		return * m_genericData;
	}
	ResourcesAvailableIndicate * clone ( ) const;
};

//
// ServiceControlIndication
//

// from 0 size 0 type 0 simple 0
class ServiceControlIndication : public Asn :: Sequence {
	public:
	explicit ServiceControlIndication ( Asn :: istream & is );
	ServiceControlIndication ( );
	enum OptionalFields {
		e_nonStandardData,
		e_endpointIdentifier,
		e_callSpecific,
		e_tokens,
		e_cryptoTokens,
		e_integrityCheckValue,
		e_featureSet,
		e_genericData
	};

	ServiceControlIndication ( const ServiceControlIndication & s );
	ServiceControlIndication & operator= ( const ServiceControlIndication & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	RequestSeqNum m_requestSeqNum;
	protected:
	NonStandardParameter * m_nonStandardData;
	public:
	ArrayOf_ServiceControlSession m_serviceControl;
	protected:
	EndpointIdentifier * m_endpointIdentifier;
	ServiceControlIndication_callSpecific * m_callSpecific;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ICV * m_integrityCheckValue;
	FeatureSet * m_featureSet;
	ArrayOf_GenericData * m_genericData;
	public:
	void encode ( Asn :: ostream & os ) const;
	~ServiceControlIndication ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const EndpointIdentifier & get_endpointIdentifier ( ) const {
		return * m_endpointIdentifier;
	}
	EndpointIdentifier & get_endpointIdentifier ( ) {
		return * m_endpointIdentifier;
	}
	const ServiceControlIndication_callSpecific & get_callSpecific ( ) const {
		return * m_callSpecific;
	}
	ServiceControlIndication_callSpecific & get_callSpecific ( ) {
		return * m_callSpecific;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ICV & get_integrityCheckValue ( ) const {
		return * m_integrityCheckValue;
	}
	ICV & get_integrityCheckValue ( ) {
		return * m_integrityCheckValue;
	}
	const FeatureSet & get_featureSet ( ) const {
		return * m_featureSet;
	}
	FeatureSet & get_featureSet ( ) {
		return * m_featureSet;
	}
	const ArrayOf_GenericData & get_genericData ( ) const {
		return * m_genericData;
	}
	ArrayOf_GenericData & get_genericData ( ) {
		return * m_genericData;
	}
	ServiceControlIndication * clone ( ) const;
};

//
// H323-UserInformation_user-data
//

// from 0 size 0 type 0 simple 0
class H323_UserInformation_user_data : public Asn :: Sequence {
	public:
	explicit H323_UserInformation_user_data ( Asn :: istream & is );
	H323_UserInformation_user_data ( );
	H323_UserInformation_user_data_protocol_discriminator m_protocol_discriminator;
	H323_UserInformation_user_data_user_information m_user_information;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	H323_UserInformation_user_data * clone ( ) const;
};

//
// H323-UU-PDU_h323-message-body
//

// from 0 size 0 type 0 simple 0
class H323_UU_PDU_h323_message_body : public Asn :: Choice {
	public:
	explicit H323_UU_PDU_h323_message_body ( Asn :: istream & is );
	H323_UU_PDU_h323_message_body ( );
	enum Choices {
		e_setup,
		e_callProceeding,
		e_connect,
		e_alerting,
		e_information,
		e_releaseComplete,
		e_facility,
		e_progress,
		e_empty,
		e_status,
		e_statusInquiry,
		e_setupAcknowledge,
		e_notify
	};

	operator Setup_UUIE & ( ) { return dynamic_cast < Setup_UUIE & > ( * choice ); }
	operator const Setup_UUIE & ( ) const { return dynamic_cast < const Setup_UUIE & > ( * choice ); }
	operator CallProceeding_UUIE & ( ) { return dynamic_cast < CallProceeding_UUIE & > ( * choice ); }
	operator const CallProceeding_UUIE & ( ) const { return dynamic_cast < const CallProceeding_UUIE & > ( * choice ); }
	operator Connect_UUIE & ( ) { return dynamic_cast < Connect_UUIE & > ( * choice ); }
	operator const Connect_UUIE & ( ) const { return dynamic_cast < const Connect_UUIE & > ( * choice ); }
	operator Alerting_UUIE & ( ) { return dynamic_cast < Alerting_UUIE & > ( * choice ); }
	operator const Alerting_UUIE & ( ) const { return dynamic_cast < const Alerting_UUIE & > ( * choice ); }
	operator Information_UUIE & ( ) { return dynamic_cast < Information_UUIE & > ( * choice ); }
	operator const Information_UUIE & ( ) const { return dynamic_cast < const Information_UUIE & > ( * choice ); }
	operator ReleaseComplete_UUIE & ( ) { return dynamic_cast < ReleaseComplete_UUIE & > ( * choice ); }
	operator const ReleaseComplete_UUIE & ( ) const { return dynamic_cast < const ReleaseComplete_UUIE & > ( * choice ); }
	operator Facility_UUIE & ( ) { return dynamic_cast < Facility_UUIE & > ( * choice ); }
	operator const Facility_UUIE & ( ) const { return dynamic_cast < const Facility_UUIE & > ( * choice ); }
	operator Progress_UUIE & ( ) { return dynamic_cast < Progress_UUIE & > ( * choice ); }
	operator const Progress_UUIE & ( ) const { return dynamic_cast < const Progress_UUIE & > ( * choice ); }
	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator Status_UUIE & ( ) { return dynamic_cast < Status_UUIE & > ( * choice ); }
	operator const Status_UUIE & ( ) const { return dynamic_cast < const Status_UUIE & > ( * choice ); }
	operator StatusInquiry_UUIE & ( ) { return dynamic_cast < StatusInquiry_UUIE & > ( * choice ); }
	operator const StatusInquiry_UUIE & ( ) const { return dynamic_cast < const StatusInquiry_UUIE & > ( * choice ); }
	operator SetupAcknowledge_UUIE & ( ) { return dynamic_cast < SetupAcknowledge_UUIE & > ( * choice ); }
	operator const SetupAcknowledge_UUIE & ( ) const { return dynamic_cast < const SetupAcknowledge_UUIE & > ( * choice ); }
	operator Notify_UUIE & ( ) { return dynamic_cast < Notify_UUIE & > ( * choice ); }
	operator const Notify_UUIE & ( ) const { return dynamic_cast < const Notify_UUIE & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	H323_UU_PDU_h323_message_body * clone ( ) const;
};

//
// Setup-UUIE_connectionParameters
//

// from 0 size 0 type 0 simple 0
class Setup_UUIE_connectionParameters : public Asn :: Sequence {
	public:
	explicit Setup_UUIE_connectionParameters ( Asn :: istream & is );
	Setup_UUIE_connectionParameters ( );
	ScnConnectionType m_connectionType;
	Setup_UUIE_connectionParameters_numberOfScnConnections m_numberOfScnConnections;
	ScnConnectionAggregation m_connectionAggregation;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	Setup_UUIE_connectionParameters * clone ( ) const;
};

//
// TransportAddress_ipAddress
//

// from 0 size 0 type 0 simple 0
class TransportAddress_ipAddress : public Asn :: Sequence {
	public:
	explicit TransportAddress_ipAddress ( Asn :: istream & is );
	TransportAddress_ipAddress ( );
	TransportAddress_ipAddress_ip m_ip;
	TransportAddress_ipAddress_port m_port;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	TransportAddress_ipAddress * clone ( ) const;
};

//
// TransportAddress_ipSourceRoute
//

// from 0 size 0 type 0 simple 0
class TransportAddress_ipSourceRoute : public Asn :: Sequence {
	public:
	explicit TransportAddress_ipSourceRoute ( Asn :: istream & is );
	TransportAddress_ipSourceRoute ( );
	TransportAddress_ipSourceRoute_ip m_ip;
	TransportAddress_ipSourceRoute_port m_port;
	TransportAddress_ipSourceRoute_route m_route;
	TransportAddress_ipSourceRoute_routing m_routing;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	TransportAddress_ipSourceRoute * clone ( ) const;
};

//
// TransportAddress_ipxAddress
//

// from 0 size 0 type 0 simple 0
class TransportAddress_ipxAddress : public Asn :: Sequence {
	public:
	explicit TransportAddress_ipxAddress ( Asn :: istream & is );
	TransportAddress_ipxAddress ( );
	TransportAddress_ipxAddress_node m_node;
	TransportAddress_ipxAddress_netnum m_netnum;
	TransportAddress_ipxAddress_port m_port;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	TransportAddress_ipxAddress * clone ( ) const;
};

//
// TransportAddress_ip6Address
//

// from 0 size 0 type 0 simple 0
class TransportAddress_ip6Address : public Asn :: Sequence {
	public:
	explicit TransportAddress_ip6Address ( Asn :: istream & is );
	TransportAddress_ip6Address ( );
	TransportAddress_ip6Address_ip m_ip;
	TransportAddress_ip6Address_port m_port;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	TransportAddress_ip6Address * clone ( ) const;
};

//
// TunnelledProtocol_id
//

// from 0 size 0 type 0 simple 0
class TunnelledProtocol_id : public Asn :: Choice {
	public:
	explicit TunnelledProtocol_id ( Asn :: istream & is );
	TunnelledProtocol_id ( );
	enum Choices {
		e_tunnelledProtocolObjectID,
		e_tunnelledProtocolAlternateID
	};

	operator Asn :: ObjectId & ( ) { return dynamic_cast < Asn :: ObjectId & > ( * choice ); }
	operator const Asn :: ObjectId & ( ) const { return dynamic_cast < const Asn :: ObjectId & > ( * choice ); }
	operator TunnelledProtocolAlternateIdentifier & ( ) { return dynamic_cast < TunnelledProtocolAlternateIdentifier & > ( * choice ); }
	operator const TunnelledProtocolAlternateIdentifier & ( ) const { return dynamic_cast < const TunnelledProtocolAlternateIdentifier & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	TunnelledProtocol_id * clone ( ) const;
};

//
// ANSI-41-UIM_system-id
//

// from 0 size 0 type 0 simple 0
class ANSI_41_UIM_system_id : public Asn :: Choice {
	public:
	explicit ANSI_41_UIM_system_id ( Asn :: istream & is );
	ANSI_41_UIM_system_id ( );
	enum Choices {
		e_sid,
		e_mid
	};

	operator ANSI_41_UIM_system_id_sid & ( ) { return dynamic_cast < ANSI_41_UIM_system_id_sid & > ( * choice ); }
	operator const ANSI_41_UIM_system_id_sid & ( ) const { return dynamic_cast < const ANSI_41_UIM_system_id_sid & > ( * choice ); }
	operator ANSI_41_UIM_system_id_mid & ( ) { return dynamic_cast < ANSI_41_UIM_system_id_mid & > ( * choice ); }
	operator const ANSI_41_UIM_system_id_mid & ( ) const { return dynamic_cast < const ANSI_41_UIM_system_id_mid & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	ANSI_41_UIM_system_id * clone ( ) const;
};

//
// H323-UU-PDU
//

// from 0 size 0 type 0 simple 0
class H323_UU_PDU_tunnelledSignallingMessage;

class H323_UU_PDU : public Asn :: Sequence {
	public:
	explicit H323_UU_PDU ( Asn :: istream & is );
	H323_UU_PDU ( );
	enum OptionalFields {
		e_nonStandardData,
		e_h4501SupplementaryService,
		e_h245Tunneling,
		e_h245Control,
		e_nonStandardControl,
		e_callLinkage,
		e_tunnelledSignallingMessage,
		e_provisionalRespToH245Tunneling,
		e_stimulusControl,
		e_genericData
	};

	H323_UU_PDU ( const H323_UU_PDU & s );
	H323_UU_PDU & operator= ( const H323_UU_PDU & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	H323_UU_PDU_h323_message_body m_h323_message_body;
	protected:
	NonStandardParameter * m_nonStandardData;
	ArrayOf_Asn_OctetString * m_h4501SupplementaryService;
	Asn :: Boolean * m_h245Tunneling;
	ArrayOf_Asn_OctetString * m_h245Control;
	ArrayOf_NonStandardParameter * m_nonStandardControl;
	CallLinkage * m_callLinkage;
	H323_UU_PDU_tunnelledSignallingMessage * m_tunnelledSignallingMessage;
	Asn :: Null * m_provisionalRespToH245Tunneling;
	StimulusControl * m_stimulusControl;
	ArrayOf_GenericData * m_genericData;
	public:
	void encode ( Asn :: ostream & os ) const;
	~H323_UU_PDU ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const ArrayOf_Asn_OctetString & get_h4501SupplementaryService ( ) const {
		return * m_h4501SupplementaryService;
	}
	ArrayOf_Asn_OctetString & get_h4501SupplementaryService ( ) {
		return * m_h4501SupplementaryService;
	}
	const Asn :: Boolean & get_h245Tunneling ( ) const {
		return * m_h245Tunneling;
	}
	Asn :: Boolean & get_h245Tunneling ( ) {
		return * m_h245Tunneling;
	}
	const ArrayOf_Asn_OctetString & get_h245Control ( ) const {
		return * m_h245Control;
	}
	ArrayOf_Asn_OctetString & get_h245Control ( ) {
		return * m_h245Control;
	}
	const ArrayOf_NonStandardParameter & get_nonStandardControl ( ) const {
		return * m_nonStandardControl;
	}
	ArrayOf_NonStandardParameter & get_nonStandardControl ( ) {
		return * m_nonStandardControl;
	}
	const CallLinkage & get_callLinkage ( ) const {
		return * m_callLinkage;
	}
	CallLinkage & get_callLinkage ( ) {
		return * m_callLinkage;
	}
	const H323_UU_PDU_tunnelledSignallingMessage & get_tunnelledSignallingMessage ( ) const {
		return * m_tunnelledSignallingMessage;
	}
	H323_UU_PDU_tunnelledSignallingMessage & get_tunnelledSignallingMessage ( ) {
		return * m_tunnelledSignallingMessage;
	}
	const Asn :: Null & get_provisionalRespToH245Tunneling ( ) const {
		return * m_provisionalRespToH245Tunneling;
	}
	Asn :: Null & get_provisionalRespToH245Tunneling ( ) {
		return * m_provisionalRespToH245Tunneling;
	}
	const StimulusControl & get_stimulusControl ( ) const {
		return * m_stimulusControl;
	}
	StimulusControl & get_stimulusControl ( ) {
		return * m_stimulusControl;
	}
	const ArrayOf_GenericData & get_genericData ( ) const {
		return * m_genericData;
	}
	ArrayOf_GenericData & get_genericData ( ) {
		return * m_genericData;
	}
	H323_UU_PDU * clone ( ) const;
};

//
// VendorIdentifier
//

// from 0 size 0 type 0 simple 0
class VendorIdentifier : public Asn :: Sequence {
	public:
	explicit VendorIdentifier ( Asn :: istream & is );
	VendorIdentifier ( );
	enum OptionalFields {
		e_productId,
		e_versionId,
		e_enterpriseNumber
	};

	VendorIdentifier ( const VendorIdentifier & s );
	VendorIdentifier & operator= ( const VendorIdentifier & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	H221NonStandard m_vendor;
	protected:
	VendorIdentifier_productId * m_productId;
	VendorIdentifier_versionId * m_versionId;
	Asn :: ObjectId * m_enterpriseNumber;
	public:
	void encode ( Asn :: ostream & os ) const;
	~VendorIdentifier ( );
	void printOn ( std :: ostream & os ) const;
	const VendorIdentifier_productId & get_productId ( ) const {
		return * m_productId;
	}
	VendorIdentifier_productId & get_productId ( ) {
		return * m_productId;
	}
	const VendorIdentifier_versionId & get_versionId ( ) const {
		return * m_versionId;
	}
	VendorIdentifier_versionId & get_versionId ( ) {
		return * m_versionId;
	}
	const Asn :: ObjectId & get_enterpriseNumber ( ) const {
		return * m_enterpriseNumber;
	}
	Asn :: ObjectId & get_enterpriseNumber ( ) {
		return * m_enterpriseNumber;
	}
	VendorIdentifier * clone ( ) const;
};

//
// TunnelledProtocol
//

// from 0 size 0 type 0 simple 0
class TunnelledProtocol : public Asn :: Sequence {
	public:
	explicit TunnelledProtocol ( Asn :: istream & is );
	TunnelledProtocol ( );
	enum OptionalFields {
		e_subIdentifier
	};

	TunnelledProtocol ( const TunnelledProtocol & s );
	TunnelledProtocol & operator= ( const TunnelledProtocol & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	TunnelledProtocol_id m_id;
	protected:
	TunnelledProtocol_subIdentifier * m_subIdentifier;
	public:
	void encode ( Asn :: ostream & os ) const;
	~TunnelledProtocol ( );
	void printOn ( std :: ostream & os ) const;
	const TunnelledProtocol_subIdentifier & get_subIdentifier ( ) const {
		return * m_subIdentifier;
	}
	TunnelledProtocol_subIdentifier & get_subIdentifier ( ) {
		return * m_subIdentifier;
	}
	TunnelledProtocol * clone ( ) const;
};

//
// NonStandardParameter
//

// from 0 size 0 type 0 simple 0
class NonStandardParameter : public Asn :: Sequence {
	public:
	explicit NonStandardParameter ( Asn :: istream & is );
	NonStandardParameter ( );
	NonStandardIdentifier m_nonStandardIdentifier;
	Asn :: OctetString m_data;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	NonStandardParameter * clone ( ) const;
};

//
// PartyNumber
//

// from 0 size 0 type 0 simple 0
class PartyNumber : public Asn :: Choice {
	public:
	explicit PartyNumber ( Asn :: istream & is );
	PartyNumber ( );
	enum Choices {
		e_e164Number,
		e_dataPartyNumber,
		e_telexPartyNumber,
		e_privateNumber,
		e_nationalStandardPartyNumber
	};

	operator PublicPartyNumber & ( ) { return dynamic_cast < PublicPartyNumber & > ( * choice ); }
	operator const PublicPartyNumber & ( ) const { return dynamic_cast < const PublicPartyNumber & > ( * choice ); }
	operator NumberDigits & ( ) { return dynamic_cast < NumberDigits & > ( * choice ); }
	operator const NumberDigits & ( ) const { return dynamic_cast < const NumberDigits & > ( * choice ); }
	operator PrivatePartyNumber & ( ) { return dynamic_cast < PrivatePartyNumber & > ( * choice ); }
	operator const PrivatePartyNumber & ( ) const { return dynamic_cast < const PrivatePartyNumber & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	PartyNumber * clone ( ) const;
};

//
// ANSI-41-UIM
//

// from 0 size 0 type 0 simple 0
class ANSI_41_UIM : public Asn :: Sequence {
	public:
	explicit ANSI_41_UIM ( Asn :: istream & is );
	ANSI_41_UIM ( );
	enum OptionalFields {
		e_systemMyTypeCode,
		e_systemAccessType,
		e_qualificationInformationCode
	};

	ANSI_41_UIM ( const ANSI_41_UIM & s );
	ANSI_41_UIM & operator= ( const ANSI_41_UIM & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	ANSI_41_UIM_imsi m_imsi;
	ANSI_41_UIM_min m_min;
	ANSI_41_UIM_mdn m_mdn;
	ANSI_41_UIM_msisdn m_msisdn;
	ANSI_41_UIM_esn m_esn;
	ANSI_41_UIM_mscid m_mscid;
	ANSI_41_UIM_system_id m_system_id;
	protected:
	ANSI_41_UIM_systemMyTypeCode * m_systemMyTypeCode;
	ANSI_41_UIM_systemAccessType * m_systemAccessType;
	ANSI_41_UIM_qualificationInformationCode * m_qualificationInformationCode;
	public:
	ANSI_41_UIM_sesn m_sesn;
	ANSI_41_UIM_soc m_soc;
	void encode ( Asn :: ostream & os ) const;
	~ANSI_41_UIM ( );
	void printOn ( std :: ostream & os ) const;
	const ANSI_41_UIM_systemMyTypeCode & get_systemMyTypeCode ( ) const {
		return * m_systemMyTypeCode;
	}
	ANSI_41_UIM_systemMyTypeCode & get_systemMyTypeCode ( ) {
		return * m_systemMyTypeCode;
	}
	const ANSI_41_UIM_systemAccessType & get_systemAccessType ( ) const {
		return * m_systemAccessType;
	}
	ANSI_41_UIM_systemAccessType & get_systemAccessType ( ) {
		return * m_systemAccessType;
	}
	const ANSI_41_UIM_qualificationInformationCode & get_qualificationInformationCode ( ) const {
		return * m_qualificationInformationCode;
	}
	ANSI_41_UIM_qualificationInformationCode & get_qualificationInformationCode ( ) {
		return * m_qualificationInformationCode;
	}
	ANSI_41_UIM * clone ( ) const;
};

//
// IsupNumber
//

// from 0 size 0 type 0 simple 0
class IsupNumber : public Asn :: Choice {
	public:
	explicit IsupNumber ( Asn :: istream & is );
	IsupNumber ( );
	enum Choices {
		e_e164Number,
		e_dataPartyNumber,
		e_telexPartyNumber,
		e_privateNumber,
		e_nationalStandardPartyNumber
	};

	operator IsupPublicPartyNumber & ( ) { return dynamic_cast < IsupPublicPartyNumber & > ( * choice ); }
	operator const IsupPublicPartyNumber & ( ) const { return dynamic_cast < const IsupPublicPartyNumber & > ( * choice ); }
	operator IsupDigits & ( ) { return dynamic_cast < IsupDigits & > ( * choice ); }
	operator const IsupDigits & ( ) const { return dynamic_cast < const IsupDigits & > ( * choice ); }
	operator IsupPrivatePartyNumber & ( ) { return dynamic_cast < IsupPrivatePartyNumber & > ( * choice ); }
	operator const IsupPrivatePartyNumber & ( ) const { return dynamic_cast < const IsupPrivatePartyNumber & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	IsupNumber * clone ( ) const;
};

//
// SecurityServiceMode
//

// from 0 size 0 type 0 simple 0
class SecurityServiceMode : public Asn :: Choice {
	public:
	explicit SecurityServiceMode ( Asn :: istream & is );
	SecurityServiceMode ( );
	enum Choices {
		e_nonStandard,
		e_none,
		e_default
	};

	operator NonStandardParameter & ( ) { return dynamic_cast < NonStandardParameter & > ( * choice ); }
	operator const NonStandardParameter & ( ) const { return dynamic_cast < const NonStandardParameter & > ( * choice ); }
	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	SecurityServiceMode * clone ( ) const;
};

//
// SecurityCapabilities
//

// from 0 size 0 type 0 simple 0
class SecurityCapabilities : public Asn :: Sequence {
	public:
	explicit SecurityCapabilities ( Asn :: istream & is );
	SecurityCapabilities ( );
	enum OptionalFields {
		e_nonStandard
	};

	SecurityCapabilities ( const SecurityCapabilities & s );
	SecurityCapabilities & operator= ( const SecurityCapabilities & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	NonStandardParameter * m_nonStandard;
	public:
	SecurityServiceMode m_encryption;
	SecurityServiceMode m_authenticaton;
	SecurityServiceMode m_integrity;
	void encode ( Asn :: ostream & os ) const;
	~SecurityCapabilities ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandard ( ) const {
		return * m_nonStandard;
	}
	NonStandardParameter & get_nonStandard ( ) {
		return * m_nonStandard;
	}
	SecurityCapabilities * clone ( ) const;
};

//
// H245Security
//

// from 0 size 0 type 0 simple 0
class H245Security : public Asn :: Choice {
	public:
	explicit H245Security ( Asn :: istream & is );
	H245Security ( );
	enum Choices {
		e_nonStandard,
		e_noSecurity,
		e_tls,
		e_ipsec
	};

	operator NonStandardParameter & ( ) { return dynamic_cast < NonStandardParameter & > ( * choice ); }
	operator const NonStandardParameter & ( ) const { return dynamic_cast < const NonStandardParameter & > ( * choice ); }
	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator SecurityCapabilities & ( ) { return dynamic_cast < SecurityCapabilities & > ( * choice ); }
	operator const SecurityCapabilities & ( ) const { return dynamic_cast < const SecurityCapabilities & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	H245Security * clone ( ) const;
};

//
// EncryptIntAlg
//

// from 0 size 0 type 0 simple 0
class EncryptIntAlg : public Asn :: Choice {
	public:
	explicit EncryptIntAlg ( Asn :: istream & is );
	EncryptIntAlg ( );
	enum Choices {
		e_nonStandard,
		e_isoAlgorithm
	};

	operator NonStandardParameter & ( ) { return dynamic_cast < NonStandardParameter & > ( * choice ); }
	operator const NonStandardParameter & ( ) const { return dynamic_cast < const NonStandardParameter & > ( * choice ); }
	operator Asn :: ObjectId & ( ) { return dynamic_cast < Asn :: ObjectId & > ( * choice ); }
	operator const Asn :: ObjectId & ( ) const { return dynamic_cast < const Asn :: ObjectId & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	EncryptIntAlg * clone ( ) const;
};

//
// NonIsoIntegrityMechanism
//

// from 0 size 0 type 0 simple 0
class NonIsoIntegrityMechanism : public Asn :: Choice {
	public:
	explicit NonIsoIntegrityMechanism ( Asn :: istream & is );
	NonIsoIntegrityMechanism ( );
	enum Choices {
		e_hMAC_MD5,
		e_hMAC_iso10118_2_s,
		e_hMAC_iso10118_2_l,
		e_hMAC_iso10118_3
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator EncryptIntAlg & ( ) { return dynamic_cast < EncryptIntAlg & > ( * choice ); }
	operator const EncryptIntAlg & ( ) const { return dynamic_cast < const EncryptIntAlg & > ( * choice ); }
	operator Asn :: ObjectId & ( ) { return dynamic_cast < Asn :: ObjectId & > ( * choice ); }
	operator const Asn :: ObjectId & ( ) const { return dynamic_cast < const Asn :: ObjectId & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	NonIsoIntegrityMechanism * clone ( ) const;
};

//
// IntegrityMechanism
//

// from 0 size 0 type 0 simple 0
class IntegrityMechanism : public Asn :: Choice {
	public:
	explicit IntegrityMechanism ( Asn :: istream & is );
	IntegrityMechanism ( );
	enum Choices {
		e_nonStandard,
		e_digSig,
		e_iso9797,
		e_nonIsoIM
	};

	operator NonStandardParameter & ( ) { return dynamic_cast < NonStandardParameter & > ( * choice ); }
	operator const NonStandardParameter & ( ) const { return dynamic_cast < const NonStandardParameter & > ( * choice ); }
	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator Asn :: ObjectId & ( ) { return dynamic_cast < Asn :: ObjectId & > ( * choice ); }
	operator const Asn :: ObjectId & ( ) const { return dynamic_cast < const Asn :: ObjectId & > ( * choice ); }
	operator NonIsoIntegrityMechanism & ( ) { return dynamic_cast < NonIsoIntegrityMechanism & > ( * choice ); }
	operator const NonIsoIntegrityMechanism & ( ) const { return dynamic_cast < const NonIsoIntegrityMechanism & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	IntegrityMechanism * clone ( ) const;
};

//
// ServiceControlDescriptor
//

// from 0 size 0 type 0 simple 0
class ServiceControlDescriptor : public Asn :: Choice {
	public:
	explicit ServiceControlDescriptor ( Asn :: istream & is );
	ServiceControlDescriptor ( );
	enum Choices {
		e_url,
		e_signal,
		e_nonStandard,
		e_callCreditServiceControl
	};

	operator ServiceControlDescriptor_url & ( ) { return dynamic_cast < ServiceControlDescriptor_url & > ( * choice ); }
	operator const ServiceControlDescriptor_url & ( ) const { return dynamic_cast < const ServiceControlDescriptor_url & > ( * choice ); }
	operator H248SignalsDescriptor & ( ) { return dynamic_cast < H248SignalsDescriptor & > ( * choice ); }
	operator const H248SignalsDescriptor & ( ) const { return dynamic_cast < const H248SignalsDescriptor & > ( * choice ); }
	operator NonStandardParameter & ( ) { return dynamic_cast < NonStandardParameter & > ( * choice ); }
	operator const NonStandardParameter & ( ) const { return dynamic_cast < const NonStandardParameter & > ( * choice ); }
	operator CallCreditServiceControl & ( ) { return dynamic_cast < CallCreditServiceControl & > ( * choice ); }
	operator const CallCreditServiceControl & ( ) const { return dynamic_cast < const CallCreditServiceControl & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	ServiceControlDescriptor * clone ( ) const;
};

//
// GenericData
//

// from 0 size 0 type 0 simple 0
class GenericData : public Asn :: Sequence {
	public:
	explicit GenericData ( Asn :: istream & is );
	GenericData ( );
	enum OptionalFields {
		e_parameters
	};

	GenericData ( const GenericData & s );
	GenericData & operator= ( const GenericData & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	GenericIdentifier m_id;
	protected:
	GenericData_parameters * m_parameters;
	public:
	void encode ( Asn :: ostream & os ) const;
	~GenericData ( );
	void printOn ( std :: ostream & os ) const;
	const GenericData_parameters & get_parameters ( ) const {
		return * m_parameters;
	}
	GenericData_parameters & get_parameters ( ) {
		return * m_parameters;
	}
	GenericData * clone ( ) const;
};

//
// RegistrationRequest
//

// from 0 size 0 type 0 simple 0
class RegistrationRequest : public Asn :: Sequence {
	public:
	explicit RegistrationRequest ( Asn :: istream & is );
	RegistrationRequest ( );
	enum OptionalFields {
		e_nonStandardData,
		e_terminalAlias,
		e_gatekeeperIdentifier,
		e_alternateEndpoints,
		e_timeToLive,
		e_tokens,
		e_cryptoTokens,
		e_integrityCheckValue,
		e_keepAlive,
		e_endpointIdentifier,
		e_willSupplyUUIEs,
		e_maintainConnection,
		e_alternateTransportAddresses,
		e_additiveRegistration,
		e_terminalAliasPattern,
		e_supportsAltGK,
		e_usageReportingCapability,
		e_multipleCalls,
		e_supportedH248Packages,
		e_callCreditCapability,
		e_capacityReportingCapability,
		e_capacity,
		e_featureSet,
		e_genericData,
		e_restart,
		e_supportsACFSequences,
		e_supportsAssignedGK,
		e_assignedGatekeeper,
		e_transportQOS,
		e_language
	};

	RegistrationRequest ( const RegistrationRequest & s );
	RegistrationRequest & operator= ( const RegistrationRequest & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	RequestSeqNum m_requestSeqNum;
	ProtocolIdentifier m_protocolIdentifier;
	protected:
	NonStandardParameter * m_nonStandardData;
	public:
	Asn :: Boolean m_discoveryComplete;
	ArrayOf_TransportAddress m_callSignalAddress;
	ArrayOf_TransportAddress m_rasAddress;
	EndpointType m_terminalType;
	protected:
	ArrayOf_AliasAddress * m_terminalAlias;
	GatekeeperIdentifier * m_gatekeeperIdentifier;
	public:
	VendorIdentifier m_endpointVendor;
	protected:
	ArrayOf_Endpoint * m_alternateEndpoints;
	TimeToLive * m_timeToLive;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ICV * m_integrityCheckValue;
	Asn :: Boolean * m_keepAlive;
	EndpointIdentifier * m_endpointIdentifier;
	Asn :: Boolean * m_willSupplyUUIEs;
	Asn :: Boolean * m_maintainConnection;
	AlternateTransportAddresses * m_alternateTransportAddresses;
	Asn :: Null * m_additiveRegistration;
	ArrayOf_AddressPattern * m_terminalAliasPattern;
	Asn :: Null * m_supportsAltGK;
	RasUsageInfoTypes * m_usageReportingCapability;
	Asn :: Boolean * m_multipleCalls;
	ArrayOf_H248PackagesDescriptor * m_supportedH248Packages;
	CallCreditCapability * m_callCreditCapability;
	CapacityReportingCapability * m_capacityReportingCapability;
	CallCapacity * m_capacity;
	FeatureSet * m_featureSet;
	ArrayOf_GenericData * m_genericData;
	Asn :: Null * m_restart;
	Asn :: Null * m_supportsACFSequences;
	Asn :: Boolean * m_supportsAssignedGK;
	AlternateGK * m_assignedGatekeeper;
	TransportQOS * m_transportQOS;
	RegistrationRequest_language * m_language;
	public:
	void encode ( Asn :: ostream & os ) const;
	~RegistrationRequest ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const ArrayOf_AliasAddress & get_terminalAlias ( ) const {
		return * m_terminalAlias;
	}
	ArrayOf_AliasAddress & get_terminalAlias ( ) {
		return * m_terminalAlias;
	}
	const GatekeeperIdentifier & get_gatekeeperIdentifier ( ) const {
		return * m_gatekeeperIdentifier;
	}
	GatekeeperIdentifier & get_gatekeeperIdentifier ( ) {
		return * m_gatekeeperIdentifier;
	}
	const ArrayOf_Endpoint & get_alternateEndpoints ( ) const {
		return * m_alternateEndpoints;
	}
	ArrayOf_Endpoint & get_alternateEndpoints ( ) {
		return * m_alternateEndpoints;
	}
	const TimeToLive & get_timeToLive ( ) const {
		return * m_timeToLive;
	}
	TimeToLive & get_timeToLive ( ) {
		return * m_timeToLive;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ICV & get_integrityCheckValue ( ) const {
		return * m_integrityCheckValue;
	}
	ICV & get_integrityCheckValue ( ) {
		return * m_integrityCheckValue;
	}
	const Asn :: Boolean & get_keepAlive ( ) const {
		return * m_keepAlive;
	}
	Asn :: Boolean & get_keepAlive ( ) {
		return * m_keepAlive;
	}
	const EndpointIdentifier & get_endpointIdentifier ( ) const {
		return * m_endpointIdentifier;
	}
	EndpointIdentifier & get_endpointIdentifier ( ) {
		return * m_endpointIdentifier;
	}
	const Asn :: Boolean & get_willSupplyUUIEs ( ) const {
		return * m_willSupplyUUIEs;
	}
	Asn :: Boolean & get_willSupplyUUIEs ( ) {
		return * m_willSupplyUUIEs;
	}
	const Asn :: Boolean & get_maintainConnection ( ) const {
		return * m_maintainConnection;
	}
	Asn :: Boolean & get_maintainConnection ( ) {
		return * m_maintainConnection;
	}
	const AlternateTransportAddresses & get_alternateTransportAddresses ( ) const {
		return * m_alternateTransportAddresses;
	}
	AlternateTransportAddresses & get_alternateTransportAddresses ( ) {
		return * m_alternateTransportAddresses;
	}
	const Asn :: Null & get_additiveRegistration ( ) const {
		return * m_additiveRegistration;
	}
	Asn :: Null & get_additiveRegistration ( ) {
		return * m_additiveRegistration;
	}
	const ArrayOf_AddressPattern & get_terminalAliasPattern ( ) const {
		return * m_terminalAliasPattern;
	}
	ArrayOf_AddressPattern & get_terminalAliasPattern ( ) {
		return * m_terminalAliasPattern;
	}
	const Asn :: Null & get_supportsAltGK ( ) const {
		return * m_supportsAltGK;
	}
	Asn :: Null & get_supportsAltGK ( ) {
		return * m_supportsAltGK;
	}
	const RasUsageInfoTypes & get_usageReportingCapability ( ) const {
		return * m_usageReportingCapability;
	}
	RasUsageInfoTypes & get_usageReportingCapability ( ) {
		return * m_usageReportingCapability;
	}
	const Asn :: Boolean & get_multipleCalls ( ) const {
		return * m_multipleCalls;
	}
	Asn :: Boolean & get_multipleCalls ( ) {
		return * m_multipleCalls;
	}
	const ArrayOf_H248PackagesDescriptor & get_supportedH248Packages ( ) const {
		return * m_supportedH248Packages;
	}
	ArrayOf_H248PackagesDescriptor & get_supportedH248Packages ( ) {
		return * m_supportedH248Packages;
	}
	const CallCreditCapability & get_callCreditCapability ( ) const {
		return * m_callCreditCapability;
	}
	CallCreditCapability & get_callCreditCapability ( ) {
		return * m_callCreditCapability;
	}
	const CapacityReportingCapability & get_capacityReportingCapability ( ) const {
		return * m_capacityReportingCapability;
	}
	CapacityReportingCapability & get_capacityReportingCapability ( ) {
		return * m_capacityReportingCapability;
	}
	const CallCapacity & get_capacity ( ) const {
		return * m_capacity;
	}
	CallCapacity & get_capacity ( ) {
		return * m_capacity;
	}
	const FeatureSet & get_featureSet ( ) const {
		return * m_featureSet;
	}
	FeatureSet & get_featureSet ( ) {
		return * m_featureSet;
	}
	const ArrayOf_GenericData & get_genericData ( ) const {
		return * m_genericData;
	}
	ArrayOf_GenericData & get_genericData ( ) {
		return * m_genericData;
	}
	const Asn :: Null & get_restart ( ) const {
		return * m_restart;
	}
	Asn :: Null & get_restart ( ) {
		return * m_restart;
	}
	const Asn :: Null & get_supportsACFSequences ( ) const {
		return * m_supportsACFSequences;
	}
	Asn :: Null & get_supportsACFSequences ( ) {
		return * m_supportsACFSequences;
	}
	const Asn :: Boolean & get_supportsAssignedGK ( ) const {
		return * m_supportsAssignedGK;
	}
	Asn :: Boolean & get_supportsAssignedGK ( ) {
		return * m_supportsAssignedGK;
	}
	const AlternateGK & get_assignedGatekeeper ( ) const {
		return * m_assignedGatekeeper;
	}
	AlternateGK & get_assignedGatekeeper ( ) {
		return * m_assignedGatekeeper;
	}
	const TransportQOS & get_transportQOS ( ) const {
		return * m_transportQOS;
	}
	TransportQOS & get_transportQOS ( ) {
		return * m_transportQOS;
	}
	const RegistrationRequest_language & get_language ( ) const {
		return * m_language;
	}
	RegistrationRequest_language & get_language ( ) {
		return * m_language;
	}
	RegistrationRequest * clone ( ) const;
};

//
// RegistrationReject
//

// from 0 size 0 type 0 simple 0
class RegistrationReject : public Asn :: Sequence {
	public:
	explicit RegistrationReject ( Asn :: istream & is );
	RegistrationReject ( );
	enum OptionalFields {
		e_nonStandardData,
		e_gatekeeperIdentifier,
		e_altGKInfo,
		e_tokens,
		e_cryptoTokens,
		e_integrityCheckValue,
		e_featureSet,
		e_genericData,
		e_assignedGatekeeper
	};

	RegistrationReject ( const RegistrationReject & s );
	RegistrationReject & operator= ( const RegistrationReject & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	RequestSeqNum m_requestSeqNum;
	ProtocolIdentifier m_protocolIdentifier;
	protected:
	NonStandardParameter * m_nonStandardData;
	public:
	RegistrationRejectReason m_rejectReason;
	protected:
	GatekeeperIdentifier * m_gatekeeperIdentifier;
	AltGKInfo * m_altGKInfo;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ICV * m_integrityCheckValue;
	FeatureSet * m_featureSet;
	ArrayOf_GenericData * m_genericData;
	AlternateGK * m_assignedGatekeeper;
	public:
	void encode ( Asn :: ostream & os ) const;
	~RegistrationReject ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const GatekeeperIdentifier & get_gatekeeperIdentifier ( ) const {
		return * m_gatekeeperIdentifier;
	}
	GatekeeperIdentifier & get_gatekeeperIdentifier ( ) {
		return * m_gatekeeperIdentifier;
	}
	const AltGKInfo & get_altGKInfo ( ) const {
		return * m_altGKInfo;
	}
	AltGKInfo & get_altGKInfo ( ) {
		return * m_altGKInfo;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ICV & get_integrityCheckValue ( ) const {
		return * m_integrityCheckValue;
	}
	ICV & get_integrityCheckValue ( ) {
		return * m_integrityCheckValue;
	}
	const FeatureSet & get_featureSet ( ) const {
		return * m_featureSet;
	}
	FeatureSet & get_featureSet ( ) {
		return * m_featureSet;
	}
	const ArrayOf_GenericData & get_genericData ( ) const {
		return * m_genericData;
	}
	ArrayOf_GenericData & get_genericData ( ) {
		return * m_genericData;
	}
	const AlternateGK & get_assignedGatekeeper ( ) const {
		return * m_assignedGatekeeper;
	}
	AlternateGK & get_assignedGatekeeper ( ) {
		return * m_assignedGatekeeper;
	}
	RegistrationReject * clone ( ) const;
};

//
// AdmissionReject
//

// from 0 size 0 type 0 simple 0
class AdmissionReject : public Asn :: Sequence {
	public:
	explicit AdmissionReject ( Asn :: istream & is );
	AdmissionReject ( );
	enum OptionalFields {
		e_nonStandardData,
		e_altGKInfo,
		e_tokens,
		e_cryptoTokens,
		e_callSignalAddress,
		e_integrityCheckValue,
		e_serviceControl,
		e_featureSet,
		e_genericData,
		e_assignedGatekeeper
	};

	AdmissionReject ( const AdmissionReject & s );
	AdmissionReject & operator= ( const AdmissionReject & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	RequestSeqNum m_requestSeqNum;
	AdmissionRejectReason m_rejectReason;
	protected:
	NonStandardParameter * m_nonStandardData;
	AltGKInfo * m_altGKInfo;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ArrayOf_TransportAddress * m_callSignalAddress;
	ICV * m_integrityCheckValue;
	ArrayOf_ServiceControlSession * m_serviceControl;
	FeatureSet * m_featureSet;
	ArrayOf_GenericData * m_genericData;
	AlternateGK * m_assignedGatekeeper;
	public:
	void encode ( Asn :: ostream & os ) const;
	~AdmissionReject ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const AltGKInfo & get_altGKInfo ( ) const {
		return * m_altGKInfo;
	}
	AltGKInfo & get_altGKInfo ( ) {
		return * m_altGKInfo;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ArrayOf_TransportAddress & get_callSignalAddress ( ) const {
		return * m_callSignalAddress;
	}
	ArrayOf_TransportAddress & get_callSignalAddress ( ) {
		return * m_callSignalAddress;
	}
	const ICV & get_integrityCheckValue ( ) const {
		return * m_integrityCheckValue;
	}
	ICV & get_integrityCheckValue ( ) {
		return * m_integrityCheckValue;
	}
	const ArrayOf_ServiceControlSession & get_serviceControl ( ) const {
		return * m_serviceControl;
	}
	ArrayOf_ServiceControlSession & get_serviceControl ( ) {
		return * m_serviceControl;
	}
	const FeatureSet & get_featureSet ( ) const {
		return * m_featureSet;
	}
	FeatureSet & get_featureSet ( ) {
		return * m_featureSet;
	}
	const ArrayOf_GenericData & get_genericData ( ) const {
		return * m_genericData;
	}
	ArrayOf_GenericData & get_genericData ( ) {
		return * m_genericData;
	}
	const AlternateGK & get_assignedGatekeeper ( ) const {
		return * m_assignedGatekeeper;
	}
	AlternateGK & get_assignedGatekeeper ( ) {
		return * m_assignedGatekeeper;
	}
	AdmissionReject * clone ( ) const;
};

//
// LocationReject
//

// from 0 size 0 type 0 simple 0
class LocationReject : public Asn :: Sequence {
	public:
	explicit LocationReject ( Asn :: istream & is );
	LocationReject ( );
	enum OptionalFields {
		e_nonStandardData,
		e_altGKInfo,
		e_tokens,
		e_cryptoTokens,
		e_integrityCheckValue,
		e_featureSet,
		e_genericData,
		e_serviceControl
	};

	LocationReject ( const LocationReject & s );
	LocationReject & operator= ( const LocationReject & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	RequestSeqNum m_requestSeqNum;
	LocationRejectReason m_rejectReason;
	protected:
	NonStandardParameter * m_nonStandardData;
	AltGKInfo * m_altGKInfo;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ICV * m_integrityCheckValue;
	FeatureSet * m_featureSet;
	ArrayOf_GenericData * m_genericData;
	ArrayOf_ServiceControlSession * m_serviceControl;
	public:
	void encode ( Asn :: ostream & os ) const;
	~LocationReject ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const AltGKInfo & get_altGKInfo ( ) const {
		return * m_altGKInfo;
	}
	AltGKInfo & get_altGKInfo ( ) {
		return * m_altGKInfo;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ICV & get_integrityCheckValue ( ) const {
		return * m_integrityCheckValue;
	}
	ICV & get_integrityCheckValue ( ) {
		return * m_integrityCheckValue;
	}
	const FeatureSet & get_featureSet ( ) const {
		return * m_featureSet;
	}
	FeatureSet & get_featureSet ( ) {
		return * m_featureSet;
	}
	const ArrayOf_GenericData & get_genericData ( ) const {
		return * m_genericData;
	}
	ArrayOf_GenericData & get_genericData ( ) {
		return * m_genericData;
	}
	const ArrayOf_ServiceControlSession & get_serviceControl ( ) const {
		return * m_serviceControl;
	}
	ArrayOf_ServiceControlSession & get_serviceControl ( ) {
		return * m_serviceControl;
	}
	LocationReject * clone ( ) const;
};

//
// NonStandardMessage
//

// from 0 size 0 type 0 simple 0
class NonStandardMessage : public Asn :: Sequence {
	public:
	explicit NonStandardMessage ( Asn :: istream & is );
	NonStandardMessage ( );
	enum OptionalFields {
		e_tokens,
		e_cryptoTokens,
		e_integrityCheckValue,
		e_featureSet,
		e_genericData
	};

	NonStandardMessage ( const NonStandardMessage & s );
	NonStandardMessage & operator= ( const NonStandardMessage & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	RequestSeqNum m_requestSeqNum;
	NonStandardParameter m_nonStandardData;
	protected:
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ICV * m_integrityCheckValue;
	FeatureSet * m_featureSet;
	ArrayOf_GenericData * m_genericData;
	public:
	void encode ( Asn :: ostream & os ) const;
	~NonStandardMessage ( );
	void printOn ( std :: ostream & os ) const;
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ICV & get_integrityCheckValue ( ) const {
		return * m_integrityCheckValue;
	}
	ICV & get_integrityCheckValue ( ) {
		return * m_integrityCheckValue;
	}
	const FeatureSet & get_featureSet ( ) const {
		return * m_featureSet;
	}
	FeatureSet & get_featureSet ( ) {
		return * m_featureSet;
	}
	const ArrayOf_GenericData & get_genericData ( ) const {
		return * m_genericData;
	}
	ArrayOf_GenericData & get_genericData ( ) {
		return * m_genericData;
	}
	NonStandardMessage * clone ( ) const;
};

//
// H323-UU-PDU_tunnelledSignallingMessage
//

// from 0 size 0 type 0 simple 0
class H323_UU_PDU_tunnelledSignallingMessage : public Asn :: Sequence {
	public:
	explicit H323_UU_PDU_tunnelledSignallingMessage ( Asn :: istream & is );
	H323_UU_PDU_tunnelledSignallingMessage ( );
	enum OptionalFields {
		e_tunnellingRequired,
		e_nonStandardData
	};

	H323_UU_PDU_tunnelledSignallingMessage ( const H323_UU_PDU_tunnelledSignallingMessage & s );
	H323_UU_PDU_tunnelledSignallingMessage & operator= ( const H323_UU_PDU_tunnelledSignallingMessage & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	TunnelledProtocol m_tunnelledProtocolID;
	ArrayOf_Asn_OctetString m_messageContent;
	protected:
	Asn :: Null * m_tunnellingRequired;
	NonStandardParameter * m_nonStandardData;
	public:
	void encode ( Asn :: ostream & os ) const;
	~H323_UU_PDU_tunnelledSignallingMessage ( );
	void printOn ( std :: ostream & os ) const;
	const Asn :: Null & get_tunnellingRequired ( ) const {
		return * m_tunnellingRequired;
	}
	Asn :: Null & get_tunnellingRequired ( ) {
		return * m_tunnellingRequired;
	}
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	H323_UU_PDU_tunnelledSignallingMessage * clone ( ) const;
};

//
// AddressPattern_range
//

// from 0 size 0 type 0 simple 0
class AddressPattern_range : public Asn :: Sequence {
	public:
	explicit AddressPattern_range ( Asn :: istream & is );
	AddressPattern_range ( );
	PartyNumber m_startOfRange;
	PartyNumber m_endOfRange;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	AddressPattern_range * clone ( ) const;
};

//
// InfoRequestResponse_perCallInfo_subtype_pdu_subtype
//

// from 0 size 0 type 0 simple 0
class InfoRequestResponse_perCallInfo_subtype_pdu_subtype : public Asn :: Sequence {
	public:
	explicit InfoRequestResponse_perCallInfo_subtype_pdu_subtype ( Asn :: istream & is );
	InfoRequestResponse_perCallInfo_subtype_pdu_subtype ( );
	H323_UU_PDU m_h323pdu;
	Asn :: Boolean m_sent;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	InfoRequestResponse_perCallInfo_subtype_pdu_subtype * clone ( ) const;
};

//
// H323-UserInformation
//

// from 0 size 0 type 0 simple 0
class H323_UserInformation : public Asn :: Sequence {
	public:
	explicit H323_UserInformation ( Asn :: istream & is );
	H323_UserInformation ( );
	enum OptionalFields {
		e_user_data
	};

	H323_UserInformation ( const H323_UserInformation & s );
	H323_UserInformation & operator= ( const H323_UserInformation & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	H323_UU_PDU m_h323_uu_pdu;
	protected:
	H323_UserInformation_user_data * m_user_data;
	public:
	void encode ( Asn :: ostream & os ) const;
	~H323_UserInformation ( );
	void printOn ( std :: ostream & os ) const;
	const H323_UserInformation_user_data & get_user_data ( ) const {
		return * m_user_data;
	}
	H323_UserInformation_user_data & get_user_data ( ) {
		return * m_user_data;
	}
	H323_UserInformation * clone ( ) const;
};

//
// ReleaseCompleteReason
//

// from 0 size 0 type 0 simple 0
class ReleaseCompleteReason : public Asn :: Choice {
	public:
	explicit ReleaseCompleteReason ( Asn :: istream & is );
	ReleaseCompleteReason ( );
	enum Choices {
		e_noBandwidth,
		e_gatekeeperResources,
		e_unreachableDestination,
		e_destinationRejection,
		e_invalidRevision,
		e_noPermission,
		e_unreachableGatekeeper,
		e_gatewayResources,
		e_badFormatAddress,
		e_adaptiveBusy,
		e_inConf,
		e_undefinedReason,
		e_facilityCallDeflection,
		e_securityDenied,
		e_calledPartyNotRegistered,
		e_callerNotRegistered,
		e_newConnectionNeeded,
		e_nonStandardReason,
		e_replaceWithConferenceInvite,
		e_genericDataReason,
		e_neededFeatureNotSupported,
		e_tunnelledSignallingRejected,
		e_invalidCID,
		e_securityError,
		e_hopCountExceeded
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator NonStandardParameter & ( ) { return dynamic_cast < NonStandardParameter & > ( * choice ); }
	operator const NonStandardParameter & ( ) const { return dynamic_cast < const NonStandardParameter & > ( * choice ); }
	operator ConferenceIdentifier & ( ) { return dynamic_cast < ConferenceIdentifier & > ( * choice ); }
	operator const ConferenceIdentifier & ( ) const { return dynamic_cast < const ConferenceIdentifier & > ( * choice ); }
	operator SecurityErrors & ( ) { return dynamic_cast < SecurityErrors & > ( * choice ); }
	operator const SecurityErrors & ( ) const { return dynamic_cast < const SecurityErrors & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	ReleaseCompleteReason * clone ( ) const;
};

//
// TransportAddress
//

// from 0 size 0 type 0 simple 0
class TransportAddress : public Asn :: Choice {
	public:
	explicit TransportAddress ( Asn :: istream & is );
	TransportAddress ( );
	enum Choices {
		e_ipAddress,
		e_ipSourceRoute,
		e_ipxAddress,
		e_ip6Address,
		e_netBios,
		e_nsap,
		e_nonStandardAddress
	};

	operator TransportAddress_ipAddress & ( ) { return dynamic_cast < TransportAddress_ipAddress & > ( * choice ); }
	operator const TransportAddress_ipAddress & ( ) const { return dynamic_cast < const TransportAddress_ipAddress & > ( * choice ); }
	operator TransportAddress_ipSourceRoute & ( ) { return dynamic_cast < TransportAddress_ipSourceRoute & > ( * choice ); }
	operator const TransportAddress_ipSourceRoute & ( ) const { return dynamic_cast < const TransportAddress_ipSourceRoute & > ( * choice ); }
	operator TransportAddress_ipxAddress & ( ) { return dynamic_cast < TransportAddress_ipxAddress & > ( * choice ); }
	operator const TransportAddress_ipxAddress & ( ) const { return dynamic_cast < const TransportAddress_ipxAddress & > ( * choice ); }
	operator TransportAddress_ip6Address & ( ) { return dynamic_cast < TransportAddress_ip6Address & > ( * choice ); }
	operator const TransportAddress_ip6Address & ( ) const { return dynamic_cast < const TransportAddress_ip6Address & > ( * choice ); }
	operator TransportAddress_netBios & ( ) { return dynamic_cast < TransportAddress_netBios & > ( * choice ); }
	operator const TransportAddress_netBios & ( ) const { return dynamic_cast < const TransportAddress_netBios & > ( * choice ); }
	operator TransportAddress_nsap & ( ) { return dynamic_cast < TransportAddress_nsap & > ( * choice ); }
	operator const TransportAddress_nsap & ( ) const { return dynamic_cast < const TransportAddress_nsap & > ( * choice ); }
	operator NonStandardParameter & ( ) { return dynamic_cast < NonStandardParameter & > ( * choice ); }
	operator const NonStandardParameter & ( ) const { return dynamic_cast < const NonStandardParameter & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	TransportAddress * clone ( ) const;
};

//
// SupportedProtocols
//

// from 0 size 0 type 0 simple 0
class SupportedProtocols : public Asn :: Choice {
	public:
	explicit SupportedProtocols ( Asn :: istream & is );
	SupportedProtocols ( );
	enum Choices {
		e_nonStandardData,
		e_h310,
		e_h320,
		e_h321,
		e_h322,
		e_h323,
		e_h324,
		e_voice,
		e_t120_only,
		e_nonStandardProtocol,
		e_t38FaxAnnexbOnly,
		e_sip
	};

	operator NonStandardParameter & ( ) { return dynamic_cast < NonStandardParameter & > ( * choice ); }
	operator const NonStandardParameter & ( ) const { return dynamic_cast < const NonStandardParameter & > ( * choice ); }
	operator H310Caps & ( ) { return dynamic_cast < H310Caps & > ( * choice ); }
	operator const H310Caps & ( ) const { return dynamic_cast < const H310Caps & > ( * choice ); }
	operator H320Caps & ( ) { return dynamic_cast < H320Caps & > ( * choice ); }
	operator const H320Caps & ( ) const { return dynamic_cast < const H320Caps & > ( * choice ); }
	operator H321Caps & ( ) { return dynamic_cast < H321Caps & > ( * choice ); }
	operator const H321Caps & ( ) const { return dynamic_cast < const H321Caps & > ( * choice ); }
	operator H322Caps & ( ) { return dynamic_cast < H322Caps & > ( * choice ); }
	operator const H322Caps & ( ) const { return dynamic_cast < const H322Caps & > ( * choice ); }
	operator H323Caps & ( ) { return dynamic_cast < H323Caps & > ( * choice ); }
	operator const H323Caps & ( ) const { return dynamic_cast < const H323Caps & > ( * choice ); }
	operator H324Caps & ( ) { return dynamic_cast < H324Caps & > ( * choice ); }
	operator const H324Caps & ( ) const { return dynamic_cast < const H324Caps & > ( * choice ); }
	operator VoiceCaps & ( ) { return dynamic_cast < VoiceCaps & > ( * choice ); }
	operator const VoiceCaps & ( ) const { return dynamic_cast < const VoiceCaps & > ( * choice ); }
	operator T120OnlyCaps & ( ) { return dynamic_cast < T120OnlyCaps & > ( * choice ); }
	operator const T120OnlyCaps & ( ) const { return dynamic_cast < const T120OnlyCaps & > ( * choice ); }
	operator NonStandardProtocol & ( ) { return dynamic_cast < NonStandardProtocol & > ( * choice ); }
	operator const NonStandardProtocol & ( ) const { return dynamic_cast < const NonStandardProtocol & > ( * choice ); }
	operator T38FaxAnnexbOnlyCaps & ( ) { return dynamic_cast < T38FaxAnnexbOnlyCaps & > ( * choice ); }
	operator const T38FaxAnnexbOnlyCaps & ( ) const { return dynamic_cast < const T38FaxAnnexbOnlyCaps & > ( * choice ); }
	operator SIPCaps & ( ) { return dynamic_cast < SIPCaps & > ( * choice ); }
	operator const SIPCaps & ( ) const { return dynamic_cast < const SIPCaps & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	SupportedProtocols * clone ( ) const;
};

//
// MobileUIM
//

// from 0 size 0 type 0 simple 0
class MobileUIM : public Asn :: Choice {
	public:
	explicit MobileUIM ( Asn :: istream & is );
	MobileUIM ( );
	enum Choices {
		e_ansi_41_uim,
		e_gsm_uim
	};

	operator ANSI_41_UIM & ( ) { return dynamic_cast < ANSI_41_UIM & > ( * choice ); }
	operator const ANSI_41_UIM & ( ) const { return dynamic_cast < const ANSI_41_UIM & > ( * choice ); }
	operator GSM_UIM & ( ) { return dynamic_cast < GSM_UIM & > ( * choice ); }
	operator const GSM_UIM & ( ) const { return dynamic_cast < const GSM_UIM & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	MobileUIM * clone ( ) const;
};

//
// AlternateGK
//

// from 0 size 0 type 0 simple 0
class AlternateGK : public Asn :: Sequence {
	public:
	explicit AlternateGK ( Asn :: istream & is );
	AlternateGK ( );
	enum OptionalFields {
		e_gatekeeperIdentifier
	};

	AlternateGK ( const AlternateGK & s );
	AlternateGK & operator= ( const AlternateGK & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	TransportAddress m_rasAddress;
	protected:
	GatekeeperIdentifier * m_gatekeeperIdentifier;
	public:
	Asn :: Boolean m_needToRegister;
	AlternateGK_priority m_priority;
	void encode ( Asn :: ostream & os ) const;
	~AlternateGK ( );
	void printOn ( std :: ostream & os ) const;
	const GatekeeperIdentifier & get_gatekeeperIdentifier ( ) const {
		return * m_gatekeeperIdentifier;
	}
	GatekeeperIdentifier & get_gatekeeperIdentifier ( ) {
		return * m_gatekeeperIdentifier;
	}
	AlternateGK * clone ( ) const;
};

//
// FeatureDescriptor
//

// from 0 size 0 type 0 simple 0
class FeatureDescriptor : public GenericData {
	public:
	explicit FeatureDescriptor ( Asn :: istream & is );
	FeatureDescriptor ( );
	FeatureDescriptor * clone ( ) const;
};

//
// CallTerminationCause
//

// from 0 size 0 type 0 simple 0
class CallTerminationCause : public Asn :: Choice {
	public:
	explicit CallTerminationCause ( Asn :: istream & is );
	CallTerminationCause ( );
	enum Choices {
		e_releaseCompleteReason,
		e_releaseCompleteCauseIE
	};

	operator ReleaseCompleteReason & ( ) { return dynamic_cast < ReleaseCompleteReason & > ( * choice ); }
	operator const ReleaseCompleteReason & ( ) const { return dynamic_cast < const ReleaseCompleteReason & > ( * choice ); }
	operator CallTerminationCause_releaseCompleteCauseIE & ( ) { return dynamic_cast < CallTerminationCause_releaseCompleteCauseIE & > ( * choice ); }
	operator const CallTerminationCause_releaseCompleteCauseIE & ( ) const { return dynamic_cast < const CallTerminationCause_releaseCompleteCauseIE & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	CallTerminationCause * clone ( ) const;
};

//
// GatekeeperRequest
//

// from 0 size 0 type 0 simple 0
class GatekeeperRequest : public Asn :: Sequence {
	public:
	explicit GatekeeperRequest ( Asn :: istream & is );
	GatekeeperRequest ( );
	enum OptionalFields {
		e_nonStandardData,
		e_gatekeeperIdentifier,
		e_callServices,
		e_endpointAlias,
		e_alternateEndpoints,
		e_tokens,
		e_cryptoTokens,
		e_authenticationCapability,
		e_algorithmOIDs,
		e_integrity,
		e_integrityCheckValue,
		e_supportsAltGK,
		e_featureSet,
		e_genericData,
		e_supportsAssignedGK,
		e_assignedGatekeeper
	};

	GatekeeperRequest ( const GatekeeperRequest & s );
	GatekeeperRequest & operator= ( const GatekeeperRequest & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	RequestSeqNum m_requestSeqNum;
	ProtocolIdentifier m_protocolIdentifier;
	protected:
	NonStandardParameter * m_nonStandardData;
	public:
	TransportAddress m_rasAddress;
	EndpointType m_endpointType;
	protected:
	GatekeeperIdentifier * m_gatekeeperIdentifier;
	QseriesOptions * m_callServices;
	ArrayOf_AliasAddress * m_endpointAlias;
	ArrayOf_Endpoint * m_alternateEndpoints;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ArrayOf_AuthenticationMechanism * m_authenticationCapability;
	ArrayOf_Asn_ObjectId * m_algorithmOIDs;
	ArrayOf_IntegrityMechanism * m_integrity;
	ICV * m_integrityCheckValue;
	Asn :: Null * m_supportsAltGK;
	FeatureSet * m_featureSet;
	ArrayOf_GenericData * m_genericData;
	Asn :: Boolean * m_supportsAssignedGK;
	AlternateGK * m_assignedGatekeeper;
	public:
	void encode ( Asn :: ostream & os ) const;
	~GatekeeperRequest ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const GatekeeperIdentifier & get_gatekeeperIdentifier ( ) const {
		return * m_gatekeeperIdentifier;
	}
	GatekeeperIdentifier & get_gatekeeperIdentifier ( ) {
		return * m_gatekeeperIdentifier;
	}
	const QseriesOptions & get_callServices ( ) const {
		return * m_callServices;
	}
	QseriesOptions & get_callServices ( ) {
		return * m_callServices;
	}
	const ArrayOf_AliasAddress & get_endpointAlias ( ) const {
		return * m_endpointAlias;
	}
	ArrayOf_AliasAddress & get_endpointAlias ( ) {
		return * m_endpointAlias;
	}
	const ArrayOf_Endpoint & get_alternateEndpoints ( ) const {
		return * m_alternateEndpoints;
	}
	ArrayOf_Endpoint & get_alternateEndpoints ( ) {
		return * m_alternateEndpoints;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ArrayOf_AuthenticationMechanism & get_authenticationCapability ( ) const {
		return * m_authenticationCapability;
	}
	ArrayOf_AuthenticationMechanism & get_authenticationCapability ( ) {
		return * m_authenticationCapability;
	}
	const ArrayOf_Asn_ObjectId & get_algorithmOIDs ( ) const {
		return * m_algorithmOIDs;
	}
	ArrayOf_Asn_ObjectId & get_algorithmOIDs ( ) {
		return * m_algorithmOIDs;
	}
	const ArrayOf_IntegrityMechanism & get_integrity ( ) const {
		return * m_integrity;
	}
	ArrayOf_IntegrityMechanism & get_integrity ( ) {
		return * m_integrity;
	}
	const ICV & get_integrityCheckValue ( ) const {
		return * m_integrityCheckValue;
	}
	ICV & get_integrityCheckValue ( ) {
		return * m_integrityCheckValue;
	}
	const Asn :: Null & get_supportsAltGK ( ) const {
		return * m_supportsAltGK;
	}
	Asn :: Null & get_supportsAltGK ( ) {
		return * m_supportsAltGK;
	}
	const FeatureSet & get_featureSet ( ) const {
		return * m_featureSet;
	}
	FeatureSet & get_featureSet ( ) {
		return * m_featureSet;
	}
	const ArrayOf_GenericData & get_genericData ( ) const {
		return * m_genericData;
	}
	ArrayOf_GenericData & get_genericData ( ) {
		return * m_genericData;
	}
	const Asn :: Boolean & get_supportsAssignedGK ( ) const {
		return * m_supportsAssignedGK;
	}
	Asn :: Boolean & get_supportsAssignedGK ( ) {
		return * m_supportsAssignedGK;
	}
	const AlternateGK & get_assignedGatekeeper ( ) const {
		return * m_assignedGatekeeper;
	}
	AlternateGK & get_assignedGatekeeper ( ) {
		return * m_assignedGatekeeper;
	}
	GatekeeperRequest * clone ( ) const;
};

//
// GatekeeperConfirm
//

// from 0 size 0 type 0 simple 0
class GatekeeperConfirm : public Asn :: Sequence {
	public:
	explicit GatekeeperConfirm ( Asn :: istream & is );
	GatekeeperConfirm ( );
	enum OptionalFields {
		e_nonStandardData,
		e_gatekeeperIdentifier,
		e_alternateGatekeeper,
		e_authenticationMode,
		e_tokens,
		e_cryptoTokens,
		e_algorithmOID,
		e_integrity,
		e_integrityCheckValue,
		e_featureSet,
		e_genericData,
		e_assignedGatekeeper,
		e_rehomingModel
	};

	GatekeeperConfirm ( const GatekeeperConfirm & s );
	GatekeeperConfirm & operator= ( const GatekeeperConfirm & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	RequestSeqNum m_requestSeqNum;
	ProtocolIdentifier m_protocolIdentifier;
	protected:
	NonStandardParameter * m_nonStandardData;
	GatekeeperIdentifier * m_gatekeeperIdentifier;
	public:
	TransportAddress m_rasAddress;
	protected:
	ArrayOf_AlternateGK * m_alternateGatekeeper;
	H235 :: AuthenticationMechanism * m_authenticationMode;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	Asn :: ObjectId * m_algorithmOID;
	ArrayOf_IntegrityMechanism * m_integrity;
	ICV * m_integrityCheckValue;
	FeatureSet * m_featureSet;
	ArrayOf_GenericData * m_genericData;
	AlternateGK * m_assignedGatekeeper;
	RehomingModel * m_rehomingModel;
	public:
	void encode ( Asn :: ostream & os ) const;
	~GatekeeperConfirm ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const GatekeeperIdentifier & get_gatekeeperIdentifier ( ) const {
		return * m_gatekeeperIdentifier;
	}
	GatekeeperIdentifier & get_gatekeeperIdentifier ( ) {
		return * m_gatekeeperIdentifier;
	}
	const ArrayOf_AlternateGK & get_alternateGatekeeper ( ) const {
		return * m_alternateGatekeeper;
	}
	ArrayOf_AlternateGK & get_alternateGatekeeper ( ) {
		return * m_alternateGatekeeper;
	}
	const H235 :: AuthenticationMechanism & get_authenticationMode ( ) const {
		return * m_authenticationMode;
	}
	H235 :: AuthenticationMechanism & get_authenticationMode ( ) {
		return * m_authenticationMode;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const Asn :: ObjectId & get_algorithmOID ( ) const {
		return * m_algorithmOID;
	}
	Asn :: ObjectId & get_algorithmOID ( ) {
		return * m_algorithmOID;
	}
	const ArrayOf_IntegrityMechanism & get_integrity ( ) const {
		return * m_integrity;
	}
	ArrayOf_IntegrityMechanism & get_integrity ( ) {
		return * m_integrity;
	}
	const ICV & get_integrityCheckValue ( ) const {
		return * m_integrityCheckValue;
	}
	ICV & get_integrityCheckValue ( ) {
		return * m_integrityCheckValue;
	}
	const FeatureSet & get_featureSet ( ) const {
		return * m_featureSet;
	}
	FeatureSet & get_featureSet ( ) {
		return * m_featureSet;
	}
	const ArrayOf_GenericData & get_genericData ( ) const {
		return * m_genericData;
	}
	ArrayOf_GenericData & get_genericData ( ) {
		return * m_genericData;
	}
	const AlternateGK & get_assignedGatekeeper ( ) const {
		return * m_assignedGatekeeper;
	}
	AlternateGK & get_assignedGatekeeper ( ) {
		return * m_assignedGatekeeper;
	}
	const RehomingModel & get_rehomingModel ( ) const {
		return * m_rehomingModel;
	}
	RehomingModel & get_rehomingModel ( ) {
		return * m_rehomingModel;
	}
	GatekeeperConfirm * clone ( ) const;
};

//
// AdmissionConfirm
//

// from 0 size 0 type 0 simple 0
class AdmissionConfirm : public Asn :: Sequence {
	public:
	explicit AdmissionConfirm ( Asn :: istream & is );
	AdmissionConfirm ( );
	enum OptionalFields {
		e_irrFrequency,
		e_nonStandardData,
		e_destinationInfo,
		e_destExtraCallInfo,
		e_destinationType,
		e_remoteExtensionAddress,
		e_alternateEndpoints,
		e_tokens,
		e_cryptoTokens,
		e_integrityCheckValue,
		e_transportQOS,
		e_willRespondToIRR,
		e_uuiesRequested,
		e_language,
		e_alternateTransportAddresses,
		e_useSpecifiedTransport,
		e_circuitInfo,
		e_usageSpec,
		e_supportedProtocols,
		e_serviceControl,
		e_multipleCalls,
		e_featureSet,
		e_genericData,
		e_modifiedSrcInfo,
		e_assignedGatekeeper
	};

	AdmissionConfirm ( const AdmissionConfirm & s );
	AdmissionConfirm & operator= ( const AdmissionConfirm & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	RequestSeqNum m_requestSeqNum;
	BandWidth m_bandWidth;
	CallModel m_callModel;
	TransportAddress m_destCallSignalAddress;
	protected:
	AdmissionConfirm_irrFrequency * m_irrFrequency;
	NonStandardParameter * m_nonStandardData;
	ArrayOf_AliasAddress * m_destinationInfo;
	ArrayOf_AliasAddress * m_destExtraCallInfo;
	EndpointType * m_destinationType;
	ArrayOf_AliasAddress * m_remoteExtensionAddress;
	ArrayOf_Endpoint * m_alternateEndpoints;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ICV * m_integrityCheckValue;
	TransportQOS * m_transportQOS;
	Asn :: Boolean * m_willRespondToIRR;
	UUIEsRequested * m_uuiesRequested;
	AdmissionConfirm_language * m_language;
	AlternateTransportAddresses * m_alternateTransportAddresses;
	UseSpecifiedTransport * m_useSpecifiedTransport;
	CircuitInfo * m_circuitInfo;
	ArrayOf_RasUsageSpecification * m_usageSpec;
	ArrayOf_SupportedProtocols * m_supportedProtocols;
	ArrayOf_ServiceControlSession * m_serviceControl;
	Asn :: Boolean * m_multipleCalls;
	FeatureSet * m_featureSet;
	ArrayOf_GenericData * m_genericData;
	ArrayOf_AliasAddress * m_modifiedSrcInfo;
	AlternateGK * m_assignedGatekeeper;
	public:
	void encode ( Asn :: ostream & os ) const;
	~AdmissionConfirm ( );
	void printOn ( std :: ostream & os ) const;
	const AdmissionConfirm_irrFrequency & get_irrFrequency ( ) const {
		return * m_irrFrequency;
	}
	AdmissionConfirm_irrFrequency & get_irrFrequency ( ) {
		return * m_irrFrequency;
	}
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const ArrayOf_AliasAddress & get_destinationInfo ( ) const {
		return * m_destinationInfo;
	}
	ArrayOf_AliasAddress & get_destinationInfo ( ) {
		return * m_destinationInfo;
	}
	const ArrayOf_AliasAddress & get_destExtraCallInfo ( ) const {
		return * m_destExtraCallInfo;
	}
	ArrayOf_AliasAddress & get_destExtraCallInfo ( ) {
		return * m_destExtraCallInfo;
	}
	const EndpointType & get_destinationType ( ) const {
		return * m_destinationType;
	}
	EndpointType & get_destinationType ( ) {
		return * m_destinationType;
	}
	const ArrayOf_AliasAddress & get_remoteExtensionAddress ( ) const {
		return * m_remoteExtensionAddress;
	}
	ArrayOf_AliasAddress & get_remoteExtensionAddress ( ) {
		return * m_remoteExtensionAddress;
	}
	const ArrayOf_Endpoint & get_alternateEndpoints ( ) const {
		return * m_alternateEndpoints;
	}
	ArrayOf_Endpoint & get_alternateEndpoints ( ) {
		return * m_alternateEndpoints;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ICV & get_integrityCheckValue ( ) const {
		return * m_integrityCheckValue;
	}
	ICV & get_integrityCheckValue ( ) {
		return * m_integrityCheckValue;
	}
	const TransportQOS & get_transportQOS ( ) const {
		return * m_transportQOS;
	}
	TransportQOS & get_transportQOS ( ) {
		return * m_transportQOS;
	}
	const Asn :: Boolean & get_willRespondToIRR ( ) const {
		return * m_willRespondToIRR;
	}
	Asn :: Boolean & get_willRespondToIRR ( ) {
		return * m_willRespondToIRR;
	}
	const UUIEsRequested & get_uuiesRequested ( ) const {
		return * m_uuiesRequested;
	}
	UUIEsRequested & get_uuiesRequested ( ) {
		return * m_uuiesRequested;
	}
	const AdmissionConfirm_language & get_language ( ) const {
		return * m_language;
	}
	AdmissionConfirm_language & get_language ( ) {
		return * m_language;
	}
	const AlternateTransportAddresses & get_alternateTransportAddresses ( ) const {
		return * m_alternateTransportAddresses;
	}
	AlternateTransportAddresses & get_alternateTransportAddresses ( ) {
		return * m_alternateTransportAddresses;
	}
	const UseSpecifiedTransport & get_useSpecifiedTransport ( ) const {
		return * m_useSpecifiedTransport;
	}
	UseSpecifiedTransport & get_useSpecifiedTransport ( ) {
		return * m_useSpecifiedTransport;
	}
	const CircuitInfo & get_circuitInfo ( ) const {
		return * m_circuitInfo;
	}
	CircuitInfo & get_circuitInfo ( ) {
		return * m_circuitInfo;
	}
	const ArrayOf_RasUsageSpecification & get_usageSpec ( ) const {
		return * m_usageSpec;
	}
	ArrayOf_RasUsageSpecification & get_usageSpec ( ) {
		return * m_usageSpec;
	}
	const ArrayOf_SupportedProtocols & get_supportedProtocols ( ) const {
		return * m_supportedProtocols;
	}
	ArrayOf_SupportedProtocols & get_supportedProtocols ( ) {
		return * m_supportedProtocols;
	}
	const ArrayOf_ServiceControlSession & get_serviceControl ( ) const {
		return * m_serviceControl;
	}
	ArrayOf_ServiceControlSession & get_serviceControl ( ) {
		return * m_serviceControl;
	}
	const Asn :: Boolean & get_multipleCalls ( ) const {
		return * m_multipleCalls;
	}
	Asn :: Boolean & get_multipleCalls ( ) {
		return * m_multipleCalls;
	}
	const FeatureSet & get_featureSet ( ) const {
		return * m_featureSet;
	}
	FeatureSet & get_featureSet ( ) {
		return * m_featureSet;
	}
	const ArrayOf_GenericData & get_genericData ( ) const {
		return * m_genericData;
	}
	ArrayOf_GenericData & get_genericData ( ) {
		return * m_genericData;
	}
	const ArrayOf_AliasAddress & get_modifiedSrcInfo ( ) const {
		return * m_modifiedSrcInfo;
	}
	ArrayOf_AliasAddress & get_modifiedSrcInfo ( ) {
		return * m_modifiedSrcInfo;
	}
	const AlternateGK & get_assignedGatekeeper ( ) const {
		return * m_assignedGatekeeper;
	}
	AlternateGK & get_assignedGatekeeper ( ) {
		return * m_assignedGatekeeper;
	}
	AdmissionConfirm * clone ( ) const;
};

//
// LocationRequest
//

// from 0 size 0 type 0 simple 0
class LocationRequest : public Asn :: Sequence {
	public:
	explicit LocationRequest ( Asn :: istream & is );
	LocationRequest ( );
	enum OptionalFields {
		e_endpointIdentifier,
		e_nonStandardData,
		e_sourceInfo,
		e_canMapAlias,
		e_gatekeeperIdentifier,
		e_tokens,
		e_cryptoTokens,
		e_integrityCheckValue,
		e_desiredProtocols,
		e_desiredTunnelledProtocol,
		e_featureSet,
		e_genericData,
		e_hopCount,
		e_circuitInfo,
		e_callIdentifier,
		e_bandWidth,
		e_sourceEndpointInfo,
		e_canMapSrcAlias,
		e_language
	};

	LocationRequest ( const LocationRequest & s );
	LocationRequest & operator= ( const LocationRequest & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	RequestSeqNum m_requestSeqNum;
	protected:
	EndpointIdentifier * m_endpointIdentifier;
	public:
	ArrayOf_AliasAddress m_destinationInfo;
	protected:
	NonStandardParameter * m_nonStandardData;
	public:
	TransportAddress m_replyAddress;
	protected:
	ArrayOf_AliasAddress * m_sourceInfo;
	Asn :: Boolean * m_canMapAlias;
	GatekeeperIdentifier * m_gatekeeperIdentifier;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ICV * m_integrityCheckValue;
	ArrayOf_SupportedProtocols * m_desiredProtocols;
	TunnelledProtocol * m_desiredTunnelledProtocol;
	FeatureSet * m_featureSet;
	ArrayOf_GenericData * m_genericData;
	LocationRequest_hopCount * m_hopCount;
	CircuitInfo * m_circuitInfo;
	CallIdentifier * m_callIdentifier;
	BandWidth * m_bandWidth;
	ArrayOf_AliasAddress * m_sourceEndpointInfo;
	Asn :: Boolean * m_canMapSrcAlias;
	LocationRequest_language * m_language;
	public:
	void encode ( Asn :: ostream & os ) const;
	~LocationRequest ( );
	void printOn ( std :: ostream & os ) const;
	const EndpointIdentifier & get_endpointIdentifier ( ) const {
		return * m_endpointIdentifier;
	}
	EndpointIdentifier & get_endpointIdentifier ( ) {
		return * m_endpointIdentifier;
	}
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const ArrayOf_AliasAddress & get_sourceInfo ( ) const {
		return * m_sourceInfo;
	}
	ArrayOf_AliasAddress & get_sourceInfo ( ) {
		return * m_sourceInfo;
	}
	const Asn :: Boolean & get_canMapAlias ( ) const {
		return * m_canMapAlias;
	}
	Asn :: Boolean & get_canMapAlias ( ) {
		return * m_canMapAlias;
	}
	const GatekeeperIdentifier & get_gatekeeperIdentifier ( ) const {
		return * m_gatekeeperIdentifier;
	}
	GatekeeperIdentifier & get_gatekeeperIdentifier ( ) {
		return * m_gatekeeperIdentifier;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ICV & get_integrityCheckValue ( ) const {
		return * m_integrityCheckValue;
	}
	ICV & get_integrityCheckValue ( ) {
		return * m_integrityCheckValue;
	}
	const ArrayOf_SupportedProtocols & get_desiredProtocols ( ) const {
		return * m_desiredProtocols;
	}
	ArrayOf_SupportedProtocols & get_desiredProtocols ( ) {
		return * m_desiredProtocols;
	}
	const TunnelledProtocol & get_desiredTunnelledProtocol ( ) const {
		return * m_desiredTunnelledProtocol;
	}
	TunnelledProtocol & get_desiredTunnelledProtocol ( ) {
		return * m_desiredTunnelledProtocol;
	}
	const FeatureSet & get_featureSet ( ) const {
		return * m_featureSet;
	}
	FeatureSet & get_featureSet ( ) {
		return * m_featureSet;
	}
	const ArrayOf_GenericData & get_genericData ( ) const {
		return * m_genericData;
	}
	ArrayOf_GenericData & get_genericData ( ) {
		return * m_genericData;
	}
	const LocationRequest_hopCount & get_hopCount ( ) const {
		return * m_hopCount;
	}
	LocationRequest_hopCount & get_hopCount ( ) {
		return * m_hopCount;
	}
	const CircuitInfo & get_circuitInfo ( ) const {
		return * m_circuitInfo;
	}
	CircuitInfo & get_circuitInfo ( ) {
		return * m_circuitInfo;
	}
	const CallIdentifier & get_callIdentifier ( ) const {
		return * m_callIdentifier;
	}
	CallIdentifier & get_callIdentifier ( ) {
		return * m_callIdentifier;
	}
	const BandWidth & get_bandWidth ( ) const {
		return * m_bandWidth;
	}
	BandWidth & get_bandWidth ( ) {
		return * m_bandWidth;
	}
	const ArrayOf_AliasAddress & get_sourceEndpointInfo ( ) const {
		return * m_sourceEndpointInfo;
	}
	ArrayOf_AliasAddress & get_sourceEndpointInfo ( ) {
		return * m_sourceEndpointInfo;
	}
	const Asn :: Boolean & get_canMapSrcAlias ( ) const {
		return * m_canMapSrcAlias;
	}
	Asn :: Boolean & get_canMapSrcAlias ( ) {
		return * m_canMapSrcAlias;
	}
	const LocationRequest_language & get_language ( ) const {
		return * m_language;
	}
	LocationRequest_language & get_language ( ) {
		return * m_language;
	}
	LocationRequest * clone ( ) const;
};

//
// LocationConfirm
//

// from 0 size 0 type 0 simple 0
class LocationConfirm : public Asn :: Sequence {
	public:
	explicit LocationConfirm ( Asn :: istream & is );
	LocationConfirm ( );
	enum OptionalFields {
		e_nonStandardData,
		e_destinationInfo,
		e_destExtraCallInfo,
		e_destinationType,
		e_remoteExtensionAddress,
		e_alternateEndpoints,
		e_tokens,
		e_cryptoTokens,
		e_integrityCheckValue,
		e_alternateTransportAddresses,
		e_supportedProtocols,
		e_multipleCalls,
		e_featureSet,
		e_genericData,
		e_circuitInfo,
		e_serviceControl,
		e_modifiedSrcInfo,
		e_bandWidth
	};

	LocationConfirm ( const LocationConfirm & s );
	LocationConfirm & operator= ( const LocationConfirm & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	RequestSeqNum m_requestSeqNum;
	TransportAddress m_callSignalAddress;
	TransportAddress m_rasAddress;
	protected:
	NonStandardParameter * m_nonStandardData;
	ArrayOf_AliasAddress * m_destinationInfo;
	ArrayOf_AliasAddress * m_destExtraCallInfo;
	EndpointType * m_destinationType;
	ArrayOf_AliasAddress * m_remoteExtensionAddress;
	ArrayOf_Endpoint * m_alternateEndpoints;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ICV * m_integrityCheckValue;
	AlternateTransportAddresses * m_alternateTransportAddresses;
	ArrayOf_SupportedProtocols * m_supportedProtocols;
	Asn :: Boolean * m_multipleCalls;
	FeatureSet * m_featureSet;
	ArrayOf_GenericData * m_genericData;
	CircuitInfo * m_circuitInfo;
	ArrayOf_ServiceControlSession * m_serviceControl;
	ArrayOf_AliasAddress * m_modifiedSrcInfo;
	BandWidth * m_bandWidth;
	public:
	void encode ( Asn :: ostream & os ) const;
	~LocationConfirm ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const ArrayOf_AliasAddress & get_destinationInfo ( ) const {
		return * m_destinationInfo;
	}
	ArrayOf_AliasAddress & get_destinationInfo ( ) {
		return * m_destinationInfo;
	}
	const ArrayOf_AliasAddress & get_destExtraCallInfo ( ) const {
		return * m_destExtraCallInfo;
	}
	ArrayOf_AliasAddress & get_destExtraCallInfo ( ) {
		return * m_destExtraCallInfo;
	}
	const EndpointType & get_destinationType ( ) const {
		return * m_destinationType;
	}
	EndpointType & get_destinationType ( ) {
		return * m_destinationType;
	}
	const ArrayOf_AliasAddress & get_remoteExtensionAddress ( ) const {
		return * m_remoteExtensionAddress;
	}
	ArrayOf_AliasAddress & get_remoteExtensionAddress ( ) {
		return * m_remoteExtensionAddress;
	}
	const ArrayOf_Endpoint & get_alternateEndpoints ( ) const {
		return * m_alternateEndpoints;
	}
	ArrayOf_Endpoint & get_alternateEndpoints ( ) {
		return * m_alternateEndpoints;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ICV & get_integrityCheckValue ( ) const {
		return * m_integrityCheckValue;
	}
	ICV & get_integrityCheckValue ( ) {
		return * m_integrityCheckValue;
	}
	const AlternateTransportAddresses & get_alternateTransportAddresses ( ) const {
		return * m_alternateTransportAddresses;
	}
	AlternateTransportAddresses & get_alternateTransportAddresses ( ) {
		return * m_alternateTransportAddresses;
	}
	const ArrayOf_SupportedProtocols & get_supportedProtocols ( ) const {
		return * m_supportedProtocols;
	}
	ArrayOf_SupportedProtocols & get_supportedProtocols ( ) {
		return * m_supportedProtocols;
	}
	const Asn :: Boolean & get_multipleCalls ( ) const {
		return * m_multipleCalls;
	}
	Asn :: Boolean & get_multipleCalls ( ) {
		return * m_multipleCalls;
	}
	const FeatureSet & get_featureSet ( ) const {
		return * m_featureSet;
	}
	FeatureSet & get_featureSet ( ) {
		return * m_featureSet;
	}
	const ArrayOf_GenericData & get_genericData ( ) const {
		return * m_genericData;
	}
	ArrayOf_GenericData & get_genericData ( ) {
		return * m_genericData;
	}
	const CircuitInfo & get_circuitInfo ( ) const {
		return * m_circuitInfo;
	}
	CircuitInfo & get_circuitInfo ( ) {
		return * m_circuitInfo;
	}
	const ArrayOf_ServiceControlSession & get_serviceControl ( ) const {
		return * m_serviceControl;
	}
	ArrayOf_ServiceControlSession & get_serviceControl ( ) {
		return * m_serviceControl;
	}
	const ArrayOf_AliasAddress & get_modifiedSrcInfo ( ) const {
		return * m_modifiedSrcInfo;
	}
	ArrayOf_AliasAddress & get_modifiedSrcInfo ( ) {
		return * m_modifiedSrcInfo;
	}
	const BandWidth & get_bandWidth ( ) const {
		return * m_bandWidth;
	}
	BandWidth & get_bandWidth ( ) {
		return * m_bandWidth;
	}
	LocationConfirm * clone ( ) const;
};

//
// InfoRequestResponse
//

// from 0 size 0 type 0 simple 0
class InfoRequestResponse : public Asn :: Sequence {
	public:
	explicit InfoRequestResponse ( Asn :: istream & is );
	InfoRequestResponse ( );
	enum OptionalFields {
		e_nonStandardData,
		e_endpointAlias,
		e_perCallInfo,
		e_tokens,
		e_cryptoTokens,
		e_integrityCheckValue,
		e_needResponse,
		e_capacity,
		e_irrStatus,
		e_unsolicited,
		e_genericData
	};

	InfoRequestResponse ( const InfoRequestResponse & s );
	InfoRequestResponse & operator= ( const InfoRequestResponse & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	NonStandardParameter * m_nonStandardData;
	public:
	RequestSeqNum m_requestSeqNum;
	EndpointType m_endpointType;
	EndpointIdentifier m_endpointIdentifier;
	TransportAddress m_rasAddress;
	ArrayOf_TransportAddress m_callSignalAddress;
	protected:
	ArrayOf_AliasAddress * m_endpointAlias;
	InfoRequestResponse_perCallInfo * m_perCallInfo;
	ArrayOf_ClearToken * m_tokens;
	ArrayOf_CryptoH323Token * m_cryptoTokens;
	ICV * m_integrityCheckValue;
	Asn :: Boolean * m_needResponse;
	CallCapacity * m_capacity;
	InfoRequestResponseStatus * m_irrStatus;
	Asn :: Boolean * m_unsolicited;
	ArrayOf_GenericData * m_genericData;
	public:
	void encode ( Asn :: ostream & os ) const;
	~InfoRequestResponse ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	const ArrayOf_AliasAddress & get_endpointAlias ( ) const {
		return * m_endpointAlias;
	}
	ArrayOf_AliasAddress & get_endpointAlias ( ) {
		return * m_endpointAlias;
	}
	const InfoRequestResponse_perCallInfo & get_perCallInfo ( ) const {
		return * m_perCallInfo;
	}
	InfoRequestResponse_perCallInfo & get_perCallInfo ( ) {
		return * m_perCallInfo;
	}
	const ArrayOf_ClearToken & get_tokens ( ) const {
		return * m_tokens;
	}
	ArrayOf_ClearToken & get_tokens ( ) {
		return * m_tokens;
	}
	const ArrayOf_CryptoH323Token & get_cryptoTokens ( ) const {
		return * m_cryptoTokens;
	}
	ArrayOf_CryptoH323Token & get_cryptoTokens ( ) {
		return * m_cryptoTokens;
	}
	const ICV & get_integrityCheckValue ( ) const {
		return * m_integrityCheckValue;
	}
	ICV & get_integrityCheckValue ( ) {
		return * m_integrityCheckValue;
	}
	const Asn :: Boolean & get_needResponse ( ) const {
		return * m_needResponse;
	}
	Asn :: Boolean & get_needResponse ( ) {
		return * m_needResponse;
	}
	const CallCapacity & get_capacity ( ) const {
		return * m_capacity;
	}
	CallCapacity & get_capacity ( ) {
		return * m_capacity;
	}
	const InfoRequestResponseStatus & get_irrStatus ( ) const {
		return * m_irrStatus;
	}
	InfoRequestResponseStatus & get_irrStatus ( ) {
		return * m_irrStatus;
	}
	const Asn :: Boolean & get_unsolicited ( ) const {
		return * m_unsolicited;
	}
	Asn :: Boolean & get_unsolicited ( ) {
		return * m_unsolicited;
	}
	const ArrayOf_GenericData & get_genericData ( ) const {
		return * m_genericData;
	}
	ArrayOf_GenericData & get_genericData ( ) {
		return * m_genericData;
	}
	InfoRequestResponse * clone ( ) const;
};

//
// AliasAddress
//

// from 0 size 0 type 0 simple 0
class AliasAddress : public Asn :: Choice {
	public:
	explicit AliasAddress ( Asn :: istream & is );
	AliasAddress ( );
	enum Choices {
		e_dialedDigits,
		e_h323_ID,
		e_url_ID,
		e_transportID,
		e_email_ID,
		e_partyNumber,
		e_mobileUIM,
		e_isupNumber
	};

	operator AliasAddress_dialedDigits & ( ) { return dynamic_cast < AliasAddress_dialedDigits & > ( * choice ); }
	operator const AliasAddress_dialedDigits & ( ) const { return dynamic_cast < const AliasAddress_dialedDigits & > ( * choice ); }
	operator AliasAddress_h323_ID & ( ) { return dynamic_cast < AliasAddress_h323_ID & > ( * choice ); }
	operator const AliasAddress_h323_ID & ( ) const { return dynamic_cast < const AliasAddress_h323_ID & > ( * choice ); }
	operator AliasAddress_url_ID & ( ) { return dynamic_cast < AliasAddress_url_ID & > ( * choice ); }
	operator const AliasAddress_url_ID & ( ) const { return dynamic_cast < const AliasAddress_url_ID & > ( * choice ); }
	operator TransportAddress & ( ) { return dynamic_cast < TransportAddress & > ( * choice ); }
	operator const TransportAddress & ( ) const { return dynamic_cast < const TransportAddress & > ( * choice ); }
	operator AliasAddress_email_ID & ( ) { return dynamic_cast < AliasAddress_email_ID & > ( * choice ); }
	operator const AliasAddress_email_ID & ( ) const { return dynamic_cast < const AliasAddress_email_ID & > ( * choice ); }
	operator PartyNumber & ( ) { return dynamic_cast < PartyNumber & > ( * choice ); }
	operator const PartyNumber & ( ) const { return dynamic_cast < const PartyNumber & > ( * choice ); }
	operator MobileUIM & ( ) { return dynamic_cast < MobileUIM & > ( * choice ); }
	operator const MobileUIM & ( ) const { return dynamic_cast < const MobileUIM & > ( * choice ); }
	operator IsupNumber & ( ) { return dynamic_cast < IsupNumber & > ( * choice ); }
	operator const IsupNumber & ( ) const { return dynamic_cast < const IsupNumber & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	AliasAddress * clone ( ) const;
};

//
// AddressPattern
//

// from 0 size 0 type 0 simple 0
class AddressPattern : public Asn :: Choice {
	public:
	explicit AddressPattern ( Asn :: istream & is );
	AddressPattern ( );
	enum Choices {
		e_wildcard,
		e_range
	};

	operator AliasAddress & ( ) { return dynamic_cast < AliasAddress & > ( * choice ); }
	operator const AliasAddress & ( ) const { return dynamic_cast < const AliasAddress & > ( * choice ); }
	operator AddressPattern_range & ( ) { return dynamic_cast < AddressPattern_range & > ( * choice ); }
	operator const AddressPattern_range & ( ) const { return dynamic_cast < const AddressPattern_range & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	AddressPattern * clone ( ) const;
};

//
// ExtendedAliasAddress
//

// from 0 size 0 type 0 simple 0
class ExtendedAliasAddress : public Asn :: Sequence {
	public:
	explicit ExtendedAliasAddress ( Asn :: istream & is );
	ExtendedAliasAddress ( );
	enum OptionalFields {
		e_presentationIndicator,
		e_screeningIndicator
	};

	ExtendedAliasAddress ( const ExtendedAliasAddress & s );
	ExtendedAliasAddress & operator= ( const ExtendedAliasAddress & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	AliasAddress m_address;
	protected:
	PresentationIndicator * m_presentationIndicator;
	ScreeningIndicator * m_screeningIndicator;
	public:
	void encode ( Asn :: ostream & os ) const;
	~ExtendedAliasAddress ( );
	void printOn ( std :: ostream & os ) const;
	const PresentationIndicator & get_presentationIndicator ( ) const {
		return * m_presentationIndicator;
	}
	PresentationIndicator & get_presentationIndicator ( ) {
		return * m_presentationIndicator;
	}
	const ScreeningIndicator & get_screeningIndicator ( ) const {
		return * m_screeningIndicator;
	}
	ScreeningIndicator & get_screeningIndicator ( ) {
		return * m_screeningIndicator;
	}
	ExtendedAliasAddress * clone ( ) const;
};

//
// SupportedPrefix
//

// from 0 size 0 type 0 simple 0
class SupportedPrefix : public Asn :: Sequence {
	public:
	explicit SupportedPrefix ( Asn :: istream & is );
	SupportedPrefix ( );
	enum OptionalFields {
		e_nonStandardData
	};

	SupportedPrefix ( const SupportedPrefix & s );
	SupportedPrefix & operator= ( const SupportedPrefix & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	NonStandardParameter * m_nonStandardData;
	public:
	AliasAddress m_prefix;
	void encode ( Asn :: ostream & os ) const;
	~SupportedPrefix ( );
	void printOn ( std :: ostream & os ) const;
	const NonStandardParameter & get_nonStandardData ( ) const {
		return * m_nonStandardData;
	}
	NonStandardParameter & get_nonStandardData ( ) {
		return * m_nonStandardData;
	}
	SupportedPrefix * clone ( ) const;
};

//
// Content
//

// from 0 size 0 type 0 simple 0
class Content : public Asn :: Choice {
	public:
	explicit Content ( Asn :: istream & is );
	Content ( );
	enum Choices {
		e_raw,
		e_text,
		e_unicode,
		e_bool,
		e_number8,
		e_number16,
		e_number32,
		e_id,
		e_alias,
		e_transport,
		e_compound,
		e_nested
	};

	operator Content_number8 & ( ) { return dynamic_cast < Content_number8 & > ( * choice ); }
	operator const Content_number8 & ( ) const { return dynamic_cast < const Content_number8 & > ( * choice ); }
	operator Content_number16 & ( ) { return dynamic_cast < Content_number16 & > ( * choice ); }
	operator const Content_number16 & ( ) const { return dynamic_cast < const Content_number16 & > ( * choice ); }
	operator Content_number32 & ( ) { return dynamic_cast < Content_number32 & > ( * choice ); }
	operator const Content_number32 & ( ) const { return dynamic_cast < const Content_number32 & > ( * choice ); }
	operator GenericIdentifier & ( ) { return dynamic_cast < GenericIdentifier & > ( * choice ); }
	operator const GenericIdentifier & ( ) const { return dynamic_cast < const GenericIdentifier & > ( * choice ); }
	operator AliasAddress & ( ) { return dynamic_cast < AliasAddress & > ( * choice ); }
	operator const AliasAddress & ( ) const { return dynamic_cast < const AliasAddress & > ( * choice ); }
	operator TransportAddress & ( ) { return dynamic_cast < TransportAddress & > ( * choice ); }
	operator const TransportAddress & ( ) const { return dynamic_cast < const TransportAddress & > ( * choice ); }
	operator Content_compound & ( ) { return dynamic_cast < Content_compound & > ( * choice ); }
	operator const Content_compound & ( ) const { return dynamic_cast < const Content_compound & > ( * choice ); }
	operator Content_nested & ( ) { return dynamic_cast < Content_nested & > ( * choice ); }
	operator const Content_nested & ( ) const { return dynamic_cast < const Content_nested & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	Content * clone ( ) const;
};

//
// RasMessage
//

// from 0 size 0 type 0 simple 0
class RasMessage : public Asn :: Choice {
	public:
	explicit RasMessage ( Asn :: istream & is );
	RasMessage ( );
	enum Choices {
		e_gatekeeperRequest,
		e_gatekeeperConfirm,
		e_gatekeeperReject,
		e_registrationRequest,
		e_registrationConfirm,
		e_registrationReject,
		e_unregistrationRequest,
		e_unregistrationConfirm,
		e_unregistrationReject,
		e_admissionRequest,
		e_admissionConfirm,
		e_admissionReject,
		e_bandwidthRequest,
		e_bandwidthConfirm,
		e_bandwidthReject,
		e_disengageRequest,
		e_disengageConfirm,
		e_disengageReject,
		e_locationRequest,
		e_locationConfirm,
		e_locationReject,
		e_infoRequest,
		e_infoRequestResponse,
		e_nonStandardMessage,
		e_unknownMessageResponse,
		e_requestInProgress,
		e_resourcesAvailableIndicate,
		e_resourcesAvailableConfirm,
		e_infoRequestAck,
		e_infoRequestNak,
		e_serviceControlIndication,
		e_serviceControlResponse,
		e_admissionConfirmSequence
	};

	operator GatekeeperRequest & ( ) { return dynamic_cast < GatekeeperRequest & > ( * choice ); }
	operator const GatekeeperRequest & ( ) const { return dynamic_cast < const GatekeeperRequest & > ( * choice ); }
	operator GatekeeperConfirm & ( ) { return dynamic_cast < GatekeeperConfirm & > ( * choice ); }
	operator const GatekeeperConfirm & ( ) const { return dynamic_cast < const GatekeeperConfirm & > ( * choice ); }
	operator GatekeeperReject & ( ) { return dynamic_cast < GatekeeperReject & > ( * choice ); }
	operator const GatekeeperReject & ( ) const { return dynamic_cast < const GatekeeperReject & > ( * choice ); }
	operator RegistrationRequest & ( ) { return dynamic_cast < RegistrationRequest & > ( * choice ); }
	operator const RegistrationRequest & ( ) const { return dynamic_cast < const RegistrationRequest & > ( * choice ); }
	operator RegistrationConfirm & ( ) { return dynamic_cast < RegistrationConfirm & > ( * choice ); }
	operator const RegistrationConfirm & ( ) const { return dynamic_cast < const RegistrationConfirm & > ( * choice ); }
	operator RegistrationReject & ( ) { return dynamic_cast < RegistrationReject & > ( * choice ); }
	operator const RegistrationReject & ( ) const { return dynamic_cast < const RegistrationReject & > ( * choice ); }
	operator UnregistrationRequest & ( ) { return dynamic_cast < UnregistrationRequest & > ( * choice ); }
	operator const UnregistrationRequest & ( ) const { return dynamic_cast < const UnregistrationRequest & > ( * choice ); }
	operator UnregistrationConfirm & ( ) { return dynamic_cast < UnregistrationConfirm & > ( * choice ); }
	operator const UnregistrationConfirm & ( ) const { return dynamic_cast < const UnregistrationConfirm & > ( * choice ); }
	operator UnregistrationReject & ( ) { return dynamic_cast < UnregistrationReject & > ( * choice ); }
	operator const UnregistrationReject & ( ) const { return dynamic_cast < const UnregistrationReject & > ( * choice ); }
	operator AdmissionRequest & ( ) { return dynamic_cast < AdmissionRequest & > ( * choice ); }
	operator const AdmissionRequest & ( ) const { return dynamic_cast < const AdmissionRequest & > ( * choice ); }
	operator AdmissionConfirm & ( ) { return dynamic_cast < AdmissionConfirm & > ( * choice ); }
	operator const AdmissionConfirm & ( ) const { return dynamic_cast < const AdmissionConfirm & > ( * choice ); }
	operator AdmissionReject & ( ) { return dynamic_cast < AdmissionReject & > ( * choice ); }
	operator const AdmissionReject & ( ) const { return dynamic_cast < const AdmissionReject & > ( * choice ); }
	operator BandwidthRequest & ( ) { return dynamic_cast < BandwidthRequest & > ( * choice ); }
	operator const BandwidthRequest & ( ) const { return dynamic_cast < const BandwidthRequest & > ( * choice ); }
	operator BandwidthConfirm & ( ) { return dynamic_cast < BandwidthConfirm & > ( * choice ); }
	operator const BandwidthConfirm & ( ) const { return dynamic_cast < const BandwidthConfirm & > ( * choice ); }
	operator BandwidthReject & ( ) { return dynamic_cast < BandwidthReject & > ( * choice ); }
	operator const BandwidthReject & ( ) const { return dynamic_cast < const BandwidthReject & > ( * choice ); }
	operator DisengageRequest & ( ) { return dynamic_cast < DisengageRequest & > ( * choice ); }
	operator const DisengageRequest & ( ) const { return dynamic_cast < const DisengageRequest & > ( * choice ); }
	operator DisengageConfirm & ( ) { return dynamic_cast < DisengageConfirm & > ( * choice ); }
	operator const DisengageConfirm & ( ) const { return dynamic_cast < const DisengageConfirm & > ( * choice ); }
	operator DisengageReject & ( ) { return dynamic_cast < DisengageReject & > ( * choice ); }
	operator const DisengageReject & ( ) const { return dynamic_cast < const DisengageReject & > ( * choice ); }
	operator LocationRequest & ( ) { return dynamic_cast < LocationRequest & > ( * choice ); }
	operator const LocationRequest & ( ) const { return dynamic_cast < const LocationRequest & > ( * choice ); }
	operator LocationConfirm & ( ) { return dynamic_cast < LocationConfirm & > ( * choice ); }
	operator const LocationConfirm & ( ) const { return dynamic_cast < const LocationConfirm & > ( * choice ); }
	operator LocationReject & ( ) { return dynamic_cast < LocationReject & > ( * choice ); }
	operator const LocationReject & ( ) const { return dynamic_cast < const LocationReject & > ( * choice ); }
	operator InfoRequest & ( ) { return dynamic_cast < InfoRequest & > ( * choice ); }
	operator const InfoRequest & ( ) const { return dynamic_cast < const InfoRequest & > ( * choice ); }
	operator InfoRequestResponse & ( ) { return dynamic_cast < InfoRequestResponse & > ( * choice ); }
	operator const InfoRequestResponse & ( ) const { return dynamic_cast < const InfoRequestResponse & > ( * choice ); }
	operator NonStandardMessage & ( ) { return dynamic_cast < NonStandardMessage & > ( * choice ); }
	operator const NonStandardMessage & ( ) const { return dynamic_cast < const NonStandardMessage & > ( * choice ); }
	operator UnknownMessageResponse & ( ) { return dynamic_cast < UnknownMessageResponse & > ( * choice ); }
	operator const UnknownMessageResponse & ( ) const { return dynamic_cast < const UnknownMessageResponse & > ( * choice ); }
	operator RequestInProgress & ( ) { return dynamic_cast < RequestInProgress & > ( * choice ); }
	operator const RequestInProgress & ( ) const { return dynamic_cast < const RequestInProgress & > ( * choice ); }
	operator ResourcesAvailableIndicate & ( ) { return dynamic_cast < ResourcesAvailableIndicate & > ( * choice ); }
	operator const ResourcesAvailableIndicate & ( ) const { return dynamic_cast < const ResourcesAvailableIndicate & > ( * choice ); }
	operator ResourcesAvailableConfirm & ( ) { return dynamic_cast < ResourcesAvailableConfirm & > ( * choice ); }
	operator const ResourcesAvailableConfirm & ( ) const { return dynamic_cast < const ResourcesAvailableConfirm & > ( * choice ); }
	operator InfoRequestAck & ( ) { return dynamic_cast < InfoRequestAck & > ( * choice ); }
	operator const InfoRequestAck & ( ) const { return dynamic_cast < const InfoRequestAck & > ( * choice ); }
	operator InfoRequestNak & ( ) { return dynamic_cast < InfoRequestNak & > ( * choice ); }
	operator const InfoRequestNak & ( ) const { return dynamic_cast < const InfoRequestNak & > ( * choice ); }
	operator ServiceControlIndication & ( ) { return dynamic_cast < ServiceControlIndication & > ( * choice ); }
	operator const ServiceControlIndication & ( ) const { return dynamic_cast < const ServiceControlIndication & > ( * choice ); }
	operator ServiceControlResponse & ( ) { return dynamic_cast < ServiceControlResponse & > ( * choice ); }
	operator const ServiceControlResponse & ( ) const { return dynamic_cast < const ServiceControlResponse & > ( * choice ); }
	operator ArrayOf_AdmissionConfirm & ( ) { return dynamic_cast < ArrayOf_AdmissionConfirm & > ( * choice ); }
	operator const ArrayOf_AdmissionConfirm & ( ) const { return dynamic_cast < const ArrayOf_AdmissionConfirm & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	RasMessage * clone ( ) const;
};

//
// CryptoH323Token_cryptoEPPwdHash
//

// from 0 size 0 type 0 simple 0
class CryptoH323Token_cryptoEPPwdHash : public Asn :: Sequence {
	public:
	explicit CryptoH323Token_cryptoEPPwdHash ( Asn :: istream & is );
	CryptoH323Token_cryptoEPPwdHash ( );
	AliasAddress m_alias;
	H235 :: TimeStamp m_timeStamp;
	H235 :: HASHED < H235 :: EncodedPwdCertToken > m_token;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	CryptoH323Token_cryptoEPPwdHash * clone ( ) const;
};

//
// CryptoH323Token
//

// from 0 size 0 type 0 simple 0
class CryptoH323Token : public Asn :: Choice {
	public:
	explicit CryptoH323Token ( Asn :: istream & is );
	CryptoH323Token ( );
	enum Choices {
		e_cryptoEPPwdHash,
		e_cryptoGKPwdHash,
		e_cryptoEPPwdEncr,
		e_cryptoGKPwdEncr,
		e_cryptoEPCert,
		e_cryptoGKCert,
		e_cryptoFastStart,
		e_nestedcryptoToken
	};

	operator CryptoH323Token_cryptoEPPwdHash & ( ) { return dynamic_cast < CryptoH323Token_cryptoEPPwdHash & > ( * choice ); }
	operator const CryptoH323Token_cryptoEPPwdHash & ( ) const { return dynamic_cast < const CryptoH323Token_cryptoEPPwdHash & > ( * choice ); }
	operator CryptoH323Token_cryptoGKPwdHash & ( ) { return dynamic_cast < CryptoH323Token_cryptoGKPwdHash & > ( * choice ); }
	operator const CryptoH323Token_cryptoGKPwdHash & ( ) const { return dynamic_cast < const CryptoH323Token_cryptoGKPwdHash & > ( * choice ); }
	operator H235 :: ENCRYPTED < H235 :: EncodedPwdCertToken > & ( ) { return dynamic_cast < H235 :: ENCRYPTED < H235 :: EncodedPwdCertToken > & > ( * choice ); }
	operator const H235 :: ENCRYPTED < H235 :: EncodedPwdCertToken > & ( ) const { return dynamic_cast < const H235 :: ENCRYPTED < H235 :: EncodedPwdCertToken > & > ( * choice ); }
	operator H235 :: SIGNED < H235 :: EncodedPwdCertToken > & ( ) { return dynamic_cast < H235 :: SIGNED < H235 :: EncodedPwdCertToken > & > ( * choice ); }
	operator const H235 :: SIGNED < H235 :: EncodedPwdCertToken > & ( ) const { return dynamic_cast < const H235 :: SIGNED < H235 :: EncodedPwdCertToken > & > ( * choice ); }
	operator H235 :: SIGNED < EncodedFastStartToken > & ( ) { return dynamic_cast < H235 :: SIGNED < EncodedFastStartToken > & > ( * choice ); }
	operator const H235 :: SIGNED < EncodedFastStartToken > & ( ) const { return dynamic_cast < const H235 :: SIGNED < EncodedFastStartToken > & > ( * choice ); }
	operator H235 :: CryptoToken & ( ) { return dynamic_cast < H235 :: CryptoToken & > ( * choice ); }
	operator const H235 :: CryptoToken & ( ) const { return dynamic_cast < const H235 :: CryptoToken & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	CryptoH323Token * clone ( ) const;
};

};

#endif // __H225_HPP


// End of h225.hpp
