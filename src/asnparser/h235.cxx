//
// h235.cxx
//
// Code automatically generated by asnparse.
//

#ifdef __GNUC__
#pragma implementation "h235.hpp"
#endif

#include "ss.hpp"
#include "allocatable.hpp"
#include <stdexcept>
#include <iomanip>
#include <limits>
#include <cstring>
#include "asn.hpp"

#include "h235.hpp"


#include "h235_t.cxx"

using namespace H235;

//
// ChallengeString
//

ChallengeString :: ChallengeString ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 8, 128 ) { }

ChallengeString :: ChallengeString ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 8, 128 ) { }

ChallengeString * ChallengeString :: clone ( ) const {
	return new ChallengeString ( * this );
}

//
// TimeStamp
//

TimeStamp :: TimeStamp ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 4294967295U ) { }

TimeStamp :: TimeStamp ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 4294967295U ) { }

TimeStamp * TimeStamp :: clone ( ) const {
	return new TimeStamp ( * this );
}

//
// RandomVal
//

RandomVal :: RandomVal ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

RandomVal :: RandomVal ( unsigned v ) : Asn :: Integer ( v, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

RandomVal * RandomVal :: clone ( ) const {
	return new RandomVal ( * this );
}

//
// Password
//

Password :: Password ( Asn :: istream & is ) : Asn :: BMPString ( is, Asn :: fixedConstraint, 1, 128 ) { }

Password :: Password ( const Asn :: string & v ) : Asn :: BMPString ( v, Asn :: fixedConstraint, 1, 128 ) { }

Password * Password :: clone ( ) const {
	return new Password ( * this );
}

//
// Identifier
//

Identifier :: Identifier ( Asn :: istream & is ) : Asn :: BMPString ( is, Asn :: fixedConstraint, 1, 128 ) { }

Identifier :: Identifier ( const Asn :: string & v ) : Asn :: BMPString ( v, Asn :: fixedConstraint, 1, 128 ) { }

Identifier * Identifier :: clone ( ) const {
	return new Identifier ( * this );
}

//
// KeyMaterial
//

KeyMaterial :: KeyMaterial ( Asn :: istream & is ) : Asn :: BitString ( is, Asn :: fixedConstraint, 1, 2048 ) { }

KeyMaterial :: KeyMaterial ( const Asn :: string & v, unsigned b ) : Asn :: BitString ( b ? : unsigned ( v.size ( ) * 8 ), v, Asn :: fixedConstraint, 1, 2048 ) {
}

KeyMaterial * KeyMaterial :: clone ( ) const {
	return new KeyMaterial ( * this );
}

//
// NonStandardParameter
//

NonStandardParameter :: NonStandardParameter ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, false, 0 ), m_nonStandardIdentifier ( is ), m_data ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) {
}

NonStandardParameter :: NonStandardParameter ( ) : Asn :: Sequence ( 0, false, 0 ) { }

void NonStandardParameter :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_nonStandardIdentifier.encode ( os );
	m_data.encode ( os );
}

void NonStandardParameter :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 24 ) << "nonStandardIdentifier = " << std :: setprecision ( indent ) << m_nonStandardIdentifier << '\n';
	os << std :: setw ( indent + 7 ) << "data = " << std :: setprecision ( indent ) << m_data << '\n';
	os << std :: setw ( indent - 1 ) << '}';
}

NonStandardParameter * NonStandardParameter :: clone ( ) const {
	return new NonStandardParameter ( * this );
}

//
// ECpoint
//

ECpoint :: ECpoint ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 0 ), m_x ( 0 ), m_y ( 0 ) {
	try {
		if ( hasOptionalField ( e_x ) )
			m_x = new ECpoint_x ( is );
		if ( hasOptionalField ( e_y ) )
			m_y = new ECpoint_y ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_x;
		delete m_y;
		throw;
	}
}

ECpoint :: ECpoint ( ) : Asn :: Sequence ( 2, true, 0 ), m_x ( 0 ), m_y ( 0 ) { }

ECpoint & ECpoint :: operator= ( const ECpoint & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_x, s.m_x );
	assignCopy ( m_y, s.m_y );
	return * this;
}

ECpoint :: ECpoint ( const ECpoint & s ) : Asn :: Sequence ( s ), m_x ( 0 ), m_y ( 0 ) {
	try {
		if ( s.m_x )
			m_x = new ECpoint_x ( * s.m_x );
		if ( s.m_y )
			m_y = new ECpoint_y ( * s.m_y );
	} catch ( ... ) {
		delete m_x;
		delete m_y;
		throw;
	}
}


void ECpoint :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_x:
			assignNew ( m_x, new ECpoint_x );
			break;
		case e_y:
			assignNew ( m_y, new ECpoint_y );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void ECpoint :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_x:
			delete m_x;
			m_x = 0;
			break;
		case e_y:
			delete m_y;
			m_y = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void ECpoint :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_x ) )
		m_x -> ECpoint_x :: encode ( os );
	if ( hasOptionalField ( e_y ) )
		m_y -> ECpoint_y :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

ECpoint :: ~ECpoint ( ) {
	delete m_x;
	delete m_y;
}

void ECpoint :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_x ) ) {
		os << std :: setw ( indent + 4 ) << "x = " << std :: setprecision ( indent );
		m_x -> ECpoint_x :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_y ) ) {
		os << std :: setw ( indent + 4 ) << "y = " << std :: setprecision ( indent );
		m_y -> ECpoint_y :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

ECpoint * ECpoint :: clone ( ) const {
	return new ECpoint ( * this );
}

//
// TypedCertificate
//

TypedCertificate :: TypedCertificate ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_type ( is ), m_certificate ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

TypedCertificate :: TypedCertificate ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void TypedCertificate :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_type.encode ( os );
	m_certificate.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void TypedCertificate :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 7 ) << "type = " << std :: setprecision ( indent ) << m_type << '\n';
	os << std :: setw ( indent + 14 ) << "certificate = " << std :: setprecision ( indent ) << m_certificate << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

TypedCertificate * TypedCertificate :: clone ( ) const {
	return new TypedCertificate ( * this );
}

//
// AuthenticationBES
//

AuthenticationBES :: AuthenticationBES ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_default:
		case e_radius:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

AuthenticationBES :: AuthenticationBES ( ) : Asn :: Choice ( 2, true ) { }

void AuthenticationBES :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_default:
		case e_radius:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & AuthenticationBES :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_default, "default" },
		{ e_radius, "radius" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

AuthenticationBES * AuthenticationBES :: clone ( ) const {
	return new AuthenticationBES ( * this );
}

//
// AuthenticationMechanism
//

AuthenticationMechanism :: AuthenticationMechanism ( Asn :: istream & is ) : Asn :: Choice ( is, 7, true ) {
	switch ( tag ) {
		case e_dhExch:
		case e_pwdSymEnc:
		case e_pwdHash:
		case e_certSign:
		case e_ipsec:
		case e_tls:
			choice = new Asn :: Null ( is );
			break;
		case e_nonStandard:
			choice = new NonStandardParameter ( is );
			break;
		case e_authenticationBES:
			choice = new AuthenticationBES ( is );
			break;
		case e_keyExch:
			choice = new Asn :: ObjectId ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

AuthenticationMechanism :: AuthenticationMechanism ( ) : Asn :: Choice ( 7, true ) { }

void AuthenticationMechanism :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_dhExch:
		case e_pwdSymEnc:
		case e_pwdHash:
		case e_certSign:
		case e_ipsec:
		case e_tls:
			o = new Asn :: Null;
			break;
		case e_nonStandard:
			o = new NonStandardParameter;
			break;
		case e_authenticationBES:
			o = new AuthenticationBES;
			break;
		case e_keyExch:
			o = new Asn :: ObjectId;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & AuthenticationMechanism :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_dhExch, "dhExch" },
		{ e_pwdSymEnc, "pwdSymEnc" },
		{ e_pwdHash, "pwdHash" },
		{ e_certSign, "certSign" },
		{ e_ipsec, "ipsec" },
		{ e_tls, "tls" },
		{ e_nonStandard, "nonStandard" },
		{ e_authenticationBES, "authenticationBES" },
		{ e_keyExch, "keyExch" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

AuthenticationMechanism * AuthenticationMechanism :: clone ( ) const {
	return new AuthenticationMechanism ( * this );
}

//
// ClearToken
//

ClearToken :: ClearToken ( Asn :: istream & is ) : Asn :: Sequence ( is, 8, true, 4 ), m_tokenOID ( is ), m_timeStamp ( 0 ), m_password ( 0 ), m_dhkey ( 0 ), m_challenge ( 0 ), m_random ( 0 ), m_certificate ( 0 ), m_generalID ( 0 ), m_nonStandard ( 0 ), m_eckasdhkey ( 0 ), m_sendersID ( 0 ), m_h235Key ( 0 ), m_profileInfo ( 0 ) {
	try {
		if ( hasOptionalField ( e_timeStamp ) )
			m_timeStamp = new TimeStamp ( is );
		if ( hasOptionalField ( e_password ) )
			m_password = new Password ( is );
		if ( hasOptionalField ( e_dhkey ) )
			m_dhkey = new DHset ( is );
		if ( hasOptionalField ( e_challenge ) )
			m_challenge = new ChallengeString ( is );
		if ( hasOptionalField ( e_random ) )
			m_random = new RandomVal ( is );
		if ( hasOptionalField ( e_certificate ) )
			m_certificate = new TypedCertificate ( is );
		if ( hasOptionalField ( e_generalID ) )
			m_generalID = new Identifier ( is );
		if ( hasOptionalField ( e_nonStandard ) )
			m_nonStandard = new NonStandardParameter ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_eckasdhkey ) )
				m_eckasdhkey = new ECKASDH ( is );
			if ( hasKnownExtensionToDecode ( is, e_sendersID ) )
				m_sendersID = new Identifier ( is );
			if ( hasKnownExtensionToDecode ( is, e_h235Key ) )
				m_h235Key = new H235Key ( is );
			if ( hasKnownExtensionToDecode ( is, e_profileInfo ) )
				m_profileInfo = new ArrayOf_ProfileElement ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_timeStamp;
		delete m_password;
		delete m_dhkey;
		delete m_challenge;
		delete m_random;
		delete m_certificate;
		delete m_generalID;
		delete m_nonStandard;
		delete m_eckasdhkey;
		delete m_sendersID;
		delete m_h235Key;
		delete m_profileInfo;
		throw;
	}
}

ClearToken :: ClearToken ( ) : Asn :: Sequence ( 8, true, 4 ), m_timeStamp ( 0 ), m_password ( 0 ), m_dhkey ( 0 ), m_challenge ( 0 ), m_random ( 0 ), m_certificate ( 0 ), m_generalID ( 0 ), m_nonStandard ( 0 ), m_eckasdhkey ( 0 ), m_sendersID ( 0 ), m_h235Key ( 0 ), m_profileInfo ( 0 ) { }

ClearToken & ClearToken :: operator= ( const ClearToken & s ) {
	Asn :: Sequence :: operator= ( s );
	m_tokenOID = s.m_tokenOID;
	assignCopy ( m_timeStamp, s.m_timeStamp );
	assignCopy ( m_password, s.m_password );
	assignCopy ( m_dhkey, s.m_dhkey );
	assignCopy ( m_challenge, s.m_challenge );
	assignCopy ( m_random, s.m_random );
	assignCopy ( m_certificate, s.m_certificate );
	assignCopy ( m_generalID, s.m_generalID );
	assignCopy ( m_nonStandard, s.m_nonStandard );
	assignCopy ( m_eckasdhkey, s.m_eckasdhkey );
	assignCopy ( m_sendersID, s.m_sendersID );
	assignCopy ( m_h235Key, s.m_h235Key );
	assignCopy ( m_profileInfo, s.m_profileInfo );
	return * this;
}

ClearToken :: ClearToken ( const ClearToken & s ) : Asn :: Sequence ( s ), m_tokenOID ( s.m_tokenOID ), m_timeStamp ( 0 ), m_password ( 0 ), m_dhkey ( 0 ), m_challenge ( 0 ), m_random ( 0 ), m_certificate ( 0 ), m_generalID ( 0 ), m_nonStandard ( 0 ), m_eckasdhkey ( 0 ), m_sendersID ( 0 ), m_h235Key ( 0 ), m_profileInfo ( 0 ) {
	try {
		if ( s.m_timeStamp )
			m_timeStamp = new TimeStamp ( * s.m_timeStamp );
		if ( s.m_password )
			m_password = new Password ( * s.m_password );
		if ( s.m_dhkey )
			m_dhkey = new DHset ( * s.m_dhkey );
		if ( s.m_challenge )
			m_challenge = new ChallengeString ( * s.m_challenge );
		if ( s.m_random )
			m_random = new RandomVal ( * s.m_random );
		if ( s.m_certificate )
			m_certificate = new TypedCertificate ( * s.m_certificate );
		if ( s.m_generalID )
			m_generalID = new Identifier ( * s.m_generalID );
		if ( s.m_nonStandard )
			m_nonStandard = new NonStandardParameter ( * s.m_nonStandard );
		if ( s.m_eckasdhkey )
			m_eckasdhkey = new ECKASDH ( * s.m_eckasdhkey );
		if ( s.m_sendersID )
			m_sendersID = new Identifier ( * s.m_sendersID );
		if ( s.m_h235Key )
			m_h235Key = new H235Key ( * s.m_h235Key );
		if ( s.m_profileInfo )
			m_profileInfo = new ArrayOf_ProfileElement ( * s.m_profileInfo );
	} catch ( ... ) {
		delete m_timeStamp;
		delete m_password;
		delete m_dhkey;
		delete m_challenge;
		delete m_random;
		delete m_certificate;
		delete m_generalID;
		delete m_nonStandard;
		delete m_eckasdhkey;
		delete m_sendersID;
		delete m_h235Key;
		delete m_profileInfo;
		throw;
	}
}


void ClearToken :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_timeStamp:
			assignNew ( m_timeStamp, new TimeStamp );
			break;
		case e_password:
			assignNew ( m_password, new Password );
			break;
		case e_dhkey:
			assignNew ( m_dhkey, new DHset );
			break;
		case e_challenge:
			assignNew ( m_challenge, new ChallengeString );
			break;
		case e_random:
			assignNew ( m_random, new RandomVal );
			break;
		case e_certificate:
			assignNew ( m_certificate, new TypedCertificate );
			break;
		case e_generalID:
			assignNew ( m_generalID, new Identifier );
			break;
		case e_nonStandard:
			assignNew ( m_nonStandard, new NonStandardParameter );
			break;
		case e_eckasdhkey:
			assignNew ( m_eckasdhkey, new ECKASDH );
			break;
		case e_sendersID:
			assignNew ( m_sendersID, new Identifier );
			break;
		case e_h235Key:
			assignNew ( m_h235Key, new H235Key );
			break;
		case e_profileInfo:
			assignNew ( m_profileInfo, new ArrayOf_ProfileElement );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void ClearToken :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_timeStamp:
			delete m_timeStamp;
			m_timeStamp = 0;
			break;
		case e_password:
			delete m_password;
			m_password = 0;
			break;
		case e_dhkey:
			delete m_dhkey;
			m_dhkey = 0;
			break;
		case e_challenge:
			delete m_challenge;
			m_challenge = 0;
			break;
		case e_random:
			delete m_random;
			m_random = 0;
			break;
		case e_certificate:
			delete m_certificate;
			m_certificate = 0;
			break;
		case e_generalID:
			delete m_generalID;
			m_generalID = 0;
			break;
		case e_nonStandard:
			delete m_nonStandard;
			m_nonStandard = 0;
			break;
		case e_eckasdhkey:
			delete m_eckasdhkey;
			m_eckasdhkey = 0;
			break;
		case e_sendersID:
			delete m_sendersID;
			m_sendersID = 0;
			break;
		case e_h235Key:
			delete m_h235Key;
			m_h235Key = 0;
			break;
		case e_profileInfo:
			delete m_profileInfo;
			m_profileInfo = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void ClearToken :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_tokenOID.encode ( os );
	if ( hasOptionalField ( e_timeStamp ) )
		m_timeStamp -> TimeStamp :: encode ( os );
	if ( hasOptionalField ( e_password ) )
		m_password -> Password :: encode ( os );
	if ( hasOptionalField ( e_dhkey ) )
		m_dhkey -> DHset :: encode ( os );
	if ( hasOptionalField ( e_challenge ) )
		m_challenge -> ChallengeString :: encode ( os );
	if ( hasOptionalField ( e_random ) )
		m_random -> RandomVal :: encode ( os );
	if ( hasOptionalField ( e_certificate ) )
		m_certificate -> TypedCertificate :: encode ( os );
	if ( hasOptionalField ( e_generalID ) )
		m_generalID -> Identifier :: encode ( os );
	if ( hasOptionalField ( e_nonStandard ) )
		m_nonStandard -> NonStandardParameter :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_eckasdhkey, m_eckasdhkey );
		knownExtensionEncode ( os, e_sendersID, m_sendersID );
		knownExtensionEncode ( os, e_h235Key, m_h235Key );
		knownExtensionEncode ( os, e_profileInfo, m_profileInfo );
		unknownExtensionsEncode ( os );
	}
}

ClearToken :: ~ClearToken ( ) {
	delete m_timeStamp;
	delete m_password;
	delete m_dhkey;
	delete m_challenge;
	delete m_random;
	delete m_certificate;
	delete m_generalID;
	delete m_nonStandard;
	delete m_eckasdhkey;
	delete m_sendersID;
	delete m_h235Key;
	delete m_profileInfo;
}

void ClearToken :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 11 ) << "tokenOID = " << std :: setprecision ( indent ) << m_tokenOID << '\n';
	if ( hasOptionalField ( e_timeStamp ) ) {
		os << std :: setw ( indent + 12 ) << "timeStamp = " << std :: setprecision ( indent );
		m_timeStamp -> TimeStamp :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_password ) ) {
		os << std :: setw ( indent + 11 ) << "password = " << std :: setprecision ( indent );
		m_password -> Password :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_dhkey ) ) {
		os << std :: setw ( indent + 8 ) << "dhkey = " << std :: setprecision ( indent );
		m_dhkey -> DHset :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_challenge ) ) {
		os << std :: setw ( indent + 12 ) << "challenge = " << std :: setprecision ( indent );
		m_challenge -> ChallengeString :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_random ) ) {
		os << std :: setw ( indent + 9 ) << "random = " << std :: setprecision ( indent );
		m_random -> RandomVal :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_certificate ) ) {
		os << std :: setw ( indent + 14 ) << "certificate = " << std :: setprecision ( indent );
		m_certificate -> TypedCertificate :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_generalID ) ) {
		os << std :: setw ( indent + 12 ) << "generalID = " << std :: setprecision ( indent );
		m_generalID -> Identifier :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_nonStandard ) ) {
		os << std :: setw ( indent + 14 ) << "nonStandard = " << std :: setprecision ( indent );
		m_nonStandard -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_eckasdhkey ) ) {
		os << std :: setw ( indent + 13 ) << "eckasdhkey = " << std :: setprecision ( indent );
		m_eckasdhkey -> ECKASDH :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_sendersID ) ) {
		os << std :: setw ( indent + 12 ) << "sendersID = " << std :: setprecision ( indent );
		m_sendersID -> Identifier :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_h235Key ) ) {
		os << std :: setw ( indent + 10 ) << "h235Key = " << std :: setprecision ( indent );
		m_h235Key -> H235Key :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_profileInfo ) ) {
		os << std :: setw ( indent + 14 ) << "profileInfo = " << std :: setprecision ( indent );
		m_profileInfo -> ArrayOf_ProfileElement :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

ClearToken * ClearToken :: clone ( ) const {
	return new ClearToken ( * this );
}

//
// Element
//

Element :: Element ( Asn :: istream & is ) : Asn :: Choice ( is, 5, true ) {
	switch ( tag ) {
		case e_octets:
			choice = new Asn :: OctetString ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) );
			break;
		case e_integer:
			choice = new Asn :: Integer ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) );
			break;
		case e_bits:
			choice = new Asn :: BitString ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) );
			break;
		case e_name:
			choice = new Asn :: BMPString ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) );
			break;
		case e_flag:
			choice = new Asn :: Boolean ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

Element :: Element ( ) : Asn :: Choice ( 5, true ) { }

void Element :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_octets:
			o = new Asn :: OctetString;
			break;
		case e_integer:
			o = new Asn :: Integer;
			break;
		case e_bits:
			o = new Asn :: BitString;
			break;
		case e_name:
			o = new Asn :: BMPString;
			break;
		case e_flag:
			o = new Asn :: Boolean;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & Element :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_octets, "octets" },
		{ e_integer, "integer" },
		{ e_bits, "bits" },
		{ e_name, "name" },
		{ e_flag, "flag" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

Element * Element :: clone ( ) const {
	return new Element ( * this );
}

//
// IV8
//

IV8 :: IV8 ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 8, 8 ) { }

IV8 :: IV8 ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 8, 8 ) { }

IV8 * IV8 :: clone ( ) const {
	return new IV8 ( * this );
}

//
// IV16
//

IV16 :: IV16 ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 16, 16 ) { }

IV16 :: IV16 ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 16, 16 ) { }

IV16 * IV16 :: clone ( ) const {
	return new IV16 ( * this );
}

//
// Params
//

Params :: Params ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 3 ), m_ranInt ( 0 ), m_iv8 ( 0 ), m_iv16 ( 0 ), m_iv ( 0 ), m_clearSalt ( 0 ) {
	try {
		if ( hasOptionalField ( e_ranInt ) )
			m_ranInt = new Asn :: Integer ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) );
		if ( hasOptionalField ( e_iv8 ) )
			m_iv8 = new IV8 ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_iv16 ) )
				m_iv16 = new IV16 ( is );
			if ( hasKnownExtensionToDecode ( is, e_iv ) )
				m_iv = new Asn :: OctetString ( is );
			if ( hasKnownExtensionToDecode ( is, e_clearSalt ) )
				m_clearSalt = new Asn :: OctetString ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_ranInt;
		delete m_iv8;
		delete m_iv16;
		delete m_iv;
		delete m_clearSalt;
		throw;
	}
}

Params :: Params ( ) : Asn :: Sequence ( 2, true, 3 ), m_ranInt ( 0 ), m_iv8 ( 0 ), m_iv16 ( 0 ), m_iv ( 0 ), m_clearSalt ( 0 ) { }

Params & Params :: operator= ( const Params & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_ranInt, s.m_ranInt );
	assignCopy ( m_iv8, s.m_iv8 );
	assignCopy ( m_iv16, s.m_iv16 );
	assignCopy ( m_iv, s.m_iv );
	assignCopy ( m_clearSalt, s.m_clearSalt );
	return * this;
}

Params :: Params ( const Params & s ) : Asn :: Sequence ( s ), m_ranInt ( 0 ), m_iv8 ( 0 ), m_iv16 ( 0 ), m_iv ( 0 ), m_clearSalt ( 0 ) {
	try {
		if ( s.m_ranInt )
			m_ranInt = new Asn :: Integer ( * s.m_ranInt );
		if ( s.m_iv8 )
			m_iv8 = new IV8 ( * s.m_iv8 );
		if ( s.m_iv16 )
			m_iv16 = new IV16 ( * s.m_iv16 );
		if ( s.m_iv )
			m_iv = new Asn :: OctetString ( * s.m_iv );
		if ( s.m_clearSalt )
			m_clearSalt = new Asn :: OctetString ( * s.m_clearSalt );
	} catch ( ... ) {
		delete m_ranInt;
		delete m_iv8;
		delete m_iv16;
		delete m_iv;
		delete m_clearSalt;
		throw;
	}
}


void Params :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_ranInt:
			assignNew ( m_ranInt, new Asn :: Integer );
			break;
		case e_iv8:
			assignNew ( m_iv8, new IV8 );
			break;
		case e_iv16:
			assignNew ( m_iv16, new IV16 );
			break;
		case e_iv:
			assignNew ( m_iv, new Asn :: OctetString );
			break;
		case e_clearSalt:
			assignNew ( m_clearSalt, new Asn :: OctetString );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void Params :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_ranInt:
			delete m_ranInt;
			m_ranInt = 0;
			break;
		case e_iv8:
			delete m_iv8;
			m_iv8 = 0;
			break;
		case e_iv16:
			delete m_iv16;
			m_iv16 = 0;
			break;
		case e_iv:
			delete m_iv;
			m_iv = 0;
			break;
		case e_clearSalt:
			delete m_clearSalt;
			m_clearSalt = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void Params :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_ranInt ) )
		m_ranInt -> Asn :: Integer :: encode ( os );
	if ( hasOptionalField ( e_iv8 ) )
		m_iv8 -> IV8 :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_iv16, m_iv16 );
		knownExtensionEncode ( os, e_iv, m_iv );
		knownExtensionEncode ( os, e_clearSalt, m_clearSalt );
		unknownExtensionsEncode ( os );
	}
}

Params :: ~Params ( ) {
	delete m_ranInt;
	delete m_iv8;
	delete m_iv16;
	delete m_iv;
	delete m_clearSalt;
}

void Params :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_ranInt ) ) {
		os << std :: setw ( indent + 9 ) << "ranInt = " << std :: setprecision ( indent );
		m_ranInt -> Asn :: Integer :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_iv8 ) ) {
		os << std :: setw ( indent + 6 ) << "iv8 = " << std :: setprecision ( indent );
		m_iv8 -> IV8 :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_iv16 ) ) {
		os << std :: setw ( indent + 7 ) << "iv16 = " << std :: setprecision ( indent );
		m_iv16 -> IV16 :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_iv ) ) {
		os << std :: setw ( indent + 5 ) << "iv = " << std :: setprecision ( indent );
		m_iv -> Asn :: OctetString :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_clearSalt ) ) {
		os << std :: setw ( indent + 12 ) << "clearSalt = " << std :: setprecision ( indent );
		m_clearSalt -> Asn :: OctetString :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

Params * Params :: clone ( ) const {
	return new Params ( * this );
}

//
// EncodedGeneralToken
//

EncodedGeneralToken :: EncodedGeneralToken ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

EncodedGeneralToken :: EncodedGeneralToken ( ) : Asn :: OctetString ( "", Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

EncodedGeneralToken * EncodedGeneralToken :: clone ( ) const {
	return new EncodedGeneralToken ( * this );
}

//
// PwdCertToken
//

PwdCertToken :: PwdCertToken ( Asn :: istream & is ) : ClearToken ( is ) { }

PwdCertToken :: PwdCertToken ( ) : ClearToken ( ) {
	includeOptionalField ( e_generalID );
	includeOptionalField ( e_timeStamp );
}

PwdCertToken * PwdCertToken :: clone ( ) const {
	return new PwdCertToken ( * this );
}

//
// EncodedPwdCertToken
//

EncodedPwdCertToken :: EncodedPwdCertToken ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

EncodedPwdCertToken :: EncodedPwdCertToken ( ) : Asn :: OctetString ( "", Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

EncodedPwdCertToken * EncodedPwdCertToken :: clone ( ) const {
	return new EncodedPwdCertToken ( * this );
}

//
// EncodedKeySignedMaterial
//

EncodedKeySignedMaterial :: EncodedKeySignedMaterial ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

EncodedKeySignedMaterial :: EncodedKeySignedMaterial ( ) : Asn :: OctetString ( "", Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

EncodedKeySignedMaterial * EncodedKeySignedMaterial :: clone ( ) const {
	return new EncodedKeySignedMaterial ( * this );
}

//
// ReturnSig
//

ReturnSig :: ReturnSig ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, false, 0 ), m_generalId ( is ), m_responseRandom ( is ), m_requestRandom ( 0 ), m_certificate ( 0 ) {
	try {
		if ( hasOptionalField ( e_requestRandom ) )
			m_requestRandom = new RandomVal ( is );
		if ( hasOptionalField ( e_certificate ) )
			m_certificate = new TypedCertificate ( is );
	} catch ( ... ) {
		delete m_requestRandom;
		delete m_certificate;
		throw;
	}
}

ReturnSig :: ReturnSig ( ) : Asn :: Sequence ( 2, false, 0 ), m_requestRandom ( 0 ), m_certificate ( 0 ) { }

ReturnSig & ReturnSig :: operator= ( const ReturnSig & s ) {
	Asn :: Sequence :: operator= ( s );
	m_generalId = s.m_generalId;
	m_responseRandom = s.m_responseRandom;
	assignCopy ( m_requestRandom, s.m_requestRandom );
	assignCopy ( m_certificate, s.m_certificate );
	return * this;
}

ReturnSig :: ReturnSig ( const ReturnSig & s ) : Asn :: Sequence ( s ), m_generalId ( s.m_generalId ), m_responseRandom ( s.m_responseRandom ), m_requestRandom ( 0 ), m_certificate ( 0 ) {
	try {
		if ( s.m_requestRandom )
			m_requestRandom = new RandomVal ( * s.m_requestRandom );
		if ( s.m_certificate )
			m_certificate = new TypedCertificate ( * s.m_certificate );
	} catch ( ... ) {
		delete m_requestRandom;
		delete m_certificate;
		throw;
	}
}


void ReturnSig :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_requestRandom:
			assignNew ( m_requestRandom, new RandomVal );
			break;
		case e_certificate:
			assignNew ( m_certificate, new TypedCertificate );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void ReturnSig :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_requestRandom:
			delete m_requestRandom;
			m_requestRandom = 0;
			break;
		case e_certificate:
			delete m_certificate;
			m_certificate = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void ReturnSig :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_generalId.encode ( os );
	m_responseRandom.encode ( os );
	if ( hasOptionalField ( e_requestRandom ) )
		m_requestRandom -> RandomVal :: encode ( os );
	if ( hasOptionalField ( e_certificate ) )
		m_certificate -> TypedCertificate :: encode ( os );
}

ReturnSig :: ~ReturnSig ( ) {
	delete m_requestRandom;
	delete m_certificate;
}

void ReturnSig :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 12 ) << "generalId = " << std :: setprecision ( indent ) << m_generalId << '\n';
	os << std :: setw ( indent + 17 ) << "responseRandom = " << std :: setprecision ( indent ) << m_responseRandom << '\n';
	if ( hasOptionalField ( e_requestRandom ) ) {
		os << std :: setw ( indent + 16 ) << "requestRandom = " << std :: setprecision ( indent );
		m_requestRandom -> RandomVal :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_certificate ) ) {
		os << std :: setw ( indent + 14 ) << "certificate = " << std :: setprecision ( indent );
		m_certificate -> TypedCertificate :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent - 1 ) << '}';
}

ReturnSig * ReturnSig :: clone ( ) const {
	return new ReturnSig ( * this );
}

//
// EncodedReturnSig
//

EncodedReturnSig :: EncodedReturnSig ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

EncodedReturnSig :: EncodedReturnSig ( ) : Asn :: OctetString ( "", Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

EncodedReturnSig * EncodedReturnSig :: clone ( ) const {
	return new EncodedReturnSig ( * this );
}

//
// KeySyncMaterial
//

KeySyncMaterial :: KeySyncMaterial ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_generalID ( is ), m_keyMaterial ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

KeySyncMaterial :: KeySyncMaterial ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void KeySyncMaterial :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_generalID.encode ( os );
	m_keyMaterial.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void KeySyncMaterial :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 12 ) << "generalID = " << std :: setprecision ( indent ) << m_generalID << '\n';
	os << std :: setw ( indent + 14 ) << "keyMaterial = " << std :: setprecision ( indent ) << m_keyMaterial << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

KeySyncMaterial * KeySyncMaterial :: clone ( ) const {
	return new KeySyncMaterial ( * this );
}

//
// EncodedKeySyncMaterial
//

EncodedKeySyncMaterial :: EncodedKeySyncMaterial ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

EncodedKeySyncMaterial :: EncodedKeySyncMaterial ( ) : Asn :: OctetString ( "", Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

EncodedKeySyncMaterial * EncodedKeySyncMaterial :: clone ( ) const {
	return new EncodedKeySyncMaterial ( * this );
}

//
// V3KeySyncMaterial
//

V3KeySyncMaterial :: V3KeySyncMaterial ( Asn :: istream & is ) : Asn :: Sequence ( is, 7, true, 1 ), m_generalID ( hasOptionalField ( e_generalID ) ? pushTemporaryMember ( new Identifier ( is ) ) : 0 ), m_algorithmOID ( hasOptionalField ( e_algorithmOID ) ? pushTemporaryMember ( new Asn :: ObjectId ( is ) ) : 0 ), m_paramS ( is ), m_encryptedSessionKey ( 0 ), m_encryptedSaltingKey ( 0 ), m_clearSaltingKey ( 0 ), m_paramSsalt ( 0 ), m_keyDerivationOID ( 0 ), m_genericKeyMaterial ( 0 ) {
	clearTemporaryMembers ( );
	try {
		if ( hasOptionalField ( e_encryptedSessionKey ) )
			m_encryptedSessionKey = new Asn :: OctetString ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) );
		if ( hasOptionalField ( e_encryptedSaltingKey ) )
			m_encryptedSaltingKey = new Asn :: OctetString ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) );
		if ( hasOptionalField ( e_clearSaltingKey ) )
			m_clearSaltingKey = new Asn :: OctetString ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) );
		if ( hasOptionalField ( e_paramSsalt ) )
			m_paramSsalt = new Params ( is );
		if ( hasOptionalField ( e_keyDerivationOID ) )
			m_keyDerivationOID = new Asn :: ObjectId ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_genericKeyMaterial ) )
				m_genericKeyMaterial = new Asn :: OctetString ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_generalID;
		delete m_algorithmOID;
		delete m_encryptedSessionKey;
		delete m_encryptedSaltingKey;
		delete m_clearSaltingKey;
		delete m_paramSsalt;
		delete m_keyDerivationOID;
		delete m_genericKeyMaterial;
		throw;
	}
}

V3KeySyncMaterial :: V3KeySyncMaterial ( ) : Asn :: Sequence ( 7, true, 1 ), m_generalID ( 0 ), m_algorithmOID ( 0 ), m_encryptedSessionKey ( 0 ), m_encryptedSaltingKey ( 0 ), m_clearSaltingKey ( 0 ), m_paramSsalt ( 0 ), m_keyDerivationOID ( 0 ), m_genericKeyMaterial ( 0 ) { }

V3KeySyncMaterial & V3KeySyncMaterial :: operator= ( const V3KeySyncMaterial & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_generalID, s.m_generalID );
	assignCopy ( m_algorithmOID, s.m_algorithmOID );
	m_paramS = s.m_paramS;
	assignCopy ( m_encryptedSessionKey, s.m_encryptedSessionKey );
	assignCopy ( m_encryptedSaltingKey, s.m_encryptedSaltingKey );
	assignCopy ( m_clearSaltingKey, s.m_clearSaltingKey );
	assignCopy ( m_paramSsalt, s.m_paramSsalt );
	assignCopy ( m_keyDerivationOID, s.m_keyDerivationOID );
	assignCopy ( m_genericKeyMaterial, s.m_genericKeyMaterial );
	return * this;
}

V3KeySyncMaterial :: V3KeySyncMaterial ( const V3KeySyncMaterial & s ) : Asn :: Sequence ( s ), m_generalID ( 0 ), m_algorithmOID ( 0 ), m_paramS ( s.m_paramS ), m_encryptedSessionKey ( 0 ), m_encryptedSaltingKey ( 0 ), m_clearSaltingKey ( 0 ), m_paramSsalt ( 0 ), m_keyDerivationOID ( 0 ), m_genericKeyMaterial ( 0 ) {
	try {
		if ( s.m_generalID )
			m_generalID = new Identifier ( * s.m_generalID );
		if ( s.m_algorithmOID )
			m_algorithmOID = new Asn :: ObjectId ( * s.m_algorithmOID );
		if ( s.m_encryptedSessionKey )
			m_encryptedSessionKey = new Asn :: OctetString ( * s.m_encryptedSessionKey );
		if ( s.m_encryptedSaltingKey )
			m_encryptedSaltingKey = new Asn :: OctetString ( * s.m_encryptedSaltingKey );
		if ( s.m_clearSaltingKey )
			m_clearSaltingKey = new Asn :: OctetString ( * s.m_clearSaltingKey );
		if ( s.m_paramSsalt )
			m_paramSsalt = new Params ( * s.m_paramSsalt );
		if ( s.m_keyDerivationOID )
			m_keyDerivationOID = new Asn :: ObjectId ( * s.m_keyDerivationOID );
		if ( s.m_genericKeyMaterial )
			m_genericKeyMaterial = new Asn :: OctetString ( * s.m_genericKeyMaterial );
	} catch ( ... ) {
		delete m_generalID;
		delete m_algorithmOID;
		delete m_encryptedSessionKey;
		delete m_encryptedSaltingKey;
		delete m_clearSaltingKey;
		delete m_paramSsalt;
		delete m_keyDerivationOID;
		delete m_genericKeyMaterial;
		throw;
	}
}


void V3KeySyncMaterial :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_generalID:
			assignNew ( m_generalID, new Identifier );
			break;
		case e_algorithmOID:
			assignNew ( m_algorithmOID, new Asn :: ObjectId );
			break;
		case e_encryptedSessionKey:
			assignNew ( m_encryptedSessionKey, new Asn :: OctetString );
			break;
		case e_encryptedSaltingKey:
			assignNew ( m_encryptedSaltingKey, new Asn :: OctetString );
			break;
		case e_clearSaltingKey:
			assignNew ( m_clearSaltingKey, new Asn :: OctetString );
			break;
		case e_paramSsalt:
			assignNew ( m_paramSsalt, new Params );
			break;
		case e_keyDerivationOID:
			assignNew ( m_keyDerivationOID, new Asn :: ObjectId );
			break;
		case e_genericKeyMaterial:
			assignNew ( m_genericKeyMaterial, new Asn :: OctetString );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void V3KeySyncMaterial :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_generalID:
			delete m_generalID;
			m_generalID = 0;
			break;
		case e_algorithmOID:
			delete m_algorithmOID;
			m_algorithmOID = 0;
			break;
		case e_encryptedSessionKey:
			delete m_encryptedSessionKey;
			m_encryptedSessionKey = 0;
			break;
		case e_encryptedSaltingKey:
			delete m_encryptedSaltingKey;
			m_encryptedSaltingKey = 0;
			break;
		case e_clearSaltingKey:
			delete m_clearSaltingKey;
			m_clearSaltingKey = 0;
			break;
		case e_paramSsalt:
			delete m_paramSsalt;
			m_paramSsalt = 0;
			break;
		case e_keyDerivationOID:
			delete m_keyDerivationOID;
			m_keyDerivationOID = 0;
			break;
		case e_genericKeyMaterial:
			delete m_genericKeyMaterial;
			m_genericKeyMaterial = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void V3KeySyncMaterial :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_generalID ) )
		m_generalID -> Identifier :: encode ( os );
	if ( hasOptionalField ( e_algorithmOID ) )
		m_algorithmOID -> Asn :: ObjectId :: encode ( os );
	m_paramS.encode ( os );
	if ( hasOptionalField ( e_encryptedSessionKey ) )
		m_encryptedSessionKey -> Asn :: OctetString :: encode ( os );
	if ( hasOptionalField ( e_encryptedSaltingKey ) )
		m_encryptedSaltingKey -> Asn :: OctetString :: encode ( os );
	if ( hasOptionalField ( e_clearSaltingKey ) )
		m_clearSaltingKey -> Asn :: OctetString :: encode ( os );
	if ( hasOptionalField ( e_paramSsalt ) )
		m_paramSsalt -> Params :: encode ( os );
	if ( hasOptionalField ( e_keyDerivationOID ) )
		m_keyDerivationOID -> Asn :: ObjectId :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_genericKeyMaterial, m_genericKeyMaterial );
		unknownExtensionsEncode ( os );
	}
}

V3KeySyncMaterial :: ~V3KeySyncMaterial ( ) {
	delete m_generalID;
	delete m_algorithmOID;
	delete m_encryptedSessionKey;
	delete m_encryptedSaltingKey;
	delete m_clearSaltingKey;
	delete m_paramSsalt;
	delete m_keyDerivationOID;
	delete m_genericKeyMaterial;
}

void V3KeySyncMaterial :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_generalID ) ) {
		os << std :: setw ( indent + 12 ) << "generalID = " << std :: setprecision ( indent );
		m_generalID -> Identifier :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_algorithmOID ) ) {
		os << std :: setw ( indent + 15 ) << "algorithmOID = " << std :: setprecision ( indent );
		m_algorithmOID -> Asn :: ObjectId :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 9 ) << "paramS = " << std :: setprecision ( indent ) << m_paramS << '\n';
	if ( hasOptionalField ( e_encryptedSessionKey ) ) {
		os << std :: setw ( indent + 22 ) << "encryptedSessionKey = " << std :: setprecision ( indent );
		m_encryptedSessionKey -> Asn :: OctetString :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_encryptedSaltingKey ) ) {
		os << std :: setw ( indent + 22 ) << "encryptedSaltingKey = " << std :: setprecision ( indent );
		m_encryptedSaltingKey -> Asn :: OctetString :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_clearSaltingKey ) ) {
		os << std :: setw ( indent + 18 ) << "clearSaltingKey = " << std :: setprecision ( indent );
		m_clearSaltingKey -> Asn :: OctetString :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_paramSsalt ) ) {
		os << std :: setw ( indent + 13 ) << "paramSsalt = " << std :: setprecision ( indent );
		m_paramSsalt -> Params :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_keyDerivationOID ) ) {
		os << std :: setw ( indent + 19 ) << "keyDerivationOID = " << std :: setprecision ( indent );
		m_keyDerivationOID -> Asn :: ObjectId :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_genericKeyMaterial ) ) {
		os << std :: setw ( indent + 21 ) << "genericKeyMaterial = " << std :: setprecision ( indent );
		m_genericKeyMaterial -> Asn :: OctetString :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

V3KeySyncMaterial * V3KeySyncMaterial :: clone ( ) const {
	return new V3KeySyncMaterial ( * this );
}

//
// DHset_halfkey
//

DHset_halfkey :: DHset_halfkey ( Asn :: istream & is ) : Asn :: BitString ( is, Asn :: fixedConstraint, 0, 2048 ) { }

DHset_halfkey :: DHset_halfkey ( const Asn :: string & v, unsigned b ) : Asn :: BitString ( b ? : unsigned ( v.size ( ) * 8 ), v, Asn :: fixedConstraint, 0, 2048 ) {
}

DHset_halfkey * DHset_halfkey :: clone ( ) const {
	return new DHset_halfkey ( * this );
}

//
// DHset_modSize
//

DHset_modSize :: DHset_modSize ( Asn :: istream & is ) : Asn :: BitString ( is, Asn :: fixedConstraint, 0, 2048 ) { }

DHset_modSize :: DHset_modSize ( const Asn :: string & v, unsigned b ) : Asn :: BitString ( b ? : unsigned ( v.size ( ) * 8 ), v, Asn :: fixedConstraint, 0, 2048 ) {
}

DHset_modSize * DHset_modSize :: clone ( ) const {
	return new DHset_modSize ( * this );
}

//
// DHset_generator
//

DHset_generator :: DHset_generator ( Asn :: istream & is ) : Asn :: BitString ( is, Asn :: fixedConstraint, 0, 2048 ) { }

DHset_generator :: DHset_generator ( const Asn :: string & v, unsigned b ) : Asn :: BitString ( b ? : unsigned ( v.size ( ) * 8 ), v, Asn :: fixedConstraint, 0, 2048 ) {
}

DHset_generator * DHset_generator :: clone ( ) const {
	return new DHset_generator ( * this );
}

//
// ECpoint_x
//

ECpoint_x :: ECpoint_x ( Asn :: istream & is ) : Asn :: BitString ( is, Asn :: fixedConstraint, 0, 511 ) { }

ECpoint_x :: ECpoint_x ( const Asn :: string & v, unsigned b ) : Asn :: BitString ( b ? : unsigned ( v.size ( ) * 8 ), v, Asn :: fixedConstraint, 0, 511 ) {
}

ECpoint_x * ECpoint_x :: clone ( ) const {
	return new ECpoint_x ( * this );
}

//
// ECpoint_y
//

ECpoint_y :: ECpoint_y ( Asn :: istream & is ) : Asn :: BitString ( is, Asn :: fixedConstraint, 0, 511 ) { }

ECpoint_y :: ECpoint_y ( const Asn :: string & v, unsigned b ) : Asn :: BitString ( b ? : unsigned ( v.size ( ) * 8 ), v, Asn :: fixedConstraint, 0, 511 ) {
}

ECpoint_y * ECpoint_y :: clone ( ) const {
	return new ECpoint_y ( * this );
}

//
// ECGDSASignature_r
//

ECGDSASignature_r :: ECGDSASignature_r ( Asn :: istream & is ) : Asn :: BitString ( is, Asn :: fixedConstraint, 0, 511 ) { }

ECGDSASignature_r :: ECGDSASignature_r ( const Asn :: string & v, unsigned b ) : Asn :: BitString ( b ? : unsigned ( v.size ( ) * 8 ), v, Asn :: fixedConstraint, 0, 511 ) {
}

ECGDSASignature_r * ECGDSASignature_r :: clone ( ) const {
	return new ECGDSASignature_r ( * this );
}

//
// ECGDSASignature_s
//

ECGDSASignature_s :: ECGDSASignature_s ( Asn :: istream & is ) : Asn :: BitString ( is, Asn :: fixedConstraint, 0, 511 ) { }

ECGDSASignature_s :: ECGDSASignature_s ( const Asn :: string & v, unsigned b ) : Asn :: BitString ( b ? : unsigned ( v.size ( ) * 8 ), v, Asn :: fixedConstraint, 0, 511 ) {
}

ECGDSASignature_s * ECGDSASignature_s :: clone ( ) const {
	return new ECGDSASignature_s ( * this );
}

//
// ArrayOf_ProfileElement
//

ArrayOf_ProfileElement :: ArrayOf_ProfileElement ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_ProfileElement :: ArrayOf_ProfileElement ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_ProfileElement :: ArrayOf_ProfileElement ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_ProfileElement :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_ProfileElement :: createObject ( Asn :: istream & is ) {
	return new ProfileElement ( is );
}

Asn :: Object * ArrayOf_ProfileElement :: createObject ( ) {
	return new ProfileElement ( );
}

ProfileElement & ArrayOf_ProfileElement :: operator[] ( std :: size_t i ) {
	return dynamic_cast < ProfileElement & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_ProfileElement :: push_back ( const ProfileElement & o ) {
	Asn :: Array :: push_back ( new ProfileElement ( o ) );
}

const ProfileElement & ArrayOf_ProfileElement :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const ProfileElement & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_ProfileElement * ArrayOf_ProfileElement :: clone ( ) const {
	return new ArrayOf_ProfileElement ( * this );
}

//
// ProfileElement_elementID
//

ProfileElement_elementID :: ProfileElement_elementID ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 255 ) { }

ProfileElement_elementID :: ProfileElement_elementID ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 255 ) { }

ProfileElement_elementID * ProfileElement_elementID :: clone ( ) const {
	return new ProfileElement_elementID ( * this );
}

//
// ECKASDH_eckasdhp_modulus
//

ECKASDH_eckasdhp_modulus :: ECKASDH_eckasdhp_modulus ( Asn :: istream & is ) : Asn :: BitString ( is, Asn :: fixedConstraint, 0, 511 ) { }

ECKASDH_eckasdhp_modulus :: ECKASDH_eckasdhp_modulus ( const Asn :: string & v, unsigned b ) : Asn :: BitString ( b ? : unsigned ( v.size ( ) * 8 ), v, Asn :: fixedConstraint, 0, 511 ) {
}

ECKASDH_eckasdhp_modulus * ECKASDH_eckasdhp_modulus :: clone ( ) const {
	return new ECKASDH_eckasdhp_modulus ( * this );
}

//
// ECKASDH_eckasdhp_weierstrassA
//

ECKASDH_eckasdhp_weierstrassA :: ECKASDH_eckasdhp_weierstrassA ( Asn :: istream & is ) : Asn :: BitString ( is, Asn :: fixedConstraint, 0, 511 ) { }

ECKASDH_eckasdhp_weierstrassA :: ECKASDH_eckasdhp_weierstrassA ( const Asn :: string & v, unsigned b ) : Asn :: BitString ( b ? : unsigned ( v.size ( ) * 8 ), v, Asn :: fixedConstraint, 0, 511 ) {
}

ECKASDH_eckasdhp_weierstrassA * ECKASDH_eckasdhp_weierstrassA :: clone ( ) const {
	return new ECKASDH_eckasdhp_weierstrassA ( * this );
}

//
// ECKASDH_eckasdhp_weierstrassB
//

ECKASDH_eckasdhp_weierstrassB :: ECKASDH_eckasdhp_weierstrassB ( Asn :: istream & is ) : Asn :: BitString ( is, Asn :: fixedConstraint, 0, 511 ) { }

ECKASDH_eckasdhp_weierstrassB :: ECKASDH_eckasdhp_weierstrassB ( const Asn :: string & v, unsigned b ) : Asn :: BitString ( b ? : unsigned ( v.size ( ) * 8 ), v, Asn :: fixedConstraint, 0, 511 ) {
}

ECKASDH_eckasdhp_weierstrassB * ECKASDH_eckasdhp_weierstrassB :: clone ( ) const {
	return new ECKASDH_eckasdhp_weierstrassB ( * this );
}

//
// ECKASDH_eckasdh2_fieldSize
//

ECKASDH_eckasdh2_fieldSize :: ECKASDH_eckasdh2_fieldSize ( Asn :: istream & is ) : Asn :: BitString ( is, Asn :: fixedConstraint, 0, 511 ) { }

ECKASDH_eckasdh2_fieldSize :: ECKASDH_eckasdh2_fieldSize ( const Asn :: string & v, unsigned b ) : Asn :: BitString ( b ? : unsigned ( v.size ( ) * 8 ), v, Asn :: fixedConstraint, 0, 511 ) {
}

ECKASDH_eckasdh2_fieldSize * ECKASDH_eckasdh2_fieldSize :: clone ( ) const {
	return new ECKASDH_eckasdh2_fieldSize ( * this );
}

//
// ECKASDH_eckasdh2_weierstrassA
//

ECKASDH_eckasdh2_weierstrassA :: ECKASDH_eckasdh2_weierstrassA ( Asn :: istream & is ) : Asn :: BitString ( is, Asn :: fixedConstraint, 0, 511 ) { }

ECKASDH_eckasdh2_weierstrassA :: ECKASDH_eckasdh2_weierstrassA ( const Asn :: string & v, unsigned b ) : Asn :: BitString ( b ? : unsigned ( v.size ( ) * 8 ), v, Asn :: fixedConstraint, 0, 511 ) {
}

ECKASDH_eckasdh2_weierstrassA * ECKASDH_eckasdh2_weierstrassA :: clone ( ) const {
	return new ECKASDH_eckasdh2_weierstrassA ( * this );
}

//
// ECKASDH_eckasdh2_weierstrassB
//

ECKASDH_eckasdh2_weierstrassB :: ECKASDH_eckasdh2_weierstrassB ( Asn :: istream & is ) : Asn :: BitString ( is, Asn :: fixedConstraint, 0, 511 ) { }

ECKASDH_eckasdh2_weierstrassB :: ECKASDH_eckasdh2_weierstrassB ( const Asn :: string & v, unsigned b ) : Asn :: BitString ( b ? : unsigned ( v.size ( ) * 8 ), v, Asn :: fixedConstraint, 0, 511 ) {
}

ECKASDH_eckasdh2_weierstrassB * ECKASDH_eckasdh2_weierstrassB :: clone ( ) const {
	return new ECKASDH_eckasdh2_weierstrassB ( * this );
}

//
// DHset
//

DHset :: DHset ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_halfkey ( is ), m_modSize ( is ), m_generator ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

DHset :: DHset ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void DHset :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_halfkey.encode ( os );
	m_modSize.encode ( os );
	m_generator.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void DHset :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 10 ) << "halfkey = " << std :: setprecision ( indent ) << m_halfkey << '\n';
	os << std :: setw ( indent + 10 ) << "modSize = " << std :: setprecision ( indent ) << m_modSize << '\n';
	os << std :: setw ( indent + 12 ) << "generator = " << std :: setprecision ( indent ) << m_generator << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

DHset * DHset :: clone ( ) const {
	return new DHset ( * this );
}

//
// ECGDSASignature
//

ECGDSASignature :: ECGDSASignature ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, false, 0 ), m_r ( is ), m_s ( is ) {
}

ECGDSASignature :: ECGDSASignature ( ) : Asn :: Sequence ( 0, false, 0 ) { }

void ECGDSASignature :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_r.encode ( os );
	m_s.encode ( os );
}

void ECGDSASignature :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 4 ) << "r = " << std :: setprecision ( indent ) << m_r << '\n';
	os << std :: setw ( indent + 4 ) << "s = " << std :: setprecision ( indent ) << m_s << '\n';
	os << std :: setw ( indent - 1 ) << '}';
}

ECGDSASignature * ECGDSASignature :: clone ( ) const {
	return new ECGDSASignature ( * this );
}

//
// ProfileElement
//

ProfileElement :: ProfileElement ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 0 ), m_elementID ( is ), m_paramS ( 0 ), m_element ( 0 ) {
	try {
		if ( hasOptionalField ( e_paramS ) )
			m_paramS = new Params ( is );
		if ( hasOptionalField ( e_element ) )
			m_element = new Element ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_paramS;
		delete m_element;
		throw;
	}
}

ProfileElement :: ProfileElement ( ) : Asn :: Sequence ( 2, true, 0 ), m_paramS ( 0 ), m_element ( 0 ) { }

ProfileElement & ProfileElement :: operator= ( const ProfileElement & s ) {
	Asn :: Sequence :: operator= ( s );
	m_elementID = s.m_elementID;
	assignCopy ( m_paramS, s.m_paramS );
	assignCopy ( m_element, s.m_element );
	return * this;
}

ProfileElement :: ProfileElement ( const ProfileElement & s ) : Asn :: Sequence ( s ), m_elementID ( s.m_elementID ), m_paramS ( 0 ), m_element ( 0 ) {
	try {
		if ( s.m_paramS )
			m_paramS = new Params ( * s.m_paramS );
		if ( s.m_element )
			m_element = new Element ( * s.m_element );
	} catch ( ... ) {
		delete m_paramS;
		delete m_element;
		throw;
	}
}


void ProfileElement :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_paramS:
			assignNew ( m_paramS, new Params );
			break;
		case e_element:
			assignNew ( m_element, new Element );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void ProfileElement :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_paramS:
			delete m_paramS;
			m_paramS = 0;
			break;
		case e_element:
			delete m_element;
			m_element = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void ProfileElement :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_elementID.encode ( os );
	if ( hasOptionalField ( e_paramS ) )
		m_paramS -> Params :: encode ( os );
	if ( hasOptionalField ( e_element ) )
		m_element -> Element :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

ProfileElement :: ~ProfileElement ( ) {
	delete m_paramS;
	delete m_element;
}

void ProfileElement :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 12 ) << "elementID = " << std :: setprecision ( indent ) << m_elementID << '\n';
	if ( hasOptionalField ( e_paramS ) ) {
		os << std :: setw ( indent + 9 ) << "paramS = " << std :: setprecision ( indent );
		m_paramS -> Params :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_element ) ) {
		os << std :: setw ( indent + 10 ) << "element = " << std :: setprecision ( indent );
		m_element -> Element :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

ProfileElement * ProfileElement :: clone ( ) const {
	return new ProfileElement ( * this );
}

//
// H235Key
//

H235Key :: H235Key ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_secureChannel:
			choice = new KeyMaterial ( is );
			break;
		case e_sharedSecret:
			choice = new ENCRYPTED < EncodedKeySyncMaterial > ( is );
			break;
		case e_certProtectedKey:
			choice = new SIGNED < EncodedKeySignedMaterial > ( is );
			break;
		case e_secureSharedSecret:
			choice = new V3KeySyncMaterial ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

H235Key :: H235Key ( ) : Asn :: Choice ( 3, true ) { }

void H235Key :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_secureChannel:
			o = new KeyMaterial;
			break;
		case e_sharedSecret:
			o = new ENCRYPTED < EncodedKeySyncMaterial >;
			break;
		case e_certProtectedKey:
			o = new SIGNED < EncodedKeySignedMaterial >;
			break;
		case e_secureSharedSecret:
			o = new V3KeySyncMaterial;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & H235Key :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_secureChannel, "secureChannel" },
		{ e_sharedSecret, "sharedSecret" },
		{ e_certProtectedKey, "certProtectedKey" },
		{ e_secureSharedSecret, "secureSharedSecret" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

H235Key * H235Key :: clone ( ) const {
	return new H235Key ( * this );
}

//
// KeySignedMaterial
//

KeySignedMaterial :: KeySignedMaterial ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, false, 0 ), m_generalId ( is ), m_mrandom ( is ), m_srandom ( hasOptionalField ( e_srandom ) ? pushTemporaryMember ( new RandomVal ( is ) ) : 0 ), m_timeStamp ( hasOptionalField ( e_timeStamp ) ? pushTemporaryMember ( new TimeStamp ( is ) ) : 0 ), m_encrptval ( is ) {
	clearTemporaryMembers ( );
}

KeySignedMaterial :: KeySignedMaterial ( ) : Asn :: Sequence ( 2, false, 0 ), m_srandom ( 0 ), m_timeStamp ( 0 ) { }

KeySignedMaterial & KeySignedMaterial :: operator= ( const KeySignedMaterial & s ) {
	Asn :: Sequence :: operator= ( s );
	m_generalId = s.m_generalId;
	m_mrandom = s.m_mrandom;
	assignCopy ( m_srandom, s.m_srandom );
	assignCopy ( m_timeStamp, s.m_timeStamp );
	m_encrptval = s.m_encrptval;
	return * this;
}

KeySignedMaterial :: KeySignedMaterial ( const KeySignedMaterial & s ) : Asn :: Sequence ( s ), m_generalId ( s.m_generalId ), m_mrandom ( s.m_mrandom ), m_srandom ( 0 ), m_timeStamp ( 0 ), m_encrptval ( s.m_encrptval ) {
	try {
		if ( s.m_srandom )
			m_srandom = new RandomVal ( * s.m_srandom );
		if ( s.m_timeStamp )
			m_timeStamp = new TimeStamp ( * s.m_timeStamp );
	} catch ( ... ) {
		delete m_srandom;
		delete m_timeStamp;
		throw;
	}
}


void KeySignedMaterial :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_srandom:
			assignNew ( m_srandom, new RandomVal );
			break;
		case e_timeStamp:
			assignNew ( m_timeStamp, new TimeStamp );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void KeySignedMaterial :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_srandom:
			delete m_srandom;
			m_srandom = 0;
			break;
		case e_timeStamp:
			delete m_timeStamp;
			m_timeStamp = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void KeySignedMaterial :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_generalId.encode ( os );
	m_mrandom.encode ( os );
	if ( hasOptionalField ( e_srandom ) )
		m_srandom -> RandomVal :: encode ( os );
	if ( hasOptionalField ( e_timeStamp ) )
		m_timeStamp -> TimeStamp :: encode ( os );
	m_encrptval.encode ( os );
}

KeySignedMaterial :: ~KeySignedMaterial ( ) {
	delete m_srandom;
	delete m_timeStamp;
}

void KeySignedMaterial :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 12 ) << "generalId = " << std :: setprecision ( indent ) << m_generalId << '\n';
	os << std :: setw ( indent + 10 ) << "mrandom = " << std :: setprecision ( indent ) << m_mrandom << '\n';
	if ( hasOptionalField ( e_srandom ) ) {
		os << std :: setw ( indent + 10 ) << "srandom = " << std :: setprecision ( indent );
		m_srandom -> RandomVal :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_timeStamp ) ) {
		os << std :: setw ( indent + 12 ) << "timeStamp = " << std :: setprecision ( indent );
		m_timeStamp -> TimeStamp :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 12 ) << "encrptval = " << std :: setprecision ( indent ) << m_encrptval << '\n';
	os << std :: setw ( indent - 1 ) << '}';
}

KeySignedMaterial * KeySignedMaterial :: clone ( ) const {
	return new KeySignedMaterial ( * this );
}

//
// H235CertificateSignature
//

H235CertificateSignature :: H235CertificateSignature ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_certificate ( is ), m_responseRandom ( is ), m_requesterRandom ( hasOptionalField ( e_requesterRandom ) ? pushTemporaryMember ( new RandomVal ( is ) ) : 0 ), m_signature ( is ) {
	clearTemporaryMembers ( );
	try {
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_requesterRandom;
		throw;
	}
}

H235CertificateSignature :: H235CertificateSignature ( ) : Asn :: Sequence ( 1, true, 0 ), m_requesterRandom ( 0 ) { }

H235CertificateSignature & H235CertificateSignature :: operator= ( const H235CertificateSignature & s ) {
	Asn :: Sequence :: operator= ( s );
	m_certificate = s.m_certificate;
	m_responseRandom = s.m_responseRandom;
	assignCopy ( m_requesterRandom, s.m_requesterRandom );
	m_signature = s.m_signature;
	return * this;
}

H235CertificateSignature :: H235CertificateSignature ( const H235CertificateSignature & s ) : Asn :: Sequence ( s ), m_certificate ( s.m_certificate ), m_responseRandom ( s.m_responseRandom ), m_requesterRandom ( 0 ), m_signature ( s.m_signature ) {
	try {
		if ( s.m_requesterRandom )
			m_requesterRandom = new RandomVal ( * s.m_requesterRandom );
	} catch ( ... ) {
		delete m_requesterRandom;
		throw;
	}
}


void H235CertificateSignature :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_requesterRandom:
			assignNew ( m_requesterRandom, new RandomVal );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void H235CertificateSignature :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_requesterRandom:
			delete m_requesterRandom;
			m_requesterRandom = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void H235CertificateSignature :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_certificate.encode ( os );
	m_responseRandom.encode ( os );
	if ( hasOptionalField ( e_requesterRandom ) )
		m_requesterRandom -> RandomVal :: encode ( os );
	m_signature.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

H235CertificateSignature :: ~H235CertificateSignature ( ) {
	delete m_requesterRandom;
}

void H235CertificateSignature :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 14 ) << "certificate = " << std :: setprecision ( indent ) << m_certificate << '\n';
	os << std :: setw ( indent + 17 ) << "responseRandom = " << std :: setprecision ( indent ) << m_responseRandom << '\n';
	if ( hasOptionalField ( e_requesterRandom ) ) {
		os << std :: setw ( indent + 18 ) << "requesterRandom = " << std :: setprecision ( indent );
		m_requesterRandom -> RandomVal :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 12 ) << "signature = " << std :: setprecision ( indent ) << m_signature << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H235CertificateSignature * H235CertificateSignature :: clone ( ) const {
	return new H235CertificateSignature ( * this );
}

//
// ECKASDH_eckasdhp
//

ECKASDH_eckasdhp :: ECKASDH_eckasdhp ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, false, 0 ), m_public_key ( is ), m_modulus ( is ), m_base ( is ), m_weierstrassA ( is ), m_weierstrassB ( is ) {
}

ECKASDH_eckasdhp :: ECKASDH_eckasdhp ( ) : Asn :: Sequence ( 0, false, 0 ) { }

void ECKASDH_eckasdhp :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_public_key.encode ( os );
	m_modulus.encode ( os );
	m_base.encode ( os );
	m_weierstrassA.encode ( os );
	m_weierstrassB.encode ( os );
}

void ECKASDH_eckasdhp :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 13 ) << "public_key = " << std :: setprecision ( indent ) << m_public_key << '\n';
	os << std :: setw ( indent + 10 ) << "modulus = " << std :: setprecision ( indent ) << m_modulus << '\n';
	os << std :: setw ( indent + 7 ) << "base = " << std :: setprecision ( indent ) << m_base << '\n';
	os << std :: setw ( indent + 15 ) << "weierstrassA = " << std :: setprecision ( indent ) << m_weierstrassA << '\n';
	os << std :: setw ( indent + 15 ) << "weierstrassB = " << std :: setprecision ( indent ) << m_weierstrassB << '\n';
	os << std :: setw ( indent - 1 ) << '}';
}

ECKASDH_eckasdhp * ECKASDH_eckasdhp :: clone ( ) const {
	return new ECKASDH_eckasdhp ( * this );
}

//
// ECKASDH_eckasdh2
//

ECKASDH_eckasdh2 :: ECKASDH_eckasdh2 ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, false, 0 ), m_public_key ( is ), m_fieldSize ( is ), m_base ( is ), m_weierstrassA ( is ), m_weierstrassB ( is ) {
}

ECKASDH_eckasdh2 :: ECKASDH_eckasdh2 ( ) : Asn :: Sequence ( 0, false, 0 ) { }

void ECKASDH_eckasdh2 :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_public_key.encode ( os );
	m_fieldSize.encode ( os );
	m_base.encode ( os );
	m_weierstrassA.encode ( os );
	m_weierstrassB.encode ( os );
}

void ECKASDH_eckasdh2 :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 13 ) << "public_key = " << std :: setprecision ( indent ) << m_public_key << '\n';
	os << std :: setw ( indent + 12 ) << "fieldSize = " << std :: setprecision ( indent ) << m_fieldSize << '\n';
	os << std :: setw ( indent + 7 ) << "base = " << std :: setprecision ( indent ) << m_base << '\n';
	os << std :: setw ( indent + 15 ) << "weierstrassA = " << std :: setprecision ( indent ) << m_weierstrassA << '\n';
	os << std :: setw ( indent + 15 ) << "weierstrassB = " << std :: setprecision ( indent ) << m_weierstrassB << '\n';
	os << std :: setw ( indent - 1 ) << '}';
}

ECKASDH_eckasdh2 * ECKASDH_eckasdh2 :: clone ( ) const {
	return new ECKASDH_eckasdh2 ( * this );
}

//
// CryptoToken_cryptoEncryptedToken
//

CryptoToken_cryptoEncryptedToken :: CryptoToken_cryptoEncryptedToken ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, false, 0 ), m_tokenOID ( is ), m_token ( is ) {
}

CryptoToken_cryptoEncryptedToken :: CryptoToken_cryptoEncryptedToken ( ) : Asn :: Sequence ( 0, false, 0 ) { }

void CryptoToken_cryptoEncryptedToken :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_tokenOID.encode ( os );
	m_token.encode ( os );
}

void CryptoToken_cryptoEncryptedToken :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 11 ) << "tokenOID = " << std :: setprecision ( indent ) << m_tokenOID << '\n';
	os << std :: setw ( indent + 8 ) << "token = " << std :: setprecision ( indent ) << m_token << '\n';
	os << std :: setw ( indent - 1 ) << '}';
}

CryptoToken_cryptoEncryptedToken * CryptoToken_cryptoEncryptedToken :: clone ( ) const {
	return new CryptoToken_cryptoEncryptedToken ( * this );
}

//
// CryptoToken_cryptoSignedToken
//

CryptoToken_cryptoSignedToken :: CryptoToken_cryptoSignedToken ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, false, 0 ), m_tokenOID ( is ), m_token ( is ) {
}

CryptoToken_cryptoSignedToken :: CryptoToken_cryptoSignedToken ( ) : Asn :: Sequence ( 0, false, 0 ) { }

void CryptoToken_cryptoSignedToken :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_tokenOID.encode ( os );
	m_token.encode ( os );
}

void CryptoToken_cryptoSignedToken :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 11 ) << "tokenOID = " << std :: setprecision ( indent ) << m_tokenOID << '\n';
	os << std :: setw ( indent + 8 ) << "token = " << std :: setprecision ( indent ) << m_token << '\n';
	os << std :: setw ( indent - 1 ) << '}';
}

CryptoToken_cryptoSignedToken * CryptoToken_cryptoSignedToken :: clone ( ) const {
	return new CryptoToken_cryptoSignedToken ( * this );
}

//
// CryptoToken_cryptoHashedToken
//

CryptoToken_cryptoHashedToken :: CryptoToken_cryptoHashedToken ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, false, 0 ), m_tokenOID ( is ), m_hashedVals ( is ), m_token ( is ) {
}

CryptoToken_cryptoHashedToken :: CryptoToken_cryptoHashedToken ( ) : Asn :: Sequence ( 0, false, 0 ) { }

void CryptoToken_cryptoHashedToken :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_tokenOID.encode ( os );
	m_hashedVals.encode ( os );
	m_token.encode ( os );
}

void CryptoToken_cryptoHashedToken :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 11 ) << "tokenOID = " << std :: setprecision ( indent ) << m_tokenOID << '\n';
	os << std :: setw ( indent + 13 ) << "hashedVals = " << std :: setprecision ( indent ) << m_hashedVals << '\n';
	os << std :: setw ( indent + 8 ) << "token = " << std :: setprecision ( indent ) << m_token << '\n';
	os << std :: setw ( indent - 1 ) << '}';
}

CryptoToken_cryptoHashedToken * CryptoToken_cryptoHashedToken :: clone ( ) const {
	return new CryptoToken_cryptoHashedToken ( * this );
}

//
// ECKASDH
//

ECKASDH :: ECKASDH ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_eckasdhp:
			choice = new ECKASDH_eckasdhp ( is );
			break;
		case e_eckasdh2:
			choice = new ECKASDH_eckasdh2 ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

ECKASDH :: ECKASDH ( ) : Asn :: Choice ( 2, true ) { }

void ECKASDH :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_eckasdhp:
			o = new ECKASDH_eckasdhp;
			break;
		case e_eckasdh2:
			o = new ECKASDH_eckasdh2;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & ECKASDH :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_eckasdhp, "eckasdhp" },
		{ e_eckasdh2, "eckasdh2" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

ECKASDH * ECKASDH :: clone ( ) const {
	return new ECKASDH ( * this );
}

//
// CryptoToken
//

CryptoToken :: CryptoToken ( Asn :: istream & is ) : Asn :: Choice ( is, 4, true ) {
	switch ( tag ) {
		case e_cryptoEncryptedToken:
			choice = new CryptoToken_cryptoEncryptedToken ( is );
			break;
		case e_cryptoSignedToken:
			choice = new CryptoToken_cryptoSignedToken ( is );
			break;
		case e_cryptoHashedToken:
			choice = new CryptoToken_cryptoHashedToken ( is );
			break;
		case e_cryptoPwdEncr:
			choice = new ENCRYPTED < EncodedPwdCertToken > ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

CryptoToken :: CryptoToken ( ) : Asn :: Choice ( 4, true ) { }

void CryptoToken :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_cryptoEncryptedToken:
			o = new CryptoToken_cryptoEncryptedToken;
			break;
		case e_cryptoSignedToken:
			o = new CryptoToken_cryptoSignedToken;
			break;
		case e_cryptoHashedToken:
			o = new CryptoToken_cryptoHashedToken;
			break;
		case e_cryptoPwdEncr:
			o = new ENCRYPTED < EncodedPwdCertToken >;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & CryptoToken :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_cryptoEncryptedToken, "cryptoEncryptedToken" },
		{ e_cryptoSignedToken, "cryptoSignedToken" },
		{ e_cryptoHashedToken, "cryptoHashedToken" },
		{ e_cryptoPwdEncr, "cryptoPwdEncr" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

CryptoToken * CryptoToken :: clone ( ) const {
	return new CryptoToken ( * this );
}


// End of h235.cxx
