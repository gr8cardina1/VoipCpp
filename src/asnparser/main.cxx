#include <ptlib.h>

#include "main.h"
#include "asn_grammar.h"
#include <limits>

#define MAJOR_VERSION 1
#define MINOR_VERSION 6
#define BUILD_TYPE    ReleaseCode
#define BUILD_NUMBER 0


unsigned lineNumber;
string  fileName;

unsigned fatals, warnings;

extern FILE * yyin;
extern int yydebug;
extern int LexEcho;

ModuleDefinition * Module;

/*
static const char * UniversalTagClassNames[] = {
  "UniversalTagClass",
  "ApplicationTagClass",
  "ContextSpecificTagClass",
  "PrivateTagClass"
};

static const char * UniversalTagNames[] = {
  NULL,
  "UniversalBoolean",
  "UniversalInteger",
  "UniversalBitString",
  "UniversalOctetString",
  "UniversalNull",
  "UniversalObjectId",
  "UniversalObjectDescriptor",
  "UniversalExternalType",
  "UniversalReal",
  "UniversalEnumeration",
  "UniversalEmbeddedPDV",
  NULL,
  NULL,
  NULL,
  NULL,
  "UniversalSequence",
  "UniversalSet",
  "UniversalNumericString",
  "UniversalPrintableString",
  "UniversalTeletexString",
  "UniversalVideotexString",
  "UniversalIA5String",
  "UniversalUTCTime",
  "UniversalGeneralisedTime",
  "UniversalGraphicString",
  "UniversalVisibleString",
  "UniversalGeneralString",
  "UniversalUniversalString",
  NULL,
  "UniversalBMPString"
};
*/

static const char * const StandardClasses[] = {
  "Asn :: Null",
  "Asn :: Boolean",
  "Asn :: Integer",
  "Asn :: Enumeration",
  "Asn :: Real",
  "Asn :: ObjectId",
  "Asn :: BitString",
  "Asn :: OctetString",
  "Asn :: NumericString",
  "Asn :: PrintableString",
  "Asn :: VisibleString",
  "Asn :: IA5String",
  "Asn :: GeneralString",
  "Asn :: BMPString",
  "Asn :: Sequence"
};


/////////////////////////////////////////
//
//  yyerror
//  required function for flex
//

void yyerror(char * str)
{
  extern char * yytext;
  PError << StdError(Fatal) << str << " near token \"" << yytext <<"\"\n";
}

ostream & operator<<(ostream & out, const StdError & e)
{
  out << fileName << '(' << lineNumber << ") : ";
  if (e.e == Fatal) {
    fatals++;
    out << "error";
  }
  else {
    warnings++;
    out << "warning";
  }
  return out << ": ";
}


/////////////////////////////////////////////////////////
//
//  Utility
//

static string MakeIdentifierC(const string & identifier)
{
  string s = identifier;
  replace ( s.begin ( ), s.end ( ), '-', '_' );
  return s;
}


class OutputFile : public PTextFile
{
    PCLASSINFO(OutputFile, PTextFile);
  public:
    ~OutputFile() { Close(); }

    BOOL Open(const PFilePath & path, const string & suffix, const char * extension);
    BOOL Close();
};


BOOL OutputFile::Open(const PFilePath & path,
                      const string & suffix,
                      const char * extension)
{
  PFilePath fn = path.GetDirectory() + path.GetTitle() + suffix.c_str ( );
  fn.SetType(extension);

  if (PTextFile::Open(fn, WriteOnly))
    *this << "//\n"
             "// " << GetFilePath().GetFileName() << "\n"
             "//\n"
             "// Code automatically generated by asnparse.\n"
             "//\n"
             "\n";
  else
    PError << PProcess::Current().GetName() << ": cannot create \""
         << GetFilePath() << "\" :" << GetErrorText() << endl;

  return IsOpen();
}


BOOL OutputFile::Close()
{
  if (IsOpen())
    *this << "\n"
             "// End of " << GetFilePath().GetFileName() << '\n';

  return PTextFile::Close();
}


/////////////////////////////////////////////////////////
//
//  Application
//

class App : public PProcess
{
    PCLASSINFO(App, PProcess);
  public:
    App();
    void Main();
    BOOL SetClassHeaderFile(PArgList & args);
    BOOL SetClassHeader(PArgList & args);
    void OutputAdditionalHeaders(ostream & hdr, const string & className);
  protected:
    map<string,string> classToHeader;
};

PCREATE_PROCESS(App);

App::App()
  : PProcess("Equivalence", "ASNParse", MAJOR_VERSION, MINOR_VERSION, BUILD_TYPE, BUILD_NUMBER)
{
}

static bool usingInlinesFlag;

void App::Main()
{
  cout << GetName() << " version " << GetVersion(TRUE)
       << " for " << GetOSClass() << ' ' << GetOSName()
       << " by " << GetManufacturer() << endl;

  PArgList & args = GetArguments();
  args.Parse("V-version."
             "v-verbose."
             "e-echo."
             "d-debug."
             "c-c++."
             "n-namespace."
             "i-inlines."
             "s-split;"
             "o-output:"
             "m-module:"
             "r-rename:"
             "-classheader:"
             "-classheaderfile:");

  if (args.HasOption('V'))
    return;

  unsigned numFiles = 1;
  if (args.HasOption('s')) {
    PString numFilesStr = args.GetOptionString('s');
    if (numFilesStr.IsEmpty())
      numFiles = 2;
    else
      numFiles = numFilesStr.AsUnsigned();
  }

  if (args.GetCount() < 1 || args.GetCount() > 1 || numFiles == 0) {
    PError << "usage: asnparse [options] asnfile\n"
              "  -V --version        Display version and exit\n"
              "  -v --verbose        Verbose output (multiple times for more verbose)\n"
              "  -e --echo           Echo input file\n"
              "  -d --debug          Debug output (copious!)\n"
              "  -c --c++            Generate C++ files\n"
              "  -n --namespace      Use C++ namespace\n"
              "  -i --inlines        Use C++ inlines\n"
              "  -s[n] --split[n]    Split output into n (default 2) files\n"
              "  -o --output file    Output filename/directory\n"
              "  -m --module name    Module name prefix/namespace\n"
              "  -r --rename from=to Rename import module\n"
           << endl;
    return;
  }

  PTextFile prcFile;
  if (!prcFile.Open(args[0], PFile::ReadOnly)) {
    PError << GetName() << ": cannot open \""
         << prcFile.GetFilePath() << "\" :" << prcFile.GetErrorText() << endl;
    return;
  }

  if (args.HasOption('d'))
    yydebug = 1;
  if (args.HasOption('e'))
    LexEcho = TRUE;

  fileName   = prcFile.GetFilePath();
  lineNumber = 1;
  fatals     = 0;
  warnings   = 0;

  if (args.HasOption("classheaderfile")) {
    if (!SetClassHeaderFile(args))
      return;
  }

  if (args.HasOption("classheader")) {
    if (!SetClassHeader(args))
      return;
  }

  if (args.HasOption('v'))
    cout << "Parsing..." << endl;

  yyin = _fdopen(prcFile.GetHandle(), "r");
  ( void ) PAssertNULL(yyin);
  usingInlinesFlag = args.HasOption('i');
  yyparse();

  if (Module != NULL) {
    if (args.GetOptionCount('v') > 1)
      PError << "Module " << *Module << endl;

    if (args.HasOption('c'))
      Module->GenerateCplusplus((const char * )args.GetOptionString('o', args[0]),
                                (const char * )args.GetOptionString('m'),
                                numFiles,
                                args.HasOption('n'),
                                args.HasOption('i'),
                                args.HasOption('v'));
  }
}


BOOL App::SetClassHeaderFile(PArgList & args)
{
  PStringArray lines = args.GetOptionString("classheaderfile").Lines();
  if (lines.IsEmpty()) {
    PError << GetName() << ": malformed --classheaderfile option\n";
    return FALSE;
  }

  for (PINDEX i = 0; i < lines.GetSize(); i++) {
    PString str = lines[i];
    PINDEX pos = str.Find("=");
    if (pos == P_MAX_INDEX) {
      PError << GetName() << ": malformed --classheaderfile option\n";
      return FALSE;
    }

    PFilePath fn = str.Right(pos+1);
    PTextFile file(fn, PFile::ReadOnly);
    if (!file.IsOpen()) {
      PError << GetName() << ": cannot open file required for --classheaderfile option \"" << fn
                          << "\" :" << file.GetErrorText() << '\n';
      return FALSE;
    }

    PString text;
    PString line;
    while (file.ReadLine(line))
      text += PString(PString::Literal, (const char *)line) + '\n';
    classToHeader [(const char *)str.Left(pos)] = text;
  }

  return TRUE;
}


BOOL App::SetClassHeader(PArgList & args)
{
  PStringArray lines = args.GetOptionString("classheader").Lines();
  if (lines.IsEmpty()) {
    PError << GetName() << ": malformed --classheader option\n";
    return FALSE;
  }

  for (PINDEX i = 0; i < lines.GetSize(); i++) {
    PString str = lines[i];
    PINDEX pos = str.Find("=");
    if (pos == P_MAX_INDEX) {
      PError << GetName() << ": malformed --classheader option\n";
      return FALSE;
    }

    PString text(PString::Literal, (const char *)str.Mid(pos+1));
    classToHeader [(const char *)str.Left(pos)] = text;
  }

  return TRUE;
}


void App::OutputAdditionalHeaders(ostream & hdr, const string & className)
{
  if (classToHeader.count(className)) {
    hdr << "// following code added by command line option\n"
           "\n"
        << classToHeader[className] << "\n"
           "\n"
           "// end of added code\n"
           "\n";
  }
}

/////////////////////////////////////////
//
//  miscellaneous
//

class indent
{
  public:
    indent() { }
    friend ostream & operator<<(ostream & s, const indent &)
    { return s << setw(Module->GetIndentLevel()*3) << ' '; }
};


/////////////////////////////////////////
//
//  intermediate structures from parser
//

NamedNumber::NamedNumber(string * nam)
  : name(*nam)
{
  delete nam;
  number = 0;
  autonumber = TRUE;
}


NamedNumber::NamedNumber(string * nam, int num)
  : name(*nam)
{
  delete nam;
  number = num;
  autonumber = FALSE;
}


NamedNumber::NamedNumber(string * nam, const string & ref)
  : name(*nam), reference(ref)
{
  delete nam;
  number = 0;
  autonumber = FALSE;
}


void NamedNumber::PrintOn(ostream & strm) const
{
  strm << name << " (";
  if (reference.empty())
    strm << number;
  else
    strm << reference;
  strm << ')';
}


void NamedNumber::SetAutoNumber(const NamedNumber & prev)
{
  if (autonumber) {
    number = prev.number + 1;
    autonumber = FALSE;
  }
}


/////////////////////////////////////////////////////////

Tag::Tag(unsigned tagNum)
{
  type = Universal;
  number = tagNum;
  mode = Module->GetDefaultTagMode();
}


const char * Tag::classNames[] = {
  "UNIVERSAL", "APPLICATION", "CONTEXTSPECIFIC", "PRIVATE"
};


const char * Tag::modeNames[] = {
  "IMPLICIT", "EXPLICIT", "AUTOMATIC"
};


void Tag::PrintOn(ostream & strm) const
{
  if (type != Universal || number != IllegalUniversalTag) {
    strm << '[';
    if (type != ContextSpecific)
      strm << classNames[type] << ' ';
    strm << number << "] " << modeNames[mode] << ' ';
  }
}


/////////////////////////////////////////////////////////

Constraint::Constraint(ConstraintElementBase * elmt)
{
  standard.Append(elmt);
  extendable = FALSE;
}


Constraint::Constraint(ConstraintElementList * stnd, BOOL extend, ConstraintElementList * ext)
{
  if (stnd != NULL) {
    standard = *stnd;
    delete stnd;
  }
  extendable = extend;
  if (ext != NULL) {
    extensions = *ext;
    delete ext;
  }
}


void Constraint::PrintOn(ostream & strm) const
{
  strm << '(';
  for (PINDEX i = 0; i < standard.GetSize(); i++)
    strm << standard[i];
  if (extendable) {
    strm << indent();
    if (standard.GetSize() > 0)
      strm << ", ";
    strm << "..., ";
    for (PINDEX i = 0; i < extensions.GetSize(); i++)
      strm << extensions[i];
  }
  strm << ')';
}


void Constraint::GenerateCplusplus(const string & fn, ostream & hdr, ostream & cxx)
{
  switch (standard.GetSize()) {
    case 0 :
      return;
    case 1 :
      break;
    default :
      PError << StdError(Warning) << "unsupported UNION constraints, ignored." << endl;
  }

  if (extensions.GetSize() > 0)
    PError << StdError(Warning) << "unsupported extension constraints, ignored." << endl;

  string fn2 = fn;
  if (fn.find("PASN_Object::") == string::npos) {
    if (extendable) {
      fn2 += "PASN_Object::ExtendableConstraint";
      cxx << ", Asn :: extendableConstraint";
    } else {
      fn2 += "PASN_Object::FixedConstraint";
      cxx << ", Asn :: fixedConstraint";
    }
  }
  standard[0].GenerateCplusplus(fn2, hdr, cxx);
}


BOOL Constraint::ReferencesType(const TypeBase & type)
{
  PINDEX i;

  for (i = 0; i < standard.GetSize(); i++) {
    if (standard[i].ReferencesType(type))
      return TRUE;
  }

  for (i = 0; i < extensions.GetSize(); i++) {
    if (extensions[i].ReferencesType(type))
      return TRUE;
  }

  return FALSE;
}

void Constraint::checkConstraints ( char typ, TypeBase * t ) {
  PINDEX i;

  for (i = 0; i < standard.GetSize(); i++) {
    standard[i].checkConstraints(typ, extendable, t);
  }

  for (i = 0; i < extensions.GetSize(); i++) {
    extensions[i].checkConstraints(typ, extendable, t);
  }

}
/////////////////////////////////////////////////////////

ConstraintElementBase::ConstraintElementBase()
{
  exclusions = NULL;
}


void ConstraintElementBase::GenerateCplusplus(const string &, ostream &, ostream &)
{
  PError << StdError(Warning) << "unsupported constraint, ignored." << endl;
}


BOOL ConstraintElementBase::ReferencesType(const TypeBase &)
{
  return FALSE;
}

void ConstraintElementBase::checkConstraints ( char typ, bool e, TypeBase * t ) {
  PError << StdError(Warning) << "unsupported constraint, ignored." << endl;
}

/////////////////////////////////////////////////////////

ConstrainAllConstraintElement::ConstrainAllConstraintElement(ConstraintElementBase * excl)
{
  SetExclusions(excl);
}

void ConstrainAllConstraintElement::checkConstraints ( char typ, bool e, TypeBase * t ) {
    PError << "ConstrainAllConstraintElement traversed\n";
}

/////////////////////////////////////////////////////////

ElementListConstraintElement::ElementListConstraintElement(ConstraintElementList * list)
  : elements(*list)
{
  delete list;
}


void ElementListConstraintElement::PrintOn(ostream & strm) const
{
  elements.PrintOn(strm);
}


void ElementListConstraintElement::GenerateCplusplus(const string & fn, ostream & hdr, ostream & cxx)
{
  for (PINDEX i = 0; i < elements.GetSize(); i++)
    elements[i].GenerateCplusplus(fn, hdr, cxx);
}


BOOL ElementListConstraintElement::ReferencesType(const TypeBase & type)
{
  for (PINDEX i = 0; i < elements.GetSize(); i++) {
    if (elements[i].ReferencesType(type))
      return TRUE;
  }
  return FALSE;
}

void ElementListConstraintElement::checkConstraints ( char typ, bool e, TypeBase * t ) {
  for (PINDEX i = 0; i < elements.GetSize(); i++)
    elements[i].checkConstraints(typ, e, t);
}

/////////////////////////////////////////////////////////

SingleValueConstraintElement::SingleValueConstraintElement(ValueBase * val)
{
  value = val;
}


SingleValueConstraintElement::~SingleValueConstraintElement()
{
  delete value;
}


void SingleValueConstraintElement::PrintOn(ostream & strm) const
{
  strm << *value;
}


void SingleValueConstraintElement::GenerateCplusplus(const string & fn, ostream & hdr, ostream & cxx)
{
  if ( fn.find ( "IT IS FROM" ) != string::npos ) {
    cxx << ", \"";
    PStringStream os;
    value->GenerateCplusplus(hdr, os);
    PString t = os;
    char buf [ 256 ];
    memset ( buf, 0, 256 );
    for ( int i = 1; i < t.GetLength ( ) - 1; i ++ )
	    buf [ ( unsigned char ) t [ i ] ] = 1;
    for ( int i = 0; i < 256; i ++ )
	    if ( buf [ i ] )
		    cxx << char ( i );
    cxx << "\", sizeof ( ";
    value->GenerateCplusplus(hdr, cxx);
    cxx << " ) > 17 ? 8 : 4";
    return;
  }
  cxx << ", ";
  value->GenerateCplusplus(hdr, cxx);
  cxx << ", ";
  value->GenerateCplusplus(hdr, cxx);
}

void SingleValueConstraintElement::checkConstraints ( char typ, bool e, TypeBase * t ) {
    t -> addConstraint ( typ, e, this );
}

/////////////////////////////////////////////////////////

ValueRangeConstraintElement::ValueRangeConstraintElement(ValueBase * lowerBound, ValueBase * upperBound)
{
  lower = lowerBound;
  upper = upperBound;
}


ValueRangeConstraintElement::~ValueRangeConstraintElement()
{
  delete lower;
  delete upper;
}


void ValueRangeConstraintElement::PrintOn(ostream & strm) const
{
  strm << *lower << ".." << *upper;
}


void ValueRangeConstraintElement::GenerateCplusplus(const string & fn, ostream & hdr, ostream & cxx)
{
  cxx << ", ";
  lower->GenerateCplusplus(hdr, cxx);
  cxx << ", ";
  upper->GenerateCplusplus(hdr, cxx);
}


void ValueRangeConstraintElement::checkConstraints ( char typ, bool e, TypeBase * t ) {
    t -> addConstraint ( typ, e, this );
}

/////////////////////////////////////////////////////////

SubTypeConstraintElement::SubTypeConstraintElement(TypeBase * typ)
{
  subtype = typ;
}


SubTypeConstraintElement::~SubTypeConstraintElement()
{
  delete subtype;
}


void SubTypeConstraintElement::PrintOn(ostream & strm) const
{
  strm << subtype->GetTypeName();
}


void SubTypeConstraintElement::GenerateCplusplus(const string &, ostream & hdr, ostream &)
{
  hdr << " subtype cnstraint element " << subtype->GetTypeName();
}


BOOL SubTypeConstraintElement::ReferencesType(const TypeBase & type)
{
//  return subtype->ReferencesType(type);
// eto nugno dlya decodesubtype kotorogo u nas net
    return FALSE;
}

void SubTypeConstraintElement::checkConstraints ( char typ, bool e, TypeBase * t ) {
//subtype pochemu-to sloman i pokazivaet v nikuda. no nam ono pohoge i ne nado
    if ( typ != ' ' )
	PError << "subtype constraint element with typ " << typ << endl;
    t -> addConstraint ( 't', e, this );
}

/////////////////////////////////////////////////////////

NestedConstraintConstraintElement::NestedConstraintConstraintElement(Constraint * con)
{
  constraint = con;
}


NestedConstraintConstraintElement::~NestedConstraintConstraintElement()
{
  delete constraint;
}


BOOL NestedConstraintConstraintElement::ReferencesType(const TypeBase & type)
{
  if (constraint == NULL)
    return FALSE;

  return constraint->ReferencesType(type);
}

void NestedConstraintConstraintElement::checkConstraints ( char typ, bool e, TypeBase * t ) {
    constraint -> checkConstraints ( typ, t );
}

/////////////////////////////////////////////////////////

SizeConstraintElement::SizeConstraintElement(Constraint * constraint)
  : NestedConstraintConstraintElement(constraint)
{
}


void SizeConstraintElement::PrintOn(ostream & strm) const
{
  strm << "SIZE" << *constraint;
}


void SizeConstraintElement::GenerateCplusplus(const string & fn, ostream & hdr, ostream & cxx)
{
  constraint->GenerateCplusplus(fn, hdr, cxx);
}

void SizeConstraintElement::checkConstraints ( char typ, bool e, TypeBase * t ) {
    if ( typ != ' ' )
	PError << "size constraint with typ " << typ << endl;
    constraint -> checkConstraints ( 's', t );
}


/////////////////////////////////////////////////////////

FromConstraintElement::FromConstraintElement(Constraint * constraint)
  : NestedConstraintConstraintElement(constraint)
{
}


void FromConstraintElement::PrintOn(ostream & strm) const
{
  strm << "FROM" << *constraint;
}


void FromConstraintElement::GenerateCplusplus(const string & fn, ostream & hdr, ostream & cxx)
{
  string newfn = fn;
//  newfn.Replace("SetConstraints(", "SetCharacterSet(");
  newfn += "IT IS FROM";
  constraint->GenerateCplusplus(newfn, hdr, cxx);
}

void FromConstraintElement::checkConstraints ( char typ, bool e, TypeBase * t ) {
    if ( typ != ' ' )
	PError << "from constraint with typ " << typ << endl;
    constraint -> checkConstraints ( 'f', t );
}


/////////////////////////////////////////////////////////

WithComponentConstraintElement::WithComponentConstraintElement(string * newName,
                                                               Constraint * constraint,
                                                               int pres)
  : NestedConstraintConstraintElement(constraint)
{
  if (newName != NULL) {
    name = *newName;
    delete newName;
  }

  presence = pres;
}


void WithComponentConstraintElement::PrintOn(ostream & strm) const
{
  if (name.empty())
    strm << "WITH COMPONENT";
  else
    strm << name;

  if (constraint != NULL)
    strm << *constraint;

  switch (presence) {
    case Present :
      strm << " PRESENT";
      break;
    case Absent :
      strm << " ABSENT";
      break;
    case Optional :
      strm << " OPTIONAL";
      break;
  }
}


void WithComponentConstraintElement::GenerateCplusplus(const string &, ostream &, ostream & cxx)
{
  if (presence == Present)
    cxx << "	includeOptionalField ( e_" << name << " );\n";
  else
    PError << "WithComponentConstraintElement " << * this << endl;
}

void WithComponentConstraintElement::checkConstraints ( char typ, bool e, TypeBase * t ) {
    if ( typ != 't' )
	PError << "with component constraint with typ " << typ << endl;
    t -> addConstraint ( typ, e, this );
    if ( constraint )
	constraint -> checkConstraints ( typ, t );

}


/////////////////////////////////////////////////////////

InnerTypeConstraintElement::InnerTypeConstraintElement(ConstraintElementList * list,
                                                       BOOL part)
  : ElementListConstraintElement(list)
{
  partial = part;
}


void InnerTypeConstraintElement::PrintOn(ostream & strm) const
{
  strm << "WITH COMPONENTS { ";

  if (partial)
    strm << "..., ";

  for (PINDEX i = 0; i < elements.GetSize(); i++) {
    if (i > 0)
      strm << ", ";
    elements[i].PrintOn(strm);
  }

  strm << " }";
}


void InnerTypeConstraintElement::GenerateCplusplus(const string & fn, ostream & hdr, ostream & cxx)
{
  for (PINDEX i = 0; i < elements.GetSize(); i++)
    elements[i].GenerateCplusplus(fn, hdr, cxx);
}

void InnerTypeConstraintElement::checkConstraints ( char typ, bool e, TypeBase * t ) {
    if ( typ != ' ' )
	PError << "inner type constraint with typ " << typ << endl;
  for (PINDEX i = 0; i < elements.GetSize(); i++)
    elements[i].checkConstraints ( 't', e, t );
}


/////////////////////////////////////////////////////////

UserDefinedConstraintElement::UserDefinedConstraintElement(TypesList * t)
{
  if (t != NULL) {
    types = *t;
    delete t;
  }
}


void UserDefinedConstraintElement::PrintOn(ostream & strm) const
{
  strm << "CONSTRAINED BY { ";
  for (PINDEX i = 0; i < types.GetSize(); i++) {
    if (i > 0)
      strm << ", ";
    strm << types[i].GetTypeName();
  }
  strm << " }";
}


void UserDefinedConstraintElement::GenerateCplusplus(const string &, ostream &, ostream &)
{
}

void UserDefinedConstraintElement::checkConstraints ( char typ, bool e, TypeBase * t ) {
//  PError << "user defined constraint with typ " << typ << endl;
//  t -> addConstraint ( typ, this );
// pohoge chto nichego delat ne nado
}

/////////////////////////////////////////////////////////

TypeBase::TypeBase(unsigned tagNum)
  : tag(tagNum), defaultTag(tagNum)
{
  isOptional = FALSE;
  defaultValue = NULL;
  isGenerated = FALSE;
}


TypeBase::TypeBase(TypeBase * copy)
  : name(copy->name),
    identifier(MakeIdentifierC(name)),
    tag(copy->tag),
    defaultTag(copy->tag)
{
  isOptional = copy->isOptional;
  defaultValue = NULL;
  isGenerated = FALSE;
}


PObject::Comparison TypeBase::Compare(const PObject & obj) const
{
  if ( name < ((const TypeBase &)obj).name )
    return LessThan;
  return name >((const TypeBase &)obj).name ? GreaterThan : EqualTo;
}


void TypeBase::PrintOn(ostream & strm) const
{
  PrintStart(strm);
  PrintFinish(strm);
}


void TypeBase::PrintStart(ostream & strm) const
{
  strm << indent();
  if (!name.empty()) {
    strm << name;
    if (!parameters.empty()) {
      strm << " { ";
      for ( list<string>::const_iterator i = parameters.begin(); i != parameters.end ( ); ++ i ) {
        if (i != parameters.begin ( ))
          strm << ", ";
        strm << *i;
      }
      strm << " } ";
    }
    strm << ": ";
  }
  strm << tag << GetClass() << ' ';
  Module->SetIndentLevel(1);
}


void TypeBase::PrintFinish(ostream & strm) const
{
  Module->SetIndentLevel(-1);
  for ( unsigned i = 0; i < constraints.size ( ); i ++ )
    strm << ' ' << constraints [ i ];
  if (isOptional)
    strm << " OPTIONAL";
  if (defaultValue != NULL)
    strm << " DEFAULT " << *defaultValue;
  strm << '\n';
}


int TypeBase::GetIdentifierTokenContext() const
{
  return IDENTIFIER;
}


int TypeBase::GetBraceTokenContext() const
{
  return '{';
}


void TypeBase::SetName(string * newName)
{
  name = *newName;
  delete newName;
  identifier = MakeIdentifierC(name);
}


void TypeBase::AdjustIdentifier( bool )
{
  identifier = Module->GetPrefix() + MakeIdentifierC(name);
}


void TypeBase::SetTag(Tag::Type type, unsigned num, Tag::Mode mode)
{
  tag.type = type;
  tag.number = num;
  tag.mode = mode;
}


void TypeBase::SetParameters(list<string> * list)
{
  parameters = *list;
  delete list;
}


void TypeBase::MoveConstraints(TypeBase * from)
{
  constraints.insert ( constraints.end ( ), from -> constraints.begin ( ), from -> constraints.end ( ) );
  from -> constraints.clear ( );
}


void TypeBase::FlattenUsedTypes()
{
}


TypeBase * TypeBase::FlattenThisType(const TypeBase & parent)
{
  if ( HasConstraints ( ) )
	return new DefinedType(this, parent);
  return this;
}


BOOL TypeBase::IsChoice() const
{
  return FALSE;
}


BOOL TypeBase::IsParameterizedType() const
{
  return FALSE;
}


BOOL TypeBase::IsPrimitiveType() const
{
  return TRUE;
}


void TypeBase::GenerateCplusplus(ostream & hdr, ostream & cxx)
{
  BeginGenerateCplusplus(hdr, cxx);
  // Close off the constructor implementation
  if ( isAsnStandardClass ( ) )
    GenerateCplusplusConstraints(string(), hdr, cxx);
  cxx << " ) { }\n\n"
      << GetTemplatePrefix()
      << GetClassNameString() << " :: " << GetIdentifier() << " ( ) : " << GetTypeName()
      << " ( ) {";
  if ( typeConstraints.size ( ) ) {
    cxx << "\n";
    for ( unsigned i = 0; i < typeConstraints.size ( ); i ++ ) {
	if ( typeConstraints [ i ].e )
	    PError << "extendable typeconstraint " << * typeConstraints [ i ].c << endl;
	const_cast < ConstraintElementBase * > ( typeConstraints [ i ].c ) -> GenerateCplusplus ( "", hdr, cxx );
    }
  } else
    cxx << ' ';
  EndGenerateCplusplus(hdr, cxx);
}


void TypeBase::GenerateForwardDecls(ostream &)
{
}


void TypeBase::GenerateOperators(ostream &, ostream &, const TypeBase &)
{
}


string TypeBase::GetTypeName() const
{
  return GetAncestorClass();
}


BOOL TypeBase::CanReferenceType() const
{
  return FALSE;
}


BOOL TypeBase::ReferencesType(const TypeBase &)
{
  return FALSE;
}


BOOL TypeBase::ReferencesTypeInside(const TypeBase &)
{
  return FALSE;
}


void TypeBase::SetImportPrefix(const string &)
{
}


BOOL TypeBase::IsParameterisedImport() const
{
  return FALSE;
}

bool TypeBase :: isAsnStandardClass ( ) const {
    return true;
}

string TypeBase :: defaultParameters ( ) const {
	return "";
}

string TypeBase :: defaultExplicit ( ) const {
	return "";
}

void TypeBase::BeginGenerateCplusplus(ostream & hdr, ostream & cxx)
{
  classNameString = GetIdentifier();

  if (!parameters.empty()) {
    templatePrefix = "template <";
    classNameString += " <";
    for (list<string> :: const_iterator i = parameters.begin(); i != parameters.end(); i++) {
      if (i != parameters.begin()) {
        templatePrefix += ",";
        classNameString += ",";
      }
      string ident = MakeIdentifierC(*i);
      templatePrefix += " typename " + ident;
      classNameString += " " + ident;
    }
    templatePrefix += " > ";
    classNameString += " >";
  }

  // Output header file declaration of class
  hdr << "//\n"
         "// " << GetName() << "\n"
         "//\n"
         "\n";
  checkConstraints ( ' ' );
  if ( sizeConstraints.size ( ) > 1 ) {
    hdr << "// removing " << sizeConstraints.size ( ) - 1 << " size constraints\n";
    sizeConstraints.erase ( sizeConstraints.begin ( ), sizeConstraints.end ( ) - 1 );
  }
  hdr << "// from " << fromConstraints.size () << " size " << sizeConstraints.size ( )
    << " type " << typeConstraints.size ( ) << " simple " << simpleConstraints.size ( ) << endl;
  GenerateForwardDecls(hdr);
  hdr << templatePrefix
      << "class " << GetIdentifier() << " : public " << GetTypeName() << " {\n"
         "	public:\n"
         "	explicit " << GetIdentifier() << " ( Asn :: istream & is );\n"
	 "	" << defaultExplicit ( ) << GetIdentifier() << " ( " << defaultParameters ( ) << ");\n";
  App & app = (App &)PProcess::Current();
  app.OutputAdditionalHeaders(hdr, GetIdentifier());

  // Output cxx file implementation of class
  cxx << "//\n"
         "// " << GetName() << "\n"
         "//\n"
         "\n"
      << GetTemplatePrefix()
      << GetClassNameString() << " :: " << GetIdentifier() << " ( Asn :: istream & is ) : " << GetTypeName()
      << " ( is";
}


void TypeBase::EndGenerateCplusplus(ostream & hdr, ostream & cxx)
{
  cxx << "}\n"
         "\n";

  GenerateOperators(hdr, cxx, *this);

  // Output header file declaration of class
  hdr << "	" << GetIdentifier() << " * clone ( ) const;\n"
         "};\n"
         "\n";

  // Output cxx file implementation of class
  cxx << GetTemplatePrefix()
      << GetClassNameString() << " * " << GetClassNameString() << " :: clone ( ) const {\n"
         "	return new " << GetIdentifier() << " ( * this );\n"
         "}\n"
         "\n";

  isGenerated = TRUE;
}


void TypeBase::GenerateCplusplusConstructor(ostream & hdr, ostream & cxx)
{
  cxx << "( is";
  if ( isAsnStandardClass ( ) )
    GenerateCplusplusConstraints ( "", hdr, cxx );
  cxx << " )";
}


void TypeBase::GenerateCplusplusConstraints(const string & prefix, ostream & hdr, ostream & cxx)
{

  if ( ! constraints.size ( ) ) {
    cxx << ", Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( )";
    return;
  }
  for (unsigned i = 0; i < constraints.size(); i++)
    constraints[i].GenerateCplusplus("  " + prefix + "SetConstraints(", hdr, cxx);
}

void TypeBase :: addConstraint ( char typ, bool e, const ConstraintElementBase * c ) {
	vector < CheckedConstraint > & vec = typ == 'f' ? fromConstraints :
	    ( typ == 's' ? sizeConstraints : ( typ == 't' ? typeConstraints : simpleConstraints ) );
	vec.push_back ( CheckedConstraint ( c, e ) );
}


void TypeBase::checkConstraints ( char typ ) {
  for (unsigned i = 0; i < constraints.size(); i++)
    constraints[i].checkConstraints ( typ, this );
}

void TypeBase :: noInlines ( ) { }

bool TypeBase :: requiresModuleInclude ( const string & m ) {
	return false;
}

string TypeBase :: getImportPrefix ( ) const {
	return "";
}

/////////////////////////////////////////////////////////

DefinedType::DefinedType(string * name, BOOL parameter)
  : TypeBase(Tag::IllegalUniversalTag),
    referenceName(*name)
{
  delete name;
  baseType = NULL;
  unresolved = !parameter;
}


DefinedType::DefinedType(TypeBase * refType, TypeBase * bType)
  : TypeBase(refType),
    referenceName(bType->GetName())
{
  MoveConstraints(refType);

  baseType = bType;
  unresolved = FALSE;
}


DefinedType::DefinedType(TypeBase * refType, const string & refName)
  : TypeBase(refType)
{
  MoveConstraints(refType);
  ConstructFromType(refType, refName);
}


DefinedType::DefinedType(TypeBase * refType, const TypeBase & parent)
  : TypeBase(refType)
{
  if (!name.empty())
    ConstructFromType(refType, parent.GetName() + '_' + name);
  else
    ConstructFromType(refType, parent.GetName() + "_subtype");
}


void DefinedType::ConstructFromType(TypeBase * refType, const string & name)
{
  referenceName = name;
  refType->SetName(new string(name));

  Module->AppendType(refType);

  baseType = refType;
  unresolved = FALSE;
}


void DefinedType::PrintOn(ostream & strm) const
{
  PrintStart(strm);
  strm << referenceName << ' ';
  PrintFinish(strm);
}


BOOL DefinedType::CanReferenceType() const
{
  return TRUE;
}


BOOL DefinedType::IsChoice() const
{
  if (baseType != NULL)
    return baseType->IsChoice();
  return FALSE;
}


BOOL DefinedType::IsParameterizedType() const
{
  if (baseType != NULL)
    return baseType->IsParameterizedType();
  return FALSE;
}

void DefinedType :: resolve ( ) {
  if (unresolved) {
    unresolved = FALSE;

    if ((baseType = Module->FindType(referenceName)) == NULL)
      PError << StdError(Warning) << "unresolved symbol: " << referenceName << endl;
    else {
      if (!HasNonStandardTag())
        defaultTag = tag = baseType->GetTag();
    }
  }
}
BOOL DefinedType::ReferencesTypeInside(const TypeBase & type)
{
  resolve ( );
  if ( type.GetName() == referenceName )
    return true;
  return ( baseType && baseType -> ReferencesTypeInside ( type ) );
}


BOOL DefinedType::ReferencesType(const TypeBase & type)
{
  resolve ( );
  if ( ! Module -> checkReferencesType ( this ) )
    return false;
  if ( type.GetName() == referenceName )
    return true;
  return false;
}


void DefinedType::GenerateOperators(ostream & hdr, ostream & cxx, const TypeBase & actualType)
{
  if (baseType != NULL)
    baseType->GenerateOperators(hdr, cxx, actualType);
}


const char * DefinedType::GetAncestorClass() const
{
  if (baseType != NULL)
    return baseType->GetAncestorClass();
  return NULL;
}


string DefinedType::GetTypeName() const
{
  if (baseType == NULL)
    return referenceName;

  if (HasConstraints() && baseType->IsPrimitiveType())
    return baseType->GetTypeName();

  return baseType->GetIdentifier();
}

TypeBase * DefinedType::FlattenThisType(const TypeBase & parent)
{

  resolve ( );
  if ( HasConstraints ( )  ){
    if ( baseType && baseType->IsPrimitiveType() ) {
	baseType = baseType -> Clone ( );
	baseType -> SetName ( new string ( name ) );
	baseType -> MoveConstraints ( this );
	return new DefinedType(baseType, parent);
    } else
	PError << "cannot flatten defined type " << GetTypeName () << endl;
  }
  return this;
}

bool DefinedType :: isAsnStandardClass ( ) const {
    if ( baseType && HasConstraints() && baseType->IsPrimitiveType() )
	return baseType -> isAsnStandardClass ( );
    return false;
}

TypeBase * DefinedType :: Clone ( ) const {
    return new DefinedType ( *this );
}

void DefinedType :: noInlines ( ) {
    if ( baseType )
	baseType -> noInlines ( );
}

bool DefinedType :: requiresModuleInclude ( const string & m ) {
  resolve ( );
  if ( ! baseType ) {
    PError << "requiresModuleInclude on " << GetIdentifier ( ) << " : no baseType\n";
    return false;
  }
  return baseType -> getImportPrefix ( ) == m;
}

/////////////////////////////////////////////////////////

ParameterizedType::ParameterizedType(string * name, TypesList * args)
  : DefinedType(name, FALSE),
    arguments(*args)
{
  delete args;
}


void ParameterizedType::PrintOn(ostream & strm) const
{
  PrintStart(strm);
  strm << referenceName << " { ";
  for (PINDEX i = 0; i < arguments.GetSize(); i++) {
    if (i > 0)
      strm << ", ";
    strm << arguments[i].GetTypeName();
  }
  strm << " }";
  PrintFinish(strm);
}


BOOL ParameterizedType::IsParameterizedType() const
{
  return TRUE;
}


BOOL ParameterizedType::ReferencesType(const TypeBase & type)
{
  for (PINDEX i = 0; i < arguments.GetSize(); i++) {
    if (arguments[i].ReferencesType(type))
      return TRUE;
  }

  return DefinedType::ReferencesType(type);
}


BOOL ParameterizedType::ReferencesTypeInside(const TypeBase & type)
{
  for (PINDEX i = 0; i < arguments.GetSize(); i++) {
    if (arguments[i].ReferencesType(type))
      return TRUE;
  }

  return DefinedType::ReferencesTypeInside(type);
}


string ParameterizedType::GetTypeName() const
{
  string typeName = DefinedType::GetTypeName();
  if (!arguments.IsEmpty()) {
    typeName += " < ";
    for (PINDEX i = 0; i < arguments.GetSize(); i++) {
      if (i > 0)
        typeName += ", ";
      typeName += arguments[i].GetTypeName();
    }
    typeName += " >";
  }
  return typeName;
}

TypeBase * ParameterizedType::FlattenThisType(const TypeBase & parent) {
  if ( HasConstraints ( ) )
    PError << "flatten parametrized type " << GetTypeName ( ) << endl;
  return this;
}

TypeBase * ParameterizedType :: Clone ( ) const {
    return new ParameterizedType ( *this );
}


/////////////////////////////////////////////////////////

SelectionType::SelectionType(string * name, TypeBase * base)
  : TypeBase(Tag::IllegalUniversalTag),
    selection(*name)
{
  delete name;
  baseType = PAssertNULL(base);
}


SelectionType::~SelectionType()
{
  delete baseType;
}


void SelectionType::PrintOn(ostream & strm) const
{
  PrintStart(strm);
  strm << selection << '<' << *baseType;
  PrintFinish(strm);
}


void SelectionType::FlattenUsedTypes()
{
  baseType = baseType->FlattenThisType(*this);
  PError << "SelectionType used\n";
}


TypeBase * SelectionType::FlattenThisType(const TypeBase & parent)
{
  PError << "SelectionType used\n";
  return new DefinedType(this, parent);
}


void SelectionType::GenerateCplusplus(ostream &, ostream &)
{
  PError << StdError(Fatal) << "Cannot generate code for Selection type" << endl;
  isGenerated = TRUE;
}


const char * SelectionType::GetAncestorClass() const
{
  return "";
}


BOOL SelectionType::CanReferenceType() const
{
  return TRUE;
}


BOOL SelectionType::ReferencesType(const TypeBase & type)
{
  return baseType->ReferencesType(type);
}

TypeBase * SelectionType :: Clone ( ) const {
    return new SelectionType ( *this );
}


/////////////////////////////////////////////////////////

BooleanType::BooleanType()
  : TypeBase(Tag::UniversalBoolean)
{
}


void BooleanType::GenerateOperators(ostream & hdr, ostream & cxx, const TypeBase & actualType)
{
  hdr << "	" << actualType.GetIdentifier() << " & operator= ( bool v )";
  if (Module->UsingInlines())
    hdr << " {\n"
      "		Asn :: Boolean :: operator= ( v );\n"
      "		return * this;\n"
      "	}\n";
  else {
    hdr << ";\n";
    cxx << actualType.GetTemplatePrefix()
        << actualType.GetIdentifier() << " & "
        << actualType.GetClassNameString() << " :: operator= ( bool v ) {\n"
           "	Asn :: Boolean :: operator= ( v );\n"
           "	return * this;\n"
           "}\n"
           "\n"
           "\n";
  }
}


const char * BooleanType::GetAncestorClass() const
{
  return "Asn :: Boolean";
}


void BooleanType::GenerateCplusplus(ostream & hdr, ostream & cxx)
{
  BeginGenerateCplusplus(hdr, cxx);
  // Close off the constructor implementation
  cxx << " ) {\n";

  EndGenerateCplusplus(hdr, cxx);
}


void BooleanType :: GenerateCplusplusConstraints(const string &, ostream &, ostream &) {
  return;
}


TypeBase * BooleanType :: Clone ( ) const {
    return new BooleanType ( *this );
}


/////////////////////////////////////////////////////////

IntegerType::IntegerType()
  : TypeBase(Tag::UniversalInteger)
{
}


IntegerType::IntegerType(NamedNumberList * lst)
  : TypeBase(Tag::UniversalInteger),
    allowedValues(*lst)
{
  delete lst;
}

string IntegerType :: defaultParameters ( ) const {
	return "unsigned v = 0 ";
}

void IntegerType::GenerateOperators(ostream & hdr, ostream & cxx, const TypeBase & actualType)
{
  hdr << "	" << actualType.GetIdentifier() << " & operator= ( int v )";
  if (Module->UsingInlines())
    hdr << " {\n"
      "		Asn :: Integer :: operator= ( v );\n"
      "		return * this;\n"
      "	}\n";
  else {
    hdr << ";\n";
    cxx << actualType.GetTemplatePrefix()
        << actualType.GetIdentifier() << " & "
        << actualType.GetClassNameString() << " :: operator= ( int v ) {\n"
           "	Asn :: Integer :: operator= ( v );\n"
           "	return * this;\n"
           "}\n"
           "\n"
           "\n";
  }

  hdr << "	" << actualType.GetIdentifier() << " & operator= ( unsigned v )";
  if (Module->UsingInlines())
    hdr << " {\n"
      "		Asn :: Integer :: operator= ( v );\n"
      "		return * this;\n"
      "	}\n";
  else {
    hdr << ";\n";
    cxx  << actualType.GetTemplatePrefix()
        << actualType.GetIdentifier() << " & "
        << actualType.GetClassNameString() << " :: operator= ( unsigned v ) {\n"
           "	Asn :: Integer :: operator = ( v );\n"
           "	return * this;\n"
           "}\n"
           "\n"
           "\n";
  }
}

void IntegerType::GenerateCplusplusConstraints(const string & prefix, ostream & hdr, ostream & cxx)
{
  if ( sizeConstraints.size ( ) || typeConstraints.size ( ) || fromConstraints.size ( ) || simpleConstraints.size ( ) > 1 )
    PError << "unsupported integer contraints\n";
  if ( ! allowedValues.IsEmpty ( ) ) {
    for ( int i = 0; i < allowedValues.GetSize ( ); i ++ )
      if ( ! allowedValues [ i ].getReference ( ).empty ( ) )
	PError << "unsupported allowed value reference  " << allowedValues [ i ]  << std :: endl;
  }
  if ( ! simpleConstraints.size ( ) ) {
    cxx << ", Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( )";
    return;
  }
  cxx << ", Asn :: " << ( simpleConstraints [ 0 ].e ? "extendableConstraint" : "fixedConstraint" );
  const_cast < ConstraintElementBase * > ( simpleConstraints [ 0 ].c ) -> GenerateCplusplus ( "", hdr, cxx );
}


void IntegerType::GenerateCplusplus(ostream & hdr, ostream & cxx)
{
  BeginGenerateCplusplus(hdr, cxx);
  if ( ! allowedValues.IsEmpty ( ) ) {
    hdr << "	enum AllowedValues {\n";
    int prevNum = - 1;
    for ( int i = 0; i < allowedValues.GetSize ( ); i ++ ) {
      const NamedNumber & n = allowedValues [ i ];
      hdr << "		e_" << MakeIdentifierC ( n.GetName ( ) );
      int num = n.GetNumber ( );
      if ( ! n.getAutonumber ( ) && num != prevNum + 1 )
	hdr << " = " << num;
      prevNum = num;
      if ( i != allowedValues.GetSize ( ) - 1 )
        hdr << ',';
      hdr << '\n';
    }
    hdr << "	};\n";
  }

  // Close off the constructor implementation
  GenerateCplusplusConstraints(string(), hdr, cxx);
  cxx << " ) { }\n\n"
      << GetTemplatePrefix()
      << GetClassNameString() << " :: " << GetIdentifier() << " ( unsigned v ) : " << GetTypeName() << " ( v";
  GenerateCplusplusConstraints(string(), hdr, cxx);
  cxx << " ) { ";

  EndGenerateCplusplus(hdr, cxx);
}


const char * IntegerType::GetAncestorClass() const
{
  return "Asn :: Integer";
}


TypeBase * IntegerType :: Clone ( ) const {
    return new IntegerType ( *this );
}

/////////////////////////////////////////////////////////

EnumeratedType::EnumeratedType(NamedNumberList * enums, BOOL extend, NamedNumberList * ext)
  : TypeBase(Tag::UniversalEnumeration),
    enumerations(*enums)
{
  numEnums = enums->GetSize();
  delete enums;
  extendable = extend;
  if (ext != NULL) {
    ext->DisallowDeleteObjects();
    for (PINDEX i = 0; i < ext->GetSize(); i++)
      enumerations.Append(ext->GetAt(i));
    delete ext;
  }
}


void EnumeratedType::PrintOn(ostream & strm) const
{
  PrintStart(strm);
  strm << '\n';
  PINDEX i;
  for (i = 0; i < numEnums; i++)
    strm << indent() << enumerations[i] << '\n';
  if (extendable) {
    strm << "...\n";
    for (; i < enumerations.GetSize(); i++)
      strm << indent() << enumerations[i] << '\n';
  }
  PrintFinish(strm);
}


TypeBase * EnumeratedType::FlattenThisType(const TypeBase & parent)
{
  return new DefinedType(this, parent);
}


void EnumeratedType::GenerateCplusplus(ostream & hdr, ostream & cxx)
{
  PINDEX i;

  BeginGenerateCplusplus(hdr, cxx);

  int maxEnumValue = 0;
  for (i = 0; i < enumerations.GetSize(); i++) {
    int num = enumerations[i].GetNumber();
    if (maxEnumValue < num)
      maxEnumValue = num;
  }

  // Generate enumerations and complete the constructor implementation
  hdr << "	enum Enumerations {\n";
  cxx << ", " << maxEnumValue << ", " << (extendable ? "true" : "false") << " ) { }\n\n"
      << GetTemplatePrefix()
      << GetClassNameString() << " :: " << GetIdentifier() << " ( ) : " << GetTypeName() << " ( e_"
      << MakeIdentifierC(enumerations[0].GetName()) << ", " << maxEnumValue << ", "
      << (extendable ? "true" : "false") << " ) { }\n\n"
	 "const Asn :: NamesMapType & " << GetClassNameString() << " :: getNames ( ) const {\n"
         "	static Asn :: NamesPair namePairs [ ] = {";

  int prevNum = -1;
  for (i = 0; i < enumerations.GetSize(); i++) {
    if (i > 0) {
      hdr << ",\n";
      cxx << ",\n";
    } else
      cxx << '\n';
    string nameC = MakeIdentifierC(enumerations[i].GetName());
    cxx << "		{ e_" << nameC << ", \"" << nameC << "\" }";
    hdr << "		e_" << nameC;
    int num = enumerations[i].GetNumber();
    if (num != prevNum+1) {
      hdr << " = " << num;
    }
    prevNum = num;
  }
  if ( i )
    cxx << "\n	";
  else
    cxx << ' ';
  cxx << "};\n"
	 "	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );\n"
	 "	return namesMap;\n";

  hdr << "\n"
         "	};\n"
         "\n"
	 "	protected:\n"
	 "	const Asn :: NamesMapType & getNames ( ) const;\n"
	 "	public:\n";

  EndGenerateCplusplus(hdr, cxx);
}


void EnumeratedType::GenerateOperators(ostream & hdr, ostream & cxx, const TypeBase & actualType)
{
  hdr << "	" << actualType.GetIdentifier() << " & operator= ( unsigned v )";
  if (Module->UsingInlines())
    hdr << " {\n"
      "		Asn :: Enumeration :: operator= ( v );\n"
      "		return * this;\n"
      "	}\n";
  else {
    hdr << ";\n";
    cxx << actualType.GetTemplatePrefix()
        << actualType.GetIdentifier() << " & "
        << actualType.GetClassNameString() << " :: operator= ( unsigned v ) {\n"
           "	Asn :: Enumeration :: operator= ( v );\n"
           "	return * this;\n"
           "}\n"
           "\n"
           "\n";
  }
}


const char * EnumeratedType::GetAncestorClass() const
{
  return "Asn :: Enumeration";
}

TypeBase * EnumeratedType :: Clone ( ) const {
    return new EnumeratedType ( *this );
}


/////////////////////////////////////////////////////////

RealType::RealType()
  : TypeBase(Tag::UniversalReal)
{
}


const char * RealType::GetAncestorClass() const
{
  return "Asn :: Real";
}


TypeBase * RealType :: Clone ( ) const {
    return new RealType ( *this );
}


/////////////////////////////////////////////////////////

BitStringType::BitStringType()
  : TypeBase(Tag::UniversalBitString)
{
}


BitStringType::BitStringType(NamedNumberList * lst)
  : TypeBase(Tag::UniversalBitString),
    allowedBits(*lst)
{
  delete lst;
}

int BitStringType::GetIdentifierTokenContext() const
{
  return OID_IDENTIFIER;
}


int BitStringType::GetBraceTokenContext() const
{
  return BITSTRING_BRACE;
}

void BitStringType::GenerateCplusplusConstraints(const string & prefix, ostream & hdr, ostream & cxx)
{
  if ( simpleConstraints.size ( ) || typeConstraints.size ( ) || fromConstraints.size ( ) || sizeConstraints.size ( ) > 1 )
    PError << "unsupported bitstring contraints\n";
  if ( ! allowedBits.IsEmpty ( ) )
    PError << "unsupported allowed values\n";
  if ( ! sizeConstraints.size ( ) ) {
    cxx << ", Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( )";
    return;
  }
  cxx << ", Asn :: " << ( sizeConstraints [ 0 ].e ? "extendableConstraint" : "fixedConstraint" );
    const_cast < ConstraintElementBase * > ( sizeConstraints [ 0 ].c ) -> GenerateCplusplus ( "", hdr, cxx );
}

string BitStringType :: defaultParameters ( ) const {
	return "const Asn :: string & v = Asn :: string ( ), unsigned b = 0 ";
}

void BitStringType::GenerateCplusplus(ostream & hdr, ostream & cxx)
{
  BeginGenerateCplusplus(hdr, cxx);

  // Close off the constructor implementation
  GenerateCplusplusConstraints(string(), hdr, cxx);
  cxx << " ) { }\n\n"
      << GetTemplatePrefix()
      << GetClassNameString() << " :: " << GetIdentifier() << " ( const Asn :: string & v, unsigned b ) : " << GetTypeName() << " ( b ? : unsigned ( v.size ( ) * 8 ), v";
  GenerateCplusplusConstraints(string(), hdr, cxx);
  cxx << " ) {\n";

  EndGenerateCplusplus(hdr, cxx);
}


const char * BitStringType::GetAncestorClass() const
{
  return "Asn :: BitString";
}

TypeBase * BitStringType :: Clone ( ) const {
    return new BitStringType ( *this );
}

/////////////////////////////////////////////////////////

OctetStringType::OctetStringType()
  : TypeBase(Tag::UniversalOctetString)
{
}


void OctetStringType::GenerateOperators(ostream & hdr, ostream & cxx, const TypeBase & actualType)
{
  hdr << "	" << actualType.GetIdentifier() << " & operator= ( const Asn :: string & v )";
  if (Module->UsingInlines())
    hdr << " {\n"
	"		Asn :: OctetString :: operator= ( v );\n"
	"		return *this;\n"
	"	}\n";
  else {
    hdr << ";\n";
    cxx << actualType.GetTemplatePrefix()
        << actualType.GetIdentifier() << " & "
        << actualType.GetClassNameString() << " :: operator= ( const Asn :: string & v ) {\n"
           "	Asn :: OctetString :: operator= ( v );\n"
           "	return * this;\n"
           "}\n"
           "\n";
  }
}


const char * OctetStringType::GetAncestorClass() const
{
  return "Asn :: OctetString";
}

TypeBase * OctetStringType :: Clone ( ) const {
    return new OctetStringType ( *this );
}


void OctetStringType::GenerateCplusplusConstraints(const string & prefix, ostream & hdr, ostream & cxx)
{
  if ( simpleConstraints.size ( ) || typeConstraints.size ( ) || fromConstraints.size ( ) || sizeConstraints.size ( ) > 1 )
    PError << "unsupported octetstring contraints\n";
  if ( ! sizeConstraints.size ( ) ) {
    cxx << ", Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( )";
    return;
  }
  cxx << ", Asn :: " << ( sizeConstraints [ 0 ].e ? "extendableConstraint" : "fixedConstraint" );
    const_cast < ConstraintElementBase * > ( sizeConstraints [ 0 ].c ) -> GenerateCplusplus ( "", hdr, cxx );
}

string OctetStringType :: defaultParameters ( ) const {
	return "const Asn :: string & v = Asn :: string ( ) ";
}

void OctetStringType::GenerateCplusplus(ostream & hdr, ostream & cxx)
{
  BeginGenerateCplusplus(hdr, cxx);

  // Close off the constructor implementation
  GenerateCplusplusConstraints(string(), hdr, cxx);
  cxx << " ) { }\n\n"
      << GetTemplatePrefix()
      << GetClassNameString() << " :: " << GetIdentifier() << " ( const Asn :: string & v ) : " << GetTypeName() << " ( v";
  GenerateCplusplusConstraints(string(), hdr, cxx);
  cxx << " ) { ";

  EndGenerateCplusplus(hdr, cxx);
}


/////////////////////////////////////////////////////////

NullType::NullType()
  : TypeBase(Tag::UniversalNull)
{
}


const char * NullType::GetAncestorClass() const
{
  return "Asn :: Null";
}


void NullType :: GenerateCplusplusConstraints(const string &, ostream &, ostream &) {
  return;
}

TypeBase * NullType :: Clone ( ) const {
    return new NullType ( *this );
}


/////////////////////////////////////////////////////////

SequenceType::SequenceType(TypesList * stnd,
                           BOOL extend,
                           TypesList * ext,
                           unsigned tagNum)
  : TypeBase(tagNum)
{
  if (stnd != NULL) {
    numFields = stnd->GetSize();
    fields = *stnd;
    delete stnd;
  }
  else
    numFields = 0;
  extendable = extend;
  if (ext != NULL) {
    ext->DisallowDeleteObjects();
    for (PINDEX i = 0; i < ext->GetSize(); i++)
      fields.Append(ext->GetAt(i));
    delete ext;
  }
}


void SequenceType::PrintOn(ostream & strm) const
{
  PrintStart(strm);
  strm << '\n';
  PINDEX i;
  for (i = 0; i < numFields; i++)
    strm << fields[i];
  if (extendable) {
    strm << indent() << "...\n";
    for (; i < fields.GetSize(); i++)
      strm << fields[i];
  }
  PrintFinish(strm);
}


void SequenceType::FlattenUsedTypes()
{
  for (PINDEX i = 0; i < fields.GetSize(); i++)
    fields.SetAt(i, fields[i].FlattenThisType(*this));
}


TypeBase * SequenceType::FlattenThisType(const TypeBase & parent)
{
  return new DefinedType(this, parent);
}


BOOL SequenceType::IsPrimitiveType() const
{
  return FALSE;
}


void SequenceType::GenerateForwardDecls(ostream & hdr)
{
  // Output forward declarations for choice pointers, but not standard classes
  BOOL needExtraLine = FALSE;

  for (PINDEX i = 0; i < fields.GetSize(); i++) {
    string type = fields[i].GetTypeName();
    if (!fields[i].IsParameterizedType() && ( i >= numFields || fields [ i ].IsOptional ( ) )
      && Module -> generateForwardDecl ( type ) ) {
      hdr << "class " << type << ";\n";
      needExtraLine = TRUE;
    }
  }

  if (needExtraLine)
    hdr << '\n';
}

void SequenceType::GenerateCplusplus(ostream & hdr, ostream & cxx)
{
  PINDEX i;

  BeginGenerateCplusplus(hdr, cxx);
  if ( sizeConstraints.size ( ) || fromConstraints.size ( ) || typeConstraints.size ( ) || simpleConstraints.size ( ) )
    PError << "unsupported sequence constraints\n";
  PINDEX baseOptions = 0;
  for (i = 0; i < fields.GetSize(); i++) {
    if (i < numFields && fields[i].IsOptional())
      baseOptions++;
  }
  if ( baseOptions > 32 )
    PError << "sequence " << GetIdentifier ( ) << " has " << baseOptions << " base optional fields\n";
  if ( fields.GetSize() - numFields > 32 )
    PError << "sequence " << GetIdentifier ( ) << " has " << fields.GetSize() - numFields << " extension fields\n";
  BOOL outputEnum = FALSE;
  for (i = 0; i < fields.GetSize(); i++) {
    if (i >= numFields || fields[i].IsOptional()) {
      if (outputEnum)
        hdr << ",\n";
      else {
        hdr << "	enum OptionalFields {\n";
        outputEnum = TRUE;
      }
      hdr << "		e_" << fields[i].GetIdentifier();
    }
  }
  // Complete ancestor constructor parameters
  cxx << ", " << baseOptions << ", "
      << (extendable ? "true" : "false") << ", "
      << fields.GetSize() - numFields
      << " )";
//  if ( GetIdentifier ( ) == "CryptoH323Token_cryptoGKPwdHash" )
//    PError << "break\n";
  int afterLastOptional = 0;
  for ( i = 0; i < numFields; i ++ )
    if ( ! fields [ i ].IsOptional ( ) )
      afterLastOptional = i + 1;
  bool hasPushed = false;
  for ( i = 0; i < afterLastOptional; i ++ ) {
    TypeBase & f = fields [ i ];
    cxx << ", m_" << f.GetIdentifier() << " ";
    if ( f.IsOptional ( ) ) {
	cxx << "( hasOptionalField ( e_" << f.GetIdentifier() << " ) ? pushTemporaryMember ( new " << f.GetTypeName ( ) << " ";
	f.GenerateCplusplusConstructor ( hdr, cxx );
	cxx << " ) : 0 )";
	hasPushed = true;
    } else
      f.GenerateCplusplusConstructor ( hdr, cxx );
  }
  for ( i = afterLastOptional; i < fields.GetSize ( ); i ++ )
    cxx << ", m_" << fields[i].GetIdentifier() << " ( 0 )";
  cxx << " {\n";
  if ( hasPushed )
    cxx << "	clearTemporaryMembers ( );\n";
  bool tryNeeded = outputEnum && ( extendable ||
    ( afterLastOptional < fields.GetSize ( ) && ( hasPushed || afterLastOptional + 1 < fields.GetSize ( ) ) ) );
  if ( tryNeeded )
    cxx << "	try {\n";
  for ( i = afterLastOptional; i < numFields; i ++ ) {
    TypeBase & f = fields [ i ];
    cxx << ( tryNeeded ? "	" : "" ) << "	if ( hasOptionalField ( e_" << f.GetIdentifier() << " ) )\n" <<
	   ( tryNeeded ? "	" : "" ) << "		m_" << f.GetIdentifier() << " = new " <<
	   f.GetTypeName ( ) << " ";
    f.GenerateCplusplusConstructor ( hdr, cxx );
    cxx << ";\n";
  }
  if ( extendable ) {
    if ( outputEnum )
      cxx << "	";
    cxx << "	if ( extensionMapDecode ( is ) )";
    if ( numFields < fields.GetSize ( ) )
      cxx << " {";
    cxx << '\n';
    for ( i = numFields; i < fields.GetSize ( ); i ++ ) {
      TypeBase & f = fields [ i ];
      string name = f.GetIdentifier();
      cxx << "			if ( hasKnownExtensionToDecode ( is, e_" << name << " ) )\n"
	     "				m_" << name << " = new " << f.GetTypeName ( ) << " ( is );\n";
    }
    if ( outputEnum )
      cxx << "	";
    cxx << "		unknownExtensionsDecode ( is );\n";
    if ( numFields < fields.GetSize ( ) )
      cxx << "		}\n";
  }
  if ( tryNeeded ) {
    cxx << "	} catch ( ... ) {\n";
    for ( i = 0; i < fields.GetSize ( ); i ++ )
      if ( i >= numFields || fields[i].IsOptional ( ) )
        cxx << "		delete m_" << fields[i].GetIdentifier() << ";\n";
    cxx << "		throw;\n"
	   "	}\n";
  }
  cxx << "}\n\n";

  // Output enum for optional parameters

  if (outputEnum)
    hdr << "\n"
           "	};\n"
           "\n"
           "	" << GetIdentifier ( ) << " ( const " << GetIdentifier ( ) << " & s );\n"
           "	" << GetIdentifier ( ) << " & operator= ( const " << GetIdentifier ( ) << " & s );\n"
           "	void includeOptionalField ( OptionalFields f );\n"
	   "	void removeOptionalField ( OptionalFields f );\n";
  // Output the declarations and constructors for member variables
  bool currentIsPublic = true;
  for (i = 0; i < fields.GetSize(); i++) {
    bool isPointer = i >= numFields || fields [ i ].IsOptional ( );
    string varname = "m_" + fields[i].GetIdentifier();
    if ( isPointer ) {
	if ( currentIsPublic ) {
	    hdr << "	protected:\n";
	    currentIsPublic = false;
	}
    } else {
	if ( ! currentIsPublic ) {
	    hdr << "	public:\n";
	    currentIsPublic = true;
	}
    }
    hdr << "	" << fields[i].GetTypeName() << ' ';
    if ( isPointer )
	hdr << "* ";
    hdr << varname << ";\n";
  }
  if ( ! currentIsPublic )
    hdr << "	public:\n";
  // Output declarations for generated functions
  hdr << "	void encode ( Asn :: ostream & os ) const;\n";
  if ( outputEnum )
    hdr << "	~" << GetIdentifier ( ) << " ( );\n";
  hdr << "	void printOn ( std :: ostream & os ) const;\n";

  cxx << GetTemplatePrefix ( ) <<
	GetClassNameString() << " :: " << GetIdentifier ( ) << " ( ) : " << GetAncestorClass ( ) << " ( " <<
	baseOptions << ", " << (extendable ? "true" : "false") << ", " << fields.GetSize() - numFields << " )";
  bool hasNonOptionalExtensions = false;
  for ( i = 0; i < fields.GetSize ( ); i ++ ) {
    TypeBase & f = fields [ i ];
    if ( i < numFields && ! f.IsOptional ( ) )
	continue;
    cxx << ", m_" << f.GetIdentifier() << " ( 0 )";
    if ( ! f.IsOptional ( ) )
      hasNonOptionalExtensions = true;
  }
  if ( hasNonOptionalExtensions ) {
    cxx << " {\n"
	   "	try {\n";
    for ( i = numFields; i < fields.GetSize ( ); i ++ ) {
      TypeBase & f = fields [ i ];
      if ( ! f.IsOptional ( ) )
	cxx << "		" << GetAncestorClass ( ) << " :: includeOptionalField ( e_" << f.GetIdentifier ( ) << " );\n"
	       "		m_" << f.GetIdentifier() << " = new " << f.GetTypeName ( ) << ";\n";
    }
    cxx << "	} catch ( ... ) {\n";
    for ( i = numFields; i < fields.GetSize ( ); i ++ ) {
      TypeBase & f = fields [ i ];
      if ( ! f.IsOptional ( ) )
	cxx << "		delete m_" << f.GetIdentifier() << ";\n";
    }
    cxx << "		throw;\n"
	   "	}\n"
	   "}\n\n";
  } else
    cxx << " { }\n\n";

  if ( outputEnum ) {
    cxx << GetTemplatePrefix ( ) <<
	   GetClassNameString ( ) << " & " << GetClassNameString ( ) << " :: operator= ( const " <<
	     GetIdentifier ( ) << " & s ) {\n"
	   "	" << GetAncestorClass ( ) << " :: operator= ( s );\n";
    for ( i = 0; i < fields.GetSize ( ); i ++ ) {
      TypeBase & f = fields [ i ];
      string name = f.GetIdentifier ( );
      if ( i < numFields && ! f.IsOptional ( ) ) {
        cxx << "	m_" << name << " = s.m_" << name << ";\n";
        continue;
      }
      cxx << "	assignCopy ( m_" << name << ", s.m_" << name << " );\n";
    }
    cxx << "	return * this;\n"
	   "}\n"
	   "\n"
	   << GetTemplatePrefix ( ) <<
	   GetClassNameString() << " :: " << GetIdentifier ( ) << " ( const " << GetIdentifier ( )
	   << " & s ) : " << GetAncestorClass ( ) << " ( s )";
    for ( i = 0; i < fields.GetSize ( ); i ++ ) {
      cxx << ", m_" << fields[i].GetIdentifier() << " ( ";
      if ( i >= numFields || fields[i].IsOptional() )
        cxx << "0 )";
      else
        cxx << "s.m_" << fields[i].GetIdentifier() << " )";
    }
    cxx << " {\n"
           "	try {\n";
    for ( i = 0; i < fields.GetSize ( ); i ++ ) {
      if ( i >= numFields || fields [ i ].IsOptional ( ) )
	  cxx << "		if ( s.m_" << fields[i].GetIdentifier() << " )\n"
		 "			m_" << fields[i].GetIdentifier() << " = new " << fields[i].GetTypeName ( ) << " ( * s.m_" << fields[i].GetIdentifier() << " );\n";
    }

    cxx << "	} catch ( ... ) {\n";
    for ( i = 0; i < fields.GetSize ( ); i ++ ) {
      if ( i >= numFields || fields [ i ].IsOptional ( ) )
	cxx << "		delete m_" << fields[i].GetIdentifier() << ";\n";
    }
    cxx << "		throw;\n"
	   "	}\n"
	   "}\n"
	   "\n"
	   "\n";
    cxx << GetTemplatePrefix()
      << "void " << GetClassNameString() << " :: includeOptionalField ( OptionalFields f ) {\n"
      "	switch ( f ) {\n";
    for (i = 0; i < fields.GetSize(); i++) {
	if (i < numFields && !fields[i].IsOptional ( ))
	    continue;
	string name = fields[i].GetIdentifier();
        cxx << "		case e_" << name << ":\n"
	       "			assignNew ( m_" << name << ", new " << fields[i].GetTypeName ( ) << " );\n"
	       "			break;\n";
    }
    cxx << "		default:\n"
	   "			throw std :: out_of_range ( \"unknown optional field\" );\n"
	   "	}\n"
	   "	" << GetAncestorClass ( ) << " :: includeOptionalField ( f );\n"
	   "}\n\n";

    cxx << GetTemplatePrefix()
      << "void " << GetClassNameString() << " :: removeOptionalField ( OptionalFields f ) {\n"
      "	" << GetAncestorClass ( ) << " :: removeOptionalField ( f );\n"
      "	switch ( f ) {\n";
    for (i = 0; i < fields.GetSize(); i++) {
	if (i < numFields && !fields[i].IsOptional ( ))
	    continue;
	string name = fields[i].GetIdentifier();
        cxx << "		case e_" << name << ":\n"
	       "			delete m_" << name << ";\n"
	       "			m_" << name << " = 0;\n"
	       "			break;\n";
	hdr << "	const " << fields[i].GetTypeName ( ) << " & get_" << name << " ( ) const {\n"
	       "		return * m_" << name << ";\n"
	       "	}\n"
	       "	" << fields[i].GetTypeName ( ) << " & get_" << name << " ( ) {\n"
	       "		return * m_" << name << ";\n"
	       "	}\n";
    }
    cxx << "		default:\n"
	   "			throw std :: out_of_range ( \"unknown optional field\" );\n"
	   "	}\n"
	   "}\n\n";
  }

  cxx << GetTemplatePrefix()
      << "void " << GetClassNameString() << " :: encode ( Asn :: ostream & os ) const {\n"
         "	preambleEncode ( os );\n";

  for (i = 0; i < numFields; i++) {
    if (fields[i].IsOptional())
      cxx << "	if ( hasOptionalField ( e_" << fields[i].GetIdentifier() << " ) )\n"
             "	";
    cxx << "	m_" << fields[i].GetIdentifier();
    if ( fields [ i ].IsOptional ( ) )
      cxx << " -> " << fields[i].GetTypeName ( ) << " :: ";
    else
      cxx << '.';
    cxx << "encode ( os );\n";
  }

  if ( extendable ) {
    cxx << "	if ( extensionMapEncode ( os ) )";
    if ( numFields < fields.GetSize ( ) )
      cxx << " {";
    cxx << '\n';
    for ( i = numFields; i < fields.GetSize(); i++) {
      const string & id = fields[i].GetIdentifier();
      cxx << "		knownExtensionEncode ( os, e_" << id << ", m_" << id << " );\n";
    }
    cxx << "		unknownExtensionsEncode ( os );\n";
    if ( numFields < fields.GetSize ( ) )
      cxx << "	}\n";
  }
  if ( outputEnum ) {
    cxx << "}\n\n"
      << GetTemplatePrefix ( ) << GetClassNameString( ) << " :: ~" << GetIdentifier ( ) << " ( ) {\n";
    for (i = 0; i < fields.GetSize(); i++) {
      if ( i >= numFields || fields [ i ].IsOptional ( ) )
	cxx << "	delete m_" << fields[i].GetIdentifier ( ) << ";\n";
    }
  }
  cxx << "}\n\n"
    << GetTemplatePrefix ( ) << "void " << GetClassNameString( ) << " :: printOn ( std :: ostream & os ) const {\n"
    "	int indent = int ( os.precision ( ) + 2 );\n"
    "	os << \"{\\n\";\n";
  for (i = 0; i < fields.GetSize ( ); i++) {
    if ( i >= numFields || fields[i].IsOptional())
      cxx << "	if ( hasOptionalField ( e_" << fields[i].GetIdentifier() << " ) ) {\n"
             "	";
    cxx << "	os << std :: setw ( indent + " << fields[i].GetIdentifier().size ( ) + 3 << " ) << \"" <<
      fields[i].GetIdentifier() << " = \" << std :: setprecision ( indent )";
    if ( i >= numFields || fields[i].IsOptional() )
      cxx << ";\n"
	     "		";
    else
      cxx << " << ";
    cxx << "m_" << fields[i].GetIdentifier();
    if ( i >= numFields || fields[i].IsOptional() )
      cxx << " -> " << fields[i].GetTypeName ( ) << " :: printOn ( os );\n"
	     "		os";
    cxx << " << '\\n';\n";
    if ( i >= numFields || fields[i].IsOptional())
      cxx << "	}\n";
  }
  if ( extendable )
    cxx << "	unknownExtensionsPrint ( os );\n";
  cxx << "	os << std :: setw ( indent - 1 ) << '}';\n";
  EndGenerateCplusplus(hdr, cxx);
}

const char * SequenceType::GetAncestorClass() const
{
  return "Asn :: Sequence";
}


BOOL SequenceType::CanReferenceType() const
{
  return TRUE;
}


BOOL SequenceType::ReferencesTypeInside(const TypeBase & type)
{
  for (PINDEX i = 0; i < fields.GetSize ( ); i++) {
    TypeBase & f = fields[i];
    if ( ( ( i < numFields && ! f.IsOptional ( ) ) || f.IsParameterizedType ( ) ) && f.ReferencesType(type) )
      return TRUE;
  }
  return FALSE;
}


void SequenceType :: GenerateCplusplusConstraints(const string & prefix, ostream & hdr, ostream & cxx) {
    return;
}

TypeBase * SequenceType :: Clone ( ) const {
    return new SequenceType ( *this );
}

bool SequenceType :: requiresModuleInclude ( const string & m ) {
  for (PINDEX i = 0; i < numFields; i++)
    if ( ! fields[i].IsOptional ( ) && fields[i].requiresModuleInclude ( m ) )
      return true;
  return false;
}

/////////////////////////////////////////////////////////

SequenceOfType::SequenceOfType(TypeBase * base, Constraint * constraint, unsigned tag)
  : TypeBase(tag)
{
  baseType = base;
  if (constraint != NULL)
    AddConstraint(constraint);
}


SequenceOfType::~SequenceOfType()
{
  delete baseType;
}


void SequenceOfType::PrintOn(ostream & strm) const
{
  PrintStart(strm);
  if (baseType == NULL)
    strm << "!!Null Type!!\n";
  else
    strm << *baseType << '\n';
  PrintFinish(strm);
}


void SequenceOfType::FlattenUsedTypes()
{
  baseType = baseType->FlattenThisType(*this);
}


TypeBase * SequenceOfType::FlattenThisType(const TypeBase & parent)
{
  if (!baseType->IsPrimitiveType() || baseType->HasConstraints() || HasConstraints ( ))
    return new DefinedType(this, parent);

  // Search for an existing sequence of type
  string seqName = "ArrayOf_" + baseType->GetTypeName();
  string :: size_type pos;
  while ( ( pos = seqName.find ( " :: " ) ) != string :: npos )
    seqName.replace ( pos, 4, "_" );
  TypeBase * existingType = Module->FindType(seqName);
  if (existingType != NULL)
    return new DefinedType(this, existingType);

  return new DefinedType(this, seqName);
}


BOOL SequenceOfType::IsPrimitiveType() const
{
  return FALSE;
}


void SequenceOfType::GenerateCplusplus(ostream & hdr, ostream & cxx)
{
  BeginGenerateCplusplus(hdr, cxx);
  cxx << ", createObject";
  GenerateCplusplusConstraints(string(), hdr, cxx);
  cxx << " ) { }\n"
         "\n";
  cxx << GetTemplatePrefix() << GetClassNameString() << " :: " << GetIdentifier ( ) << " ( ) : "
      << GetAncestorClass ( ) << " ( createObject";
  GenerateCplusplusConstraints(string(), hdr, cxx);
  cxx << " ) { }\n"
         "\n";
  hdr << "	explicit " << GetIdentifier() << " ( int s );\n";
  cxx << GetTemplatePrefix() << GetClassNameString() << " :: " << GetIdentifier ( ) << " ( int s ) : "
      << GetAncestorClass ( ) << " ( s, createObject";
  GenerateCplusplusConstraints(string(), hdr, cxx);
  cxx << " ) { }\n"
         "\n"
         "\n";
  string baseTypeName = baseType->GetTypeName();

  // Generate declarations for generated functions
  hdr << "	private:\n"
	 "	static Asn :: Object * createObject ( Asn :: istream & );\n"
	 "	static Asn :: Object * createObject ( );\n"
	 "	Asn :: Object * createObjectVirt ( ) const;\n"
	 "	public:\n"
	 "	void push_back ( const " << baseTypeName << " & o )";
  if (false && Module->UsingInlines())
    hdr << " {\n"
	   "		" << GetAncestorClass ( ) << " :: push_back ( new " << baseTypeName << " ( o ) );\n"
	   "	}\n";
  else
    hdr << ";\n";
  hdr << "	const " << baseTypeName << " & operator[] ( std :: size_t i ) const";
  if (false && Module->UsingInlines())
    hdr << " { return dynamic_cast < const " << baseTypeName << " & > ( Asn :: Array :: operator[] ( i ) ); }\n";
  else
    hdr << ";\n";
  hdr << "	" << baseTypeName << " & operator[] ( std :: size_t i )";
  if (false && Module->UsingInlines())
    hdr << " { return dynamic_cast < " << baseTypeName << " & > ( Asn :: Array :: operator[] ( i ) ); }\n";
  else
    hdr << ";\n";

  // Generate implementation for functions
  cxx << GetTemplatePrefix()
      << "Asn :: Object * " << GetClassNameString() << " :: createObjectVirt ( ) const {\n"
	 "	return createObject ( );\n"
	 "}\n\n";
  cxx << GetTemplatePrefix()
      << "Asn :: Object * " << GetClassNameString() << " :: createObject ( Asn :: istream & is ) {\n";

  cxx << "	return new " << baseTypeName << ' ';
  baseType -> GenerateCplusplusConstructor ( hdr, cxx );
  cxx << ";\n"
	 "}\n\n";
  cxx << GetTemplatePrefix()
      << "Asn :: Object * " << GetClassNameString() << " :: createObject ( ) {\n";
  cxx << "	return new " << baseTypeName << " ( );\n";

  if (true || !Module->UsingInlines())
    cxx << "}\n"
           "\n"
        << GetTemplatePrefix()
        << baseTypeName << " & " << GetClassNameString() << " :: operator[] ( std :: size_t i ) {\n"
           "	return dynamic_cast < " << baseTypeName << " & > ( Asn :: Array :: operator[] ( i ) );\n"
	   "}\n"
	   "\n"
        << GetTemplatePrefix()
        << "void " << GetClassNameString() << " :: push_back ( const " << baseTypeName << " & o ) {\n"
           "	" << GetAncestorClass ( ) << " :: push_back ( new " << baseTypeName << " ( o ) );\n"
	   "}\n"
           "\n"
        << GetTemplatePrefix()
        << "const " << baseTypeName << " & " << GetClassNameString() << " :: operator[] ( std :: size_t i ) const {\n"
           "	return dynamic_cast < const " << baseTypeName << " & > ( Asn :: Array :: operator[] ( i ) );\n";

  EndGenerateCplusplus(hdr, cxx);
}


void SequenceOfType::GenerateForwardDecls(ostream & hdr)
{
  if (baseType->IsParameterizedType())
    return;

  string baseTypeName = baseType->GetTypeName();

  if ( Module -> generateForwardDecl ( baseTypeName ) )
    hdr << "class " << baseTypeName << ";\n\n";
}


const char * SequenceOfType::GetAncestorClass() const
{
  return "Asn :: Array";
}


BOOL SequenceOfType::CanReferenceType() const
{
  return TRUE;
}


BOOL SequenceOfType::ReferencesTypeInside(const TypeBase & type)
{
  return baseType->ReferencesType(type) && baseType->IsParameterizedType();
}


void SequenceOfType::GenerateCplusplusConstraints(const string & prefix, ostream & hdr, ostream & cxx)
{
  if ( simpleConstraints.size ( ) || typeConstraints.size ( ) || fromConstraints.size ( ) || sizeConstraints.size ( ) > 1 )
    PError << "unsupported bitstring contraints\n";
  if ( ! sizeConstraints.size ( ) ) {
    cxx << ", Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( )";
    return;
  }
  cxx << ", Asn :: " << ( sizeConstraints [ 0 ].e ? "extendableConstraint" : "fixedConstraint" );
    const_cast < ConstraintElementBase * > ( sizeConstraints [ 0 ].c ) -> GenerateCplusplus ( "", hdr, cxx );
}


TypeBase * SequenceOfType :: Clone ( ) const {
    return new SequenceOfType ( *this );
}


/////////////////////////////////////////////////////////

SetType::SetType()
  : SequenceType(NULL, FALSE, NULL, Tag::UniversalSet)
{
}


SetType::SetType(SequenceType * seq)
  : SequenceType(*seq)
{
  tag.number = Tag::UniversalSet;
}


void SetType::GenerateCplusplusConstraints(const string & prefix, ostream & hdr, ostream & cxx)
{
    PError << "set type " << GetTypeName ( ) << " - what iz it ?\n";
}


const char * SetType::GetAncestorClass() const
{
  return "Asn :: Set";
}

TypeBase * SetType :: Clone ( ) const {
    return new SetType ( *this );
}


/////////////////////////////////////////////////////////

SetOfType::SetOfType(TypeBase * base, Constraint * constraint)
  : SequenceOfType(base, constraint, Tag::UniversalSet)
{
}

void SetOfType::GenerateCplusplusConstraints(const string & prefix, ostream & hdr, ostream & cxx)
{
//    PError << "set of type " << GetIdentifier ( ) << " - what iz it ?\n";
    SequenceOfType::GenerateCplusplusConstraints(prefix, hdr, cxx);
}


TypeBase * SetOfType :: Clone ( ) const {
    return new SetOfType ( *this );
}


/////////////////////////////////////////////////////////

ChoiceType::ChoiceType(TypesList * stnd,
                       BOOL extendable,
                       TypesList * extensions)
  : SequenceType(stnd, extendable, extensions, Tag::IllegalUniversalTag), usingInlines ( usingInlinesFlag )
{
}


void ChoiceType::GenerateCplusplus(ostream & hdr, ostream & cxx)
{
  PINDEX i;


  BeginGenerateCplusplus(hdr, cxx);
  if ( sizeConstraints.size ( ) || fromConstraints.size ( ) || typeConstraints.size ( ) || simpleConstraints.size ( ) )
    PError << "choice with constraints " << GetIdentifier( ) << endl;
  // Generate the enum's for each choice discriminator, and include strings for
  // PrintOn() debug output into acncestor constructor
  BOOL outputEnum = FALSE;
  int prevNum = -1;
  for (i = 0; i < fields.GetSize(); i++) {
    const Tag & fieldTag = fields[i].GetTag();
    if (fieldTag.mode == Tag::Automatic || !fields[i].IsChoice()) {
      if (outputEnum) {
        hdr << ",\n";
      }
      else {
        hdr << "	enum Choices {\n";
        outputEnum = TRUE;
      }

      hdr << "		e_" << fields[i].GetIdentifier();

      if (fieldTag.mode != Tag::Automatic && fieldTag.number != (unsigned)(prevNum+1)) {
        hdr << " = " << fieldTag.number;
      }
      prevNum = fieldTag.number;
    }
  }

  if (outputEnum)
    hdr << "\n"
           "	};\n"
           "\n";
  // Complete the ancestor constructor parameters
  cxx << ", " << numFields << ", " << (extendable ? "true" : "false") << " ) {\n";

  // declare an array of flags indicating whether the tag has been output or not
  PBYTEArray flags(fields.GetSize());
  for (i = 0; i < fields.GetSize(); i++)
    flags[i] = 0;

  // keep
  outputEnum = FALSE;
  for (i = 0; i < fields.GetSize(); i++) {

    if (fields[i].GetTag().mode == Tag::Automatic || !fields[i].IsChoice()) {

      // ignore this tag if output previously
      if (flags[i] != 0)
        continue;

      if (!outputEnum) {
        cxx << "	switch ( tag ) {\n";
        outputEnum = TRUE;
      }

      // if the field has constraints, then output it alone
      // otherwise, look for all fields with the same type
      string name = fields[i].GetTypeName();
      PINDEX j;
      for (j = i; j < fields.GetSize(); j++) {
        if (fields[j].GetTypeName() == name) {
          cxx << "		case e_" << fields[j].GetIdentifier() << ":\n";
          flags[j] = 1;
        }
      }

      cxx << "			choice = new " << name << " ";
      fields[i].GenerateCplusplusConstructor(hdr, cxx);
      cxx << ";\n			break;\n";
    }
  }

  if (outputEnum) {
    cxx << "		default:\n";
    if ( extendable )
      cxx << "			if ( nextPosition ) {\n"
	     "				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );\n"
	     "				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );\n"
	     "			} else\n	";
    cxx << "			throw std :: runtime_error ( \"unknown choice\" );\n"
	   "	}\n";
  }
  if ( extendable ) {
    cxx << "	if ( nextPosition )\n"
	"		is.setPosition ( nextPosition );\n";
  }
  cxx << "}\n\n";
  cxx << GetTemplatePrefix() << GetClassNameString() << " :: " << GetIdentifier ( ) << " ( ) : "
      << GetAncestorClass ( ) << " ( " << numFields << ", " << (extendable ? "true" : "false") << " ) { }\n\n";

  if ( constraints.size ( ) ) {
    PError << "choice " << GetIdentifier ( ) << " with constraints\n";
    GenerateCplusplusConstraints(string(), hdr, cxx);
  }

  // Generate code for type safe cast operators of selected choice object
  BOOL needExtraLine = FALSE;

  PStringSet typesOutput(PARRAYSIZE(StandardClasses), StandardClasses);
  typesOutput += GetIdentifier().c_str();
  typesOutput -= "Asn :: Null";
  typesOutput -= "Asn :: ObjectId";

  for (i = 0; i < fields.GetSize(); i++) {
    string type = fields[i].GetTypeName();
    if (!typesOutput.Contains(type.c_str())) {
      if ( usingInlines ) {
        hdr << "	operator " << type << " & ( ) { return dynamic_cast < " << type << " & > ( * choice ); }\n"
               "	operator const " << type << " & ( ) const { return dynamic_cast < const " << type <<
                 " & > ( * choice ); }\n";
      } else {
        hdr << "	operator " << type << " & ( );\n"
               "	operator const " << type << " & ( ) const;\n";
        cxx << GetTemplatePrefix()
            << GetClassNameString() << " :: operator " << type << " & ( ) {\n"
               "	return dynamic_cast < " << type << " & > ( * choice );\n"
               "}\n"
               "\n"
               "\n"
            << GetTemplatePrefix()
            << GetClassNameString() << " :: operator const " << type << " & ( ) const {\n"
               "	return dynamic_cast < const " << type << " & > ( * choice );\n"
               "}\n"
               "\n"
               "\n";
      }
      typesOutput += type.c_str();
      needExtraLine = TRUE;
    }
  }

  if (needExtraLine)
    hdr << '\n';


  // Generate virtual function to create chosen object based on discriminator
  hdr << "	void setTag ( Choices t );\n";
  hdr << "	private:\n";
  cxx << GetTemplatePrefix()
      << "void " << GetClassNameString() << " :: setTag ( Choices t ) {\n"
	 "	Object * o = 0;\n";

  for (i = 0; i < fields.GetSize(); i++)
    flags[i] = 0;

  // keep
  outputEnum = FALSE;
  for (i = 0; i < fields.GetSize(); i++) {

    if (fields[i].GetTag().mode == Tag::Automatic || !fields[i].IsChoice()) {
      // ignore this tag if output previously
      if (flags[i] != 0)
        continue;
      if (!outputEnum) {
        cxx << "	switch ( t ) {\n";
        outputEnum = TRUE;
      }

      // if the field has constraints, then output it alone
      // otherwise, look for all fields with the same type
      string name = fields[i].GetTypeName();
      PINDEX j;
      for (j = i; j < fields.GetSize(); j++) {
	if (fields[j].GetTypeName() == name) {
	  cxx << "		case e_" << fields[j].GetIdentifier() << ":\n";
	  flags[j] = 1;
	}
      }
      cxx << "			o = new " << name << ";\n"
    	     "			break;\n";
    }
  }

  if (outputEnum) {
    cxx << "		default:\n";
    cxx << "			throw std :: runtime_error ( \"unknown choice\" );\n"
	"	}\n";
  }
  cxx << "	Asn :: Choice :: setTag ( t, o );\n"
	 "}\n\n";

  hdr << "	const Asn :: NamesMapType & getNames ( ) const;\n"
	 "	public:\n";
  cxx << "const Asn :: NamesMapType & " << GetClassNameString() << " :: getNames ( ) const {\n"
         "	static Asn :: NamesPair namePairs [ ] = {";
  bool first = true;
  for (i = 0; i < fields.GetSize(); i++) {
    const Tag & fieldTag = fields[i].GetTag();
    if (fieldTag.mode == Tag::Automatic || !fields[i].IsChoice()) {
      if ( first )
	first = false;
      else
	cxx << ',';
      cxx << "\n		{ e_" << fields[i].GetIdentifier() << ", \"" << fields[i].GetIdentifier() << "\" }";
    }
  }
  if ( ! first )
    cxx << "\n	";
  else
    cxx << ' ';
  cxx << "};\n"
	 "	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );\n"
	 "	return namesMap;\n";
  EndGenerateCplusplus(hdr, cxx);
}


void ChoiceType::GenerateForwardDecls(ostream & hdr)
{
  // Output forward declarations for choice pointers, but not standard classes
  BOOL needExtraLine = FALSE;

  for (PINDEX i = 0; i < fields.GetSize(); i++) {
    string type = fields[i].GetTypeName();
    if (!fields[i].IsParameterizedType() && Module -> generateForwardDecl ( type ) ) {
      hdr << "class " << type << ";\n";
      needExtraLine = TRUE;
    }
  }

  if (needExtraLine)
    hdr << '\n';
}


BOOL ChoiceType::IsPrimitiveType() const
{
  return FALSE;
}


BOOL ChoiceType::IsChoice() const
{
  return TRUE;
}


const char * ChoiceType::GetAncestorClass() const
{
  return "Asn :: Choice";
}


BOOL ChoiceType::ReferencesTypeInside(const TypeBase & type)
{
  for (PINDEX i = 0; i < fields.GetSize(); i++) {
    if ( ( usingInlines || fields[i].IsParameterizedType() ) && fields[i].ReferencesType(type))
      return TRUE;
  }
  return FALSE;
}

TypeBase * ChoiceType :: Clone ( ) const {
    return new ChoiceType ( *this );
}

void ChoiceType :: noInlines ( ) {
    usingInlines = false;
}

/////////////////////////////////////////////////////////

EmbeddedPDVType::EmbeddedPDVType()
  : TypeBase(Tag::UniversalEmbeddedPDV)
{
}


void EmbeddedPDVType::GenerateCplusplusConstraints(const string & prefix, ostream & hdr, ostream & cxx)
{
    PError << "embedded pdv type " << GetTypeName ( ) << " - what iz it ?\n";
}


const char * EmbeddedPDVType::GetAncestorClass() const
{
  return "Asn :: OctetString";
}


TypeBase * EmbeddedPDVType :: Clone ( ) const {
    return new EmbeddedPDVType ( *this );
}


/////////////////////////////////////////////////////////

ExternalType::ExternalType()
  : TypeBase(Tag::UniversalExternalType)
{
}


const char * ExternalType::GetAncestorClass() const
{
  return "Asn :: OctetString";
}

TypeBase * ExternalType :: Clone ( ) const {
    return new ExternalType ( *this );
}

void ExternalType::GenerateCplusplusConstraints(const string & prefix, ostream & hdr, ostream & cxx) {
    PError << "external type " << GetIdentifier ( ) << " - what iz it ?\n";
}

/////////////////////////////////////////////////////////

AnyType::AnyType(string * ident)
  : TypeBase(Tag::UniversalExternalType)
{
  if (ident != NULL) {
    identifier = *ident;
    delete ident;
  }
}


void AnyType::PrintOn(ostream & strm) const
{
  PrintStart(strm);
  if (!identifier.empty())
    strm << "Defined by " << identifier;
  PrintFinish(strm);
}


void AnyType::GenerateCplusplusConstraints(const string & prefix, ostream & hdr, ostream & cxx) {
    PError << "any type " << GetIdentifier ( ) << " - what iz it ?\n";
}


const char * AnyType::GetAncestorClass() const
{
  return "Asn :: OctetString";
}

TypeBase * AnyType :: Clone ( ) const {
    return new AnyType ( *this );
}


/////////////////////////////////////////////////////////

StringTypeBase::StringTypeBase(int tag)
  : TypeBase(tag)
{
}


int StringTypeBase::GetBraceTokenContext() const
{
  return STRING_BRACE;
}


static void GenerateOperator(const char * rhsType, ostream & hdr, ostream & cxx, const TypeBase & actualType)
{
  hdr << "	" << actualType.GetIdentifier() << " & operator= ( const " << rhsType << " v )";
  if (Module->UsingInlines())
    hdr << " {\n"
	   "		" << actualType.GetTypeName ( ) << " :: operator= ( v );\n"
	   "		return * this;\n"
	   "	}\n";
  else {
    hdr << ";\n";
    cxx << actualType.GetTemplatePrefix()
        << actualType.GetIdentifier() << " & "
        << actualType.GetClassNameString() << " :: operator= ( const " << rhsType << " v ) {\n"
           "	" << actualType.GetTypeName ( ) << " :: operator= ( v );\n"
           "	return * this;\n"
           "}\n"
           "\n";
  }
}


void StringTypeBase::GenerateOperators(ostream & hdr, ostream & cxx, const TypeBase & actualType)
{
//  GenerateOperator("char *", hdr, cxx, actualType);
  GenerateOperator("Asn :: string &", hdr, cxx, actualType);
}

void StringTypeBase::GenerateCplusplusConstraints(const string & prefix, ostream & hdr, ostream & cxx)
{
  if ( typeConstraints.size ( ) || simpleConstraints.size ( ) || fromConstraints.size ( ) > 1 || sizeConstraints.size( ) > 1 )
    PError << "ignoring unsupported string constraints\n";
  if ( sizeConstraints.size ( ) > 0 ) {
    cxx << ", Asn :: " << ( sizeConstraints [ 0 ].e ? "extendableConstraint" : "fixedConstraint" );
    const_cast < ConstraintElementBase * > ( sizeConstraints [ 0 ].c ) -> GenerateCplusplus ( "", hdr, cxx );
  } else
    cxx << ", Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( )";
  if ( fromConstraints.size ( ) > 0 )
    const_cast < ConstraintElementBase * > ( fromConstraints [ 0 ].c ) -> GenerateCplusplus ( "IT IS FROM", hdr, cxx );
}

string StringTypeBase :: defaultParameters ( ) const {
	return "const Asn :: string & v = Asn :: string ( ) ";
}

void StringTypeBase::GenerateCplusplus(ostream & hdr, ostream & cxx)
{
  BeginGenerateCplusplus(hdr, cxx);

  // Close off the constructor implementation
  GenerateCplusplusConstraints(string(), hdr, cxx);
  cxx << " ) { }\n\n"
      << GetTemplatePrefix()
      << GetClassNameString() << " :: " << GetIdentifier() << " ( const Asn :: string & v ) : " << GetTypeName() << " ( v";
  GenerateCplusplusConstraints(string(), hdr, cxx);
  cxx << " ) { ";

  EndGenerateCplusplus(hdr, cxx);
}




/////////////////////////////////////////////////////////

BMPStringType::BMPStringType()
  : StringTypeBase(Tag::UniversalBMPString)
{
}


const char * BMPStringType::GetAncestorClass() const
{
  return "Asn :: BMPString";
}


void BMPStringType::GenerateOperators(ostream & hdr, ostream & cxx, const TypeBase & actualType)
{
  StringTypeBase :: GenerateOperators (hdr, cxx, actualType );
//  GenerateOperator("PWORDArray &", hdr, cxx, actualType);
//  GenerateOperator("PASN_BMPString &", hdr, cxx, actualType);
}

TypeBase * BMPStringType :: Clone ( ) const {
    return new BMPStringType ( *this );
}


/////////////////////////////////////////////////////////

GeneralStringType::GeneralStringType()
  : StringTypeBase(Tag::UniversalGeneralString)
{
}


const char * GeneralStringType::GetAncestorClass() const
{
  return "Asn :: GeneralString";
}

TypeBase * GeneralStringType :: Clone ( ) const {
    return new GeneralStringType ( *this );
}


/////////////////////////////////////////////////////////

GraphicStringType::GraphicStringType()
  : StringTypeBase(Tag::UniversalGraphicString)
{
}


const char * GraphicStringType::GetAncestorClass() const
{
  return "Asn :: GraphicString";
}

TypeBase * GraphicStringType :: Clone ( ) const {
    return new GraphicStringType ( *this );
}


/////////////////////////////////////////////////////////

IA5StringType::IA5StringType()
  : StringTypeBase(Tag::UniversalIA5String)
{
}


const char * IA5StringType::GetAncestorClass() const
{
  return "Asn :: IA5String";
}

TypeBase * IA5StringType :: Clone ( ) const {
    return new IA5StringType ( *this );
}


/////////////////////////////////////////////////////////

ISO646StringType::ISO646StringType()
  : StringTypeBase(Tag::UniversalVisibleString)
{
}


const char * ISO646StringType::GetAncestorClass() const
{
  return "Asn :: ISO646String";
}

TypeBase * ISO646StringType :: Clone ( ) const {
    return new ISO646StringType ( *this );
}


/////////////////////////////////////////////////////////

NumericStringType::NumericStringType()
  : StringTypeBase(Tag::UniversalNumericString)
{
}


const char * NumericStringType::GetAncestorClass() const
{
  return "Asn :: NumericString";
}

TypeBase * NumericStringType :: Clone ( ) const {
    return new NumericStringType ( *this );
}


/////////////////////////////////////////////////////////

PrintableStringType::PrintableStringType()
  : StringTypeBase(Tag::UniversalPrintableString)
{
}


const char * PrintableStringType::GetAncestorClass() const
{
  return "Asn :: PrintableString";
}

TypeBase * PrintableStringType :: Clone ( ) const {
    return new PrintableStringType ( *this );
}


/////////////////////////////////////////////////////////

TeletexStringType::TeletexStringType()
  : StringTypeBase(Tag::UniversalTeletexString)
{
}


const char * TeletexStringType::GetAncestorClass() const
{
  return "Asn :: TeletexString";
}

TypeBase * TeletexStringType :: Clone ( ) const {
    return new TeletexStringType ( *this );
}


/////////////////////////////////////////////////////////

T61StringType::T61StringType()
  : StringTypeBase(Tag::UniversalTeletexString)
{
}


const char * T61StringType::GetAncestorClass() const
{
  return "Asn :: T61String";
}

TypeBase * T61StringType :: Clone ( ) const {
    return new T61StringType ( *this );
}


/////////////////////////////////////////////////////////

UniversalStringType::UniversalStringType()
  : StringTypeBase(Tag::UniversalUniversalString)
{
}


const char * UniversalStringType::GetAncestorClass() const
{
  return "Asn :: UniversalString";
}

TypeBase * UniversalStringType :: Clone ( ) const {
    return new UniversalStringType ( *this );
}


/////////////////////////////////////////////////////////

VideotexStringType::VideotexStringType()
  : StringTypeBase(Tag::UniversalVideotexString)
{
}


const char * VideotexStringType::GetAncestorClass() const
{
  return "Asn :: VideotexString";
}

TypeBase * VideotexStringType :: Clone ( ) const {
    return new VideotexStringType ( *this );
}


/////////////////////////////////////////////////////////

VisibleStringType::VisibleStringType()
  : StringTypeBase(Tag::UniversalVisibleString)
{
}


const char * VisibleStringType::GetAncestorClass() const
{
  return "Asn :: VisibleString";
}

TypeBase * VisibleStringType :: Clone ( ) const {
    return new VisibleStringType ( *this );
}


/////////////////////////////////////////////////////////

UnrestrictedCharacterStringType::UnrestrictedCharacterStringType()
  : StringTypeBase(Tag::UniversalUniversalString)
{
}


const char * UnrestrictedCharacterStringType::GetAncestorClass() const
{
  return "Asn :: UnrestrictedString";
}

TypeBase * UnrestrictedCharacterStringType :: Clone ( ) const {
    return new UnrestrictedCharacterStringType ( *this );
}


/////////////////////////////////////////////////////////

GeneralizedTimeType::GeneralizedTimeType()
  : TypeBase(Tag::UniversalGeneralisedTime)
{
}


void GeneralizedTimeType::GenerateCplusplusConstraints(const string & prefix, ostream & hdr, ostream & cxx) {
  if ( typeConstraints.size ( ) || simpleConstraints.size ( ) || fromConstraints.size ( ) > 1 || sizeConstraints.size( ) > 1 )
    PError << "ignoring unsupported string constraints\n";
  if ( sizeConstraints.size ( ) > 0 ) {
    cxx << ", Asn :: " << ( sizeConstraints [ 0 ].e ? "extendableConstraint" : "fixedConstraint" );
    const_cast < ConstraintElementBase * > ( sizeConstraints [ 0 ].c ) -> GenerateCplusplus ( "", hdr, cxx );
  } else
    cxx << ", Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( )";
  if ( fromConstraints.size ( ) > 0 )
    const_cast < ConstraintElementBase * > ( fromConstraints [ 0 ].c ) -> GenerateCplusplus ( "IT IS FROM", hdr, cxx );
}


const char * GeneralizedTimeType::GetAncestorClass() const
{
  return "Asn :: GeneralisedTime";
}

TypeBase * GeneralizedTimeType :: Clone ( ) const {
    return new GeneralizedTimeType ( *this );
}


/////////////////////////////////////////////////////////

UTCTimeType::UTCTimeType()
  : TypeBase(Tag::UniversalUTCTime)
{
}


void UTCTimeType::GenerateCplusplusConstraints(const string & prefix, ostream & hdr, ostream & cxx) {
    PError << "utc time " << GetIdentifier ( ) << " what iz it ?\n";
}


const char * UTCTimeType::GetAncestorClass() const
{
  return "Asn :: UniversalTime";
}

TypeBase * UTCTimeType :: Clone ( ) const {
    return new UTCTimeType ( *this );
}


/////////////////////////////////////////////////////////

ObjectDescriptorType::ObjectDescriptorType()
  : TypeBase(Tag::UniversalObjectDescriptor)
{
}


const char * ObjectDescriptorType::GetAncestorClass() const
{
  return "Asn :: ObectDescriptor";
}

TypeBase * ObjectDescriptorType :: Clone ( ) const {
    return new ObjectDescriptorType ( *this );
}


/////////////////////////////////////////////////////////

ObjectIdentifierType::ObjectIdentifierType()
  : TypeBase(Tag::UniversalObjectId)
{
}


int ObjectIdentifierType::GetIdentifierTokenContext() const
{
  return OID_IDENTIFIER;
}


int ObjectIdentifierType::GetBraceTokenContext() const
{
  return OID_BRACE;
}


const char * ObjectIdentifierType::GetAncestorClass() const
{
  return "Asn :: ObjectId";
}


void ObjectIdentifierType::GenerateCplusplusConstraints(const string & prefix, ostream & hdr, ostream & cxx)
{

  if ( constraints.size ( ) )
    cxx << " ObjectIdentifier with constraints";
}

void ObjectIdentifierType::GenerateOperators(ostream & hdr, ostream & cxx, const TypeBase & actualType) {
    GenerateOperator ( "Asn :: string &", hdr, cxx, actualType );
}


void ObjectIdentifierType::GenerateCplusplus(ostream & hdr, ostream & cxx)
{
  BeginGenerateCplusplus(hdr, cxx);
  // Close off the constructor implementation
  cxx << " ) { }\n\n";
  hdr << "	explicit " << GetIdentifier ( ) << " ( const Asn :: string & s ) : "
      << GetAncestorClass ( ) << " ( s ) { }\n";
  cxx  << GetTemplatePrefix() << GetClassNameString() << " :: " << GetIdentifier ( ) << " ( ) : "
      << GetAncestorClass ( ) << " ( \"\" ) {\n";
  EndGenerateCplusplus(hdr, cxx);
}



TypeBase * ObjectIdentifierType :: Clone ( ) const {
    return new ObjectIdentifierType ( *this );
}


/////////////////////////////////////////////////////////

ObjectClassFieldType::ObjectClassFieldType(string * objclass, string * field)
  : TypeBase(Tag::IllegalUniversalTag),
    asnObjectClassName(*objclass),
    asnObjectClassField(*field)
{
  delete objclass;
  delete field;
}


const char * ObjectClassFieldType::GetAncestorClass() const
{
  return "Asn :: OctetString";
}


void ObjectClassFieldType::PrintOn(ostream & strm) const
{
  PrintStart(strm);
  strm << asnObjectClassName << '.' << asnObjectClassField;
  PrintFinish(strm);
}


TypeBase * ObjectClassFieldType::FlattenThisType(const TypeBase & parent)
{
  return new DefinedType(this, parent);
}


BOOL ObjectClassFieldType::IsPrimitiveType() const
{
  return FALSE;
}


void ObjectClassFieldType::GenerateCplusplus(ostream & hdr, ostream & cxx)
{
  //PError << "ObjectClassFieldType " << GetName ( ) << "\n";
  BeginGenerateCplusplus(hdr, cxx);
  if ( sizeConstraints.size ( ) || fromConstraints.size ( ) || simpleConstraints.size ( ) || typeConstraints.size ( ) != 1 )
    PError << "ObjectClassFieldType " << GetIdentifier() << " with strange constraints\n";

  cxx << ", Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }\n\n"
      << GetTemplatePrefix()
      << GetClassNameString() << " :: " << GetIdentifier() << " ( ) : " << GetTypeName() <<
		" ( \"\", Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { ";
  EndGenerateCplusplus(hdr, cxx);
}


BOOL ObjectClassFieldType::CanReferenceType() const
{
  return TRUE;
}


BOOL ObjectClassFieldType::ReferencesType(const TypeBase & type)
{
  for (unsigned i = 0; i < constraints.size(); i++) {
    if (constraints[i].ReferencesType(type))
      return TRUE;
  }
  return FALSE;
}

TypeBase * ObjectClassFieldType :: Clone ( ) const {
    return new ObjectClassFieldType ( *this );
}


/////////////////////////////////////////////////////////

ImportedType::ImportedType(string * theName, BOOL param)
  : TypeBase(Tag::IllegalUniversalTag)
{
  identifier = name = *theName;
  delete theName;

  parameterised = param;
}


const char * ImportedType::GetAncestorClass() const
{
  return identifier.c_str();
}


void ImportedType::AdjustIdentifier( bool useNamespace )
{
  if ( useNamespace )
    identifier = modulePrefix + " :: " + MakeIdentifierC(name);
  else
    identifier = modulePrefix + '_' + MakeIdentifierC(name);
}


void ImportedType::GenerateCplusplus(ostream &, ostream & cxx)
{
 if ( HasConstraints ( ) )
    cxx << "ImportedType " << GetTypeName ( ) << " with constraints" << endl;
}


void ImportedType::SetImportPrefix(const string & prefix)
{
  modulePrefix = prefix;
}


BOOL ImportedType::IsParameterisedImport() const
{
  return parameterised;
}


bool ImportedType::isAsnStandardClass ( ) const {
  return false;
}
TypeBase * ImportedType :: Clone ( ) const {
    return new ImportedType ( *this );
}

string ImportedType :: getImportPrefix ( ) const {
  return modulePrefix;
}

/////////////////////////////////////////////////////////

SearchType::SearchType(const string & theName)
  : TypeBase(Tag::IllegalUniversalTag)
{
  identifier = name = theName;
}

void SearchType::GenerateCplusplusConstraints(const string & prefix, ostream & hdr, ostream & cxx) {
    PError << "search type " << GetIdentifier ( ) << " - what iz it ?\n";
}

const char * SearchType::GetAncestorClass() const
{
  return identifier.c_str();
}

TypeBase * SearchType :: Clone ( ) const {
    return new SearchType ( *this );
}


/////////////////////////////////////////////////////////

void ValueBase::SetValueName(string * name)
{
  valueName = *name;
  delete name;
}


void ValueBase::PrintBase(ostream & strm) const
{
  if (!valueName.empty())
    strm << '\n' << indent() << valueName << '=';
}


void ValueBase::GenerateCplusplus(ostream &, ostream &)
{
  PError << StdError(Warning) << "unsupported value type." << endl;
}


/////////////////////////////////////////////////////////

DefinedValue::DefinedValue(string * name)
  : referenceName(*name)
{
  delete name;
  actualValue = NULL;
  unresolved = TRUE;
}


void DefinedValue::PrintOn(ostream & strm) const
{
  PrintBase(strm);
  strm << referenceName;
}


void DefinedValue::GenerateCplusplus(ostream & hdr, ostream & cxx)
{
  if (unresolved) {
    unresolved = FALSE;

    const ValuesList & values = Module->GetValues();
    for (PINDEX i = 0; i < values.GetSize(); i++) {
      if (values[i].GetName() == referenceName) {
        actualValue = &values[i];
        break;
      }
    }
  }

  if (actualValue != NULL)
    actualValue->GenerateCplusplus(hdr, cxx);
  else
    cxx << "e_" << referenceName;
}


/////////////////////////////////////////////////////////

BooleanValue::BooleanValue(BOOL newVal)
{
  value = newVal;
}


void BooleanValue::PrintOn(ostream & strm) const
{
  PrintBase(strm);
  strm << (value ? "TRUE" : "FALSE");
}


void BooleanValue::GenerateCplusplus(ostream &, ostream & cxx)
{
  cxx << (value ? "TRUE" : "FALSE");
}


/////////////////////////////////////////////////////////

IntegerValue::IntegerValue(PInt64 newVal)
{
  value = newVal;
}


void IntegerValue::PrintOn(ostream & strm) const
{
  PrintBase(strm);

  strm << value;
}


void IntegerValue::GenerateCplusplus(ostream &, ostream & cxx)
{
  cxx << value;
  if (value > std :: numeric_limits < int > :: max ( ))
    cxx << 'U';
}


/////////////////////////////////////////////////////////

RealValue::RealValue(double newVal)
{
  value = newVal;
}


/////////////////////////////////////////////////////////

OctetStringValue::OctetStringValue(string * newVal)
{
  // value = *newVal;
  delete newVal;
}


/////////////////////////////////////////////////////////

BitStringValue::BitStringValue(string * newVal)
{
  // value = *newVal;
  delete newVal;
}


BitStringValue::BitStringValue(list<string> * newVal)
{
  // value = *newVal;
  delete newVal;
}


/////////////////////////////////////////////////////////

CharacterValue::CharacterValue(BYTE c)
{
  value = c;
}


CharacterValue::CharacterValue(BYTE t1, BYTE t2)
{
  value = (t1<<8) + t2;
}


CharacterValue::CharacterValue(BYTE q1, BYTE q2, BYTE q3, BYTE q4)
{
  value = (q1<<24) + (q2<<16) + (q3<<8) + q4;
}


void CharacterValue::PrintOn(ostream & strm) const
{
  strm << "'\\x" << hex << value << '\'';
}


void CharacterValue::GenerateCplusplus(ostream &, ostream & cxx)
{
  cxx << value;
}


/////////////////////////////////////////////////////////

CharacterStringValue::CharacterStringValue(string * newVal)
{
  value = *newVal;
  delete newVal;
}


CharacterStringValue::CharacterStringValue(list<string> * newVal)
{
    for ( list<string> :: const_iterator i = newVal -> begin ( ); i != newVal -> end ( ); ++ i )
	value += * i;
  delete newVal;
}


void CharacterStringValue::PrintOn(ostream & strm) const
{
  strm << value;
}


void CharacterStringValue::GenerateCplusplus(ostream &, ostream & cxx)
{
  cxx << value;
}


/////////////////////////////////////////////////////////

ObjectIdentifierValue::ObjectIdentifierValue(string * newVal)
{
  value.push_back ( *newVal);
}


ObjectIdentifierValue::ObjectIdentifierValue(list<string> * newVal)
{
  value.swap ( * newVal );
  delete newVal;
}


void ObjectIdentifierValue::PrintOn(ostream & strm) const
{
  PrintBase(strm);
  if (value.empty())
    strm << "empty object identifier";
  else {
    for ( list<string> :: const_iterator i = value.begin(); i != value.end(); ++ i ) {
	if ( i != value.begin() )
	    strm << '.';
	strm << * i;
    }
  }
  strm << '\n';
}


/////////////////////////////////////////////////////////

void MinValue::PrintOn(ostream & strm) const
{
  strm << "MIN";
}


void MinValue::GenerateCplusplus(ostream &, ostream & cxx)
{
  cxx << "MinimumValue";
}


/////////////////////////////////////////////////////////

void MaxValue::PrintOn(ostream & strm) const
{
  strm << "MAX";
}


void MaxValue::GenerateCplusplus(ostream &, ostream & cxx)
{
  cxx << "std :: numeric_limits < int > :: max ( )";
}


/////////////////////////////////////////////////////////

SequenceValue::SequenceValue(ValuesList * list)
{
  if (list != NULL) {
    values = *list;
    delete list;
  }
}


void SequenceValue::PrintOn(ostream & strm) const
{
  strm << "{ ";
  for (PINDEX i = 0; i < values.GetSize(); i++) {
    if (i > 0)
      strm << ", ";
    strm << values[i];
  }
  strm << " }";
}


/////////////////////////////////////////////////////////

MibBase::MibBase(string * nam,
                 string * descr,
                 string * refer,
                 ValueBase * val)
  : name(*nam)
{
  delete nam;
  if (descr != NULL) {
    description = *descr;
    delete descr;
  }
  if (refer != NULL) {
    reference = *refer;
    delete refer;
  }
  value = val;
}


MibBase::~MibBase()
{
  delete value;
}


/////////////////////////////////////////////////////////

MibObject::MibObject(string * nam,
                     TypeBase * typ,
                     Access acc,
                     Status stat,
                     string * descr,
                     string * refer,
                     list<string> * idx,
                     ValueBase * defVal,
                     ValueBase * setVal)
  : MibBase(nam, descr, refer, setVal)
{
  type = typ;
  access = acc;
  status = stat;
  if (idx != NULL) {
    index = *idx;
    delete idx;
  }
  defaultValue = defVal;
}


MibObject::~MibObject()
{
  delete type;
  delete defaultValue;
}


void MibObject::PrintOn(ostream & strm) const
{
  strm << "  Object: " << name << "\n  " << *type
       << "    " << description << "\n"
          "    " << *value << '\n';
}


/////////////////////////////////////////////////////////

MibTrap::MibTrap(string * nam, ValueBase * ent, ValuesList * var,
                 string * descr, string * refer, ValueBase * val)
  : MibBase(nam, descr, refer, val)
{
  enterprise = ent;
  if (var != NULL) {
    variables = *var;
    delete var;
  }
}


MibTrap::~MibTrap()
{
  delete enterprise;
}


void MibTrap::PrintOn(ostream & strm) const
{
  strm << "  Trap: " << name << "\n  " << *enterprise
       << "    " << description << "\n"
          "    " << *value << '\n';
}


/////////////////////////////////////////////////////////

ImportModule::ImportModule(string * name, TypesList * syms)
  : fullModuleName(*name),
    shortModuleName(Module->GetImportModuleName(*name))
{
  delete name;
  symbols = *syms;
  delete syms;

  for (PINDEX i = 0; i < symbols.GetSize(); i++) {
    symbols[i].SetImportPrefix(shortModuleName);
    Module->AppendType(&symbols[i]);
  }
}


void ImportModule::PrintOn(ostream & strm) const
{
  strm << "  " << fullModuleName << " (" << shortModuleName << "):\n";
  for (PINDEX i = 0; i < symbols.GetSize(); i++)
    strm << "    " << symbols[i];
  strm << '\n';
}


void ImportModule::GenerateCplusplus(ostream & hdr, ostream & cxx)
{
  string filename = shortModuleName;
  for ( unsigned i = 0; i < filename.size(); i ++ )
    filename[i] =tolower(filename[i]);

  bool requiresInclude = Module -> requiresInclude ( shortModuleName );
  if (requiresInclude) {
    hdr << "#include \"" << filename << ".hpp\"\n";
  } else {
    cxx << "#include \"" << filename << ".hpp\"\n";
    hdr << "namespace " << shortModuleName << " {\n";
    for (PINDEX i = 0; i < symbols.GetSize(); i++)
      hdr << "	" << symbols[i].GetTemplatePrefix() << "class " << MakeIdentifierC ( symbols[i].GetName() ) << ";\n";
    hdr << "}\n";
  }
  for (PINDEX i = 0; i < symbols.GetSize(); i++) {
    if (symbols[i].IsParameterisedImport()) {
      cxx << "#include \"" << filename << "_t.cxx\"\n";
      break;
    }
  }
  hdr << "\n";
}


/////////////////////////////////////////////////////////

ModuleDefinition::ModuleDefinition(string * name, list<string> * id, Tag::Mode defTagMode)
  : moduleName(*name),
    definitiveId(*id),
    typesOutput(StandardClasses, StandardClasses + sizeof(StandardClasses)/sizeof(*StandardClasses))
{
  delete name;
  delete id;
  defaultTagMode = defTagMode;
  exportAll = FALSE;
  indentLevel = 1;

  PArgList & args = PProcess::Current().GetArguments();
  if (args.HasOption('r')) {
    PStringArray renames = args.GetOptionString('r').Lines();
    for (PINDEX i = 0; i < renames.GetSize(); i++) {
      PINDEX equal = renames[i].Find('=');
      if (equal > 0 && equal != P_MAX_INDEX)
        importNames [(const char*)renames[i].Left(equal).Trim()] = (const char*) renames[i].Mid(equal+1).Trim();
    }
  }
}


void ModuleDefinition::SetExportAll()
{
  exportAll = TRUE;
}


void ModuleDefinition::SetExports(TypesList * syms)
{
  exports = *syms;
  delete syms;
}


void ModuleDefinition::PrintOn(ostream & strm) const
{
  strm << moduleName << "\n"
          "Default Tags: " << Tag::modeNames[defaultTagMode] << "\n"
          "Exports:";
  if (exportAll)
    strm << " ALL";
  else {
    strm << "\n  ";
    for (PINDEX i = 0; i < exports.GetSize(); i++)
      strm << exports[i] << ' ';
    strm << '\n';
  }
  strm << "Imports:\n" << imports << "\n"
          "Types:\n" << types << "\n"
          "Values:\n" << values << "\n"
          "MIBs:\n" << mibs << endl;
}


void ModuleDefinition::AppendType(TypeBase * type)
{
  types.Append(type);
  sortedTypes.Append(type);
}


TypeBase * ModuleDefinition::FindType(const string & name)
{
  PINDEX pos = sortedTypes.GetValuesIndex(SearchType(name));
  if (pos != P_MAX_INDEX)
    return &sortedTypes[pos];
  return NULL;
}


string ModuleDefinition::GetImportModuleName(const string & moduleName)
{
  if (importNames.count(moduleName))
    return importNames[moduleName];

  PINDEX pos = moduleName.find('-');
  if (pos > 32)
    pos = 32;
  return moduleName.substr(0,pos);
}


void ModuleDefinition::GenerateCplusplus(const PFilePath & path,
                                         const string & modName,
                                         unsigned numFiles,
                                         BOOL useNamespaces,
                                         BOOL useInlines,
                                         BOOL verbose)
{

  //sleep ( 10 );
  PINDEX i;

  usingInlines = useInlines;

  // Adjust the module name to what is specified to a default
  if (!modName.empty())
    moduleName = modName;
  else
    moduleName = MakeIdentifierC(moduleName);

  // Set the prefix on all external class names
  if (!useNamespaces)
    classNamePrefix = moduleName + '_';


  if (verbose)
    cout << "Sorting " << types.GetSize() << " types..." << endl;


  // Create sorted list for faster searching.
  sortedTypes.DisallowDeleteObjects();
  for (i = 0; i < types.GetSize(); i++)
    sortedTypes.Append(&types[i]);

  // Flatten types by generating types for "inline" definitions
  for (i = 0; i < types.GetSize(); i++)
    types[i].FlattenUsedTypes();

  // Reorder types
  // Determine if we need a separate file for template closure
  BOOL hasTemplates = FALSE;
  types.DisallowDeleteObjects();
  PINDEX loopDetect = 0;
  PINDEX bubble = 0;
  bool setNoInlines = ! UsingInlines ( );
  while (bubble < types.GetSize()) {
    BOOL makesReference = FALSE;

    TypeBase & bubbleType = types[bubble];
//    if ( bubbleType.GetName ( ) == "FeatureDescriptor" )
//	PError << "break" << endl;
    if ( bubbleType.CanReferenceType ( ) /*&& ( bubble < types.GetSize ( ) - 1 )*/ ) {
      for (i = bubble; i < types.GetSize(); i++) {
	crtSet.clear ( );
        if (bubbleType.ReferencesTypeInside(types[i])) {
          makesReference = TRUE;
	  if ( loopDetect > types.GetSize ( ) ) {
	    if ( ! setNoInlines ) {
		setNoInlines = true;
		loopDetect = bubble;
		for ( int j = bubble; j < types.GetSize ( ); j ++ )
		    types [ j ].noInlines ( );
	    } else {
		PError << StdError(Fatal) << bubbleType.GetName() << " references " << types[i].GetName ( ) << endl;
		crtSet.clear ( );
		bubbleType.ReferencesTypeInside(types[i]);
	    }
	  }
          break;
        }
      }
    }

    if (makesReference) {
      types.Append(types.RemoveAt(bubble));
      if (loopDetect > types.GetSize() * 2) {
        PError << StdError(Fatal)
               << "Recursive type definition: " << bubbleType.GetName() << " "
	       << types.GetSize ( ) << " " << bubble << endl;
        break;
      }
      loopDetect++;
    }
    else {
      loopDetect = bubble;
      bubble++;
    }

    if (bubbleType.HasParameters())
      hasTemplates = TRUE;
  }
  types.AllowDeleteObjects();

  // Adjust all of the C++ identifiers prepending module name
  for (i = 0; i < types.GetSize(); i++)
    types[i].AdjustIdentifier( useNamespaces );


  // Generate the code
  if (verbose)
    cout << "Generating code (" << types.GetSize() << " classes) ..." << endl;


  // Output the special template closure file, if necessary
  string templateFilename;
  if (hasTemplates) {
    OutputFile templateFile;
    if (!templateFile.Open(path, "_t", ".cxx"))
      return;
    if (useNamespaces)
      templateFile << "namespace " << moduleName << " {\n"
               "\n";

    for (i = 0; i < types.GetSize(); i++) {
      if (types[i].HasParameters()) {
        PStringStream dummy;
        types[i].GenerateCplusplus(dummy, templateFile);
      }
    }
    if (useNamespaces)
      templateFile << "}\n"
               "\n";

    if (verbose)
      cout << "Completed " << templateFile.GetFilePath() << endl;

    templateFilename = templateFile.GetFilePath().GetFileName();
  }

  // Start the header file
  OutputFile hdrFile;
  if (!hdrFile.Open(path, "", ".hpp"))
    return;
  string mnu = moduleName;
  for ( std :: size_t i = 0; i < mnu.size ( ); i ++ )
    mnu [ i ] = toupper ( mnu [ i ] );
  hdrFile << "#ifndef __" << mnu << "_HPP\n"
    	     "#define __" << mnu << "_HPP\n"
             "\n"
             "#ifdef __GNUC__\n"
             "#pragma interface\n"
             "#endif\n"
             "\n";

  // Start the first (and maybe only) cxx file
  OutputFile cxxFile;
  if (!cxxFile.Open(path, "", ".cxx"))
    return;

  string headerName = (const char *)hdrFile.GetFilePath().GetFileName();

  cxxFile << "#ifdef __GNUC__\n"
             "#pragma implementation \"" << headerName << "\"\n"
             "#endif\n"
             "\n"
             "#include \"ss.hpp\"\n"
             "#include \"allocatable.hpp\"\n"
             "#include <stdexcept>\n"
             "#include <iomanip>\n"
             "#include <limits>\n"
             "#include <cstring>\n"
             "#include \"asn.hpp\"\n"
             "\n"
             "#include \"" << headerName << "\"\n"
             "\n"
             "\n";

  // Include the template closure file.
  if (hasTemplates)
    cxxFile << "#include \"" << templateFilename << "\"\n\n";


  for (i = 0; i < imports.GetSize(); i++)
    imports[i].GenerateCplusplus(hdrFile, cxxFile);
  if (!imports.IsEmpty()) {
    hdrFile << "\n\n";
    cxxFile << "\n\n";
  }


  if (useNamespaces) {
    hdrFile << "namespace " << moduleName << " {\n"
               "\n";
    cxxFile << "using namespace " << moduleName << ";\n"
               "\n";
  }


  for (i = 0; i < types.GetSize(); i++) {
    typesOutput.insert ( types[i].GetIdentifier ( ) );
    if (types[i].HasParameters()) {
      PStringStream dummy;
      types[i].GenerateCplusplus(hdrFile, dummy);
    }
    else
      types[i].GenerateCplusplus(hdrFile, cxxFile);
  }


  // Close off the files
  if (useNamespaces)
    hdrFile << "};\n"
               "\n";

  hdrFile << "#endif // __" << mnu << "_HPP\n"
             "\n";

  if (verbose)
    cout << "Completed " << cxxFile.GetFilePath() << endl;
}

bool ModuleDefinition::checkReferencesType ( const PObject * ob ) {
	return crtSet.insert ( ob ).second;
}

bool ModuleDefinition::generateForwardDecl ( const string & typeName ) {
	if ( typesOutput.count ( typeName ) )
		return false;
	typesOutput.insert ( typeName );
	return true;
}

bool ModuleDefinition :: requiresInclude ( const string & n ) const {
  for ( PINDEX i = 0; i < types.GetSize(); i++)
    if (types[i].requiresModuleInclude(n))
      return true;
   return false;
}

//////////////////////////////////////////////////////////////////////////////
