//
// h235.hpp
//
// Code automatically generated by asnparse.
//

#ifndef __H235_HPP
#define __H235_HPP

#ifdef __GNUC__
#pragma interface
#endif

namespace H235 {

//
// ChallengeString
//

// from 0 size 1 type 0 simple 0
class ChallengeString : public Asn :: OctetString {
	public:
	explicit ChallengeString ( Asn :: istream & is );
	ChallengeString ( const Asn :: string & v = Asn :: string ( ) );
	ChallengeString & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	ChallengeString * clone ( ) const;
};

//
// TimeStamp
//

// from 0 size 0 type 0 simple 1
class TimeStamp : public Asn :: Integer {
	public:
	explicit TimeStamp ( Asn :: istream & is );
	TimeStamp ( unsigned v = 0 );
	TimeStamp & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	TimeStamp & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	TimeStamp * clone ( ) const;
};

//
// RandomVal
//

// from 0 size 0 type 0 simple 0
class RandomVal : public Asn :: Integer {
	public:
	explicit RandomVal ( Asn :: istream & is );
	RandomVal ( unsigned v = 0 );
	RandomVal & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RandomVal & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	RandomVal * clone ( ) const;
};

//
// Password
//

// from 0 size 1 type 0 simple 0
class Password : public Asn :: BMPString {
	public:
	explicit Password ( Asn :: istream & is );
	Password ( const Asn :: string & v = Asn :: string ( ) );
	Password & operator= ( const Asn :: string & v ) {
		Asn :: BMPString :: operator= ( v );
		return * this;
	}
	Password * clone ( ) const;
};

//
// Identifier
//

// from 0 size 1 type 0 simple 0
class Identifier : public Asn :: BMPString {
	public:
	explicit Identifier ( Asn :: istream & is );
	Identifier ( const Asn :: string & v = Asn :: string ( ) );
	Identifier & operator= ( const Asn :: string & v ) {
		Asn :: BMPString :: operator= ( v );
		return * this;
	}
	Identifier * clone ( ) const;
};

//
// KeyMaterial
//

// from 0 size 1 type 0 simple 0
class KeyMaterial : public Asn :: BitString {
	public:
	explicit KeyMaterial ( Asn :: istream & is );
	KeyMaterial ( const Asn :: string & v = Asn :: string ( ), unsigned b = 0 );
	KeyMaterial * clone ( ) const;
};

//
// NonStandardParameter
//

// from 0 size 0 type 0 simple 0
class NonStandardParameter : public Asn :: Sequence {
	public:
	explicit NonStandardParameter ( Asn :: istream & is );
	NonStandardParameter ( );
	Asn :: ObjectId m_nonStandardIdentifier;
	Asn :: OctetString m_data;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	NonStandardParameter * clone ( ) const;
};

//
// ECpoint
//

// from 0 size 0 type 0 simple 0
class ECpoint_x;
class ECpoint_y;

class ECpoint : public Asn :: Sequence {
	public:
	explicit ECpoint ( Asn :: istream & is );
	ECpoint ( );
	enum OptionalFields {
		e_x,
		e_y
	};

	ECpoint ( const ECpoint & s );
	ECpoint & operator= ( const ECpoint & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	ECpoint_x * m_x;
	ECpoint_y * m_y;
	public:
	void encode ( Asn :: ostream & os ) const;
	~ECpoint ( );
	void printOn ( std :: ostream & os ) const;
	const ECpoint_x & get_x ( ) const {
		return * m_x;
	}
	ECpoint_x & get_x ( ) {
		return * m_x;
	}
	const ECpoint_y & get_y ( ) const {
		return * m_y;
	}
	ECpoint_y & get_y ( ) {
		return * m_y;
	}
	ECpoint * clone ( ) const;
};

//
// TypedCertificate
//

// from 0 size 0 type 0 simple 0
class TypedCertificate : public Asn :: Sequence {
	public:
	explicit TypedCertificate ( Asn :: istream & is );
	TypedCertificate ( );
	Asn :: ObjectId m_type;
	Asn :: OctetString m_certificate;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	TypedCertificate * clone ( ) const;
};

//
// AuthenticationBES
//

// from 0 size 0 type 0 simple 0
class AuthenticationBES : public Asn :: Choice {
	public:
	explicit AuthenticationBES ( Asn :: istream & is );
	AuthenticationBES ( );
	enum Choices {
		e_default,
		e_radius
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	AuthenticationBES * clone ( ) const;
};

//
// AuthenticationMechanism
//

// from 0 size 0 type 0 simple 0
class AuthenticationMechanism : public Asn :: Choice {
	public:
	explicit AuthenticationMechanism ( Asn :: istream & is );
	AuthenticationMechanism ( );
	enum Choices {
		e_dhExch,
		e_pwdSymEnc,
		e_pwdHash,
		e_certSign,
		e_ipsec,
		e_tls,
		e_nonStandard,
		e_authenticationBES,
		e_keyExch
	};

	operator Asn :: Null & ( ) { return dynamic_cast < Asn :: Null & > ( * choice ); }
	operator const Asn :: Null & ( ) const { return dynamic_cast < const Asn :: Null & > ( * choice ); }
	operator NonStandardParameter & ( ) { return dynamic_cast < NonStandardParameter & > ( * choice ); }
	operator const NonStandardParameter & ( ) const { return dynamic_cast < const NonStandardParameter & > ( * choice ); }
	operator AuthenticationBES & ( ) { return dynamic_cast < AuthenticationBES & > ( * choice ); }
	operator const AuthenticationBES & ( ) const { return dynamic_cast < const AuthenticationBES & > ( * choice ); }
	operator Asn :: ObjectId & ( ) { return dynamic_cast < Asn :: ObjectId & > ( * choice ); }
	operator const Asn :: ObjectId & ( ) const { return dynamic_cast < const Asn :: ObjectId & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	AuthenticationMechanism * clone ( ) const;
};

//
// ClearToken
//

// from 0 size 0 type 0 simple 0
class DHset;
class ECKASDH;
class H235Key;
class ArrayOf_ProfileElement;

class ClearToken : public Asn :: Sequence {
	public:
	explicit ClearToken ( Asn :: istream & is );
	ClearToken ( );
	enum OptionalFields {
		e_timeStamp,
		e_password,
		e_dhkey,
		e_challenge,
		e_random,
		e_certificate,
		e_generalID,
		e_nonStandard,
		e_eckasdhkey,
		e_sendersID,
		e_h235Key,
		e_profileInfo
	};

	ClearToken ( const ClearToken & s );
	ClearToken & operator= ( const ClearToken & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	Asn :: ObjectId m_tokenOID;
	protected:
	TimeStamp * m_timeStamp;
	Password * m_password;
	DHset * m_dhkey;
	ChallengeString * m_challenge;
	RandomVal * m_random;
	TypedCertificate * m_certificate;
	Identifier * m_generalID;
	NonStandardParameter * m_nonStandard;
	ECKASDH * m_eckasdhkey;
	Identifier * m_sendersID;
	H235Key * m_h235Key;
	ArrayOf_ProfileElement * m_profileInfo;
	public:
	void encode ( Asn :: ostream & os ) const;
	~ClearToken ( );
	void printOn ( std :: ostream & os ) const;
	const TimeStamp & get_timeStamp ( ) const {
		return * m_timeStamp;
	}
	TimeStamp & get_timeStamp ( ) {
		return * m_timeStamp;
	}
	const Password & get_password ( ) const {
		return * m_password;
	}
	Password & get_password ( ) {
		return * m_password;
	}
	const DHset & get_dhkey ( ) const {
		return * m_dhkey;
	}
	DHset & get_dhkey ( ) {
		return * m_dhkey;
	}
	const ChallengeString & get_challenge ( ) const {
		return * m_challenge;
	}
	ChallengeString & get_challenge ( ) {
		return * m_challenge;
	}
	const RandomVal & get_random ( ) const {
		return * m_random;
	}
	RandomVal & get_random ( ) {
		return * m_random;
	}
	const TypedCertificate & get_certificate ( ) const {
		return * m_certificate;
	}
	TypedCertificate & get_certificate ( ) {
		return * m_certificate;
	}
	const Identifier & get_generalID ( ) const {
		return * m_generalID;
	}
	Identifier & get_generalID ( ) {
		return * m_generalID;
	}
	const NonStandardParameter & get_nonStandard ( ) const {
		return * m_nonStandard;
	}
	NonStandardParameter & get_nonStandard ( ) {
		return * m_nonStandard;
	}
	const ECKASDH & get_eckasdhkey ( ) const {
		return * m_eckasdhkey;
	}
	ECKASDH & get_eckasdhkey ( ) {
		return * m_eckasdhkey;
	}
	const Identifier & get_sendersID ( ) const {
		return * m_sendersID;
	}
	Identifier & get_sendersID ( ) {
		return * m_sendersID;
	}
	const H235Key & get_h235Key ( ) const {
		return * m_h235Key;
	}
	H235Key & get_h235Key ( ) {
		return * m_h235Key;
	}
	const ArrayOf_ProfileElement & get_profileInfo ( ) const {
		return * m_profileInfo;
	}
	ArrayOf_ProfileElement & get_profileInfo ( ) {
		return * m_profileInfo;
	}
	ClearToken * clone ( ) const;
};

//
// Element
//

// from 0 size 0 type 0 simple 0
class Element : public Asn :: Choice {
	public:
	explicit Element ( Asn :: istream & is );
	Element ( );
	enum Choices {
		e_octets,
		e_integer,
		e_bits,
		e_name,
		e_flag
	};

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	Element * clone ( ) const;
};

//
// IV8
//

// from 0 size 1 type 0 simple 0
class IV8 : public Asn :: OctetString {
	public:
	explicit IV8 ( Asn :: istream & is );
	IV8 ( const Asn :: string & v = Asn :: string ( ) );
	IV8 & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	IV8 * clone ( ) const;
};

//
// IV16
//

// from 0 size 1 type 0 simple 0
class IV16 : public Asn :: OctetString {
	public:
	explicit IV16 ( Asn :: istream & is );
	IV16 ( const Asn :: string & v = Asn :: string ( ) );
	IV16 & operator= ( const Asn :: string & v ) {
		Asn :: OctetString :: operator= ( v );
		return *this;
	}
	IV16 * clone ( ) const;
};

//
// Params
//

// from 0 size 0 type 0 simple 0
class Params : public Asn :: Sequence {
	public:
	explicit Params ( Asn :: istream & is );
	Params ( );
	enum OptionalFields {
		e_ranInt,
		e_iv8,
		e_iv16,
		e_iv,
		e_clearSalt
	};

	Params ( const Params & s );
	Params & operator= ( const Params & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	Asn :: Integer * m_ranInt;
	IV8 * m_iv8;
	IV16 * m_iv16;
	Asn :: OctetString * m_iv;
	Asn :: OctetString * m_clearSalt;
	public:
	void encode ( Asn :: ostream & os ) const;
	~Params ( );
	void printOn ( std :: ostream & os ) const;
	const Asn :: Integer & get_ranInt ( ) const {
		return * m_ranInt;
	}
	Asn :: Integer & get_ranInt ( ) {
		return * m_ranInt;
	}
	const IV8 & get_iv8 ( ) const {
		return * m_iv8;
	}
	IV8 & get_iv8 ( ) {
		return * m_iv8;
	}
	const IV16 & get_iv16 ( ) const {
		return * m_iv16;
	}
	IV16 & get_iv16 ( ) {
		return * m_iv16;
	}
	const Asn :: OctetString & get_iv ( ) const {
		return * m_iv;
	}
	Asn :: OctetString & get_iv ( ) {
		return * m_iv;
	}
	const Asn :: OctetString & get_clearSalt ( ) const {
		return * m_clearSalt;
	}
	Asn :: OctetString & get_clearSalt ( ) {
		return * m_clearSalt;
	}
	Params * clone ( ) const;
};

//
// EncodedGeneralToken
//

// from 0 size 0 type 1 simple 0
class EncodedGeneralToken : public Asn :: OctetString {
	public:
	explicit EncodedGeneralToken ( Asn :: istream & is );
	EncodedGeneralToken ( );
	EncodedGeneralToken * clone ( ) const;
};

//
// PwdCertToken
//

// from 0 size 0 type 2 simple 0
class PwdCertToken : public ClearToken {
	public:
	explicit PwdCertToken ( Asn :: istream & is );
	PwdCertToken ( );
	PwdCertToken * clone ( ) const;
};

//
// EncodedPwdCertToken
//

// from 0 size 0 type 1 simple 0
class EncodedPwdCertToken : public Asn :: OctetString {
	public:
	explicit EncodedPwdCertToken ( Asn :: istream & is );
	EncodedPwdCertToken ( );
	EncodedPwdCertToken * clone ( ) const;
};

//
// EncodedKeySignedMaterial
//

// from 0 size 0 type 1 simple 0
class EncodedKeySignedMaterial : public Asn :: OctetString {
	public:
	explicit EncodedKeySignedMaterial ( Asn :: istream & is );
	EncodedKeySignedMaterial ( );
	EncodedKeySignedMaterial * clone ( ) const;
};

//
// ReturnSig
//

// from 0 size 0 type 0 simple 0
class ReturnSig : public Asn :: Sequence {
	public:
	explicit ReturnSig ( Asn :: istream & is );
	ReturnSig ( );
	enum OptionalFields {
		e_requestRandom,
		e_certificate
	};

	ReturnSig ( const ReturnSig & s );
	ReturnSig & operator= ( const ReturnSig & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	Identifier m_generalId;
	RandomVal m_responseRandom;
	protected:
	RandomVal * m_requestRandom;
	TypedCertificate * m_certificate;
	public:
	void encode ( Asn :: ostream & os ) const;
	~ReturnSig ( );
	void printOn ( std :: ostream & os ) const;
	const RandomVal & get_requestRandom ( ) const {
		return * m_requestRandom;
	}
	RandomVal & get_requestRandom ( ) {
		return * m_requestRandom;
	}
	const TypedCertificate & get_certificate ( ) const {
		return * m_certificate;
	}
	TypedCertificate & get_certificate ( ) {
		return * m_certificate;
	}
	ReturnSig * clone ( ) const;
};

//
// EncodedReturnSig
//

// from 0 size 0 type 1 simple 0
class EncodedReturnSig : public Asn :: OctetString {
	public:
	explicit EncodedReturnSig ( Asn :: istream & is );
	EncodedReturnSig ( );
	EncodedReturnSig * clone ( ) const;
};

//
// KeySyncMaterial
//

// from 0 size 0 type 0 simple 0
class KeySyncMaterial : public Asn :: Sequence {
	public:
	explicit KeySyncMaterial ( Asn :: istream & is );
	KeySyncMaterial ( );
	Identifier m_generalID;
	KeyMaterial m_keyMaterial;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	KeySyncMaterial * clone ( ) const;
};

//
// EncodedKeySyncMaterial
//

// from 0 size 0 type 1 simple 0
class EncodedKeySyncMaterial : public Asn :: OctetString {
	public:
	explicit EncodedKeySyncMaterial ( Asn :: istream & is );
	EncodedKeySyncMaterial ( );
	EncodedKeySyncMaterial * clone ( ) const;
};

//
// V3KeySyncMaterial
//

// from 0 size 0 type 0 simple 0
class V3KeySyncMaterial : public Asn :: Sequence {
	public:
	explicit V3KeySyncMaterial ( Asn :: istream & is );
	V3KeySyncMaterial ( );
	enum OptionalFields {
		e_generalID,
		e_algorithmOID,
		e_encryptedSessionKey,
		e_encryptedSaltingKey,
		e_clearSaltingKey,
		e_paramSsalt,
		e_keyDerivationOID,
		e_genericKeyMaterial
	};

	V3KeySyncMaterial ( const V3KeySyncMaterial & s );
	V3KeySyncMaterial & operator= ( const V3KeySyncMaterial & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	protected:
	Identifier * m_generalID;
	Asn :: ObjectId * m_algorithmOID;
	public:
	Params m_paramS;
	protected:
	Asn :: OctetString * m_encryptedSessionKey;
	Asn :: OctetString * m_encryptedSaltingKey;
	Asn :: OctetString * m_clearSaltingKey;
	Params * m_paramSsalt;
	Asn :: ObjectId * m_keyDerivationOID;
	Asn :: OctetString * m_genericKeyMaterial;
	public:
	void encode ( Asn :: ostream & os ) const;
	~V3KeySyncMaterial ( );
	void printOn ( std :: ostream & os ) const;
	const Identifier & get_generalID ( ) const {
		return * m_generalID;
	}
	Identifier & get_generalID ( ) {
		return * m_generalID;
	}
	const Asn :: ObjectId & get_algorithmOID ( ) const {
		return * m_algorithmOID;
	}
	Asn :: ObjectId & get_algorithmOID ( ) {
		return * m_algorithmOID;
	}
	const Asn :: OctetString & get_encryptedSessionKey ( ) const {
		return * m_encryptedSessionKey;
	}
	Asn :: OctetString & get_encryptedSessionKey ( ) {
		return * m_encryptedSessionKey;
	}
	const Asn :: OctetString & get_encryptedSaltingKey ( ) const {
		return * m_encryptedSaltingKey;
	}
	Asn :: OctetString & get_encryptedSaltingKey ( ) {
		return * m_encryptedSaltingKey;
	}
	const Asn :: OctetString & get_clearSaltingKey ( ) const {
		return * m_clearSaltingKey;
	}
	Asn :: OctetString & get_clearSaltingKey ( ) {
		return * m_clearSaltingKey;
	}
	const Params & get_paramSsalt ( ) const {
		return * m_paramSsalt;
	}
	Params & get_paramSsalt ( ) {
		return * m_paramSsalt;
	}
	const Asn :: ObjectId & get_keyDerivationOID ( ) const {
		return * m_keyDerivationOID;
	}
	Asn :: ObjectId & get_keyDerivationOID ( ) {
		return * m_keyDerivationOID;
	}
	const Asn :: OctetString & get_genericKeyMaterial ( ) const {
		return * m_genericKeyMaterial;
	}
	Asn :: OctetString & get_genericKeyMaterial ( ) {
		return * m_genericKeyMaterial;
	}
	V3KeySyncMaterial * clone ( ) const;
};

//
// DHset_halfkey
//

// from 0 size 1 type 0 simple 0
class DHset_halfkey : public Asn :: BitString {
	public:
	explicit DHset_halfkey ( Asn :: istream & is );
	DHset_halfkey ( const Asn :: string & v = Asn :: string ( ), unsigned b = 0 );
	DHset_halfkey * clone ( ) const;
};

//
// DHset_modSize
//

// from 0 size 1 type 0 simple 0
class DHset_modSize : public Asn :: BitString {
	public:
	explicit DHset_modSize ( Asn :: istream & is );
	DHset_modSize ( const Asn :: string & v = Asn :: string ( ), unsigned b = 0 );
	DHset_modSize * clone ( ) const;
};

//
// DHset_generator
//

// from 0 size 1 type 0 simple 0
class DHset_generator : public Asn :: BitString {
	public:
	explicit DHset_generator ( Asn :: istream & is );
	DHset_generator ( const Asn :: string & v = Asn :: string ( ), unsigned b = 0 );
	DHset_generator * clone ( ) const;
};

//
// ECpoint_x
//

// from 0 size 1 type 0 simple 0
class ECpoint_x : public Asn :: BitString {
	public:
	explicit ECpoint_x ( Asn :: istream & is );
	ECpoint_x ( const Asn :: string & v = Asn :: string ( ), unsigned b = 0 );
	ECpoint_x * clone ( ) const;
};

//
// ECpoint_y
//

// from 0 size 1 type 0 simple 0
class ECpoint_y : public Asn :: BitString {
	public:
	explicit ECpoint_y ( Asn :: istream & is );
	ECpoint_y ( const Asn :: string & v = Asn :: string ( ), unsigned b = 0 );
	ECpoint_y * clone ( ) const;
};

//
// ECGDSASignature_r
//

// from 0 size 1 type 0 simple 0
class ECGDSASignature_r : public Asn :: BitString {
	public:
	explicit ECGDSASignature_r ( Asn :: istream & is );
	ECGDSASignature_r ( const Asn :: string & v = Asn :: string ( ), unsigned b = 0 );
	ECGDSASignature_r * clone ( ) const;
};

//
// ECGDSASignature_s
//

// from 0 size 1 type 0 simple 0
class ECGDSASignature_s : public Asn :: BitString {
	public:
	explicit ECGDSASignature_s ( Asn :: istream & is );
	ECGDSASignature_s ( const Asn :: string & v = Asn :: string ( ), unsigned b = 0 );
	ECGDSASignature_s * clone ( ) const;
};

//
// ArrayOf_ProfileElement
//

// from 0 size 0 type 0 simple 0
class ProfileElement;

class ArrayOf_ProfileElement : public Asn :: Array {
	public:
	explicit ArrayOf_ProfileElement ( Asn :: istream & is );
	ArrayOf_ProfileElement ( );
	explicit ArrayOf_ProfileElement ( int s );
	private:
	static Asn :: Object * createObject ( Asn :: istream & );
	static Asn :: Object * createObject ( );
	Asn :: Object * createObjectVirt ( ) const;
	public:
	void push_back ( const ProfileElement & o );
	const ProfileElement & operator[] ( std :: size_t i ) const;
	ProfileElement & operator[] ( std :: size_t i );
	ArrayOf_ProfileElement * clone ( ) const;
};

//
// ProfileElement_elementID
//

// from 0 size 0 type 0 simple 1
class ProfileElement_elementID : public Asn :: Integer {
	public:
	explicit ProfileElement_elementID ( Asn :: istream & is );
	ProfileElement_elementID ( unsigned v = 0 );
	ProfileElement_elementID & operator= ( int v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	ProfileElement_elementID & operator= ( unsigned v ) {
		Asn :: Integer :: operator= ( v );
		return * this;
	}
	ProfileElement_elementID * clone ( ) const;
};

//
// ECKASDH_eckasdhp_modulus
//

// from 0 size 1 type 0 simple 0
class ECKASDH_eckasdhp_modulus : public Asn :: BitString {
	public:
	explicit ECKASDH_eckasdhp_modulus ( Asn :: istream & is );
	ECKASDH_eckasdhp_modulus ( const Asn :: string & v = Asn :: string ( ), unsigned b = 0 );
	ECKASDH_eckasdhp_modulus * clone ( ) const;
};

//
// ECKASDH_eckasdhp_weierstrassA
//

// from 0 size 1 type 0 simple 0
class ECKASDH_eckasdhp_weierstrassA : public Asn :: BitString {
	public:
	explicit ECKASDH_eckasdhp_weierstrassA ( Asn :: istream & is );
	ECKASDH_eckasdhp_weierstrassA ( const Asn :: string & v = Asn :: string ( ), unsigned b = 0 );
	ECKASDH_eckasdhp_weierstrassA * clone ( ) const;
};

//
// ECKASDH_eckasdhp_weierstrassB
//

// from 0 size 1 type 0 simple 0
class ECKASDH_eckasdhp_weierstrassB : public Asn :: BitString {
	public:
	explicit ECKASDH_eckasdhp_weierstrassB ( Asn :: istream & is );
	ECKASDH_eckasdhp_weierstrassB ( const Asn :: string & v = Asn :: string ( ), unsigned b = 0 );
	ECKASDH_eckasdhp_weierstrassB * clone ( ) const;
};

//
// ECKASDH_eckasdh2_fieldSize
//

// from 0 size 1 type 0 simple 0
class ECKASDH_eckasdh2_fieldSize : public Asn :: BitString {
	public:
	explicit ECKASDH_eckasdh2_fieldSize ( Asn :: istream & is );
	ECKASDH_eckasdh2_fieldSize ( const Asn :: string & v = Asn :: string ( ), unsigned b = 0 );
	ECKASDH_eckasdh2_fieldSize * clone ( ) const;
};

//
// ECKASDH_eckasdh2_weierstrassA
//

// from 0 size 1 type 0 simple 0
class ECKASDH_eckasdh2_weierstrassA : public Asn :: BitString {
	public:
	explicit ECKASDH_eckasdh2_weierstrassA ( Asn :: istream & is );
	ECKASDH_eckasdh2_weierstrassA ( const Asn :: string & v = Asn :: string ( ), unsigned b = 0 );
	ECKASDH_eckasdh2_weierstrassA * clone ( ) const;
};

//
// ECKASDH_eckasdh2_weierstrassB
//

// from 0 size 1 type 0 simple 0
class ECKASDH_eckasdh2_weierstrassB : public Asn :: BitString {
	public:
	explicit ECKASDH_eckasdh2_weierstrassB ( Asn :: istream & is );
	ECKASDH_eckasdh2_weierstrassB ( const Asn :: string & v = Asn :: string ( ), unsigned b = 0 );
	ECKASDH_eckasdh2_weierstrassB * clone ( ) const;
};

//
// DHset
//

// from 0 size 0 type 0 simple 0
class DHset : public Asn :: Sequence {
	public:
	explicit DHset ( Asn :: istream & is );
	DHset ( );
	DHset_halfkey m_halfkey;
	DHset_modSize m_modSize;
	DHset_generator m_generator;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	DHset * clone ( ) const;
};

//
// ECGDSASignature
//

// from 0 size 0 type 0 simple 0
class ECGDSASignature : public Asn :: Sequence {
	public:
	explicit ECGDSASignature ( Asn :: istream & is );
	ECGDSASignature ( );
	ECGDSASignature_r m_r;
	ECGDSASignature_s m_s;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	ECGDSASignature * clone ( ) const;
};

//
// ProfileElement
//

// from 0 size 0 type 0 simple 0
class ProfileElement : public Asn :: Sequence {
	public:
	explicit ProfileElement ( Asn :: istream & is );
	ProfileElement ( );
	enum OptionalFields {
		e_paramS,
		e_element
	};

	ProfileElement ( const ProfileElement & s );
	ProfileElement & operator= ( const ProfileElement & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	ProfileElement_elementID m_elementID;
	protected:
	Params * m_paramS;
	Element * m_element;
	public:
	void encode ( Asn :: ostream & os ) const;
	~ProfileElement ( );
	void printOn ( std :: ostream & os ) const;
	const Params & get_paramS ( ) const {
		return * m_paramS;
	}
	Params & get_paramS ( ) {
		return * m_paramS;
	}
	const Element & get_element ( ) const {
		return * m_element;
	}
	Element & get_element ( ) {
		return * m_element;
	}
	ProfileElement * clone ( ) const;
};

//
// SIGNED
//

// from 0 size 0 type 0 simple 0
template < typename ToBeSigned > class SIGNED : public Asn :: Sequence {
	public:
	explicit SIGNED ( Asn :: istream & is );
	SIGNED ( );
	ToBeSigned m_toBeSigned;
	Asn :: ObjectId m_algorithmOID;
	Params m_paramS;
	Asn :: BitString m_signature;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	SIGNED * clone ( ) const;
};

//
// ENCRYPTED
//

// from 0 size 0 type 0 simple 0
template < typename ToBeEncrypted > class ENCRYPTED : public Asn :: Sequence {
	public:
	explicit ENCRYPTED ( Asn :: istream & is );
	ENCRYPTED ( );
	Asn :: ObjectId m_algorithmOID;
	Params m_paramS;
	Asn :: OctetString m_encryptedData;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	ENCRYPTED * clone ( ) const;
};

//
// HASHED
//

// from 0 size 0 type 0 simple 0
template < typename ToBeHashed > class HASHED : public Asn :: Sequence {
	public:
	explicit HASHED ( Asn :: istream & is );
	HASHED ( );
	Asn :: ObjectId m_algorithmOID;
	Params m_paramS;
	Asn :: BitString m_hash;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	HASHED * clone ( ) const;
};

//
// H235Key
//

// from 0 size 0 type 0 simple 0
class H235Key : public Asn :: Choice {
	public:
	explicit H235Key ( Asn :: istream & is );
	H235Key ( );
	enum Choices {
		e_secureChannel,
		e_sharedSecret,
		e_certProtectedKey,
		e_secureSharedSecret
	};

	operator KeyMaterial & ( ) { return dynamic_cast < KeyMaterial & > ( * choice ); }
	operator const KeyMaterial & ( ) const { return dynamic_cast < const KeyMaterial & > ( * choice ); }
	operator ENCRYPTED < EncodedKeySyncMaterial > & ( ) { return dynamic_cast < ENCRYPTED < EncodedKeySyncMaterial > & > ( * choice ); }
	operator const ENCRYPTED < EncodedKeySyncMaterial > & ( ) const { return dynamic_cast < const ENCRYPTED < EncodedKeySyncMaterial > & > ( * choice ); }
	operator SIGNED < EncodedKeySignedMaterial > & ( ) { return dynamic_cast < SIGNED < EncodedKeySignedMaterial > & > ( * choice ); }
	operator const SIGNED < EncodedKeySignedMaterial > & ( ) const { return dynamic_cast < const SIGNED < EncodedKeySignedMaterial > & > ( * choice ); }
	operator V3KeySyncMaterial & ( ) { return dynamic_cast < V3KeySyncMaterial & > ( * choice ); }
	operator const V3KeySyncMaterial & ( ) const { return dynamic_cast < const V3KeySyncMaterial & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	H235Key * clone ( ) const;
};

//
// KeySignedMaterial
//

// from 0 size 0 type 0 simple 0
class KeySignedMaterial : public Asn :: Sequence {
	public:
	explicit KeySignedMaterial ( Asn :: istream & is );
	KeySignedMaterial ( );
	enum OptionalFields {
		e_srandom,
		e_timeStamp
	};

	KeySignedMaterial ( const KeySignedMaterial & s );
	KeySignedMaterial & operator= ( const KeySignedMaterial & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	Identifier m_generalId;
	RandomVal m_mrandom;
	protected:
	RandomVal * m_srandom;
	TimeStamp * m_timeStamp;
	public:
	ENCRYPTED < EncodedKeySyncMaterial > m_encrptval;
	void encode ( Asn :: ostream & os ) const;
	~KeySignedMaterial ( );
	void printOn ( std :: ostream & os ) const;
	const RandomVal & get_srandom ( ) const {
		return * m_srandom;
	}
	RandomVal & get_srandom ( ) {
		return * m_srandom;
	}
	const TimeStamp & get_timeStamp ( ) const {
		return * m_timeStamp;
	}
	TimeStamp & get_timeStamp ( ) {
		return * m_timeStamp;
	}
	KeySignedMaterial * clone ( ) const;
};

//
// H235CertificateSignature
//

// from 0 size 0 type 0 simple 0
class H235CertificateSignature : public Asn :: Sequence {
	public:
	explicit H235CertificateSignature ( Asn :: istream & is );
	H235CertificateSignature ( );
	enum OptionalFields {
		e_requesterRandom
	};

	H235CertificateSignature ( const H235CertificateSignature & s );
	H235CertificateSignature & operator= ( const H235CertificateSignature & s );
	void includeOptionalField ( OptionalFields f );
	void removeOptionalField ( OptionalFields f );
	TypedCertificate m_certificate;
	RandomVal m_responseRandom;
	protected:
	RandomVal * m_requesterRandom;
	public:
	SIGNED < EncodedReturnSig > m_signature;
	void encode ( Asn :: ostream & os ) const;
	~H235CertificateSignature ( );
	void printOn ( std :: ostream & os ) const;
	const RandomVal & get_requesterRandom ( ) const {
		return * m_requesterRandom;
	}
	RandomVal & get_requesterRandom ( ) {
		return * m_requesterRandom;
	}
	H235CertificateSignature * clone ( ) const;
};

//
// ECKASDH_eckasdhp
//

// from 0 size 0 type 0 simple 0
class ECKASDH_eckasdhp : public Asn :: Sequence {
	public:
	explicit ECKASDH_eckasdhp ( Asn :: istream & is );
	ECKASDH_eckasdhp ( );
	ECpoint m_public_key;
	ECKASDH_eckasdhp_modulus m_modulus;
	ECpoint m_base;
	ECKASDH_eckasdhp_weierstrassA m_weierstrassA;
	ECKASDH_eckasdhp_weierstrassB m_weierstrassB;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	ECKASDH_eckasdhp * clone ( ) const;
};

//
// ECKASDH_eckasdh2
//

// from 0 size 0 type 0 simple 0
class ECKASDH_eckasdh2 : public Asn :: Sequence {
	public:
	explicit ECKASDH_eckasdh2 ( Asn :: istream & is );
	ECKASDH_eckasdh2 ( );
	ECpoint m_public_key;
	ECKASDH_eckasdh2_fieldSize m_fieldSize;
	ECpoint m_base;
	ECKASDH_eckasdh2_weierstrassA m_weierstrassA;
	ECKASDH_eckasdh2_weierstrassB m_weierstrassB;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	ECKASDH_eckasdh2 * clone ( ) const;
};

//
// CryptoToken_cryptoEncryptedToken
//

// from 0 size 0 type 0 simple 0
class CryptoToken_cryptoEncryptedToken : public Asn :: Sequence {
	public:
	explicit CryptoToken_cryptoEncryptedToken ( Asn :: istream & is );
	CryptoToken_cryptoEncryptedToken ( );
	Asn :: ObjectId m_tokenOID;
	ENCRYPTED < EncodedGeneralToken > m_token;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	CryptoToken_cryptoEncryptedToken * clone ( ) const;
};

//
// CryptoToken_cryptoSignedToken
//

// from 0 size 0 type 0 simple 0
class CryptoToken_cryptoSignedToken : public Asn :: Sequence {
	public:
	explicit CryptoToken_cryptoSignedToken ( Asn :: istream & is );
	CryptoToken_cryptoSignedToken ( );
	Asn :: ObjectId m_tokenOID;
	SIGNED < EncodedGeneralToken > m_token;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	CryptoToken_cryptoSignedToken * clone ( ) const;
};

//
// CryptoToken_cryptoHashedToken
//

// from 0 size 0 type 0 simple 0
class CryptoToken_cryptoHashedToken : public Asn :: Sequence {
	public:
	explicit CryptoToken_cryptoHashedToken ( Asn :: istream & is );
	CryptoToken_cryptoHashedToken ( );
	Asn :: ObjectId m_tokenOID;
	ClearToken m_hashedVals;
	HASHED < EncodedGeneralToken > m_token;
	void encode ( Asn :: ostream & os ) const;
	void printOn ( std :: ostream & os ) const;
	CryptoToken_cryptoHashedToken * clone ( ) const;
};

//
// ECKASDH
//

// from 0 size 0 type 0 simple 0
class ECKASDH : public Asn :: Choice {
	public:
	explicit ECKASDH ( Asn :: istream & is );
	ECKASDH ( );
	enum Choices {
		e_eckasdhp,
		e_eckasdh2
	};

	operator ECKASDH_eckasdhp & ( ) { return dynamic_cast < ECKASDH_eckasdhp & > ( * choice ); }
	operator const ECKASDH_eckasdhp & ( ) const { return dynamic_cast < const ECKASDH_eckasdhp & > ( * choice ); }
	operator ECKASDH_eckasdh2 & ( ) { return dynamic_cast < ECKASDH_eckasdh2 & > ( * choice ); }
	operator const ECKASDH_eckasdh2 & ( ) const { return dynamic_cast < const ECKASDH_eckasdh2 & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	ECKASDH * clone ( ) const;
};

//
// CryptoToken
//

// from 0 size 0 type 0 simple 0
class CryptoToken : public Asn :: Choice {
	public:
	explicit CryptoToken ( Asn :: istream & is );
	CryptoToken ( );
	enum Choices {
		e_cryptoEncryptedToken,
		e_cryptoSignedToken,
		e_cryptoHashedToken,
		e_cryptoPwdEncr
	};

	operator CryptoToken_cryptoEncryptedToken & ( ) { return dynamic_cast < CryptoToken_cryptoEncryptedToken & > ( * choice ); }
	operator const CryptoToken_cryptoEncryptedToken & ( ) const { return dynamic_cast < const CryptoToken_cryptoEncryptedToken & > ( * choice ); }
	operator CryptoToken_cryptoSignedToken & ( ) { return dynamic_cast < CryptoToken_cryptoSignedToken & > ( * choice ); }
	operator const CryptoToken_cryptoSignedToken & ( ) const { return dynamic_cast < const CryptoToken_cryptoSignedToken & > ( * choice ); }
	operator CryptoToken_cryptoHashedToken & ( ) { return dynamic_cast < CryptoToken_cryptoHashedToken & > ( * choice ); }
	operator const CryptoToken_cryptoHashedToken & ( ) const { return dynamic_cast < const CryptoToken_cryptoHashedToken & > ( * choice ); }
	operator ENCRYPTED < EncodedPwdCertToken > & ( ) { return dynamic_cast < ENCRYPTED < EncodedPwdCertToken > & > ( * choice ); }
	operator const ENCRYPTED < EncodedPwdCertToken > & ( ) const { return dynamic_cast < const ENCRYPTED < EncodedPwdCertToken > & > ( * choice ); }

	void setTag ( Choices t );
	private:
	const Asn :: NamesMapType & getNames ( ) const;
	public:
	CryptoToken * clone ( ) const;
};

};

#endif // __H235_HPP


// End of h235.hpp
