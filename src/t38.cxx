//
// t38.cxx
//
// Code automatically generated by asnparse.
//

#ifdef __GNUC__
#pragma implementation "t38.hpp"
#endif

#include "ss.hpp"
#include "allocatable.hpp"
#include <stdexcept>
#include <iomanip>
#include <limits>
#include <cstring>
#include "asn.hpp"

#include "t38.hpp"


using namespace T38;

//
// Data-Field
//

Data_Field :: Data_Field ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

Data_Field :: Data_Field ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

Data_Field :: Data_Field ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * Data_Field :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * Data_Field :: createObject ( Asn :: istream & is ) {
	return new Data_Field_subtype ( is );
}

Asn :: Object * Data_Field :: createObject ( ) {
	return new Data_Field_subtype ( );
}

Data_Field_subtype & Data_Field :: operator[] ( std :: size_t i ) {
	return dynamic_cast < Data_Field_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

void Data_Field :: push_back ( const Data_Field_subtype & o ) {
	Asn :: Array :: push_back ( new Data_Field_subtype ( o ) );
}

const Data_Field_subtype & Data_Field :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const Data_Field_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

Data_Field * Data_Field :: clone ( ) const {
	return new Data_Field ( * this );
}

//
// PreCorrigendum-Data-Field
//

PreCorrigendum_Data_Field :: PreCorrigendum_Data_Field ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

PreCorrigendum_Data_Field :: PreCorrigendum_Data_Field ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

PreCorrigendum_Data_Field :: PreCorrigendum_Data_Field ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * PreCorrigendum_Data_Field :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * PreCorrigendum_Data_Field :: createObject ( Asn :: istream & is ) {
	return new PreCorrigendum_Data_Field_subtype ( is );
}

Asn :: Object * PreCorrigendum_Data_Field :: createObject ( ) {
	return new PreCorrigendum_Data_Field_subtype ( );
}

PreCorrigendum_Data_Field_subtype & PreCorrigendum_Data_Field :: operator[] ( std :: size_t i ) {
	return dynamic_cast < PreCorrigendum_Data_Field_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

void PreCorrigendum_Data_Field :: push_back ( const PreCorrigendum_Data_Field_subtype & o ) {
	Asn :: Array :: push_back ( new PreCorrigendum_Data_Field_subtype ( o ) );
}

const PreCorrigendum_Data_Field_subtype & PreCorrigendum_Data_Field :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const PreCorrigendum_Data_Field_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

PreCorrigendum_Data_Field * PreCorrigendum_Data_Field :: clone ( ) const {
	return new PreCorrigendum_Data_Field ( * this );
}

//
// Type-of-msg_t30-indicator
//

Type_of_msg_t30_indicator :: Type_of_msg_t30_indicator ( Asn :: istream & is ) : Asn :: Enumeration ( is, 15, true ) { }

Type_of_msg_t30_indicator :: Type_of_msg_t30_indicator ( ) : Asn :: Enumeration ( e_no_signal, 15, true ) { }

const Asn :: NamesMapType & Type_of_msg_t30_indicator :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_no_signal, "no_signal" },
		{ e_cng, "cng" },
		{ e_ced, "ced" },
		{ e_v21_preamble, "v21_preamble" },
		{ e_v27_2400_training, "v27_2400_training" },
		{ e_v27_4800_training, "v27_4800_training" },
		{ e_v29_7200_training, "v29_7200_training" },
		{ e_v29_9600_training, "v29_9600_training" },
		{ e_v17_7200_short_training, "v17_7200_short_training" },
		{ e_v17_7200_long_training, "v17_7200_long_training" },
		{ e_v17_9600_short_training, "v17_9600_short_training" },
		{ e_v17_9600_long_training, "v17_9600_long_training" },
		{ e_v17_12000_short_training, "v17_12000_short_training" },
		{ e_v17_12000_long_training, "v17_12000_long_training" },
		{ e_v17_14400_short_training, "v17_14400_short_training" },
		{ e_v17_14400_long_training, "v17_14400_long_training" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

Type_of_msg_t30_indicator * Type_of_msg_t30_indicator :: clone ( ) const {
	return new Type_of_msg_t30_indicator ( * this );
}

//
// Type-of-msg_data
//

Type_of_msg_data :: Type_of_msg_data ( Asn :: istream & is ) : Asn :: Enumeration ( is, 8, true ) { }

Type_of_msg_data :: Type_of_msg_data ( ) : Asn :: Enumeration ( e_v21, 8, true ) { }

const Asn :: NamesMapType & Type_of_msg_data :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_v21, "v21" },
		{ e_v27_2400, "v27_2400" },
		{ e_v27_4800, "v27_4800" },
		{ e_v29_7200, "v29_7200" },
		{ e_v29_9600, "v29_9600" },
		{ e_v17_7200, "v17_7200" },
		{ e_v17_9600, "v17_9600" },
		{ e_v17_12000, "v17_12000" },
		{ e_v17_14400, "v17_14400" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

Type_of_msg_data * Type_of_msg_data :: clone ( ) const {
	return new Type_of_msg_data ( * this );
}

//
// UDPTLPacket_seq-number
//

UDPTLPacket_seq_number :: UDPTLPacket_seq_number ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

UDPTLPacket_seq_number :: UDPTLPacket_seq_number ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

UDPTLPacket_seq_number * UDPTLPacket_seq_number :: clone ( ) const {
	return new UDPTLPacket_seq_number ( * this );
}

//
// UDPTLPacket_primary-ifp-packet
//

UDPTLPacket_primary_ifp_packet :: UDPTLPacket_primary_ifp_packet ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

UDPTLPacket_primary_ifp_packet :: UDPTLPacket_primary_ifp_packet ( ) : Asn :: OctetString ( "", Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

UDPTLPacket_primary_ifp_packet * UDPTLPacket_primary_ifp_packet :: clone ( ) const {
	return new UDPTLPacket_primary_ifp_packet ( * this );
}

//
// Data-Field_subtype_field-type
//

Data_Field_subtype_field_type :: Data_Field_subtype_field_type ( Asn :: istream & is ) : Asn :: Enumeration ( is, 7, true ) { }

Data_Field_subtype_field_type :: Data_Field_subtype_field_type ( ) : Asn :: Enumeration ( e_hdlc_data, 7, true ) { }

const Asn :: NamesMapType & Data_Field_subtype_field_type :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_hdlc_data, "hdlc_data" },
		{ e_hdlc_sig_end, "hdlc_sig_end" },
		{ e_hdlc_fcs_OK, "hdlc_fcs_OK" },
		{ e_hdlc_fcs_BAD, "hdlc_fcs_BAD" },
		{ e_hdlc_fcs_OK_sig_end, "hdlc_fcs_OK_sig_end" },
		{ e_hdlc_fcs_BAD_sig_end, "hdlc_fcs_BAD_sig_end" },
		{ e_t4_non_ecm_data, "t4_non_ecm_data" },
		{ e_t4_non_ecm_sig_end, "t4_non_ecm_sig_end" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

Data_Field_subtype_field_type * Data_Field_subtype_field_type :: clone ( ) const {
	return new Data_Field_subtype_field_type ( * this );
}

//
// Data-Field_subtype_field-data
//

Data_Field_subtype_field_data :: Data_Field_subtype_field_data ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 1, 65535 ) { }

Data_Field_subtype_field_data :: Data_Field_subtype_field_data ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 1, 65535 ) { }

Data_Field_subtype_field_data * Data_Field_subtype_field_data :: clone ( ) const {
	return new Data_Field_subtype_field_data ( * this );
}

//
// PreCorrigendum-Data-Field_subtype_field-type
//

PreCorrigendum_Data_Field_subtype_field_type :: PreCorrigendum_Data_Field_subtype_field_type ( Asn :: istream & is ) : Asn :: Enumeration ( is, 7, false ) { }

PreCorrigendum_Data_Field_subtype_field_type :: PreCorrigendum_Data_Field_subtype_field_type ( ) : Asn :: Enumeration ( e_hdlc_data, 7, false ) { }

const Asn :: NamesMapType & PreCorrigendum_Data_Field_subtype_field_type :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_hdlc_data, "hdlc_data" },
		{ e_hdlc_sig_end, "hdlc_sig_end" },
		{ e_hdlc_fcs_OK, "hdlc_fcs_OK" },
		{ e_hdlc_fcs_BAD, "hdlc_fcs_BAD" },
		{ e_hdlc_fcs_OK_sig_end, "hdlc_fcs_OK_sig_end" },
		{ e_hdlc_fcs_BAD_sig_end, "hdlc_fcs_BAD_sig_end" },
		{ e_t4_non_ecm_data, "t4_non_ecm_data" },
		{ e_t4_non_ecm_sig_end, "t4_non_ecm_sig_end" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

PreCorrigendum_Data_Field_subtype_field_type * PreCorrigendum_Data_Field_subtype_field_type :: clone ( ) const {
	return new PreCorrigendum_Data_Field_subtype_field_type ( * this );
}

//
// PreCorrigendum-Data-Field_subtype_field-data
//

PreCorrigendum_Data_Field_subtype_field_data :: PreCorrigendum_Data_Field_subtype_field_data ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 1, 65535 ) { }

PreCorrigendum_Data_Field_subtype_field_data :: PreCorrigendum_Data_Field_subtype_field_data ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 1, 65535 ) { }

PreCorrigendum_Data_Field_subtype_field_data * PreCorrigendum_Data_Field_subtype_field_data :: clone ( ) const {
	return new PreCorrigendum_Data_Field_subtype_field_data ( * this );
}

//
// UDPTLPacket_error-recovery_secondary-ifp-packets
//

UDPTLPacket_error_recovery_secondary_ifp_packets :: UDPTLPacket_error_recovery_secondary_ifp_packets ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

UDPTLPacket_error_recovery_secondary_ifp_packets :: UDPTLPacket_error_recovery_secondary_ifp_packets ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

UDPTLPacket_error_recovery_secondary_ifp_packets :: UDPTLPacket_error_recovery_secondary_ifp_packets ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * UDPTLPacket_error_recovery_secondary_ifp_packets :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * UDPTLPacket_error_recovery_secondary_ifp_packets :: createObject ( Asn :: istream & is ) {
	return new UDPTLPacket_error_recovery_secondary_ifp_packets_subtype ( is );
}

Asn :: Object * UDPTLPacket_error_recovery_secondary_ifp_packets :: createObject ( ) {
	return new UDPTLPacket_error_recovery_secondary_ifp_packets_subtype ( );
}

UDPTLPacket_error_recovery_secondary_ifp_packets_subtype & UDPTLPacket_error_recovery_secondary_ifp_packets :: operator[] ( std :: size_t i ) {
	return dynamic_cast < UDPTLPacket_error_recovery_secondary_ifp_packets_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

void UDPTLPacket_error_recovery_secondary_ifp_packets :: push_back ( const UDPTLPacket_error_recovery_secondary_ifp_packets_subtype & o ) {
	Asn :: Array :: push_back ( new UDPTLPacket_error_recovery_secondary_ifp_packets_subtype ( o ) );
}

const UDPTLPacket_error_recovery_secondary_ifp_packets_subtype & UDPTLPacket_error_recovery_secondary_ifp_packets :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const UDPTLPacket_error_recovery_secondary_ifp_packets_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

UDPTLPacket_error_recovery_secondary_ifp_packets * UDPTLPacket_error_recovery_secondary_ifp_packets :: clone ( ) const {
	return new UDPTLPacket_error_recovery_secondary_ifp_packets ( * this );
}

//
// UDPTLPacket_error-recovery_secondary-ifp-packets_subtype
//

UDPTLPacket_error_recovery_secondary_ifp_packets_subtype :: UDPTLPacket_error_recovery_secondary_ifp_packets_subtype ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

UDPTLPacket_error_recovery_secondary_ifp_packets_subtype :: UDPTLPacket_error_recovery_secondary_ifp_packets_subtype ( ) : Asn :: OctetString ( "", Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

UDPTLPacket_error_recovery_secondary_ifp_packets_subtype * UDPTLPacket_error_recovery_secondary_ifp_packets_subtype :: clone ( ) const {
	return new UDPTLPacket_error_recovery_secondary_ifp_packets_subtype ( * this );
}

//
// ArrayOf_Asn_OctetString
//

ArrayOf_Asn_OctetString :: ArrayOf_Asn_OctetString ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_Asn_OctetString :: ArrayOf_Asn_OctetString ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_Asn_OctetString :: ArrayOf_Asn_OctetString ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_Asn_OctetString :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_Asn_OctetString :: createObject ( Asn :: istream & is ) {
	return new Asn :: OctetString ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) );
}

Asn :: Object * ArrayOf_Asn_OctetString :: createObject ( ) {
	return new Asn :: OctetString ( );
}

Asn :: OctetString & ArrayOf_Asn_OctetString :: operator[] ( std :: size_t i ) {
	return dynamic_cast < Asn :: OctetString & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_Asn_OctetString :: push_back ( const Asn :: OctetString & o ) {
	Asn :: Array :: push_back ( new Asn :: OctetString ( o ) );
}

const Asn :: OctetString & ArrayOf_Asn_OctetString :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const Asn :: OctetString & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_Asn_OctetString * ArrayOf_Asn_OctetString :: clone ( ) const {
	return new ArrayOf_Asn_OctetString ( * this );
}

//
// Type-of-msg
//

Type_of_msg :: Type_of_msg ( Asn :: istream & is ) : Asn :: Choice ( is, 2, false ) {
	switch ( tag ) {
		case e_t30_indicator:
			choice = new Type_of_msg_t30_indicator ( is );
			break;
		case e_data:
			choice = new Type_of_msg_data ( is );
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
}

Type_of_msg :: Type_of_msg ( ) : Asn :: Choice ( 2, false ) { }

void Type_of_msg :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_t30_indicator:
			o = new Type_of_msg_t30_indicator;
			break;
		case e_data:
			o = new Type_of_msg_data;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & Type_of_msg :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_t30_indicator, "t30_indicator" },
		{ e_data, "data" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

Type_of_msg * Type_of_msg :: clone ( ) const {
	return new Type_of_msg ( * this );
}

//
// Data-Field_subtype
//

Data_Field_subtype :: Data_Field_subtype ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, false, 0 ), m_field_type ( is ), m_field_data ( 0 ) {
	if ( hasOptionalField ( e_field_data ) )
		m_field_data = new Data_Field_subtype_field_data ( is );
}

Data_Field_subtype :: Data_Field_subtype ( ) : Asn :: Sequence ( 1, false, 0 ), m_field_data ( 0 ) { }

Data_Field_subtype & Data_Field_subtype :: operator= ( const Data_Field_subtype & s ) {
	Asn :: Sequence :: operator= ( s );
	m_field_type = s.m_field_type;
	assignCopy ( m_field_data, s.m_field_data );
	return * this;
}

Data_Field_subtype :: Data_Field_subtype ( const Data_Field_subtype & s ) : Asn :: Sequence ( s ), m_field_type ( s.m_field_type ), m_field_data ( 0 ) {
	try {
		if ( s.m_field_data )
			m_field_data = new Data_Field_subtype_field_data ( * s.m_field_data );
	} catch ( ... ) {
		delete m_field_data;
		throw;
	}
}


void Data_Field_subtype :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_field_data:
			assignNew ( m_field_data, new Data_Field_subtype_field_data );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void Data_Field_subtype :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_field_data:
			delete m_field_data;
			m_field_data = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void Data_Field_subtype :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_field_type.encode ( os );
	if ( hasOptionalField ( e_field_data ) )
		m_field_data -> Data_Field_subtype_field_data :: encode ( os );
}

Data_Field_subtype :: ~Data_Field_subtype ( ) {
	delete m_field_data;
}

void Data_Field_subtype :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 13 ) << "field_type = " << std :: setprecision ( indent ) << m_field_type << '\n';
	if ( hasOptionalField ( e_field_data ) ) {
		os << std :: setw ( indent + 13 ) << "field_data = " << std :: setprecision ( indent );
		m_field_data -> Data_Field_subtype_field_data :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent - 1 ) << '}';
}

Data_Field_subtype * Data_Field_subtype :: clone ( ) const {
	return new Data_Field_subtype ( * this );
}

//
// PreCorrigendum-Data-Field_subtype
//

PreCorrigendum_Data_Field_subtype :: PreCorrigendum_Data_Field_subtype ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, false, 0 ), m_field_type ( is ), m_field_data ( 0 ) {
	if ( hasOptionalField ( e_field_data ) )
		m_field_data = new PreCorrigendum_Data_Field_subtype_field_data ( is );
}

PreCorrigendum_Data_Field_subtype :: PreCorrigendum_Data_Field_subtype ( ) : Asn :: Sequence ( 1, false, 0 ), m_field_data ( 0 ) { }

PreCorrigendum_Data_Field_subtype & PreCorrigendum_Data_Field_subtype :: operator= ( const PreCorrigendum_Data_Field_subtype & s ) {
	Asn :: Sequence :: operator= ( s );
	m_field_type = s.m_field_type;
	assignCopy ( m_field_data, s.m_field_data );
	return * this;
}

PreCorrigendum_Data_Field_subtype :: PreCorrigendum_Data_Field_subtype ( const PreCorrigendum_Data_Field_subtype & s ) : Asn :: Sequence ( s ), m_field_type ( s.m_field_type ), m_field_data ( 0 ) {
	try {
		if ( s.m_field_data )
			m_field_data = new PreCorrigendum_Data_Field_subtype_field_data ( * s.m_field_data );
	} catch ( ... ) {
		delete m_field_data;
		throw;
	}
}


void PreCorrigendum_Data_Field_subtype :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_field_data:
			assignNew ( m_field_data, new PreCorrigendum_Data_Field_subtype_field_data );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void PreCorrigendum_Data_Field_subtype :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_field_data:
			delete m_field_data;
			m_field_data = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void PreCorrigendum_Data_Field_subtype :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_field_type.encode ( os );
	if ( hasOptionalField ( e_field_data ) )
		m_field_data -> PreCorrigendum_Data_Field_subtype_field_data :: encode ( os );
}

PreCorrigendum_Data_Field_subtype :: ~PreCorrigendum_Data_Field_subtype ( ) {
	delete m_field_data;
}

void PreCorrigendum_Data_Field_subtype :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 13 ) << "field_type = " << std :: setprecision ( indent ) << m_field_type << '\n';
	if ( hasOptionalField ( e_field_data ) ) {
		os << std :: setw ( indent + 13 ) << "field_data = " << std :: setprecision ( indent );
		m_field_data -> PreCorrigendum_Data_Field_subtype_field_data :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent - 1 ) << '}';
}

PreCorrigendum_Data_Field_subtype * PreCorrigendum_Data_Field_subtype :: clone ( ) const {
	return new PreCorrigendum_Data_Field_subtype ( * this );
}

//
// UDPTLPacket_error-recovery_fec-info
//

UDPTLPacket_error_recovery_fec_info :: UDPTLPacket_error_recovery_fec_info ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, false, 0 ), m_fec_npackets ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ), m_fec_data ( is ) {
}

UDPTLPacket_error_recovery_fec_info :: UDPTLPacket_error_recovery_fec_info ( ) : Asn :: Sequence ( 0, false, 0 ) { }

void UDPTLPacket_error_recovery_fec_info :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_fec_npackets.encode ( os );
	m_fec_data.encode ( os );
}

void UDPTLPacket_error_recovery_fec_info :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 15 ) << "fec_npackets = " << std :: setprecision ( indent ) << m_fec_npackets << '\n';
	os << std :: setw ( indent + 11 ) << "fec_data = " << std :: setprecision ( indent ) << m_fec_data << '\n';
	os << std :: setw ( indent - 1 ) << '}';
}

UDPTLPacket_error_recovery_fec_info * UDPTLPacket_error_recovery_fec_info :: clone ( ) const {
	return new UDPTLPacket_error_recovery_fec_info ( * this );
}

//
// IFPPacket
//

IFPPacket :: IFPPacket ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, false, 0 ), m_type_of_msg ( is ), m_data_field ( 0 ) {
	if ( hasOptionalField ( e_data_field ) )
		m_data_field = new Data_Field ( is );
}

IFPPacket :: IFPPacket ( ) : Asn :: Sequence ( 1, false, 0 ), m_data_field ( 0 ) { }

IFPPacket & IFPPacket :: operator= ( const IFPPacket & s ) {
	Asn :: Sequence :: operator= ( s );
	m_type_of_msg = s.m_type_of_msg;
	assignCopy ( m_data_field, s.m_data_field );
	return * this;
}

IFPPacket :: IFPPacket ( const IFPPacket & s ) : Asn :: Sequence ( s ), m_type_of_msg ( s.m_type_of_msg ), m_data_field ( 0 ) {
	try {
		if ( s.m_data_field )
			m_data_field = new Data_Field ( * s.m_data_field );
	} catch ( ... ) {
		delete m_data_field;
		throw;
	}
}


void IFPPacket :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_data_field:
			assignNew ( m_data_field, new Data_Field );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void IFPPacket :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_data_field:
			delete m_data_field;
			m_data_field = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void IFPPacket :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_type_of_msg.encode ( os );
	if ( hasOptionalField ( e_data_field ) )
		m_data_field -> Data_Field :: encode ( os );
}

IFPPacket :: ~IFPPacket ( ) {
	delete m_data_field;
}

void IFPPacket :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 14 ) << "type_of_msg = " << std :: setprecision ( indent ) << m_type_of_msg << '\n';
	if ( hasOptionalField ( e_data_field ) ) {
		os << std :: setw ( indent + 13 ) << "data_field = " << std :: setprecision ( indent );
		m_data_field -> Data_Field :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent - 1 ) << '}';
}

IFPPacket * IFPPacket :: clone ( ) const {
	return new IFPPacket ( * this );
}

//
// PreCorrigendum-IFPPacket
//

PreCorrigendum_IFPPacket :: PreCorrigendum_IFPPacket ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, false, 0 ), m_type_of_msg ( is ), m_data_field ( 0 ) {
	if ( hasOptionalField ( e_data_field ) )
		m_data_field = new PreCorrigendum_Data_Field ( is );
}

PreCorrigendum_IFPPacket :: PreCorrigendum_IFPPacket ( ) : Asn :: Sequence ( 1, false, 0 ), m_data_field ( 0 ) { }

PreCorrigendum_IFPPacket & PreCorrigendum_IFPPacket :: operator= ( const PreCorrigendum_IFPPacket & s ) {
	Asn :: Sequence :: operator= ( s );
	m_type_of_msg = s.m_type_of_msg;
	assignCopy ( m_data_field, s.m_data_field );
	return * this;
}

PreCorrigendum_IFPPacket :: PreCorrigendum_IFPPacket ( const PreCorrigendum_IFPPacket & s ) : Asn :: Sequence ( s ), m_type_of_msg ( s.m_type_of_msg ), m_data_field ( 0 ) {
	try {
		if ( s.m_data_field )
			m_data_field = new PreCorrigendum_Data_Field ( * s.m_data_field );
	} catch ( ... ) {
		delete m_data_field;
		throw;
	}
}


void PreCorrigendum_IFPPacket :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_data_field:
			assignNew ( m_data_field, new PreCorrigendum_Data_Field );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void PreCorrigendum_IFPPacket :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_data_field:
			delete m_data_field;
			m_data_field = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void PreCorrigendum_IFPPacket :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_type_of_msg.encode ( os );
	if ( hasOptionalField ( e_data_field ) )
		m_data_field -> PreCorrigendum_Data_Field :: encode ( os );
}

PreCorrigendum_IFPPacket :: ~PreCorrigendum_IFPPacket ( ) {
	delete m_data_field;
}

void PreCorrigendum_IFPPacket :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 14 ) << "type_of_msg = " << std :: setprecision ( indent ) << m_type_of_msg << '\n';
	if ( hasOptionalField ( e_data_field ) ) {
		os << std :: setw ( indent + 13 ) << "data_field = " << std :: setprecision ( indent );
		m_data_field -> PreCorrigendum_Data_Field :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent - 1 ) << '}';
}

PreCorrigendum_IFPPacket * PreCorrigendum_IFPPacket :: clone ( ) const {
	return new PreCorrigendum_IFPPacket ( * this );
}

//
// UDPTLPacket_error-recovery
//

UDPTLPacket_error_recovery :: UDPTLPacket_error_recovery ( Asn :: istream & is ) : Asn :: Choice ( is, 2, false ) {
	switch ( tag ) {
		case e_secondary_ifp_packets:
			choice = new UDPTLPacket_error_recovery_secondary_ifp_packets ( is );
			break;
		case e_fec_info:
			choice = new UDPTLPacket_error_recovery_fec_info ( is );
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
}

UDPTLPacket_error_recovery :: UDPTLPacket_error_recovery ( ) : Asn :: Choice ( 2, false ) { }

void UDPTLPacket_error_recovery :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_secondary_ifp_packets:
			o = new UDPTLPacket_error_recovery_secondary_ifp_packets;
			break;
		case e_fec_info:
			o = new UDPTLPacket_error_recovery_fec_info;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & UDPTLPacket_error_recovery :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_secondary_ifp_packets, "secondary_ifp_packets" },
		{ e_fec_info, "fec_info" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

UDPTLPacket_error_recovery * UDPTLPacket_error_recovery :: clone ( ) const {
	return new UDPTLPacket_error_recovery ( * this );
}

//
// UDPTLPacket
//

UDPTLPacket :: UDPTLPacket ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, false, 0 ), m_seq_number ( is ), m_primary_ifp_packet ( is ), m_error_recovery ( is ) {
}

UDPTLPacket :: UDPTLPacket ( ) : Asn :: Sequence ( 0, false, 0 ) { }

void UDPTLPacket :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_seq_number.encode ( os );
	m_primary_ifp_packet.encode ( os );
	m_error_recovery.encode ( os );
}

void UDPTLPacket :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 13 ) << "seq_number = " << std :: setprecision ( indent ) << m_seq_number << '\n';
	os << std :: setw ( indent + 21 ) << "primary_ifp_packet = " << std :: setprecision ( indent ) << m_primary_ifp_packet << '\n';
	os << std :: setw ( indent + 17 ) << "error_recovery = " << std :: setprecision ( indent ) << m_error_recovery << '\n';
	os << std :: setw ( indent - 1 ) << '}';
}

UDPTLPacket * UDPTLPacket :: clone ( ) const {
	return new UDPTLPacket ( * this );
}


// End of t38.cxx
