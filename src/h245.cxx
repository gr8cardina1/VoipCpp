//
// h245.cxx
//
// Code automatically generated by asnparse.
//

#ifdef __GNUC__
#pragma implementation "h245.hpp"
#endif

#include "ss.hpp"
#include "allocatable.hpp"
#include <stdexcept>
#include <iomanip>
#include <limits>
#include <cstring>
#include "asn.hpp"

#include "h245.hpp"


using namespace H245;

//
// SequenceNumber
//

SequenceNumber :: SequenceNumber ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 255 ) { }

SequenceNumber :: SequenceNumber ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 255 ) { }

SequenceNumber * SequenceNumber :: clone ( ) const {
	return new SequenceNumber ( * this );
}

//
// MasterSlaveDeterminationRelease
//

MasterSlaveDeterminationRelease :: MasterSlaveDeterminationRelease ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MasterSlaveDeterminationRelease :: MasterSlaveDeterminationRelease ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MasterSlaveDeterminationRelease :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MasterSlaveDeterminationRelease :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MasterSlaveDeterminationRelease * MasterSlaveDeterminationRelease :: clone ( ) const {
	return new MasterSlaveDeterminationRelease ( * this );
}

//
// TerminalCapabilitySet
//

TerminalCapabilitySet :: TerminalCapabilitySet ( Asn :: istream & is ) : Asn :: Sequence ( is, 3, true, 1 ), m_sequenceNumber ( is ), m_protocolIdentifier ( is ), m_multiplexCapability ( 0 ), m_capabilityTable ( 0 ), m_capabilityDescriptors ( 0 ), m_genericInformation ( 0 ) {
	try {
		if ( hasOptionalField ( e_multiplexCapability ) )
			m_multiplexCapability = new MultiplexCapability ( is );
		if ( hasOptionalField ( e_capabilityTable ) )
			m_capabilityTable = new TerminalCapabilitySet_capabilityTable ( is );
		if ( hasOptionalField ( e_capabilityDescriptors ) )
			m_capabilityDescriptors = new TerminalCapabilitySet_capabilityDescriptors ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_genericInformation ) )
				m_genericInformation = new ArrayOf_GenericInformation ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_multiplexCapability;
		delete m_capabilityTable;
		delete m_capabilityDescriptors;
		delete m_genericInformation;
		throw;
	}
}

TerminalCapabilitySet :: TerminalCapabilitySet ( ) : Asn :: Sequence ( 3, true, 1 ), m_multiplexCapability ( 0 ), m_capabilityTable ( 0 ), m_capabilityDescriptors ( 0 ), m_genericInformation ( 0 ) { }

TerminalCapabilitySet & TerminalCapabilitySet :: operator= ( const TerminalCapabilitySet & s ) {
	Asn :: Sequence :: operator= ( s );
	m_sequenceNumber = s.m_sequenceNumber;
	m_protocolIdentifier = s.m_protocolIdentifier;
	assignCopy ( m_multiplexCapability, s.m_multiplexCapability );
	assignCopy ( m_capabilityTable, s.m_capabilityTable );
	assignCopy ( m_capabilityDescriptors, s.m_capabilityDescriptors );
	assignCopy ( m_genericInformation, s.m_genericInformation );
	return * this;
}

TerminalCapabilitySet :: TerminalCapabilitySet ( const TerminalCapabilitySet & s ) : Asn :: Sequence ( s ), m_sequenceNumber ( s.m_sequenceNumber ), m_protocolIdentifier ( s.m_protocolIdentifier ), m_multiplexCapability ( 0 ), m_capabilityTable ( 0 ), m_capabilityDescriptors ( 0 ), m_genericInformation ( 0 ) {
	try {
		if ( s.m_multiplexCapability )
			m_multiplexCapability = new MultiplexCapability ( * s.m_multiplexCapability );
		if ( s.m_capabilityTable )
			m_capabilityTable = new TerminalCapabilitySet_capabilityTable ( * s.m_capabilityTable );
		if ( s.m_capabilityDescriptors )
			m_capabilityDescriptors = new TerminalCapabilitySet_capabilityDescriptors ( * s.m_capabilityDescriptors );
		if ( s.m_genericInformation )
			m_genericInformation = new ArrayOf_GenericInformation ( * s.m_genericInformation );
	} catch ( ... ) {
		delete m_multiplexCapability;
		delete m_capabilityTable;
		delete m_capabilityDescriptors;
		delete m_genericInformation;
		throw;
	}
}


void TerminalCapabilitySet :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_multiplexCapability:
			assignNew ( m_multiplexCapability, new MultiplexCapability );
			break;
		case e_capabilityTable:
			assignNew ( m_capabilityTable, new TerminalCapabilitySet_capabilityTable );
			break;
		case e_capabilityDescriptors:
			assignNew ( m_capabilityDescriptors, new TerminalCapabilitySet_capabilityDescriptors );
			break;
		case e_genericInformation:
			assignNew ( m_genericInformation, new ArrayOf_GenericInformation );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void TerminalCapabilitySet :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_multiplexCapability:
			delete m_multiplexCapability;
			m_multiplexCapability = 0;
			break;
		case e_capabilityTable:
			delete m_capabilityTable;
			m_capabilityTable = 0;
			break;
		case e_capabilityDescriptors:
			delete m_capabilityDescriptors;
			m_capabilityDescriptors = 0;
			break;
		case e_genericInformation:
			delete m_genericInformation;
			m_genericInformation = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void TerminalCapabilitySet :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_sequenceNumber.encode ( os );
	m_protocolIdentifier.encode ( os );
	if ( hasOptionalField ( e_multiplexCapability ) )
		m_multiplexCapability -> MultiplexCapability :: encode ( os );
	if ( hasOptionalField ( e_capabilityTable ) )
		m_capabilityTable -> TerminalCapabilitySet_capabilityTable :: encode ( os );
	if ( hasOptionalField ( e_capabilityDescriptors ) )
		m_capabilityDescriptors -> TerminalCapabilitySet_capabilityDescriptors :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_genericInformation, m_genericInformation );
		unknownExtensionsEncode ( os );
	}
}

TerminalCapabilitySet :: ~TerminalCapabilitySet ( ) {
	delete m_multiplexCapability;
	delete m_capabilityTable;
	delete m_capabilityDescriptors;
	delete m_genericInformation;
}

void TerminalCapabilitySet :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 17 ) << "sequenceNumber = " << std :: setprecision ( indent ) << m_sequenceNumber << '\n';
	os << std :: setw ( indent + 21 ) << "protocolIdentifier = " << std :: setprecision ( indent ) << m_protocolIdentifier << '\n';
	if ( hasOptionalField ( e_multiplexCapability ) ) {
		os << std :: setw ( indent + 22 ) << "multiplexCapability = " << std :: setprecision ( indent );
		m_multiplexCapability -> MultiplexCapability :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_capabilityTable ) ) {
		os << std :: setw ( indent + 18 ) << "capabilityTable = " << std :: setprecision ( indent );
		m_capabilityTable -> TerminalCapabilitySet_capabilityTable :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_capabilityDescriptors ) ) {
		os << std :: setw ( indent + 24 ) << "capabilityDescriptors = " << std :: setprecision ( indent );
		m_capabilityDescriptors -> TerminalCapabilitySet_capabilityDescriptors :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_genericInformation ) ) {
		os << std :: setw ( indent + 21 ) << "genericInformation = " << std :: setprecision ( indent );
		m_genericInformation -> ArrayOf_GenericInformation :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

TerminalCapabilitySet * TerminalCapabilitySet :: clone ( ) const {
	return new TerminalCapabilitySet ( * this );
}

//
// AlternativeCapabilitySet
//

AlternativeCapabilitySet :: AlternativeCapabilitySet ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 256 ) { }

AlternativeCapabilitySet :: AlternativeCapabilitySet ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 256 ) { }

AlternativeCapabilitySet :: AlternativeCapabilitySet ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 256 ) { }


Asn :: Object * AlternativeCapabilitySet :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * AlternativeCapabilitySet :: createObject ( Asn :: istream & is ) {
	return new CapabilityTableEntryNumber ( is );
}

Asn :: Object * AlternativeCapabilitySet :: createObject ( ) {
	return new CapabilityTableEntryNumber ( );
}

CapabilityTableEntryNumber & AlternativeCapabilitySet :: operator[] ( std :: size_t i ) {
	return dynamic_cast < CapabilityTableEntryNumber & > ( Asn :: Array :: operator[] ( i ) );
}

void AlternativeCapabilitySet :: push_back ( const CapabilityTableEntryNumber & o ) {
	Asn :: Array :: push_back ( new CapabilityTableEntryNumber ( o ) );
}

const CapabilityTableEntryNumber & AlternativeCapabilitySet :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const CapabilityTableEntryNumber & > ( Asn :: Array :: operator[] ( i ) );
}

AlternativeCapabilitySet * AlternativeCapabilitySet :: clone ( ) const {
	return new AlternativeCapabilitySet ( * this );
}

//
// CapabilityTableEntryNumber
//

CapabilityTableEntryNumber :: CapabilityTableEntryNumber ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 65535 ) { }

CapabilityTableEntryNumber :: CapabilityTableEntryNumber ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 65535 ) { }

CapabilityTableEntryNumber * CapabilityTableEntryNumber :: clone ( ) const {
	return new CapabilityTableEntryNumber ( * this );
}

//
// CapabilityDescriptorNumber
//

CapabilityDescriptorNumber :: CapabilityDescriptorNumber ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 255 ) { }

CapabilityDescriptorNumber :: CapabilityDescriptorNumber ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 255 ) { }

CapabilityDescriptorNumber * CapabilityDescriptorNumber :: clone ( ) const {
	return new CapabilityDescriptorNumber ( * this );
}

//
// TerminalCapabilitySetAck
//

TerminalCapabilitySetAck :: TerminalCapabilitySetAck ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 1 ), m_sequenceNumber ( is ), m_genericInformation ( 0 ) {
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_genericInformation ) )
				m_genericInformation = new ArrayOf_GenericInformation ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_genericInformation;
		throw;
	}
}

TerminalCapabilitySetAck :: TerminalCapabilitySetAck ( ) : Asn :: Sequence ( 0, true, 1 ), m_genericInformation ( 0 ) { }

TerminalCapabilitySetAck & TerminalCapabilitySetAck :: operator= ( const TerminalCapabilitySetAck & s ) {
	Asn :: Sequence :: operator= ( s );
	m_sequenceNumber = s.m_sequenceNumber;
	assignCopy ( m_genericInformation, s.m_genericInformation );
	return * this;
}

TerminalCapabilitySetAck :: TerminalCapabilitySetAck ( const TerminalCapabilitySetAck & s ) : Asn :: Sequence ( s ), m_sequenceNumber ( s.m_sequenceNumber ), m_genericInformation ( 0 ) {
	try {
		if ( s.m_genericInformation )
			m_genericInformation = new ArrayOf_GenericInformation ( * s.m_genericInformation );
	} catch ( ... ) {
		delete m_genericInformation;
		throw;
	}
}


void TerminalCapabilitySetAck :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_genericInformation:
			assignNew ( m_genericInformation, new ArrayOf_GenericInformation );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void TerminalCapabilitySetAck :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_genericInformation:
			delete m_genericInformation;
			m_genericInformation = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void TerminalCapabilitySetAck :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_sequenceNumber.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_genericInformation, m_genericInformation );
		unknownExtensionsEncode ( os );
	}
}

TerminalCapabilitySetAck :: ~TerminalCapabilitySetAck ( ) {
	delete m_genericInformation;
}

void TerminalCapabilitySetAck :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 17 ) << "sequenceNumber = " << std :: setprecision ( indent ) << m_sequenceNumber << '\n';
	if ( hasOptionalField ( e_genericInformation ) ) {
		os << std :: setw ( indent + 21 ) << "genericInformation = " << std :: setprecision ( indent );
		m_genericInformation -> ArrayOf_GenericInformation :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

TerminalCapabilitySetAck * TerminalCapabilitySetAck :: clone ( ) const {
	return new TerminalCapabilitySetAck ( * this );
}

//
// TerminalCapabilitySetRelease
//

TerminalCapabilitySetRelease :: TerminalCapabilitySetRelease ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 1 ), m_genericInformation ( 0 ) {
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_genericInformation ) )
				m_genericInformation = new ArrayOf_GenericInformation ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_genericInformation;
		throw;
	}
}

TerminalCapabilitySetRelease :: TerminalCapabilitySetRelease ( ) : Asn :: Sequence ( 0, true, 1 ), m_genericInformation ( 0 ) { }

TerminalCapabilitySetRelease & TerminalCapabilitySetRelease :: operator= ( const TerminalCapabilitySetRelease & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_genericInformation, s.m_genericInformation );
	return * this;
}

TerminalCapabilitySetRelease :: TerminalCapabilitySetRelease ( const TerminalCapabilitySetRelease & s ) : Asn :: Sequence ( s ), m_genericInformation ( 0 ) {
	try {
		if ( s.m_genericInformation )
			m_genericInformation = new ArrayOf_GenericInformation ( * s.m_genericInformation );
	} catch ( ... ) {
		delete m_genericInformation;
		throw;
	}
}


void TerminalCapabilitySetRelease :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_genericInformation:
			assignNew ( m_genericInformation, new ArrayOf_GenericInformation );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void TerminalCapabilitySetRelease :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_genericInformation:
			delete m_genericInformation;
			m_genericInformation = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void TerminalCapabilitySetRelease :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_genericInformation, m_genericInformation );
		unknownExtensionsEncode ( os );
	}
}

TerminalCapabilitySetRelease :: ~TerminalCapabilitySetRelease ( ) {
	delete m_genericInformation;
}

void TerminalCapabilitySetRelease :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_genericInformation ) ) {
		os << std :: setw ( indent + 21 ) << "genericInformation = " << std :: setprecision ( indent );
		m_genericInformation -> ArrayOf_GenericInformation :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

TerminalCapabilitySetRelease * TerminalCapabilitySetRelease :: clone ( ) const {
	return new TerminalCapabilitySetRelease ( * this );
}

//
// V75Capability
//

V75Capability :: V75Capability ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_audioHeader ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

V75Capability :: V75Capability ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void V75Capability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_audioHeader.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void V75Capability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 14 ) << "audioHeader = " << std :: setprecision ( indent ) << m_audioHeader << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

V75Capability * V75Capability :: clone ( ) const {
	return new V75Capability ( * this );
}

//
// MediaPacketizationCapability
//

MediaPacketizationCapability :: MediaPacketizationCapability ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 1 ), m_h261aVideoPacketization ( is ), m_rtpPayloadType ( 0 ) {
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_rtpPayloadType ) )
				m_rtpPayloadType = new MediaPacketizationCapability_rtpPayloadType ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_rtpPayloadType;
		throw;
	}
}

MediaPacketizationCapability :: MediaPacketizationCapability ( ) : Asn :: Sequence ( 0, true, 1 ), m_rtpPayloadType ( 0 ) { }

MediaPacketizationCapability & MediaPacketizationCapability :: operator= ( const MediaPacketizationCapability & s ) {
	Asn :: Sequence :: operator= ( s );
	m_h261aVideoPacketization = s.m_h261aVideoPacketization;
	assignCopy ( m_rtpPayloadType, s.m_rtpPayloadType );
	return * this;
}

MediaPacketizationCapability :: MediaPacketizationCapability ( const MediaPacketizationCapability & s ) : Asn :: Sequence ( s ), m_h261aVideoPacketization ( s.m_h261aVideoPacketization ), m_rtpPayloadType ( 0 ) {
	try {
		if ( s.m_rtpPayloadType )
			m_rtpPayloadType = new MediaPacketizationCapability_rtpPayloadType ( * s.m_rtpPayloadType );
	} catch ( ... ) {
		delete m_rtpPayloadType;
		throw;
	}
}


void MediaPacketizationCapability :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_rtpPayloadType:
			assignNew ( m_rtpPayloadType, new MediaPacketizationCapability_rtpPayloadType );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void MediaPacketizationCapability :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_rtpPayloadType:
			delete m_rtpPayloadType;
			m_rtpPayloadType = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void MediaPacketizationCapability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_h261aVideoPacketization.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_rtpPayloadType, m_rtpPayloadType );
		unknownExtensionsEncode ( os );
	}
}

MediaPacketizationCapability :: ~MediaPacketizationCapability ( ) {
	delete m_rtpPayloadType;
}

void MediaPacketizationCapability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 26 ) << "h261aVideoPacketization = " << std :: setprecision ( indent ) << m_h261aVideoPacketization << '\n';
	if ( hasOptionalField ( e_rtpPayloadType ) ) {
		os << std :: setw ( indent + 17 ) << "rtpPayloadType = " << std :: setprecision ( indent );
		m_rtpPayloadType -> MediaPacketizationCapability_rtpPayloadType :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MediaPacketizationCapability * MediaPacketizationCapability :: clone ( ) const {
	return new MediaPacketizationCapability ( * this );
}

//
// RSVPParameters
//

RSVPParameters :: RSVPParameters ( Asn :: istream & is ) : Asn :: Sequence ( is, 6, true, 0 ), m_qosMode ( 0 ), m_tokenRate ( 0 ), m_bucketSize ( 0 ), m_peakRate ( 0 ), m_minPoliced ( 0 ), m_maxPktSize ( 0 ) {
	try {
		if ( hasOptionalField ( e_qosMode ) )
			m_qosMode = new QOSMode ( is );
		if ( hasOptionalField ( e_tokenRate ) )
			m_tokenRate = new RSVPParameters_tokenRate ( is );
		if ( hasOptionalField ( e_bucketSize ) )
			m_bucketSize = new RSVPParameters_bucketSize ( is );
		if ( hasOptionalField ( e_peakRate ) )
			m_peakRate = new RSVPParameters_peakRate ( is );
		if ( hasOptionalField ( e_minPoliced ) )
			m_minPoliced = new RSVPParameters_minPoliced ( is );
		if ( hasOptionalField ( e_maxPktSize ) )
			m_maxPktSize = new RSVPParameters_maxPktSize ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_qosMode;
		delete m_tokenRate;
		delete m_bucketSize;
		delete m_peakRate;
		delete m_minPoliced;
		delete m_maxPktSize;
		throw;
	}
}

RSVPParameters :: RSVPParameters ( ) : Asn :: Sequence ( 6, true, 0 ), m_qosMode ( 0 ), m_tokenRate ( 0 ), m_bucketSize ( 0 ), m_peakRate ( 0 ), m_minPoliced ( 0 ), m_maxPktSize ( 0 ) { }

RSVPParameters & RSVPParameters :: operator= ( const RSVPParameters & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_qosMode, s.m_qosMode );
	assignCopy ( m_tokenRate, s.m_tokenRate );
	assignCopy ( m_bucketSize, s.m_bucketSize );
	assignCopy ( m_peakRate, s.m_peakRate );
	assignCopy ( m_minPoliced, s.m_minPoliced );
	assignCopy ( m_maxPktSize, s.m_maxPktSize );
	return * this;
}

RSVPParameters :: RSVPParameters ( const RSVPParameters & s ) : Asn :: Sequence ( s ), m_qosMode ( 0 ), m_tokenRate ( 0 ), m_bucketSize ( 0 ), m_peakRate ( 0 ), m_minPoliced ( 0 ), m_maxPktSize ( 0 ) {
	try {
		if ( s.m_qosMode )
			m_qosMode = new QOSMode ( * s.m_qosMode );
		if ( s.m_tokenRate )
			m_tokenRate = new RSVPParameters_tokenRate ( * s.m_tokenRate );
		if ( s.m_bucketSize )
			m_bucketSize = new RSVPParameters_bucketSize ( * s.m_bucketSize );
		if ( s.m_peakRate )
			m_peakRate = new RSVPParameters_peakRate ( * s.m_peakRate );
		if ( s.m_minPoliced )
			m_minPoliced = new RSVPParameters_minPoliced ( * s.m_minPoliced );
		if ( s.m_maxPktSize )
			m_maxPktSize = new RSVPParameters_maxPktSize ( * s.m_maxPktSize );
	} catch ( ... ) {
		delete m_qosMode;
		delete m_tokenRate;
		delete m_bucketSize;
		delete m_peakRate;
		delete m_minPoliced;
		delete m_maxPktSize;
		throw;
	}
}


void RSVPParameters :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_qosMode:
			assignNew ( m_qosMode, new QOSMode );
			break;
		case e_tokenRate:
			assignNew ( m_tokenRate, new RSVPParameters_tokenRate );
			break;
		case e_bucketSize:
			assignNew ( m_bucketSize, new RSVPParameters_bucketSize );
			break;
		case e_peakRate:
			assignNew ( m_peakRate, new RSVPParameters_peakRate );
			break;
		case e_minPoliced:
			assignNew ( m_minPoliced, new RSVPParameters_minPoliced );
			break;
		case e_maxPktSize:
			assignNew ( m_maxPktSize, new RSVPParameters_maxPktSize );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void RSVPParameters :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_qosMode:
			delete m_qosMode;
			m_qosMode = 0;
			break;
		case e_tokenRate:
			delete m_tokenRate;
			m_tokenRate = 0;
			break;
		case e_bucketSize:
			delete m_bucketSize;
			m_bucketSize = 0;
			break;
		case e_peakRate:
			delete m_peakRate;
			m_peakRate = 0;
			break;
		case e_minPoliced:
			delete m_minPoliced;
			m_minPoliced = 0;
			break;
		case e_maxPktSize:
			delete m_maxPktSize;
			m_maxPktSize = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void RSVPParameters :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_qosMode ) )
		m_qosMode -> QOSMode :: encode ( os );
	if ( hasOptionalField ( e_tokenRate ) )
		m_tokenRate -> RSVPParameters_tokenRate :: encode ( os );
	if ( hasOptionalField ( e_bucketSize ) )
		m_bucketSize -> RSVPParameters_bucketSize :: encode ( os );
	if ( hasOptionalField ( e_peakRate ) )
		m_peakRate -> RSVPParameters_peakRate :: encode ( os );
	if ( hasOptionalField ( e_minPoliced ) )
		m_minPoliced -> RSVPParameters_minPoliced :: encode ( os );
	if ( hasOptionalField ( e_maxPktSize ) )
		m_maxPktSize -> RSVPParameters_maxPktSize :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

RSVPParameters :: ~RSVPParameters ( ) {
	delete m_qosMode;
	delete m_tokenRate;
	delete m_bucketSize;
	delete m_peakRate;
	delete m_minPoliced;
	delete m_maxPktSize;
}

void RSVPParameters :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_qosMode ) ) {
		os << std :: setw ( indent + 10 ) << "qosMode = " << std :: setprecision ( indent );
		m_qosMode -> QOSMode :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_tokenRate ) ) {
		os << std :: setw ( indent + 12 ) << "tokenRate = " << std :: setprecision ( indent );
		m_tokenRate -> RSVPParameters_tokenRate :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_bucketSize ) ) {
		os << std :: setw ( indent + 13 ) << "bucketSize = " << std :: setprecision ( indent );
		m_bucketSize -> RSVPParameters_bucketSize :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_peakRate ) ) {
		os << std :: setw ( indent + 11 ) << "peakRate = " << std :: setprecision ( indent );
		m_peakRate -> RSVPParameters_peakRate :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_minPoliced ) ) {
		os << std :: setw ( indent + 13 ) << "minPoliced = " << std :: setprecision ( indent );
		m_minPoliced -> RSVPParameters_minPoliced :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_maxPktSize ) ) {
		os << std :: setw ( indent + 13 ) << "maxPktSize = " << std :: setprecision ( indent );
		m_maxPktSize -> RSVPParameters_maxPktSize :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RSVPParameters * RSVPParameters :: clone ( ) const {
	return new RSVPParameters ( * this );
}

//
// QOSMode
//

QOSMode :: QOSMode ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_guaranteedQOS:
		case e_controlledLoad:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

QOSMode :: QOSMode ( ) : Asn :: Choice ( 2, true ) { }

void QOSMode :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_guaranteedQOS:
		case e_controlledLoad:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & QOSMode :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_guaranteedQOS, "guaranteedQOS" },
		{ e_controlledLoad, "controlledLoad" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

QOSMode * QOSMode :: clone ( ) const {
	return new QOSMode ( * this );
}

//
// ServicePriorityValue
//

ServicePriorityValue :: ServicePriorityValue ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_nonStandardParameter ( 0 ) {
	try {
		if ( hasOptionalField ( e_nonStandardParameter ) )
			m_nonStandardParameter = new NonStandardParameter ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_nonStandardParameter;
		throw;
	}
}

ServicePriorityValue :: ServicePriorityValue ( ) : Asn :: Sequence ( 1, true, 0 ), m_nonStandardParameter ( 0 ) { }

ServicePriorityValue & ServicePriorityValue :: operator= ( const ServicePriorityValue & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_nonStandardParameter, s.m_nonStandardParameter );
	return * this;
}

ServicePriorityValue :: ServicePriorityValue ( const ServicePriorityValue & s ) : Asn :: Sequence ( s ), m_nonStandardParameter ( 0 ) {
	try {
		if ( s.m_nonStandardParameter )
			m_nonStandardParameter = new NonStandardParameter ( * s.m_nonStandardParameter );
	} catch ( ... ) {
		delete m_nonStandardParameter;
		throw;
	}
}


void ServicePriorityValue :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardParameter:
			assignNew ( m_nonStandardParameter, new NonStandardParameter );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void ServicePriorityValue :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardParameter:
			delete m_nonStandardParameter;
			m_nonStandardParameter = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void ServicePriorityValue :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_nonStandardParameter ) )
		m_nonStandardParameter -> NonStandardParameter :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

ServicePriorityValue :: ~ServicePriorityValue ( ) {
	delete m_nonStandardParameter;
}

void ServicePriorityValue :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_nonStandardParameter ) ) {
		os << std :: setw ( indent + 23 ) << "nonStandardParameter = " << std :: setprecision ( indent );
		m_nonStandardParameter -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

ServicePriorityValue * ServicePriorityValue :: clone ( ) const {
	return new ServicePriorityValue ( * this );
}

//
// ServicePriority
//

ServicePriority :: ServicePriority ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 0 ), m_nonStandardData ( hasOptionalField ( e_nonStandardData ) ? pushTemporaryMember ( new NonStandardParameter ( is ) ) : 0 ), m_servicePrioritySignalled ( is ), m_servicePriorityValue ( 0 ) {
	clearTemporaryMembers ( );
	try {
		if ( hasOptionalField ( e_servicePriorityValue ) )
			m_servicePriorityValue = new ServicePriorityValue ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_servicePriorityValue;
		throw;
	}
}

ServicePriority :: ServicePriority ( ) : Asn :: Sequence ( 2, true, 0 ), m_nonStandardData ( 0 ), m_servicePriorityValue ( 0 ) { }

ServicePriority & ServicePriority :: operator= ( const ServicePriority & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	m_servicePrioritySignalled = s.m_servicePrioritySignalled;
	assignCopy ( m_servicePriorityValue, s.m_servicePriorityValue );
	return * this;
}

ServicePriority :: ServicePriority ( const ServicePriority & s ) : Asn :: Sequence ( s ), m_nonStandardData ( 0 ), m_servicePrioritySignalled ( s.m_servicePrioritySignalled ), m_servicePriorityValue ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_servicePriorityValue )
			m_servicePriorityValue = new ServicePriorityValue ( * s.m_servicePriorityValue );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_servicePriorityValue;
		throw;
	}
}


void ServicePriority :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_servicePriorityValue:
			assignNew ( m_servicePriorityValue, new ServicePriorityValue );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void ServicePriority :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_servicePriorityValue:
			delete m_servicePriorityValue;
			m_servicePriorityValue = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void ServicePriority :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	m_servicePrioritySignalled.encode ( os );
	if ( hasOptionalField ( e_servicePriorityValue ) )
		m_servicePriorityValue -> ServicePriorityValue :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

ServicePriority :: ~ServicePriority ( ) {
	delete m_nonStandardData;
	delete m_servicePriorityValue;
}

void ServicePriority :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 27 ) << "servicePrioritySignalled = " << std :: setprecision ( indent ) << m_servicePrioritySignalled << '\n';
	if ( hasOptionalField ( e_servicePriorityValue ) ) {
		os << std :: setw ( indent + 23 ) << "servicePriorityValue = " << std :: setprecision ( indent );
		m_servicePriorityValue -> ServicePriorityValue :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

ServicePriority * ServicePriority :: clone ( ) const {
	return new ServicePriority ( * this );
}

//
// AuthorizationParameters
//

AuthorizationParameters :: AuthorizationParameters ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_nonStandardData ( 0 ) {
	try {
		if ( hasOptionalField ( e_nonStandardData ) )
			m_nonStandardData = new NonStandardParameter ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_nonStandardData;
		throw;
	}
}

AuthorizationParameters :: AuthorizationParameters ( ) : Asn :: Sequence ( 1, true, 0 ), m_nonStandardData ( 0 ) { }

AuthorizationParameters & AuthorizationParameters :: operator= ( const AuthorizationParameters & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	return * this;
}

AuthorizationParameters :: AuthorizationParameters ( const AuthorizationParameters & s ) : Asn :: Sequence ( s ), m_nonStandardData ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
	} catch ( ... ) {
		delete m_nonStandardData;
		throw;
	}
}


void AuthorizationParameters :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void AuthorizationParameters :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void AuthorizationParameters :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

AuthorizationParameters :: ~AuthorizationParameters ( ) {
	delete m_nonStandardData;
}

void AuthorizationParameters :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

AuthorizationParameters * AuthorizationParameters :: clone ( ) const {
	return new AuthorizationParameters ( * this );
}

//
// QOSType
//

QOSType :: QOSType ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_desired:
		case e_required:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

QOSType :: QOSType ( ) : Asn :: Choice ( 2, true ) { }

void QOSType :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_desired:
		case e_required:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & QOSType :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_desired, "desired" },
		{ e_required, "required" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

QOSType * QOSType :: clone ( ) const {
	return new QOSType ( * this );
}

//
// QOSClass
//

QOSClass :: QOSClass ( Asn :: istream & is ) : Asn :: Choice ( is, 6, true ) {
	switch ( tag ) {
		case e_class0:
		case e_class1:
		case e_class2:
		case e_class3:
		case e_class4:
		case e_class5:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

QOSClass :: QOSClass ( ) : Asn :: Choice ( 6, true ) { }

void QOSClass :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_class0:
		case e_class1:
		case e_class2:
		case e_class3:
		case e_class4:
		case e_class5:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & QOSClass :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_class0, "class0" },
		{ e_class1, "class1" },
		{ e_class2, "class2" },
		{ e_class3, "class3" },
		{ e_class4, "class4" },
		{ e_class5, "class5" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

QOSClass * QOSClass :: clone ( ) const {
	return new QOSClass ( * this );
}

//
// QOSDescriptor
//

QOSDescriptor :: QOSDescriptor ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_nonStandardData ( hasOptionalField ( e_nonStandardData ) ? pushTemporaryMember ( new NonStandardParameter ( is ) ) : 0 ), m_qosType ( is ), m_qosClass ( is ) {
	clearTemporaryMembers ( );
	try {
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_nonStandardData;
		throw;
	}
}

QOSDescriptor :: QOSDescriptor ( ) : Asn :: Sequence ( 1, true, 0 ), m_nonStandardData ( 0 ) { }

QOSDescriptor & QOSDescriptor :: operator= ( const QOSDescriptor & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	m_qosType = s.m_qosType;
	m_qosClass = s.m_qosClass;
	return * this;
}

QOSDescriptor :: QOSDescriptor ( const QOSDescriptor & s ) : Asn :: Sequence ( s ), m_nonStandardData ( 0 ), m_qosType ( s.m_qosType ), m_qosClass ( s.m_qosClass ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
	} catch ( ... ) {
		delete m_nonStandardData;
		throw;
	}
}


void QOSDescriptor :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void QOSDescriptor :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void QOSDescriptor :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	m_qosType.encode ( os );
	m_qosClass.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

QOSDescriptor :: ~QOSDescriptor ( ) {
	delete m_nonStandardData;
}

void QOSDescriptor :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 10 ) << "qosType = " << std :: setprecision ( indent ) << m_qosType << '\n';
	os << std :: setw ( indent + 11 ) << "qosClass = " << std :: setprecision ( indent ) << m_qosClass << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

QOSDescriptor * QOSDescriptor :: clone ( ) const {
	return new QOSDescriptor ( * this );
}

//
// GenericTransportParameters
//

GenericTransportParameters :: GenericTransportParameters ( Asn :: istream & is ) : Asn :: Sequence ( is, 5, true, 0 ), m_nonStandardData ( 0 ), m_averageRate ( 0 ), m_burst ( 0 ), m_peakRate ( 0 ), m_maxPktSize ( 0 ) {
	try {
		if ( hasOptionalField ( e_nonStandardData ) )
			m_nonStandardData = new NonStandardParameter ( is );
		if ( hasOptionalField ( e_averageRate ) )
			m_averageRate = new GenericTransportParameters_averageRate ( is );
		if ( hasOptionalField ( e_burst ) )
			m_burst = new GenericTransportParameters_burst ( is );
		if ( hasOptionalField ( e_peakRate ) )
			m_peakRate = new GenericTransportParameters_peakRate ( is );
		if ( hasOptionalField ( e_maxPktSize ) )
			m_maxPktSize = new GenericTransportParameters_maxPktSize ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_averageRate;
		delete m_burst;
		delete m_peakRate;
		delete m_maxPktSize;
		throw;
	}
}

GenericTransportParameters :: GenericTransportParameters ( ) : Asn :: Sequence ( 5, true, 0 ), m_nonStandardData ( 0 ), m_averageRate ( 0 ), m_burst ( 0 ), m_peakRate ( 0 ), m_maxPktSize ( 0 ) { }

GenericTransportParameters & GenericTransportParameters :: operator= ( const GenericTransportParameters & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	assignCopy ( m_averageRate, s.m_averageRate );
	assignCopy ( m_burst, s.m_burst );
	assignCopy ( m_peakRate, s.m_peakRate );
	assignCopy ( m_maxPktSize, s.m_maxPktSize );
	return * this;
}

GenericTransportParameters :: GenericTransportParameters ( const GenericTransportParameters & s ) : Asn :: Sequence ( s ), m_nonStandardData ( 0 ), m_averageRate ( 0 ), m_burst ( 0 ), m_peakRate ( 0 ), m_maxPktSize ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_averageRate )
			m_averageRate = new GenericTransportParameters_averageRate ( * s.m_averageRate );
		if ( s.m_burst )
			m_burst = new GenericTransportParameters_burst ( * s.m_burst );
		if ( s.m_peakRate )
			m_peakRate = new GenericTransportParameters_peakRate ( * s.m_peakRate );
		if ( s.m_maxPktSize )
			m_maxPktSize = new GenericTransportParameters_maxPktSize ( * s.m_maxPktSize );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_averageRate;
		delete m_burst;
		delete m_peakRate;
		delete m_maxPktSize;
		throw;
	}
}


void GenericTransportParameters :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_averageRate:
			assignNew ( m_averageRate, new GenericTransportParameters_averageRate );
			break;
		case e_burst:
			assignNew ( m_burst, new GenericTransportParameters_burst );
			break;
		case e_peakRate:
			assignNew ( m_peakRate, new GenericTransportParameters_peakRate );
			break;
		case e_maxPktSize:
			assignNew ( m_maxPktSize, new GenericTransportParameters_maxPktSize );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void GenericTransportParameters :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_averageRate:
			delete m_averageRate;
			m_averageRate = 0;
			break;
		case e_burst:
			delete m_burst;
			m_burst = 0;
			break;
		case e_peakRate:
			delete m_peakRate;
			m_peakRate = 0;
			break;
		case e_maxPktSize:
			delete m_maxPktSize;
			m_maxPktSize = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void GenericTransportParameters :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( hasOptionalField ( e_averageRate ) )
		m_averageRate -> GenericTransportParameters_averageRate :: encode ( os );
	if ( hasOptionalField ( e_burst ) )
		m_burst -> GenericTransportParameters_burst :: encode ( os );
	if ( hasOptionalField ( e_peakRate ) )
		m_peakRate -> GenericTransportParameters_peakRate :: encode ( os );
	if ( hasOptionalField ( e_maxPktSize ) )
		m_maxPktSize -> GenericTransportParameters_maxPktSize :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

GenericTransportParameters :: ~GenericTransportParameters ( ) {
	delete m_nonStandardData;
	delete m_averageRate;
	delete m_burst;
	delete m_peakRate;
	delete m_maxPktSize;
}

void GenericTransportParameters :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_averageRate ) ) {
		os << std :: setw ( indent + 14 ) << "averageRate = " << std :: setprecision ( indent );
		m_averageRate -> GenericTransportParameters_averageRate :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_burst ) ) {
		os << std :: setw ( indent + 8 ) << "burst = " << std :: setprecision ( indent );
		m_burst -> GenericTransportParameters_burst :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_peakRate ) ) {
		os << std :: setw ( indent + 11 ) << "peakRate = " << std :: setprecision ( indent );
		m_peakRate -> GenericTransportParameters_peakRate :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_maxPktSize ) ) {
		os << std :: setw ( indent + 13 ) << "maxPktSize = " << std :: setprecision ( indent );
		m_maxPktSize -> GenericTransportParameters_maxPktSize :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

GenericTransportParameters * GenericTransportParameters :: clone ( ) const {
	return new GenericTransportParameters ( * this );
}

//
// QOSCapability
//

QOSCapability :: QOSCapability ( Asn :: istream & is ) : Asn :: Sequence ( is, 3, true, 6 ), m_nonStandardData ( 0 ), m_rsvpParameters ( 0 ), m_atmParameters ( 0 ), m_localQoS ( 0 ), m_genericTransportParameters ( 0 ), m_servicePriority ( 0 ), m_authorizationParameter ( 0 ), m_qosDescriptor ( 0 ), m_dscpValue ( 0 ) {
	try {
		if ( hasOptionalField ( e_nonStandardData ) )
			m_nonStandardData = new NonStandardParameter ( is );
		if ( hasOptionalField ( e_rsvpParameters ) )
			m_rsvpParameters = new RSVPParameters ( is );
		if ( hasOptionalField ( e_atmParameters ) )
			m_atmParameters = new ATMParameters ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_localQoS ) )
				m_localQoS = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_genericTransportParameters ) )
				m_genericTransportParameters = new GenericTransportParameters ( is );
			if ( hasKnownExtensionToDecode ( is, e_servicePriority ) )
				m_servicePriority = new ServicePriority ( is );
			if ( hasKnownExtensionToDecode ( is, e_authorizationParameter ) )
				m_authorizationParameter = new AuthorizationParameters ( is );
			if ( hasKnownExtensionToDecode ( is, e_qosDescriptor ) )
				m_qosDescriptor = new QOSDescriptor ( is );
			if ( hasKnownExtensionToDecode ( is, e_dscpValue ) )
				m_dscpValue = new QOSCapability_dscpValue ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_rsvpParameters;
		delete m_atmParameters;
		delete m_localQoS;
		delete m_genericTransportParameters;
		delete m_servicePriority;
		delete m_authorizationParameter;
		delete m_qosDescriptor;
		delete m_dscpValue;
		throw;
	}
}

QOSCapability :: QOSCapability ( ) : Asn :: Sequence ( 3, true, 6 ), m_nonStandardData ( 0 ), m_rsvpParameters ( 0 ), m_atmParameters ( 0 ), m_localQoS ( 0 ), m_genericTransportParameters ( 0 ), m_servicePriority ( 0 ), m_authorizationParameter ( 0 ), m_qosDescriptor ( 0 ), m_dscpValue ( 0 ) { }

QOSCapability & QOSCapability :: operator= ( const QOSCapability & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	assignCopy ( m_rsvpParameters, s.m_rsvpParameters );
	assignCopy ( m_atmParameters, s.m_atmParameters );
	assignCopy ( m_localQoS, s.m_localQoS );
	assignCopy ( m_genericTransportParameters, s.m_genericTransportParameters );
	assignCopy ( m_servicePriority, s.m_servicePriority );
	assignCopy ( m_authorizationParameter, s.m_authorizationParameter );
	assignCopy ( m_qosDescriptor, s.m_qosDescriptor );
	assignCopy ( m_dscpValue, s.m_dscpValue );
	return * this;
}

QOSCapability :: QOSCapability ( const QOSCapability & s ) : Asn :: Sequence ( s ), m_nonStandardData ( 0 ), m_rsvpParameters ( 0 ), m_atmParameters ( 0 ), m_localQoS ( 0 ), m_genericTransportParameters ( 0 ), m_servicePriority ( 0 ), m_authorizationParameter ( 0 ), m_qosDescriptor ( 0 ), m_dscpValue ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_rsvpParameters )
			m_rsvpParameters = new RSVPParameters ( * s.m_rsvpParameters );
		if ( s.m_atmParameters )
			m_atmParameters = new ATMParameters ( * s.m_atmParameters );
		if ( s.m_localQoS )
			m_localQoS = new Asn :: Boolean ( * s.m_localQoS );
		if ( s.m_genericTransportParameters )
			m_genericTransportParameters = new GenericTransportParameters ( * s.m_genericTransportParameters );
		if ( s.m_servicePriority )
			m_servicePriority = new ServicePriority ( * s.m_servicePriority );
		if ( s.m_authorizationParameter )
			m_authorizationParameter = new AuthorizationParameters ( * s.m_authorizationParameter );
		if ( s.m_qosDescriptor )
			m_qosDescriptor = new QOSDescriptor ( * s.m_qosDescriptor );
		if ( s.m_dscpValue )
			m_dscpValue = new QOSCapability_dscpValue ( * s.m_dscpValue );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_rsvpParameters;
		delete m_atmParameters;
		delete m_localQoS;
		delete m_genericTransportParameters;
		delete m_servicePriority;
		delete m_authorizationParameter;
		delete m_qosDescriptor;
		delete m_dscpValue;
		throw;
	}
}


void QOSCapability :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new NonStandardParameter );
			break;
		case e_rsvpParameters:
			assignNew ( m_rsvpParameters, new RSVPParameters );
			break;
		case e_atmParameters:
			assignNew ( m_atmParameters, new ATMParameters );
			break;
		case e_localQoS:
			assignNew ( m_localQoS, new Asn :: Boolean );
			break;
		case e_genericTransportParameters:
			assignNew ( m_genericTransportParameters, new GenericTransportParameters );
			break;
		case e_servicePriority:
			assignNew ( m_servicePriority, new ServicePriority );
			break;
		case e_authorizationParameter:
			assignNew ( m_authorizationParameter, new AuthorizationParameters );
			break;
		case e_qosDescriptor:
			assignNew ( m_qosDescriptor, new QOSDescriptor );
			break;
		case e_dscpValue:
			assignNew ( m_dscpValue, new QOSCapability_dscpValue );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void QOSCapability :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_rsvpParameters:
			delete m_rsvpParameters;
			m_rsvpParameters = 0;
			break;
		case e_atmParameters:
			delete m_atmParameters;
			m_atmParameters = 0;
			break;
		case e_localQoS:
			delete m_localQoS;
			m_localQoS = 0;
			break;
		case e_genericTransportParameters:
			delete m_genericTransportParameters;
			m_genericTransportParameters = 0;
			break;
		case e_servicePriority:
			delete m_servicePriority;
			m_servicePriority = 0;
			break;
		case e_authorizationParameter:
			delete m_authorizationParameter;
			m_authorizationParameter = 0;
			break;
		case e_qosDescriptor:
			delete m_qosDescriptor;
			m_qosDescriptor = 0;
			break;
		case e_dscpValue:
			delete m_dscpValue;
			m_dscpValue = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void QOSCapability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> NonStandardParameter :: encode ( os );
	if ( hasOptionalField ( e_rsvpParameters ) )
		m_rsvpParameters -> RSVPParameters :: encode ( os );
	if ( hasOptionalField ( e_atmParameters ) )
		m_atmParameters -> ATMParameters :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_localQoS, m_localQoS );
		knownExtensionEncode ( os, e_genericTransportParameters, m_genericTransportParameters );
		knownExtensionEncode ( os, e_servicePriority, m_servicePriority );
		knownExtensionEncode ( os, e_authorizationParameter, m_authorizationParameter );
		knownExtensionEncode ( os, e_qosDescriptor, m_qosDescriptor );
		knownExtensionEncode ( os, e_dscpValue, m_dscpValue );
		unknownExtensionsEncode ( os );
	}
}

QOSCapability :: ~QOSCapability ( ) {
	delete m_nonStandardData;
	delete m_rsvpParameters;
	delete m_atmParameters;
	delete m_localQoS;
	delete m_genericTransportParameters;
	delete m_servicePriority;
	delete m_authorizationParameter;
	delete m_qosDescriptor;
	delete m_dscpValue;
}

void QOSCapability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_rsvpParameters ) ) {
		os << std :: setw ( indent + 17 ) << "rsvpParameters = " << std :: setprecision ( indent );
		m_rsvpParameters -> RSVPParameters :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_atmParameters ) ) {
		os << std :: setw ( indent + 16 ) << "atmParameters = " << std :: setprecision ( indent );
		m_atmParameters -> ATMParameters :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_localQoS ) ) {
		os << std :: setw ( indent + 11 ) << "localQoS = " << std :: setprecision ( indent );
		m_localQoS -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_genericTransportParameters ) ) {
		os << std :: setw ( indent + 29 ) << "genericTransportParameters = " << std :: setprecision ( indent );
		m_genericTransportParameters -> GenericTransportParameters :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_servicePriority ) ) {
		os << std :: setw ( indent + 18 ) << "servicePriority = " << std :: setprecision ( indent );
		m_servicePriority -> ServicePriority :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_authorizationParameter ) ) {
		os << std :: setw ( indent + 25 ) << "authorizationParameter = " << std :: setprecision ( indent );
		m_authorizationParameter -> AuthorizationParameters :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_qosDescriptor ) ) {
		os << std :: setw ( indent + 16 ) << "qosDescriptor = " << std :: setprecision ( indent );
		m_qosDescriptor -> QOSDescriptor :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_dscpValue ) ) {
		os << std :: setw ( indent + 12 ) << "dscpValue = " << std :: setprecision ( indent );
		m_dscpValue -> QOSCapability_dscpValue :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

QOSCapability * QOSCapability :: clone ( ) const {
	return new QOSCapability ( * this );
}

//
// MediaChannelCapability
//

MediaChannelCapability :: MediaChannelCapability ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_mediaTransport ( 0 ) {
	try {
		if ( hasOptionalField ( e_mediaTransport ) )
			m_mediaTransport = new MediaTransportType ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_mediaTransport;
		throw;
	}
}

MediaChannelCapability :: MediaChannelCapability ( ) : Asn :: Sequence ( 1, true, 0 ), m_mediaTransport ( 0 ) { }

MediaChannelCapability & MediaChannelCapability :: operator= ( const MediaChannelCapability & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_mediaTransport, s.m_mediaTransport );
	return * this;
}

MediaChannelCapability :: MediaChannelCapability ( const MediaChannelCapability & s ) : Asn :: Sequence ( s ), m_mediaTransport ( 0 ) {
	try {
		if ( s.m_mediaTransport )
			m_mediaTransport = new MediaTransportType ( * s.m_mediaTransport );
	} catch ( ... ) {
		delete m_mediaTransport;
		throw;
	}
}


void MediaChannelCapability :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_mediaTransport:
			assignNew ( m_mediaTransport, new MediaTransportType );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void MediaChannelCapability :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_mediaTransport:
			delete m_mediaTransport;
			m_mediaTransport = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void MediaChannelCapability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_mediaTransport ) )
		m_mediaTransport -> MediaTransportType :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

MediaChannelCapability :: ~MediaChannelCapability ( ) {
	delete m_mediaTransport;
}

void MediaChannelCapability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_mediaTransport ) ) {
		os << std :: setw ( indent + 17 ) << "mediaTransport = " << std :: setprecision ( indent );
		m_mediaTransport -> MediaTransportType :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MediaChannelCapability * MediaChannelCapability :: clone ( ) const {
	return new MediaChannelCapability ( * this );
}

//
// TransportCapability
//

TransportCapability :: TransportCapability ( Asn :: istream & is ) : Asn :: Sequence ( is, 3, true, 0 ), m_nonStandard ( 0 ), m_qOSCapabilities ( 0 ), m_mediaChannelCapabilities ( 0 ) {
	try {
		if ( hasOptionalField ( e_nonStandard ) )
			m_nonStandard = new NonStandardParameter ( is );
		if ( hasOptionalField ( e_qOSCapabilities ) )
			m_qOSCapabilities = new TransportCapability_qOSCapabilities ( is );
		if ( hasOptionalField ( e_mediaChannelCapabilities ) )
			m_mediaChannelCapabilities = new TransportCapability_mediaChannelCapabilities ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_nonStandard;
		delete m_qOSCapabilities;
		delete m_mediaChannelCapabilities;
		throw;
	}
}

TransportCapability :: TransportCapability ( ) : Asn :: Sequence ( 3, true, 0 ), m_nonStandard ( 0 ), m_qOSCapabilities ( 0 ), m_mediaChannelCapabilities ( 0 ) { }

TransportCapability & TransportCapability :: operator= ( const TransportCapability & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_nonStandard, s.m_nonStandard );
	assignCopy ( m_qOSCapabilities, s.m_qOSCapabilities );
	assignCopy ( m_mediaChannelCapabilities, s.m_mediaChannelCapabilities );
	return * this;
}

TransportCapability :: TransportCapability ( const TransportCapability & s ) : Asn :: Sequence ( s ), m_nonStandard ( 0 ), m_qOSCapabilities ( 0 ), m_mediaChannelCapabilities ( 0 ) {
	try {
		if ( s.m_nonStandard )
			m_nonStandard = new NonStandardParameter ( * s.m_nonStandard );
		if ( s.m_qOSCapabilities )
			m_qOSCapabilities = new TransportCapability_qOSCapabilities ( * s.m_qOSCapabilities );
		if ( s.m_mediaChannelCapabilities )
			m_mediaChannelCapabilities = new TransportCapability_mediaChannelCapabilities ( * s.m_mediaChannelCapabilities );
	} catch ( ... ) {
		delete m_nonStandard;
		delete m_qOSCapabilities;
		delete m_mediaChannelCapabilities;
		throw;
	}
}


void TransportCapability :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandard:
			assignNew ( m_nonStandard, new NonStandardParameter );
			break;
		case e_qOSCapabilities:
			assignNew ( m_qOSCapabilities, new TransportCapability_qOSCapabilities );
			break;
		case e_mediaChannelCapabilities:
			assignNew ( m_mediaChannelCapabilities, new TransportCapability_mediaChannelCapabilities );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void TransportCapability :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandard:
			delete m_nonStandard;
			m_nonStandard = 0;
			break;
		case e_qOSCapabilities:
			delete m_qOSCapabilities;
			m_qOSCapabilities = 0;
			break;
		case e_mediaChannelCapabilities:
			delete m_mediaChannelCapabilities;
			m_mediaChannelCapabilities = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void TransportCapability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_nonStandard ) )
		m_nonStandard -> NonStandardParameter :: encode ( os );
	if ( hasOptionalField ( e_qOSCapabilities ) )
		m_qOSCapabilities -> TransportCapability_qOSCapabilities :: encode ( os );
	if ( hasOptionalField ( e_mediaChannelCapabilities ) )
		m_mediaChannelCapabilities -> TransportCapability_mediaChannelCapabilities :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

TransportCapability :: ~TransportCapability ( ) {
	delete m_nonStandard;
	delete m_qOSCapabilities;
	delete m_mediaChannelCapabilities;
}

void TransportCapability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_nonStandard ) ) {
		os << std :: setw ( indent + 14 ) << "nonStandard = " << std :: setprecision ( indent );
		m_nonStandard -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_qOSCapabilities ) ) {
		os << std :: setw ( indent + 18 ) << "qOSCapabilities = " << std :: setprecision ( indent );
		m_qOSCapabilities -> TransportCapability_qOSCapabilities :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_mediaChannelCapabilities ) ) {
		os << std :: setw ( indent + 27 ) << "mediaChannelCapabilities = " << std :: setprecision ( indent );
		m_mediaChannelCapabilities -> TransportCapability_mediaChannelCapabilities :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

TransportCapability * TransportCapability :: clone ( ) const {
	return new TransportCapability ( * this );
}

//
// MediaDistributionCapability
//

MediaDistributionCapability :: MediaDistributionCapability ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 0 ), m_centralizedControl ( is ), m_distributedControl ( is ), m_centralizedAudio ( is ), m_distributedAudio ( is ), m_centralizedVideo ( is ), m_distributedVideo ( is ), m_centralizedData ( 0 ), m_distributedData ( 0 ) {
	try {
		if ( hasOptionalField ( e_centralizedData ) )
			m_centralizedData = new ArrayOf_DataApplicationCapability ( is );
		if ( hasOptionalField ( e_distributedData ) )
			m_distributedData = new ArrayOf_DataApplicationCapability ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_centralizedData;
		delete m_distributedData;
		throw;
	}
}

MediaDistributionCapability :: MediaDistributionCapability ( ) : Asn :: Sequence ( 2, true, 0 ), m_centralizedData ( 0 ), m_distributedData ( 0 ) { }

MediaDistributionCapability & MediaDistributionCapability :: operator= ( const MediaDistributionCapability & s ) {
	Asn :: Sequence :: operator= ( s );
	m_centralizedControl = s.m_centralizedControl;
	m_distributedControl = s.m_distributedControl;
	m_centralizedAudio = s.m_centralizedAudio;
	m_distributedAudio = s.m_distributedAudio;
	m_centralizedVideo = s.m_centralizedVideo;
	m_distributedVideo = s.m_distributedVideo;
	assignCopy ( m_centralizedData, s.m_centralizedData );
	assignCopy ( m_distributedData, s.m_distributedData );
	return * this;
}

MediaDistributionCapability :: MediaDistributionCapability ( const MediaDistributionCapability & s ) : Asn :: Sequence ( s ), m_centralizedControl ( s.m_centralizedControl ), m_distributedControl ( s.m_distributedControl ), m_centralizedAudio ( s.m_centralizedAudio ), m_distributedAudio ( s.m_distributedAudio ), m_centralizedVideo ( s.m_centralizedVideo ), m_distributedVideo ( s.m_distributedVideo ), m_centralizedData ( 0 ), m_distributedData ( 0 ) {
	try {
		if ( s.m_centralizedData )
			m_centralizedData = new ArrayOf_DataApplicationCapability ( * s.m_centralizedData );
		if ( s.m_distributedData )
			m_distributedData = new ArrayOf_DataApplicationCapability ( * s.m_distributedData );
	} catch ( ... ) {
		delete m_centralizedData;
		delete m_distributedData;
		throw;
	}
}


void MediaDistributionCapability :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_centralizedData:
			assignNew ( m_centralizedData, new ArrayOf_DataApplicationCapability );
			break;
		case e_distributedData:
			assignNew ( m_distributedData, new ArrayOf_DataApplicationCapability );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void MediaDistributionCapability :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_centralizedData:
			delete m_centralizedData;
			m_centralizedData = 0;
			break;
		case e_distributedData:
			delete m_distributedData;
			m_distributedData = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void MediaDistributionCapability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_centralizedControl.encode ( os );
	m_distributedControl.encode ( os );
	m_centralizedAudio.encode ( os );
	m_distributedAudio.encode ( os );
	m_centralizedVideo.encode ( os );
	m_distributedVideo.encode ( os );
	if ( hasOptionalField ( e_centralizedData ) )
		m_centralizedData -> ArrayOf_DataApplicationCapability :: encode ( os );
	if ( hasOptionalField ( e_distributedData ) )
		m_distributedData -> ArrayOf_DataApplicationCapability :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

MediaDistributionCapability :: ~MediaDistributionCapability ( ) {
	delete m_centralizedData;
	delete m_distributedData;
}

void MediaDistributionCapability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 21 ) << "centralizedControl = " << std :: setprecision ( indent ) << m_centralizedControl << '\n';
	os << std :: setw ( indent + 21 ) << "distributedControl = " << std :: setprecision ( indent ) << m_distributedControl << '\n';
	os << std :: setw ( indent + 19 ) << "centralizedAudio = " << std :: setprecision ( indent ) << m_centralizedAudio << '\n';
	os << std :: setw ( indent + 19 ) << "distributedAudio = " << std :: setprecision ( indent ) << m_distributedAudio << '\n';
	os << std :: setw ( indent + 19 ) << "centralizedVideo = " << std :: setprecision ( indent ) << m_centralizedVideo << '\n';
	os << std :: setw ( indent + 19 ) << "distributedVideo = " << std :: setprecision ( indent ) << m_distributedVideo << '\n';
	if ( hasOptionalField ( e_centralizedData ) ) {
		os << std :: setw ( indent + 18 ) << "centralizedData = " << std :: setprecision ( indent );
		m_centralizedData -> ArrayOf_DataApplicationCapability :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_distributedData ) ) {
		os << std :: setw ( indent + 18 ) << "distributedData = " << std :: setprecision ( indent );
		m_distributedData -> ArrayOf_DataApplicationCapability :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MediaDistributionCapability * MediaDistributionCapability :: clone ( ) const {
	return new MediaDistributionCapability ( * this );
}

//
// H262VideoCapability
//

H262VideoCapability :: H262VideoCapability ( Asn :: istream & is ) : Asn :: Sequence ( is, 6, false, 0 ), m_profileAndLevel_SPatML ( is ), m_profileAndLevel_MPatLL ( is ), m_profileAndLevel_MPatML ( is ), m_profileAndLevel_MPatH_14 ( is ), m_profileAndLevel_MPatHL ( is ), m_profileAndLevel_SNRatLL ( is ), m_profileAndLevel_SNRatML ( is ), m_profileAndLevel_SpatialatH_14 ( is ), m_profileAndLevel_HPatML ( is ), m_profileAndLevel_HPatH_14 ( is ), m_profileAndLevel_HPatHL ( is ), m_videoBitRate ( hasOptionalField ( e_videoBitRate ) ? pushTemporaryMember ( new H262VideoCapability_videoBitRate ( is ) ) : 0 ), m_vbvBufferSize ( hasOptionalField ( e_vbvBufferSize ) ? pushTemporaryMember ( new H262VideoCapability_vbvBufferSize ( is ) ) : 0 ), m_samplesPerLine ( hasOptionalField ( e_samplesPerLine ) ? pushTemporaryMember ( new H262VideoCapability_samplesPerLine ( is ) ) : 0 ), m_linesPerFrame ( hasOptionalField ( e_linesPerFrame ) ? pushTemporaryMember ( new H262VideoCapability_linesPerFrame ( is ) ) : 0 ), m_framesPerSecond ( hasOptionalField ( e_framesPerSecond ) ? pushTemporaryMember ( new H262VideoCapability_framesPerSecond ( is ) ) : 0 ), m_luminanceSampleRate ( hasOptionalField ( e_luminanceSampleRate ) ? pushTemporaryMember ( new H262VideoCapability_luminanceSampleRate ( is ) ) : 0 ), m_videoBadMBsCap ( is ) {
	clearTemporaryMembers ( );
}

H262VideoCapability :: H262VideoCapability ( ) : Asn :: Sequence ( 6, false, 0 ), m_videoBitRate ( 0 ), m_vbvBufferSize ( 0 ), m_samplesPerLine ( 0 ), m_linesPerFrame ( 0 ), m_framesPerSecond ( 0 ), m_luminanceSampleRate ( 0 ) { }

H262VideoCapability & H262VideoCapability :: operator= ( const H262VideoCapability & s ) {
	Asn :: Sequence :: operator= ( s );
	m_profileAndLevel_SPatML = s.m_profileAndLevel_SPatML;
	m_profileAndLevel_MPatLL = s.m_profileAndLevel_MPatLL;
	m_profileAndLevel_MPatML = s.m_profileAndLevel_MPatML;
	m_profileAndLevel_MPatH_14 = s.m_profileAndLevel_MPatH_14;
	m_profileAndLevel_MPatHL = s.m_profileAndLevel_MPatHL;
	m_profileAndLevel_SNRatLL = s.m_profileAndLevel_SNRatLL;
	m_profileAndLevel_SNRatML = s.m_profileAndLevel_SNRatML;
	m_profileAndLevel_SpatialatH_14 = s.m_profileAndLevel_SpatialatH_14;
	m_profileAndLevel_HPatML = s.m_profileAndLevel_HPatML;
	m_profileAndLevel_HPatH_14 = s.m_profileAndLevel_HPatH_14;
	m_profileAndLevel_HPatHL = s.m_profileAndLevel_HPatHL;
	assignCopy ( m_videoBitRate, s.m_videoBitRate );
	assignCopy ( m_vbvBufferSize, s.m_vbvBufferSize );
	assignCopy ( m_samplesPerLine, s.m_samplesPerLine );
	assignCopy ( m_linesPerFrame, s.m_linesPerFrame );
	assignCopy ( m_framesPerSecond, s.m_framesPerSecond );
	assignCopy ( m_luminanceSampleRate, s.m_luminanceSampleRate );
	m_videoBadMBsCap = s.m_videoBadMBsCap;
	return * this;
}

H262VideoCapability :: H262VideoCapability ( const H262VideoCapability & s ) : Asn :: Sequence ( s ), m_profileAndLevel_SPatML ( s.m_profileAndLevel_SPatML ), m_profileAndLevel_MPatLL ( s.m_profileAndLevel_MPatLL ), m_profileAndLevel_MPatML ( s.m_profileAndLevel_MPatML ), m_profileAndLevel_MPatH_14 ( s.m_profileAndLevel_MPatH_14 ), m_profileAndLevel_MPatHL ( s.m_profileAndLevel_MPatHL ), m_profileAndLevel_SNRatLL ( s.m_profileAndLevel_SNRatLL ), m_profileAndLevel_SNRatML ( s.m_profileAndLevel_SNRatML ), m_profileAndLevel_SpatialatH_14 ( s.m_profileAndLevel_SpatialatH_14 ), m_profileAndLevel_HPatML ( s.m_profileAndLevel_HPatML ), m_profileAndLevel_HPatH_14 ( s.m_profileAndLevel_HPatH_14 ), m_profileAndLevel_HPatHL ( s.m_profileAndLevel_HPatHL ), m_videoBitRate ( 0 ), m_vbvBufferSize ( 0 ), m_samplesPerLine ( 0 ), m_linesPerFrame ( 0 ), m_framesPerSecond ( 0 ), m_luminanceSampleRate ( 0 ), m_videoBadMBsCap ( s.m_videoBadMBsCap ) {
	try {
		if ( s.m_videoBitRate )
			m_videoBitRate = new H262VideoCapability_videoBitRate ( * s.m_videoBitRate );
		if ( s.m_vbvBufferSize )
			m_vbvBufferSize = new H262VideoCapability_vbvBufferSize ( * s.m_vbvBufferSize );
		if ( s.m_samplesPerLine )
			m_samplesPerLine = new H262VideoCapability_samplesPerLine ( * s.m_samplesPerLine );
		if ( s.m_linesPerFrame )
			m_linesPerFrame = new H262VideoCapability_linesPerFrame ( * s.m_linesPerFrame );
		if ( s.m_framesPerSecond )
			m_framesPerSecond = new H262VideoCapability_framesPerSecond ( * s.m_framesPerSecond );
		if ( s.m_luminanceSampleRate )
			m_luminanceSampleRate = new H262VideoCapability_luminanceSampleRate ( * s.m_luminanceSampleRate );
	} catch ( ... ) {
		delete m_videoBitRate;
		delete m_vbvBufferSize;
		delete m_samplesPerLine;
		delete m_linesPerFrame;
		delete m_framesPerSecond;
		delete m_luminanceSampleRate;
		throw;
	}
}


void H262VideoCapability :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_videoBitRate:
			assignNew ( m_videoBitRate, new H262VideoCapability_videoBitRate );
			break;
		case e_vbvBufferSize:
			assignNew ( m_vbvBufferSize, new H262VideoCapability_vbvBufferSize );
			break;
		case e_samplesPerLine:
			assignNew ( m_samplesPerLine, new H262VideoCapability_samplesPerLine );
			break;
		case e_linesPerFrame:
			assignNew ( m_linesPerFrame, new H262VideoCapability_linesPerFrame );
			break;
		case e_framesPerSecond:
			assignNew ( m_framesPerSecond, new H262VideoCapability_framesPerSecond );
			break;
		case e_luminanceSampleRate:
			assignNew ( m_luminanceSampleRate, new H262VideoCapability_luminanceSampleRate );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void H262VideoCapability :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_videoBitRate:
			delete m_videoBitRate;
			m_videoBitRate = 0;
			break;
		case e_vbvBufferSize:
			delete m_vbvBufferSize;
			m_vbvBufferSize = 0;
			break;
		case e_samplesPerLine:
			delete m_samplesPerLine;
			m_samplesPerLine = 0;
			break;
		case e_linesPerFrame:
			delete m_linesPerFrame;
			m_linesPerFrame = 0;
			break;
		case e_framesPerSecond:
			delete m_framesPerSecond;
			m_framesPerSecond = 0;
			break;
		case e_luminanceSampleRate:
			delete m_luminanceSampleRate;
			m_luminanceSampleRate = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void H262VideoCapability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_profileAndLevel_SPatML.encode ( os );
	m_profileAndLevel_MPatLL.encode ( os );
	m_profileAndLevel_MPatML.encode ( os );
	m_profileAndLevel_MPatH_14.encode ( os );
	m_profileAndLevel_MPatHL.encode ( os );
	m_profileAndLevel_SNRatLL.encode ( os );
	m_profileAndLevel_SNRatML.encode ( os );
	m_profileAndLevel_SpatialatH_14.encode ( os );
	m_profileAndLevel_HPatML.encode ( os );
	m_profileAndLevel_HPatH_14.encode ( os );
	m_profileAndLevel_HPatHL.encode ( os );
	if ( hasOptionalField ( e_videoBitRate ) )
		m_videoBitRate -> H262VideoCapability_videoBitRate :: encode ( os );
	if ( hasOptionalField ( e_vbvBufferSize ) )
		m_vbvBufferSize -> H262VideoCapability_vbvBufferSize :: encode ( os );
	if ( hasOptionalField ( e_samplesPerLine ) )
		m_samplesPerLine -> H262VideoCapability_samplesPerLine :: encode ( os );
	if ( hasOptionalField ( e_linesPerFrame ) )
		m_linesPerFrame -> H262VideoCapability_linesPerFrame :: encode ( os );
	if ( hasOptionalField ( e_framesPerSecond ) )
		m_framesPerSecond -> H262VideoCapability_framesPerSecond :: encode ( os );
	if ( hasOptionalField ( e_luminanceSampleRate ) )
		m_luminanceSampleRate -> H262VideoCapability_luminanceSampleRate :: encode ( os );
	m_videoBadMBsCap.encode ( os );
}

H262VideoCapability :: ~H262VideoCapability ( ) {
	delete m_videoBitRate;
	delete m_vbvBufferSize;
	delete m_samplesPerLine;
	delete m_linesPerFrame;
	delete m_framesPerSecond;
	delete m_luminanceSampleRate;
}

void H262VideoCapability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 25 ) << "profileAndLevel_SPatML = " << std :: setprecision ( indent ) << m_profileAndLevel_SPatML << '\n';
	os << std :: setw ( indent + 25 ) << "profileAndLevel_MPatLL = " << std :: setprecision ( indent ) << m_profileAndLevel_MPatLL << '\n';
	os << std :: setw ( indent + 25 ) << "profileAndLevel_MPatML = " << std :: setprecision ( indent ) << m_profileAndLevel_MPatML << '\n';
	os << std :: setw ( indent + 27 ) << "profileAndLevel_MPatH_14 = " << std :: setprecision ( indent ) << m_profileAndLevel_MPatH_14 << '\n';
	os << std :: setw ( indent + 25 ) << "profileAndLevel_MPatHL = " << std :: setprecision ( indent ) << m_profileAndLevel_MPatHL << '\n';
	os << std :: setw ( indent + 26 ) << "profileAndLevel_SNRatLL = " << std :: setprecision ( indent ) << m_profileAndLevel_SNRatLL << '\n';
	os << std :: setw ( indent + 26 ) << "profileAndLevel_SNRatML = " << std :: setprecision ( indent ) << m_profileAndLevel_SNRatML << '\n';
	os << std :: setw ( indent + 32 ) << "profileAndLevel_SpatialatH_14 = " << std :: setprecision ( indent ) << m_profileAndLevel_SpatialatH_14 << '\n';
	os << std :: setw ( indent + 25 ) << "profileAndLevel_HPatML = " << std :: setprecision ( indent ) << m_profileAndLevel_HPatML << '\n';
	os << std :: setw ( indent + 27 ) << "profileAndLevel_HPatH_14 = " << std :: setprecision ( indent ) << m_profileAndLevel_HPatH_14 << '\n';
	os << std :: setw ( indent + 25 ) << "profileAndLevel_HPatHL = " << std :: setprecision ( indent ) << m_profileAndLevel_HPatHL << '\n';
	if ( hasOptionalField ( e_videoBitRate ) ) {
		os << std :: setw ( indent + 15 ) << "videoBitRate = " << std :: setprecision ( indent );
		m_videoBitRate -> H262VideoCapability_videoBitRate :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_vbvBufferSize ) ) {
		os << std :: setw ( indent + 16 ) << "vbvBufferSize = " << std :: setprecision ( indent );
		m_vbvBufferSize -> H262VideoCapability_vbvBufferSize :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_samplesPerLine ) ) {
		os << std :: setw ( indent + 17 ) << "samplesPerLine = " << std :: setprecision ( indent );
		m_samplesPerLine -> H262VideoCapability_samplesPerLine :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_linesPerFrame ) ) {
		os << std :: setw ( indent + 16 ) << "linesPerFrame = " << std :: setprecision ( indent );
		m_linesPerFrame -> H262VideoCapability_linesPerFrame :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_framesPerSecond ) ) {
		os << std :: setw ( indent + 18 ) << "framesPerSecond = " << std :: setprecision ( indent );
		m_framesPerSecond -> H262VideoCapability_framesPerSecond :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_luminanceSampleRate ) ) {
		os << std :: setw ( indent + 22 ) << "luminanceSampleRate = " << std :: setprecision ( indent );
		m_luminanceSampleRate -> H262VideoCapability_luminanceSampleRate :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 17 ) << "videoBadMBsCap = " << std :: setprecision ( indent ) << m_videoBadMBsCap << '\n';
	os << std :: setw ( indent - 1 ) << '}';
}

H262VideoCapability * H262VideoCapability :: clone ( ) const {
	return new H262VideoCapability ( * this );
}

//
// EnhancementLayerInfo
//

EnhancementLayerInfo :: EnhancementLayerInfo ( Asn :: istream & is ) : Asn :: Sequence ( is, 3, true, 0 ), m_baseBitRateConstrained ( is ), m_snrEnhancement ( 0 ), m_spatialEnhancement ( 0 ), m_bPictureEnhancement ( 0 ) {
	try {
		if ( hasOptionalField ( e_snrEnhancement ) )
			m_snrEnhancement = new EnhancementLayerInfo_snrEnhancement ( is );
		if ( hasOptionalField ( e_spatialEnhancement ) )
			m_spatialEnhancement = new EnhancementLayerInfo_spatialEnhancement ( is );
		if ( hasOptionalField ( e_bPictureEnhancement ) )
			m_bPictureEnhancement = new EnhancementLayerInfo_bPictureEnhancement ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_snrEnhancement;
		delete m_spatialEnhancement;
		delete m_bPictureEnhancement;
		throw;
	}
}

EnhancementLayerInfo :: EnhancementLayerInfo ( ) : Asn :: Sequence ( 3, true, 0 ), m_snrEnhancement ( 0 ), m_spatialEnhancement ( 0 ), m_bPictureEnhancement ( 0 ) { }

EnhancementLayerInfo & EnhancementLayerInfo :: operator= ( const EnhancementLayerInfo & s ) {
	Asn :: Sequence :: operator= ( s );
	m_baseBitRateConstrained = s.m_baseBitRateConstrained;
	assignCopy ( m_snrEnhancement, s.m_snrEnhancement );
	assignCopy ( m_spatialEnhancement, s.m_spatialEnhancement );
	assignCopy ( m_bPictureEnhancement, s.m_bPictureEnhancement );
	return * this;
}

EnhancementLayerInfo :: EnhancementLayerInfo ( const EnhancementLayerInfo & s ) : Asn :: Sequence ( s ), m_baseBitRateConstrained ( s.m_baseBitRateConstrained ), m_snrEnhancement ( 0 ), m_spatialEnhancement ( 0 ), m_bPictureEnhancement ( 0 ) {
	try {
		if ( s.m_snrEnhancement )
			m_snrEnhancement = new EnhancementLayerInfo_snrEnhancement ( * s.m_snrEnhancement );
		if ( s.m_spatialEnhancement )
			m_spatialEnhancement = new EnhancementLayerInfo_spatialEnhancement ( * s.m_spatialEnhancement );
		if ( s.m_bPictureEnhancement )
			m_bPictureEnhancement = new EnhancementLayerInfo_bPictureEnhancement ( * s.m_bPictureEnhancement );
	} catch ( ... ) {
		delete m_snrEnhancement;
		delete m_spatialEnhancement;
		delete m_bPictureEnhancement;
		throw;
	}
}


void EnhancementLayerInfo :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_snrEnhancement:
			assignNew ( m_snrEnhancement, new EnhancementLayerInfo_snrEnhancement );
			break;
		case e_spatialEnhancement:
			assignNew ( m_spatialEnhancement, new EnhancementLayerInfo_spatialEnhancement );
			break;
		case e_bPictureEnhancement:
			assignNew ( m_bPictureEnhancement, new EnhancementLayerInfo_bPictureEnhancement );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void EnhancementLayerInfo :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_snrEnhancement:
			delete m_snrEnhancement;
			m_snrEnhancement = 0;
			break;
		case e_spatialEnhancement:
			delete m_spatialEnhancement;
			m_spatialEnhancement = 0;
			break;
		case e_bPictureEnhancement:
			delete m_bPictureEnhancement;
			m_bPictureEnhancement = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void EnhancementLayerInfo :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_baseBitRateConstrained.encode ( os );
	if ( hasOptionalField ( e_snrEnhancement ) )
		m_snrEnhancement -> EnhancementLayerInfo_snrEnhancement :: encode ( os );
	if ( hasOptionalField ( e_spatialEnhancement ) )
		m_spatialEnhancement -> EnhancementLayerInfo_spatialEnhancement :: encode ( os );
	if ( hasOptionalField ( e_bPictureEnhancement ) )
		m_bPictureEnhancement -> EnhancementLayerInfo_bPictureEnhancement :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

EnhancementLayerInfo :: ~EnhancementLayerInfo ( ) {
	delete m_snrEnhancement;
	delete m_spatialEnhancement;
	delete m_bPictureEnhancement;
}

void EnhancementLayerInfo :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 25 ) << "baseBitRateConstrained = " << std :: setprecision ( indent ) << m_baseBitRateConstrained << '\n';
	if ( hasOptionalField ( e_snrEnhancement ) ) {
		os << std :: setw ( indent + 17 ) << "snrEnhancement = " << std :: setprecision ( indent );
		m_snrEnhancement -> EnhancementLayerInfo_snrEnhancement :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_spatialEnhancement ) ) {
		os << std :: setw ( indent + 21 ) << "spatialEnhancement = " << std :: setprecision ( indent );
		m_spatialEnhancement -> EnhancementLayerInfo_spatialEnhancement :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_bPictureEnhancement ) ) {
		os << std :: setw ( indent + 22 ) << "bPictureEnhancement = " << std :: setprecision ( indent );
		m_bPictureEnhancement -> EnhancementLayerInfo_bPictureEnhancement :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

EnhancementLayerInfo * EnhancementLayerInfo :: clone ( ) const {
	return new EnhancementLayerInfo ( * this );
}

//
// H263Options
//

H263Options :: H263Options ( Asn :: istream & is ) : Asn :: Sequence ( is, 5, true, 2 ), m_advancedIntraCodingMode ( is ), m_deblockingFilterMode ( is ), m_improvedPBFramesMode ( is ), m_unlimitedMotionVectors ( is ), m_fullPictureFreeze ( is ), m_partialPictureFreezeAndRelease ( is ), m_resizingPartPicFreezeAndRelease ( is ), m_fullPictureSnapshot ( is ), m_partialPictureSnapshot ( is ), m_videoSegmentTagging ( is ), m_progressiveRefinement ( is ), m_dynamicPictureResizingByFour ( is ), m_dynamicPictureResizingSixteenthPel ( is ), m_dynamicWarpingHalfPel ( is ), m_dynamicWarpingSixteenthPel ( is ), m_independentSegmentDecoding ( is ), m_slicesInOrder_NonRect ( is ), m_slicesInOrder_Rect ( is ), m_slicesNoOrder_NonRect ( is ), m_slicesNoOrder_Rect ( is ), m_alternateInterVLCMode ( is ), m_modifiedQuantizationMode ( is ), m_reducedResolutionUpdate ( is ), m_transparencyParameters ( hasOptionalField ( e_transparencyParameters ) ? pushTemporaryMember ( new TransparencyParameters ( is ) ) : 0 ), m_separateVideoBackChannel ( is ), m_refPictureSelection ( 0 ), m_customPictureClockFrequency ( 0 ), m_customPictureFormat ( 0 ), m_modeCombos ( 0 ), m_videoBadMBsCap ( 0 ), m_h263Version3Options ( 0 ) {
	clearTemporaryMembers ( );
	try {
		if ( hasOptionalField ( e_refPictureSelection ) )
			m_refPictureSelection = new RefPictureSelection ( is );
		if ( hasOptionalField ( e_customPictureClockFrequency ) )
			m_customPictureClockFrequency = new H263Options_customPictureClockFrequency ( is );
		if ( hasOptionalField ( e_customPictureFormat ) )
			m_customPictureFormat = new H263Options_customPictureFormat ( is );
		if ( hasOptionalField ( e_modeCombos ) )
			m_modeCombos = new H263Options_modeCombos ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_videoBadMBsCap ) )
				m_videoBadMBsCap = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_h263Version3Options ) )
				m_h263Version3Options = new H263Version3Options ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_transparencyParameters;
		delete m_refPictureSelection;
		delete m_customPictureClockFrequency;
		delete m_customPictureFormat;
		delete m_modeCombos;
		delete m_videoBadMBsCap;
		delete m_h263Version3Options;
		throw;
	}
}

H263Options :: H263Options ( ) : Asn :: Sequence ( 5, true, 2 ), m_transparencyParameters ( 0 ), m_refPictureSelection ( 0 ), m_customPictureClockFrequency ( 0 ), m_customPictureFormat ( 0 ), m_modeCombos ( 0 ), m_videoBadMBsCap ( 0 ), m_h263Version3Options ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_videoBadMBsCap );
		m_videoBadMBsCap = new Asn :: Boolean;
		Asn :: Sequence :: includeOptionalField ( e_h263Version3Options );
		m_h263Version3Options = new H263Version3Options;
	} catch ( ... ) {
		delete m_videoBadMBsCap;
		delete m_h263Version3Options;
		throw;
	}
}

H263Options & H263Options :: operator= ( const H263Options & s ) {
	Asn :: Sequence :: operator= ( s );
	m_advancedIntraCodingMode = s.m_advancedIntraCodingMode;
	m_deblockingFilterMode = s.m_deblockingFilterMode;
	m_improvedPBFramesMode = s.m_improvedPBFramesMode;
	m_unlimitedMotionVectors = s.m_unlimitedMotionVectors;
	m_fullPictureFreeze = s.m_fullPictureFreeze;
	m_partialPictureFreezeAndRelease = s.m_partialPictureFreezeAndRelease;
	m_resizingPartPicFreezeAndRelease = s.m_resizingPartPicFreezeAndRelease;
	m_fullPictureSnapshot = s.m_fullPictureSnapshot;
	m_partialPictureSnapshot = s.m_partialPictureSnapshot;
	m_videoSegmentTagging = s.m_videoSegmentTagging;
	m_progressiveRefinement = s.m_progressiveRefinement;
	m_dynamicPictureResizingByFour = s.m_dynamicPictureResizingByFour;
	m_dynamicPictureResizingSixteenthPel = s.m_dynamicPictureResizingSixteenthPel;
	m_dynamicWarpingHalfPel = s.m_dynamicWarpingHalfPel;
	m_dynamicWarpingSixteenthPel = s.m_dynamicWarpingSixteenthPel;
	m_independentSegmentDecoding = s.m_independentSegmentDecoding;
	m_slicesInOrder_NonRect = s.m_slicesInOrder_NonRect;
	m_slicesInOrder_Rect = s.m_slicesInOrder_Rect;
	m_slicesNoOrder_NonRect = s.m_slicesNoOrder_NonRect;
	m_slicesNoOrder_Rect = s.m_slicesNoOrder_Rect;
	m_alternateInterVLCMode = s.m_alternateInterVLCMode;
	m_modifiedQuantizationMode = s.m_modifiedQuantizationMode;
	m_reducedResolutionUpdate = s.m_reducedResolutionUpdate;
	assignCopy ( m_transparencyParameters, s.m_transparencyParameters );
	m_separateVideoBackChannel = s.m_separateVideoBackChannel;
	assignCopy ( m_refPictureSelection, s.m_refPictureSelection );
	assignCopy ( m_customPictureClockFrequency, s.m_customPictureClockFrequency );
	assignCopy ( m_customPictureFormat, s.m_customPictureFormat );
	assignCopy ( m_modeCombos, s.m_modeCombos );
	assignCopy ( m_videoBadMBsCap, s.m_videoBadMBsCap );
	assignCopy ( m_h263Version3Options, s.m_h263Version3Options );
	return * this;
}

H263Options :: H263Options ( const H263Options & s ) : Asn :: Sequence ( s ), m_advancedIntraCodingMode ( s.m_advancedIntraCodingMode ), m_deblockingFilterMode ( s.m_deblockingFilterMode ), m_improvedPBFramesMode ( s.m_improvedPBFramesMode ), m_unlimitedMotionVectors ( s.m_unlimitedMotionVectors ), m_fullPictureFreeze ( s.m_fullPictureFreeze ), m_partialPictureFreezeAndRelease ( s.m_partialPictureFreezeAndRelease ), m_resizingPartPicFreezeAndRelease ( s.m_resizingPartPicFreezeAndRelease ), m_fullPictureSnapshot ( s.m_fullPictureSnapshot ), m_partialPictureSnapshot ( s.m_partialPictureSnapshot ), m_videoSegmentTagging ( s.m_videoSegmentTagging ), m_progressiveRefinement ( s.m_progressiveRefinement ), m_dynamicPictureResizingByFour ( s.m_dynamicPictureResizingByFour ), m_dynamicPictureResizingSixteenthPel ( s.m_dynamicPictureResizingSixteenthPel ), m_dynamicWarpingHalfPel ( s.m_dynamicWarpingHalfPel ), m_dynamicWarpingSixteenthPel ( s.m_dynamicWarpingSixteenthPel ), m_independentSegmentDecoding ( s.m_independentSegmentDecoding ), m_slicesInOrder_NonRect ( s.m_slicesInOrder_NonRect ), m_slicesInOrder_Rect ( s.m_slicesInOrder_Rect ), m_slicesNoOrder_NonRect ( s.m_slicesNoOrder_NonRect ), m_slicesNoOrder_Rect ( s.m_slicesNoOrder_Rect ), m_alternateInterVLCMode ( s.m_alternateInterVLCMode ), m_modifiedQuantizationMode ( s.m_modifiedQuantizationMode ), m_reducedResolutionUpdate ( s.m_reducedResolutionUpdate ), m_transparencyParameters ( 0 ), m_separateVideoBackChannel ( s.m_separateVideoBackChannel ), m_refPictureSelection ( 0 ), m_customPictureClockFrequency ( 0 ), m_customPictureFormat ( 0 ), m_modeCombos ( 0 ), m_videoBadMBsCap ( 0 ), m_h263Version3Options ( 0 ) {
	try {
		if ( s.m_transparencyParameters )
			m_transparencyParameters = new TransparencyParameters ( * s.m_transparencyParameters );
		if ( s.m_refPictureSelection )
			m_refPictureSelection = new RefPictureSelection ( * s.m_refPictureSelection );
		if ( s.m_customPictureClockFrequency )
			m_customPictureClockFrequency = new H263Options_customPictureClockFrequency ( * s.m_customPictureClockFrequency );
		if ( s.m_customPictureFormat )
			m_customPictureFormat = new H263Options_customPictureFormat ( * s.m_customPictureFormat );
		if ( s.m_modeCombos )
			m_modeCombos = new H263Options_modeCombos ( * s.m_modeCombos );
		if ( s.m_videoBadMBsCap )
			m_videoBadMBsCap = new Asn :: Boolean ( * s.m_videoBadMBsCap );
		if ( s.m_h263Version3Options )
			m_h263Version3Options = new H263Version3Options ( * s.m_h263Version3Options );
	} catch ( ... ) {
		delete m_transparencyParameters;
		delete m_refPictureSelection;
		delete m_customPictureClockFrequency;
		delete m_customPictureFormat;
		delete m_modeCombos;
		delete m_videoBadMBsCap;
		delete m_h263Version3Options;
		throw;
	}
}


void H263Options :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_transparencyParameters:
			assignNew ( m_transparencyParameters, new TransparencyParameters );
			break;
		case e_refPictureSelection:
			assignNew ( m_refPictureSelection, new RefPictureSelection );
			break;
		case e_customPictureClockFrequency:
			assignNew ( m_customPictureClockFrequency, new H263Options_customPictureClockFrequency );
			break;
		case e_customPictureFormat:
			assignNew ( m_customPictureFormat, new H263Options_customPictureFormat );
			break;
		case e_modeCombos:
			assignNew ( m_modeCombos, new H263Options_modeCombos );
			break;
		case e_videoBadMBsCap:
			assignNew ( m_videoBadMBsCap, new Asn :: Boolean );
			break;
		case e_h263Version3Options:
			assignNew ( m_h263Version3Options, new H263Version3Options );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void H263Options :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_transparencyParameters:
			delete m_transparencyParameters;
			m_transparencyParameters = 0;
			break;
		case e_refPictureSelection:
			delete m_refPictureSelection;
			m_refPictureSelection = 0;
			break;
		case e_customPictureClockFrequency:
			delete m_customPictureClockFrequency;
			m_customPictureClockFrequency = 0;
			break;
		case e_customPictureFormat:
			delete m_customPictureFormat;
			m_customPictureFormat = 0;
			break;
		case e_modeCombos:
			delete m_modeCombos;
			m_modeCombos = 0;
			break;
		case e_videoBadMBsCap:
			delete m_videoBadMBsCap;
			m_videoBadMBsCap = 0;
			break;
		case e_h263Version3Options:
			delete m_h263Version3Options;
			m_h263Version3Options = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void H263Options :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_advancedIntraCodingMode.encode ( os );
	m_deblockingFilterMode.encode ( os );
	m_improvedPBFramesMode.encode ( os );
	m_unlimitedMotionVectors.encode ( os );
	m_fullPictureFreeze.encode ( os );
	m_partialPictureFreezeAndRelease.encode ( os );
	m_resizingPartPicFreezeAndRelease.encode ( os );
	m_fullPictureSnapshot.encode ( os );
	m_partialPictureSnapshot.encode ( os );
	m_videoSegmentTagging.encode ( os );
	m_progressiveRefinement.encode ( os );
	m_dynamicPictureResizingByFour.encode ( os );
	m_dynamicPictureResizingSixteenthPel.encode ( os );
	m_dynamicWarpingHalfPel.encode ( os );
	m_dynamicWarpingSixteenthPel.encode ( os );
	m_independentSegmentDecoding.encode ( os );
	m_slicesInOrder_NonRect.encode ( os );
	m_slicesInOrder_Rect.encode ( os );
	m_slicesNoOrder_NonRect.encode ( os );
	m_slicesNoOrder_Rect.encode ( os );
	m_alternateInterVLCMode.encode ( os );
	m_modifiedQuantizationMode.encode ( os );
	m_reducedResolutionUpdate.encode ( os );
	if ( hasOptionalField ( e_transparencyParameters ) )
		m_transparencyParameters -> TransparencyParameters :: encode ( os );
	m_separateVideoBackChannel.encode ( os );
	if ( hasOptionalField ( e_refPictureSelection ) )
		m_refPictureSelection -> RefPictureSelection :: encode ( os );
	if ( hasOptionalField ( e_customPictureClockFrequency ) )
		m_customPictureClockFrequency -> H263Options_customPictureClockFrequency :: encode ( os );
	if ( hasOptionalField ( e_customPictureFormat ) )
		m_customPictureFormat -> H263Options_customPictureFormat :: encode ( os );
	if ( hasOptionalField ( e_modeCombos ) )
		m_modeCombos -> H263Options_modeCombos :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_videoBadMBsCap, m_videoBadMBsCap );
		knownExtensionEncode ( os, e_h263Version3Options, m_h263Version3Options );
		unknownExtensionsEncode ( os );
	}
}

H263Options :: ~H263Options ( ) {
	delete m_transparencyParameters;
	delete m_refPictureSelection;
	delete m_customPictureClockFrequency;
	delete m_customPictureFormat;
	delete m_modeCombos;
	delete m_videoBadMBsCap;
	delete m_h263Version3Options;
}

void H263Options :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 26 ) << "advancedIntraCodingMode = " << std :: setprecision ( indent ) << m_advancedIntraCodingMode << '\n';
	os << std :: setw ( indent + 23 ) << "deblockingFilterMode = " << std :: setprecision ( indent ) << m_deblockingFilterMode << '\n';
	os << std :: setw ( indent + 23 ) << "improvedPBFramesMode = " << std :: setprecision ( indent ) << m_improvedPBFramesMode << '\n';
	os << std :: setw ( indent + 25 ) << "unlimitedMotionVectors = " << std :: setprecision ( indent ) << m_unlimitedMotionVectors << '\n';
	os << std :: setw ( indent + 20 ) << "fullPictureFreeze = " << std :: setprecision ( indent ) << m_fullPictureFreeze << '\n';
	os << std :: setw ( indent + 33 ) << "partialPictureFreezeAndRelease = " << std :: setprecision ( indent ) << m_partialPictureFreezeAndRelease << '\n';
	os << std :: setw ( indent + 34 ) << "resizingPartPicFreezeAndRelease = " << std :: setprecision ( indent ) << m_resizingPartPicFreezeAndRelease << '\n';
	os << std :: setw ( indent + 22 ) << "fullPictureSnapshot = " << std :: setprecision ( indent ) << m_fullPictureSnapshot << '\n';
	os << std :: setw ( indent + 25 ) << "partialPictureSnapshot = " << std :: setprecision ( indent ) << m_partialPictureSnapshot << '\n';
	os << std :: setw ( indent + 22 ) << "videoSegmentTagging = " << std :: setprecision ( indent ) << m_videoSegmentTagging << '\n';
	os << std :: setw ( indent + 24 ) << "progressiveRefinement = " << std :: setprecision ( indent ) << m_progressiveRefinement << '\n';
	os << std :: setw ( indent + 31 ) << "dynamicPictureResizingByFour = " << std :: setprecision ( indent ) << m_dynamicPictureResizingByFour << '\n';
	os << std :: setw ( indent + 37 ) << "dynamicPictureResizingSixteenthPel = " << std :: setprecision ( indent ) << m_dynamicPictureResizingSixteenthPel << '\n';
	os << std :: setw ( indent + 24 ) << "dynamicWarpingHalfPel = " << std :: setprecision ( indent ) << m_dynamicWarpingHalfPel << '\n';
	os << std :: setw ( indent + 29 ) << "dynamicWarpingSixteenthPel = " << std :: setprecision ( indent ) << m_dynamicWarpingSixteenthPel << '\n';
	os << std :: setw ( indent + 29 ) << "independentSegmentDecoding = " << std :: setprecision ( indent ) << m_independentSegmentDecoding << '\n';
	os << std :: setw ( indent + 24 ) << "slicesInOrder_NonRect = " << std :: setprecision ( indent ) << m_slicesInOrder_NonRect << '\n';
	os << std :: setw ( indent + 21 ) << "slicesInOrder_Rect = " << std :: setprecision ( indent ) << m_slicesInOrder_Rect << '\n';
	os << std :: setw ( indent + 24 ) << "slicesNoOrder_NonRect = " << std :: setprecision ( indent ) << m_slicesNoOrder_NonRect << '\n';
	os << std :: setw ( indent + 21 ) << "slicesNoOrder_Rect = " << std :: setprecision ( indent ) << m_slicesNoOrder_Rect << '\n';
	os << std :: setw ( indent + 24 ) << "alternateInterVLCMode = " << std :: setprecision ( indent ) << m_alternateInterVLCMode << '\n';
	os << std :: setw ( indent + 27 ) << "modifiedQuantizationMode = " << std :: setprecision ( indent ) << m_modifiedQuantizationMode << '\n';
	os << std :: setw ( indent + 26 ) << "reducedResolutionUpdate = " << std :: setprecision ( indent ) << m_reducedResolutionUpdate << '\n';
	if ( hasOptionalField ( e_transparencyParameters ) ) {
		os << std :: setw ( indent + 25 ) << "transparencyParameters = " << std :: setprecision ( indent );
		m_transparencyParameters -> TransparencyParameters :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 27 ) << "separateVideoBackChannel = " << std :: setprecision ( indent ) << m_separateVideoBackChannel << '\n';
	if ( hasOptionalField ( e_refPictureSelection ) ) {
		os << std :: setw ( indent + 22 ) << "refPictureSelection = " << std :: setprecision ( indent );
		m_refPictureSelection -> RefPictureSelection :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_customPictureClockFrequency ) ) {
		os << std :: setw ( indent + 30 ) << "customPictureClockFrequency = " << std :: setprecision ( indent );
		m_customPictureClockFrequency -> H263Options_customPictureClockFrequency :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_customPictureFormat ) ) {
		os << std :: setw ( indent + 22 ) << "customPictureFormat = " << std :: setprecision ( indent );
		m_customPictureFormat -> H263Options_customPictureFormat :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_modeCombos ) ) {
		os << std :: setw ( indent + 13 ) << "modeCombos = " << std :: setprecision ( indent );
		m_modeCombos -> H263Options_modeCombos :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_videoBadMBsCap ) ) {
		os << std :: setw ( indent + 17 ) << "videoBadMBsCap = " << std :: setprecision ( indent );
		m_videoBadMBsCap -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_h263Version3Options ) ) {
		os << std :: setw ( indent + 22 ) << "h263Version3Options = " << std :: setprecision ( indent );
		m_h263Version3Options -> H263Version3Options :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H263Options * H263Options :: clone ( ) const {
	return new H263Options ( * this );
}

//
// H263ModeComboFlags
//

H263ModeComboFlags :: H263ModeComboFlags ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 2 ), m_unrestrictedVector ( is ), m_arithmeticCoding ( is ), m_advancedPrediction ( is ), m_pbFrames ( is ), m_advancedIntraCodingMode ( is ), m_deblockingFilterMode ( is ), m_unlimitedMotionVectors ( is ), m_slicesInOrder_NonRect ( is ), m_slicesInOrder_Rect ( is ), m_slicesNoOrder_NonRect ( is ), m_slicesNoOrder_Rect ( is ), m_improvedPBFramesMode ( is ), m_referencePicSelect ( is ), m_dynamicPictureResizingByFour ( is ), m_dynamicPictureResizingSixteenthPel ( is ), m_dynamicWarpingHalfPel ( is ), m_dynamicWarpingSixteenthPel ( is ), m_reducedResolutionUpdate ( is ), m_independentSegmentDecoding ( is ), m_alternateInterVLCMode ( is ), m_modifiedQuantizationMode ( is ), m_enhancedReferencePicSelect ( 0 ), m_h263Version3Options ( 0 ) {
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_enhancedReferencePicSelect ) )
				m_enhancedReferencePicSelect = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_h263Version3Options ) )
				m_h263Version3Options = new H263Version3Options ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_enhancedReferencePicSelect;
		delete m_h263Version3Options;
		throw;
	}
}

H263ModeComboFlags :: H263ModeComboFlags ( ) : Asn :: Sequence ( 0, true, 2 ), m_enhancedReferencePicSelect ( 0 ), m_h263Version3Options ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_enhancedReferencePicSelect );
		m_enhancedReferencePicSelect = new Asn :: Boolean;
		Asn :: Sequence :: includeOptionalField ( e_h263Version3Options );
		m_h263Version3Options = new H263Version3Options;
	} catch ( ... ) {
		delete m_enhancedReferencePicSelect;
		delete m_h263Version3Options;
		throw;
	}
}

H263ModeComboFlags & H263ModeComboFlags :: operator= ( const H263ModeComboFlags & s ) {
	Asn :: Sequence :: operator= ( s );
	m_unrestrictedVector = s.m_unrestrictedVector;
	m_arithmeticCoding = s.m_arithmeticCoding;
	m_advancedPrediction = s.m_advancedPrediction;
	m_pbFrames = s.m_pbFrames;
	m_advancedIntraCodingMode = s.m_advancedIntraCodingMode;
	m_deblockingFilterMode = s.m_deblockingFilterMode;
	m_unlimitedMotionVectors = s.m_unlimitedMotionVectors;
	m_slicesInOrder_NonRect = s.m_slicesInOrder_NonRect;
	m_slicesInOrder_Rect = s.m_slicesInOrder_Rect;
	m_slicesNoOrder_NonRect = s.m_slicesNoOrder_NonRect;
	m_slicesNoOrder_Rect = s.m_slicesNoOrder_Rect;
	m_improvedPBFramesMode = s.m_improvedPBFramesMode;
	m_referencePicSelect = s.m_referencePicSelect;
	m_dynamicPictureResizingByFour = s.m_dynamicPictureResizingByFour;
	m_dynamicPictureResizingSixteenthPel = s.m_dynamicPictureResizingSixteenthPel;
	m_dynamicWarpingHalfPel = s.m_dynamicWarpingHalfPel;
	m_dynamicWarpingSixteenthPel = s.m_dynamicWarpingSixteenthPel;
	m_reducedResolutionUpdate = s.m_reducedResolutionUpdate;
	m_independentSegmentDecoding = s.m_independentSegmentDecoding;
	m_alternateInterVLCMode = s.m_alternateInterVLCMode;
	m_modifiedQuantizationMode = s.m_modifiedQuantizationMode;
	assignCopy ( m_enhancedReferencePicSelect, s.m_enhancedReferencePicSelect );
	assignCopy ( m_h263Version3Options, s.m_h263Version3Options );
	return * this;
}

H263ModeComboFlags :: H263ModeComboFlags ( const H263ModeComboFlags & s ) : Asn :: Sequence ( s ), m_unrestrictedVector ( s.m_unrestrictedVector ), m_arithmeticCoding ( s.m_arithmeticCoding ), m_advancedPrediction ( s.m_advancedPrediction ), m_pbFrames ( s.m_pbFrames ), m_advancedIntraCodingMode ( s.m_advancedIntraCodingMode ), m_deblockingFilterMode ( s.m_deblockingFilterMode ), m_unlimitedMotionVectors ( s.m_unlimitedMotionVectors ), m_slicesInOrder_NonRect ( s.m_slicesInOrder_NonRect ), m_slicesInOrder_Rect ( s.m_slicesInOrder_Rect ), m_slicesNoOrder_NonRect ( s.m_slicesNoOrder_NonRect ), m_slicesNoOrder_Rect ( s.m_slicesNoOrder_Rect ), m_improvedPBFramesMode ( s.m_improvedPBFramesMode ), m_referencePicSelect ( s.m_referencePicSelect ), m_dynamicPictureResizingByFour ( s.m_dynamicPictureResizingByFour ), m_dynamicPictureResizingSixteenthPel ( s.m_dynamicPictureResizingSixteenthPel ), m_dynamicWarpingHalfPel ( s.m_dynamicWarpingHalfPel ), m_dynamicWarpingSixteenthPel ( s.m_dynamicWarpingSixteenthPel ), m_reducedResolutionUpdate ( s.m_reducedResolutionUpdate ), m_independentSegmentDecoding ( s.m_independentSegmentDecoding ), m_alternateInterVLCMode ( s.m_alternateInterVLCMode ), m_modifiedQuantizationMode ( s.m_modifiedQuantizationMode ), m_enhancedReferencePicSelect ( 0 ), m_h263Version3Options ( 0 ) {
	try {
		if ( s.m_enhancedReferencePicSelect )
			m_enhancedReferencePicSelect = new Asn :: Boolean ( * s.m_enhancedReferencePicSelect );
		if ( s.m_h263Version3Options )
			m_h263Version3Options = new H263Version3Options ( * s.m_h263Version3Options );
	} catch ( ... ) {
		delete m_enhancedReferencePicSelect;
		delete m_h263Version3Options;
		throw;
	}
}


void H263ModeComboFlags :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_enhancedReferencePicSelect:
			assignNew ( m_enhancedReferencePicSelect, new Asn :: Boolean );
			break;
		case e_h263Version3Options:
			assignNew ( m_h263Version3Options, new H263Version3Options );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void H263ModeComboFlags :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_enhancedReferencePicSelect:
			delete m_enhancedReferencePicSelect;
			m_enhancedReferencePicSelect = 0;
			break;
		case e_h263Version3Options:
			delete m_h263Version3Options;
			m_h263Version3Options = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void H263ModeComboFlags :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_unrestrictedVector.encode ( os );
	m_arithmeticCoding.encode ( os );
	m_advancedPrediction.encode ( os );
	m_pbFrames.encode ( os );
	m_advancedIntraCodingMode.encode ( os );
	m_deblockingFilterMode.encode ( os );
	m_unlimitedMotionVectors.encode ( os );
	m_slicesInOrder_NonRect.encode ( os );
	m_slicesInOrder_Rect.encode ( os );
	m_slicesNoOrder_NonRect.encode ( os );
	m_slicesNoOrder_Rect.encode ( os );
	m_improvedPBFramesMode.encode ( os );
	m_referencePicSelect.encode ( os );
	m_dynamicPictureResizingByFour.encode ( os );
	m_dynamicPictureResizingSixteenthPel.encode ( os );
	m_dynamicWarpingHalfPel.encode ( os );
	m_dynamicWarpingSixteenthPel.encode ( os );
	m_reducedResolutionUpdate.encode ( os );
	m_independentSegmentDecoding.encode ( os );
	m_alternateInterVLCMode.encode ( os );
	m_modifiedQuantizationMode.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_enhancedReferencePicSelect, m_enhancedReferencePicSelect );
		knownExtensionEncode ( os, e_h263Version3Options, m_h263Version3Options );
		unknownExtensionsEncode ( os );
	}
}

H263ModeComboFlags :: ~H263ModeComboFlags ( ) {
	delete m_enhancedReferencePicSelect;
	delete m_h263Version3Options;
}

void H263ModeComboFlags :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 21 ) << "unrestrictedVector = " << std :: setprecision ( indent ) << m_unrestrictedVector << '\n';
	os << std :: setw ( indent + 19 ) << "arithmeticCoding = " << std :: setprecision ( indent ) << m_arithmeticCoding << '\n';
	os << std :: setw ( indent + 21 ) << "advancedPrediction = " << std :: setprecision ( indent ) << m_advancedPrediction << '\n';
	os << std :: setw ( indent + 11 ) << "pbFrames = " << std :: setprecision ( indent ) << m_pbFrames << '\n';
	os << std :: setw ( indent + 26 ) << "advancedIntraCodingMode = " << std :: setprecision ( indent ) << m_advancedIntraCodingMode << '\n';
	os << std :: setw ( indent + 23 ) << "deblockingFilterMode = " << std :: setprecision ( indent ) << m_deblockingFilterMode << '\n';
	os << std :: setw ( indent + 25 ) << "unlimitedMotionVectors = " << std :: setprecision ( indent ) << m_unlimitedMotionVectors << '\n';
	os << std :: setw ( indent + 24 ) << "slicesInOrder_NonRect = " << std :: setprecision ( indent ) << m_slicesInOrder_NonRect << '\n';
	os << std :: setw ( indent + 21 ) << "slicesInOrder_Rect = " << std :: setprecision ( indent ) << m_slicesInOrder_Rect << '\n';
	os << std :: setw ( indent + 24 ) << "slicesNoOrder_NonRect = " << std :: setprecision ( indent ) << m_slicesNoOrder_NonRect << '\n';
	os << std :: setw ( indent + 21 ) << "slicesNoOrder_Rect = " << std :: setprecision ( indent ) << m_slicesNoOrder_Rect << '\n';
	os << std :: setw ( indent + 23 ) << "improvedPBFramesMode = " << std :: setprecision ( indent ) << m_improvedPBFramesMode << '\n';
	os << std :: setw ( indent + 21 ) << "referencePicSelect = " << std :: setprecision ( indent ) << m_referencePicSelect << '\n';
	os << std :: setw ( indent + 31 ) << "dynamicPictureResizingByFour = " << std :: setprecision ( indent ) << m_dynamicPictureResizingByFour << '\n';
	os << std :: setw ( indent + 37 ) << "dynamicPictureResizingSixteenthPel = " << std :: setprecision ( indent ) << m_dynamicPictureResizingSixteenthPel << '\n';
	os << std :: setw ( indent + 24 ) << "dynamicWarpingHalfPel = " << std :: setprecision ( indent ) << m_dynamicWarpingHalfPel << '\n';
	os << std :: setw ( indent + 29 ) << "dynamicWarpingSixteenthPel = " << std :: setprecision ( indent ) << m_dynamicWarpingSixteenthPel << '\n';
	os << std :: setw ( indent + 26 ) << "reducedResolutionUpdate = " << std :: setprecision ( indent ) << m_reducedResolutionUpdate << '\n';
	os << std :: setw ( indent + 29 ) << "independentSegmentDecoding = " << std :: setprecision ( indent ) << m_independentSegmentDecoding << '\n';
	os << std :: setw ( indent + 24 ) << "alternateInterVLCMode = " << std :: setprecision ( indent ) << m_alternateInterVLCMode << '\n';
	os << std :: setw ( indent + 27 ) << "modifiedQuantizationMode = " << std :: setprecision ( indent ) << m_modifiedQuantizationMode << '\n';
	if ( hasOptionalField ( e_enhancedReferencePicSelect ) ) {
		os << std :: setw ( indent + 29 ) << "enhancedReferencePicSelect = " << std :: setprecision ( indent );
		m_enhancedReferencePicSelect -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_h263Version3Options ) ) {
		os << std :: setw ( indent + 22 ) << "h263Version3Options = " << std :: setprecision ( indent );
		m_h263Version3Options -> H263Version3Options :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H263ModeComboFlags * H263ModeComboFlags :: clone ( ) const {
	return new H263ModeComboFlags ( * this );
}

//
// H263Version3Options
//

H263Version3Options :: H263Version3Options ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_dataPartitionedSlices ( is ), m_fixedPointIDCT0 ( is ), m_interlacedFields ( is ), m_currentPictureHeaderRepetition ( is ), m_previousPictureHeaderRepetition ( is ), m_nextPictureHeaderRepetition ( is ), m_pictureNumber ( is ), m_spareReferencePictures ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

H263Version3Options :: H263Version3Options ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void H263Version3Options :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_dataPartitionedSlices.encode ( os );
	m_fixedPointIDCT0.encode ( os );
	m_interlacedFields.encode ( os );
	m_currentPictureHeaderRepetition.encode ( os );
	m_previousPictureHeaderRepetition.encode ( os );
	m_nextPictureHeaderRepetition.encode ( os );
	m_pictureNumber.encode ( os );
	m_spareReferencePictures.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void H263Version3Options :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 24 ) << "dataPartitionedSlices = " << std :: setprecision ( indent ) << m_dataPartitionedSlices << '\n';
	os << std :: setw ( indent + 18 ) << "fixedPointIDCT0 = " << std :: setprecision ( indent ) << m_fixedPointIDCT0 << '\n';
	os << std :: setw ( indent + 19 ) << "interlacedFields = " << std :: setprecision ( indent ) << m_interlacedFields << '\n';
	os << std :: setw ( indent + 33 ) << "currentPictureHeaderRepetition = " << std :: setprecision ( indent ) << m_currentPictureHeaderRepetition << '\n';
	os << std :: setw ( indent + 34 ) << "previousPictureHeaderRepetition = " << std :: setprecision ( indent ) << m_previousPictureHeaderRepetition << '\n';
	os << std :: setw ( indent + 30 ) << "nextPictureHeaderRepetition = " << std :: setprecision ( indent ) << m_nextPictureHeaderRepetition << '\n';
	os << std :: setw ( indent + 16 ) << "pictureNumber = " << std :: setprecision ( indent ) << m_pictureNumber << '\n';
	os << std :: setw ( indent + 25 ) << "spareReferencePictures = " << std :: setprecision ( indent ) << m_spareReferencePictures << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H263Version3Options * H263Version3Options :: clone ( ) const {
	return new H263Version3Options ( * this );
}

//
// IS11172VideoCapability
//

IS11172VideoCapability :: IS11172VideoCapability ( Asn :: istream & is ) : Asn :: Sequence ( is, 6, true, 1 ), m_constrainedBitstream ( is ), m_videoBitRate ( 0 ), m_vbvBufferSize ( 0 ), m_samplesPerLine ( 0 ), m_linesPerFrame ( 0 ), m_pictureRate ( 0 ), m_luminanceSampleRate ( 0 ), m_videoBadMBsCap ( 0 ) {
	try {
		if ( hasOptionalField ( e_videoBitRate ) )
			m_videoBitRate = new IS11172VideoCapability_videoBitRate ( is );
		if ( hasOptionalField ( e_vbvBufferSize ) )
			m_vbvBufferSize = new IS11172VideoCapability_vbvBufferSize ( is );
		if ( hasOptionalField ( e_samplesPerLine ) )
			m_samplesPerLine = new IS11172VideoCapability_samplesPerLine ( is );
		if ( hasOptionalField ( e_linesPerFrame ) )
			m_linesPerFrame = new IS11172VideoCapability_linesPerFrame ( is );
		if ( hasOptionalField ( e_pictureRate ) )
			m_pictureRate = new IS11172VideoCapability_pictureRate ( is );
		if ( hasOptionalField ( e_luminanceSampleRate ) )
			m_luminanceSampleRate = new IS11172VideoCapability_luminanceSampleRate ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_videoBadMBsCap ) )
				m_videoBadMBsCap = new Asn :: Boolean ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_videoBitRate;
		delete m_vbvBufferSize;
		delete m_samplesPerLine;
		delete m_linesPerFrame;
		delete m_pictureRate;
		delete m_luminanceSampleRate;
		delete m_videoBadMBsCap;
		throw;
	}
}

IS11172VideoCapability :: IS11172VideoCapability ( ) : Asn :: Sequence ( 6, true, 1 ), m_videoBitRate ( 0 ), m_vbvBufferSize ( 0 ), m_samplesPerLine ( 0 ), m_linesPerFrame ( 0 ), m_pictureRate ( 0 ), m_luminanceSampleRate ( 0 ), m_videoBadMBsCap ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_videoBadMBsCap );
		m_videoBadMBsCap = new Asn :: Boolean;
	} catch ( ... ) {
		delete m_videoBadMBsCap;
		throw;
	}
}

IS11172VideoCapability & IS11172VideoCapability :: operator= ( const IS11172VideoCapability & s ) {
	Asn :: Sequence :: operator= ( s );
	m_constrainedBitstream = s.m_constrainedBitstream;
	assignCopy ( m_videoBitRate, s.m_videoBitRate );
	assignCopy ( m_vbvBufferSize, s.m_vbvBufferSize );
	assignCopy ( m_samplesPerLine, s.m_samplesPerLine );
	assignCopy ( m_linesPerFrame, s.m_linesPerFrame );
	assignCopy ( m_pictureRate, s.m_pictureRate );
	assignCopy ( m_luminanceSampleRate, s.m_luminanceSampleRate );
	assignCopy ( m_videoBadMBsCap, s.m_videoBadMBsCap );
	return * this;
}

IS11172VideoCapability :: IS11172VideoCapability ( const IS11172VideoCapability & s ) : Asn :: Sequence ( s ), m_constrainedBitstream ( s.m_constrainedBitstream ), m_videoBitRate ( 0 ), m_vbvBufferSize ( 0 ), m_samplesPerLine ( 0 ), m_linesPerFrame ( 0 ), m_pictureRate ( 0 ), m_luminanceSampleRate ( 0 ), m_videoBadMBsCap ( 0 ) {
	try {
		if ( s.m_videoBitRate )
			m_videoBitRate = new IS11172VideoCapability_videoBitRate ( * s.m_videoBitRate );
		if ( s.m_vbvBufferSize )
			m_vbvBufferSize = new IS11172VideoCapability_vbvBufferSize ( * s.m_vbvBufferSize );
		if ( s.m_samplesPerLine )
			m_samplesPerLine = new IS11172VideoCapability_samplesPerLine ( * s.m_samplesPerLine );
		if ( s.m_linesPerFrame )
			m_linesPerFrame = new IS11172VideoCapability_linesPerFrame ( * s.m_linesPerFrame );
		if ( s.m_pictureRate )
			m_pictureRate = new IS11172VideoCapability_pictureRate ( * s.m_pictureRate );
		if ( s.m_luminanceSampleRate )
			m_luminanceSampleRate = new IS11172VideoCapability_luminanceSampleRate ( * s.m_luminanceSampleRate );
		if ( s.m_videoBadMBsCap )
			m_videoBadMBsCap = new Asn :: Boolean ( * s.m_videoBadMBsCap );
	} catch ( ... ) {
		delete m_videoBitRate;
		delete m_vbvBufferSize;
		delete m_samplesPerLine;
		delete m_linesPerFrame;
		delete m_pictureRate;
		delete m_luminanceSampleRate;
		delete m_videoBadMBsCap;
		throw;
	}
}


void IS11172VideoCapability :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_videoBitRate:
			assignNew ( m_videoBitRate, new IS11172VideoCapability_videoBitRate );
			break;
		case e_vbvBufferSize:
			assignNew ( m_vbvBufferSize, new IS11172VideoCapability_vbvBufferSize );
			break;
		case e_samplesPerLine:
			assignNew ( m_samplesPerLine, new IS11172VideoCapability_samplesPerLine );
			break;
		case e_linesPerFrame:
			assignNew ( m_linesPerFrame, new IS11172VideoCapability_linesPerFrame );
			break;
		case e_pictureRate:
			assignNew ( m_pictureRate, new IS11172VideoCapability_pictureRate );
			break;
		case e_luminanceSampleRate:
			assignNew ( m_luminanceSampleRate, new IS11172VideoCapability_luminanceSampleRate );
			break;
		case e_videoBadMBsCap:
			assignNew ( m_videoBadMBsCap, new Asn :: Boolean );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void IS11172VideoCapability :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_videoBitRate:
			delete m_videoBitRate;
			m_videoBitRate = 0;
			break;
		case e_vbvBufferSize:
			delete m_vbvBufferSize;
			m_vbvBufferSize = 0;
			break;
		case e_samplesPerLine:
			delete m_samplesPerLine;
			m_samplesPerLine = 0;
			break;
		case e_linesPerFrame:
			delete m_linesPerFrame;
			m_linesPerFrame = 0;
			break;
		case e_pictureRate:
			delete m_pictureRate;
			m_pictureRate = 0;
			break;
		case e_luminanceSampleRate:
			delete m_luminanceSampleRate;
			m_luminanceSampleRate = 0;
			break;
		case e_videoBadMBsCap:
			delete m_videoBadMBsCap;
			m_videoBadMBsCap = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void IS11172VideoCapability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_constrainedBitstream.encode ( os );
	if ( hasOptionalField ( e_videoBitRate ) )
		m_videoBitRate -> IS11172VideoCapability_videoBitRate :: encode ( os );
	if ( hasOptionalField ( e_vbvBufferSize ) )
		m_vbvBufferSize -> IS11172VideoCapability_vbvBufferSize :: encode ( os );
	if ( hasOptionalField ( e_samplesPerLine ) )
		m_samplesPerLine -> IS11172VideoCapability_samplesPerLine :: encode ( os );
	if ( hasOptionalField ( e_linesPerFrame ) )
		m_linesPerFrame -> IS11172VideoCapability_linesPerFrame :: encode ( os );
	if ( hasOptionalField ( e_pictureRate ) )
		m_pictureRate -> IS11172VideoCapability_pictureRate :: encode ( os );
	if ( hasOptionalField ( e_luminanceSampleRate ) )
		m_luminanceSampleRate -> IS11172VideoCapability_luminanceSampleRate :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_videoBadMBsCap, m_videoBadMBsCap );
		unknownExtensionsEncode ( os );
	}
}

IS11172VideoCapability :: ~IS11172VideoCapability ( ) {
	delete m_videoBitRate;
	delete m_vbvBufferSize;
	delete m_samplesPerLine;
	delete m_linesPerFrame;
	delete m_pictureRate;
	delete m_luminanceSampleRate;
	delete m_videoBadMBsCap;
}

void IS11172VideoCapability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 23 ) << "constrainedBitstream = " << std :: setprecision ( indent ) << m_constrainedBitstream << '\n';
	if ( hasOptionalField ( e_videoBitRate ) ) {
		os << std :: setw ( indent + 15 ) << "videoBitRate = " << std :: setprecision ( indent );
		m_videoBitRate -> IS11172VideoCapability_videoBitRate :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_vbvBufferSize ) ) {
		os << std :: setw ( indent + 16 ) << "vbvBufferSize = " << std :: setprecision ( indent );
		m_vbvBufferSize -> IS11172VideoCapability_vbvBufferSize :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_samplesPerLine ) ) {
		os << std :: setw ( indent + 17 ) << "samplesPerLine = " << std :: setprecision ( indent );
		m_samplesPerLine -> IS11172VideoCapability_samplesPerLine :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_linesPerFrame ) ) {
		os << std :: setw ( indent + 16 ) << "linesPerFrame = " << std :: setprecision ( indent );
		m_linesPerFrame -> IS11172VideoCapability_linesPerFrame :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_pictureRate ) ) {
		os << std :: setw ( indent + 14 ) << "pictureRate = " << std :: setprecision ( indent );
		m_pictureRate -> IS11172VideoCapability_pictureRate :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_luminanceSampleRate ) ) {
		os << std :: setw ( indent + 22 ) << "luminanceSampleRate = " << std :: setprecision ( indent );
		m_luminanceSampleRate -> IS11172VideoCapability_luminanceSampleRate :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_videoBadMBsCap ) ) {
		os << std :: setw ( indent + 17 ) << "videoBadMBsCap = " << std :: setprecision ( indent );
		m_videoBadMBsCap -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

IS11172VideoCapability * IS11172VideoCapability :: clone ( ) const {
	return new IS11172VideoCapability ( * this );
}

//
// G729Extensions
//

G729Extensions :: G729Extensions ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_audioUnit ( hasOptionalField ( e_audioUnit ) ? pushTemporaryMember ( new G729Extensions_audioUnit ( is ) ) : 0 ), m_annexA ( is ), m_annexB ( is ), m_annexD ( is ), m_annexE ( is ), m_annexF ( is ), m_annexG ( is ), m_annexH ( is ) {
	clearTemporaryMembers ( );
	try {
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_audioUnit;
		throw;
	}
}

G729Extensions :: G729Extensions ( ) : Asn :: Sequence ( 1, true, 0 ), m_audioUnit ( 0 ) { }

G729Extensions & G729Extensions :: operator= ( const G729Extensions & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_audioUnit, s.m_audioUnit );
	m_annexA = s.m_annexA;
	m_annexB = s.m_annexB;
	m_annexD = s.m_annexD;
	m_annexE = s.m_annexE;
	m_annexF = s.m_annexF;
	m_annexG = s.m_annexG;
	m_annexH = s.m_annexH;
	return * this;
}

G729Extensions :: G729Extensions ( const G729Extensions & s ) : Asn :: Sequence ( s ), m_audioUnit ( 0 ), m_annexA ( s.m_annexA ), m_annexB ( s.m_annexB ), m_annexD ( s.m_annexD ), m_annexE ( s.m_annexE ), m_annexF ( s.m_annexF ), m_annexG ( s.m_annexG ), m_annexH ( s.m_annexH ) {
	try {
		if ( s.m_audioUnit )
			m_audioUnit = new G729Extensions_audioUnit ( * s.m_audioUnit );
	} catch ( ... ) {
		delete m_audioUnit;
		throw;
	}
}


void G729Extensions :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_audioUnit:
			assignNew ( m_audioUnit, new G729Extensions_audioUnit );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void G729Extensions :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_audioUnit:
			delete m_audioUnit;
			m_audioUnit = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void G729Extensions :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_audioUnit ) )
		m_audioUnit -> G729Extensions_audioUnit :: encode ( os );
	m_annexA.encode ( os );
	m_annexB.encode ( os );
	m_annexD.encode ( os );
	m_annexE.encode ( os );
	m_annexF.encode ( os );
	m_annexG.encode ( os );
	m_annexH.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

G729Extensions :: ~G729Extensions ( ) {
	delete m_audioUnit;
}

void G729Extensions :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_audioUnit ) ) {
		os << std :: setw ( indent + 12 ) << "audioUnit = " << std :: setprecision ( indent );
		m_audioUnit -> G729Extensions_audioUnit :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 9 ) << "annexA = " << std :: setprecision ( indent ) << m_annexA << '\n';
	os << std :: setw ( indent + 9 ) << "annexB = " << std :: setprecision ( indent ) << m_annexB << '\n';
	os << std :: setw ( indent + 9 ) << "annexD = " << std :: setprecision ( indent ) << m_annexD << '\n';
	os << std :: setw ( indent + 9 ) << "annexE = " << std :: setprecision ( indent ) << m_annexE << '\n';
	os << std :: setw ( indent + 9 ) << "annexF = " << std :: setprecision ( indent ) << m_annexF << '\n';
	os << std :: setw ( indent + 9 ) << "annexG = " << std :: setprecision ( indent ) << m_annexG << '\n';
	os << std :: setw ( indent + 9 ) << "annexH = " << std :: setprecision ( indent ) << m_annexH << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

G729Extensions * G729Extensions :: clone ( ) const {
	return new G729Extensions ( * this );
}

//
// T38FaxProfile
//

T38FaxProfile :: T38FaxProfile ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 4 ), m_fillBitRemoval ( is ), m_transcodingJBIG ( is ), m_transcodingMMR ( is ), m_version ( 0 ), m_t38FaxRateManagement ( 0 ), m_t38FaxUdpOptions ( 0 ), m_t38FaxTcpOptions ( 0 ) {
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_version ) )
				m_version = new T38FaxProfile_version ( is );
			if ( hasKnownExtensionToDecode ( is, e_t38FaxRateManagement ) )
				m_t38FaxRateManagement = new T38FaxRateManagement ( is );
			if ( hasKnownExtensionToDecode ( is, e_t38FaxUdpOptions ) )
				m_t38FaxUdpOptions = new T38FaxUdpOptions ( is );
			if ( hasKnownExtensionToDecode ( is, e_t38FaxTcpOptions ) )
				m_t38FaxTcpOptions = new T38FaxTcpOptions ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_version;
		delete m_t38FaxRateManagement;
		delete m_t38FaxUdpOptions;
		delete m_t38FaxTcpOptions;
		throw;
	}
}

T38FaxProfile :: T38FaxProfile ( ) : Asn :: Sequence ( 0, true, 4 ), m_version ( 0 ), m_t38FaxRateManagement ( 0 ), m_t38FaxUdpOptions ( 0 ), m_t38FaxTcpOptions ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_version );
		m_version = new T38FaxProfile_version;
		Asn :: Sequence :: includeOptionalField ( e_t38FaxRateManagement );
		m_t38FaxRateManagement = new T38FaxRateManagement;
	} catch ( ... ) {
		delete m_version;
		delete m_t38FaxRateManagement;
		throw;
	}
}

T38FaxProfile & T38FaxProfile :: operator= ( const T38FaxProfile & s ) {
	Asn :: Sequence :: operator= ( s );
	m_fillBitRemoval = s.m_fillBitRemoval;
	m_transcodingJBIG = s.m_transcodingJBIG;
	m_transcodingMMR = s.m_transcodingMMR;
	assignCopy ( m_version, s.m_version );
	assignCopy ( m_t38FaxRateManagement, s.m_t38FaxRateManagement );
	assignCopy ( m_t38FaxUdpOptions, s.m_t38FaxUdpOptions );
	assignCopy ( m_t38FaxTcpOptions, s.m_t38FaxTcpOptions );
	return * this;
}

T38FaxProfile :: T38FaxProfile ( const T38FaxProfile & s ) : Asn :: Sequence ( s ), m_fillBitRemoval ( s.m_fillBitRemoval ), m_transcodingJBIG ( s.m_transcodingJBIG ), m_transcodingMMR ( s.m_transcodingMMR ), m_version ( 0 ), m_t38FaxRateManagement ( 0 ), m_t38FaxUdpOptions ( 0 ), m_t38FaxTcpOptions ( 0 ) {
	try {
		if ( s.m_version )
			m_version = new T38FaxProfile_version ( * s.m_version );
		if ( s.m_t38FaxRateManagement )
			m_t38FaxRateManagement = new T38FaxRateManagement ( * s.m_t38FaxRateManagement );
		if ( s.m_t38FaxUdpOptions )
			m_t38FaxUdpOptions = new T38FaxUdpOptions ( * s.m_t38FaxUdpOptions );
		if ( s.m_t38FaxTcpOptions )
			m_t38FaxTcpOptions = new T38FaxTcpOptions ( * s.m_t38FaxTcpOptions );
	} catch ( ... ) {
		delete m_version;
		delete m_t38FaxRateManagement;
		delete m_t38FaxUdpOptions;
		delete m_t38FaxTcpOptions;
		throw;
	}
}


void T38FaxProfile :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_version:
			assignNew ( m_version, new T38FaxProfile_version );
			break;
		case e_t38FaxRateManagement:
			assignNew ( m_t38FaxRateManagement, new T38FaxRateManagement );
			break;
		case e_t38FaxUdpOptions:
			assignNew ( m_t38FaxUdpOptions, new T38FaxUdpOptions );
			break;
		case e_t38FaxTcpOptions:
			assignNew ( m_t38FaxTcpOptions, new T38FaxTcpOptions );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void T38FaxProfile :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_version:
			delete m_version;
			m_version = 0;
			break;
		case e_t38FaxRateManagement:
			delete m_t38FaxRateManagement;
			m_t38FaxRateManagement = 0;
			break;
		case e_t38FaxUdpOptions:
			delete m_t38FaxUdpOptions;
			m_t38FaxUdpOptions = 0;
			break;
		case e_t38FaxTcpOptions:
			delete m_t38FaxTcpOptions;
			m_t38FaxTcpOptions = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void T38FaxProfile :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_fillBitRemoval.encode ( os );
	m_transcodingJBIG.encode ( os );
	m_transcodingMMR.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_version, m_version );
		knownExtensionEncode ( os, e_t38FaxRateManagement, m_t38FaxRateManagement );
		knownExtensionEncode ( os, e_t38FaxUdpOptions, m_t38FaxUdpOptions );
		knownExtensionEncode ( os, e_t38FaxTcpOptions, m_t38FaxTcpOptions );
		unknownExtensionsEncode ( os );
	}
}

T38FaxProfile :: ~T38FaxProfile ( ) {
	delete m_version;
	delete m_t38FaxRateManagement;
	delete m_t38FaxUdpOptions;
	delete m_t38FaxTcpOptions;
}

void T38FaxProfile :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 17 ) << "fillBitRemoval = " << std :: setprecision ( indent ) << m_fillBitRemoval << '\n';
	os << std :: setw ( indent + 18 ) << "transcodingJBIG = " << std :: setprecision ( indent ) << m_transcodingJBIG << '\n';
	os << std :: setw ( indent + 17 ) << "transcodingMMR = " << std :: setprecision ( indent ) << m_transcodingMMR << '\n';
	if ( hasOptionalField ( e_version ) ) {
		os << std :: setw ( indent + 10 ) << "version = " << std :: setprecision ( indent );
		m_version -> T38FaxProfile_version :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_t38FaxRateManagement ) ) {
		os << std :: setw ( indent + 23 ) << "t38FaxRateManagement = " << std :: setprecision ( indent );
		m_t38FaxRateManagement -> T38FaxRateManagement :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_t38FaxUdpOptions ) ) {
		os << std :: setw ( indent + 19 ) << "t38FaxUdpOptions = " << std :: setprecision ( indent );
		m_t38FaxUdpOptions -> T38FaxUdpOptions :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_t38FaxTcpOptions ) ) {
		os << std :: setw ( indent + 19 ) << "t38FaxTcpOptions = " << std :: setprecision ( indent );
		m_t38FaxTcpOptions -> T38FaxTcpOptions :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

T38FaxProfile * T38FaxProfile :: clone ( ) const {
	return new T38FaxProfile ( * this );
}

//
// T38FaxRateManagement
//

T38FaxRateManagement :: T38FaxRateManagement ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_localTCF:
		case e_transferredTCF:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

T38FaxRateManagement :: T38FaxRateManagement ( ) : Asn :: Choice ( 2, true ) { }

void T38FaxRateManagement :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_localTCF:
		case e_transferredTCF:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & T38FaxRateManagement :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_localTCF, "localTCF" },
		{ e_transferredTCF, "transferredTCF" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

T38FaxRateManagement * T38FaxRateManagement :: clone ( ) const {
	return new T38FaxRateManagement ( * this );
}

//
// T38FaxTcpOptions
//

T38FaxTcpOptions :: T38FaxTcpOptions ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_t38TCPBidirectionalMode ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

T38FaxTcpOptions :: T38FaxTcpOptions ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void T38FaxTcpOptions :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_t38TCPBidirectionalMode.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void T38FaxTcpOptions :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 26 ) << "t38TCPBidirectionalMode = " << std :: setprecision ( indent ) << m_t38TCPBidirectionalMode << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

T38FaxTcpOptions * T38FaxTcpOptions :: clone ( ) const {
	return new T38FaxTcpOptions ( * this );
}

//
// EncryptionAuthenticationAndIntegrity
//

EncryptionAuthenticationAndIntegrity :: EncryptionAuthenticationAndIntegrity ( Asn :: istream & is ) : Asn :: Sequence ( is, 3, true, 1 ), m_encryptionCapability ( 0 ), m_authenticationCapability ( 0 ), m_integrityCapability ( 0 ), m_genericH235SecurityCapability ( 0 ) {
	try {
		if ( hasOptionalField ( e_encryptionCapability ) )
			m_encryptionCapability = new EncryptionCapability ( is );
		if ( hasOptionalField ( e_authenticationCapability ) )
			m_authenticationCapability = new AuthenticationCapability ( is );
		if ( hasOptionalField ( e_integrityCapability ) )
			m_integrityCapability = new IntegrityCapability ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_genericH235SecurityCapability ) )
				m_genericH235SecurityCapability = new GenericCapability ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_encryptionCapability;
		delete m_authenticationCapability;
		delete m_integrityCapability;
		delete m_genericH235SecurityCapability;
		throw;
	}
}

EncryptionAuthenticationAndIntegrity :: EncryptionAuthenticationAndIntegrity ( ) : Asn :: Sequence ( 3, true, 1 ), m_encryptionCapability ( 0 ), m_authenticationCapability ( 0 ), m_integrityCapability ( 0 ), m_genericH235SecurityCapability ( 0 ) { }

EncryptionAuthenticationAndIntegrity & EncryptionAuthenticationAndIntegrity :: operator= ( const EncryptionAuthenticationAndIntegrity & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_encryptionCapability, s.m_encryptionCapability );
	assignCopy ( m_authenticationCapability, s.m_authenticationCapability );
	assignCopy ( m_integrityCapability, s.m_integrityCapability );
	assignCopy ( m_genericH235SecurityCapability, s.m_genericH235SecurityCapability );
	return * this;
}

EncryptionAuthenticationAndIntegrity :: EncryptionAuthenticationAndIntegrity ( const EncryptionAuthenticationAndIntegrity & s ) : Asn :: Sequence ( s ), m_encryptionCapability ( 0 ), m_authenticationCapability ( 0 ), m_integrityCapability ( 0 ), m_genericH235SecurityCapability ( 0 ) {
	try {
		if ( s.m_encryptionCapability )
			m_encryptionCapability = new EncryptionCapability ( * s.m_encryptionCapability );
		if ( s.m_authenticationCapability )
			m_authenticationCapability = new AuthenticationCapability ( * s.m_authenticationCapability );
		if ( s.m_integrityCapability )
			m_integrityCapability = new IntegrityCapability ( * s.m_integrityCapability );
		if ( s.m_genericH235SecurityCapability )
			m_genericH235SecurityCapability = new GenericCapability ( * s.m_genericH235SecurityCapability );
	} catch ( ... ) {
		delete m_encryptionCapability;
		delete m_authenticationCapability;
		delete m_integrityCapability;
		delete m_genericH235SecurityCapability;
		throw;
	}
}


void EncryptionAuthenticationAndIntegrity :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_encryptionCapability:
			assignNew ( m_encryptionCapability, new EncryptionCapability );
			break;
		case e_authenticationCapability:
			assignNew ( m_authenticationCapability, new AuthenticationCapability );
			break;
		case e_integrityCapability:
			assignNew ( m_integrityCapability, new IntegrityCapability );
			break;
		case e_genericH235SecurityCapability:
			assignNew ( m_genericH235SecurityCapability, new GenericCapability );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void EncryptionAuthenticationAndIntegrity :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_encryptionCapability:
			delete m_encryptionCapability;
			m_encryptionCapability = 0;
			break;
		case e_authenticationCapability:
			delete m_authenticationCapability;
			m_authenticationCapability = 0;
			break;
		case e_integrityCapability:
			delete m_integrityCapability;
			m_integrityCapability = 0;
			break;
		case e_genericH235SecurityCapability:
			delete m_genericH235SecurityCapability;
			m_genericH235SecurityCapability = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void EncryptionAuthenticationAndIntegrity :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_encryptionCapability ) )
		m_encryptionCapability -> EncryptionCapability :: encode ( os );
	if ( hasOptionalField ( e_authenticationCapability ) )
		m_authenticationCapability -> AuthenticationCapability :: encode ( os );
	if ( hasOptionalField ( e_integrityCapability ) )
		m_integrityCapability -> IntegrityCapability :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_genericH235SecurityCapability, m_genericH235SecurityCapability );
		unknownExtensionsEncode ( os );
	}
}

EncryptionAuthenticationAndIntegrity :: ~EncryptionAuthenticationAndIntegrity ( ) {
	delete m_encryptionCapability;
	delete m_authenticationCapability;
	delete m_integrityCapability;
	delete m_genericH235SecurityCapability;
}

void EncryptionAuthenticationAndIntegrity :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_encryptionCapability ) ) {
		os << std :: setw ( indent + 23 ) << "encryptionCapability = " << std :: setprecision ( indent );
		m_encryptionCapability -> EncryptionCapability :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_authenticationCapability ) ) {
		os << std :: setw ( indent + 27 ) << "authenticationCapability = " << std :: setprecision ( indent );
		m_authenticationCapability -> AuthenticationCapability :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_integrityCapability ) ) {
		os << std :: setw ( indent + 22 ) << "integrityCapability = " << std :: setprecision ( indent );
		m_integrityCapability -> IntegrityCapability :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_genericH235SecurityCapability ) ) {
		os << std :: setw ( indent + 32 ) << "genericH235SecurityCapability = " << std :: setprecision ( indent );
		m_genericH235SecurityCapability -> GenericCapability :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

EncryptionAuthenticationAndIntegrity * EncryptionAuthenticationAndIntegrity :: clone ( ) const {
	return new EncryptionAuthenticationAndIntegrity ( * this );
}

//
// EncryptionCapability
//

EncryptionCapability :: EncryptionCapability ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 256 ) { }

EncryptionCapability :: EncryptionCapability ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 256 ) { }

EncryptionCapability :: EncryptionCapability ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 256 ) { }


Asn :: Object * EncryptionCapability :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * EncryptionCapability :: createObject ( Asn :: istream & is ) {
	return new MediaEncryptionAlgorithm ( is );
}

Asn :: Object * EncryptionCapability :: createObject ( ) {
	return new MediaEncryptionAlgorithm ( );
}

MediaEncryptionAlgorithm & EncryptionCapability :: operator[] ( std :: size_t i ) {
	return dynamic_cast < MediaEncryptionAlgorithm & > ( Asn :: Array :: operator[] ( i ) );
}

void EncryptionCapability :: push_back ( const MediaEncryptionAlgorithm & o ) {
	Asn :: Array :: push_back ( new MediaEncryptionAlgorithm ( o ) );
}

const MediaEncryptionAlgorithm & EncryptionCapability :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const MediaEncryptionAlgorithm & > ( Asn :: Array :: operator[] ( i ) );
}

EncryptionCapability * EncryptionCapability :: clone ( ) const {
	return new EncryptionCapability ( * this );
}

//
// AuthenticationCapability
//

AuthenticationCapability :: AuthenticationCapability ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 1 ), m_nonStandard ( 0 ), m_antiSpamAlgorithm ( 0 ) {
	try {
		if ( hasOptionalField ( e_nonStandard ) )
			m_nonStandard = new NonStandardParameter ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_antiSpamAlgorithm ) )
				m_antiSpamAlgorithm = new Asn :: ObjectId ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandard;
		delete m_antiSpamAlgorithm;
		throw;
	}
}

AuthenticationCapability :: AuthenticationCapability ( ) : Asn :: Sequence ( 1, true, 1 ), m_nonStandard ( 0 ), m_antiSpamAlgorithm ( 0 ) { }

AuthenticationCapability & AuthenticationCapability :: operator= ( const AuthenticationCapability & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_nonStandard, s.m_nonStandard );
	assignCopy ( m_antiSpamAlgorithm, s.m_antiSpamAlgorithm );
	return * this;
}

AuthenticationCapability :: AuthenticationCapability ( const AuthenticationCapability & s ) : Asn :: Sequence ( s ), m_nonStandard ( 0 ), m_antiSpamAlgorithm ( 0 ) {
	try {
		if ( s.m_nonStandard )
			m_nonStandard = new NonStandardParameter ( * s.m_nonStandard );
		if ( s.m_antiSpamAlgorithm )
			m_antiSpamAlgorithm = new Asn :: ObjectId ( * s.m_antiSpamAlgorithm );
	} catch ( ... ) {
		delete m_nonStandard;
		delete m_antiSpamAlgorithm;
		throw;
	}
}


void AuthenticationCapability :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandard:
			assignNew ( m_nonStandard, new NonStandardParameter );
			break;
		case e_antiSpamAlgorithm:
			assignNew ( m_antiSpamAlgorithm, new Asn :: ObjectId );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void AuthenticationCapability :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandard:
			delete m_nonStandard;
			m_nonStandard = 0;
			break;
		case e_antiSpamAlgorithm:
			delete m_antiSpamAlgorithm;
			m_antiSpamAlgorithm = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void AuthenticationCapability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_nonStandard ) )
		m_nonStandard -> NonStandardParameter :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_antiSpamAlgorithm, m_antiSpamAlgorithm );
		unknownExtensionsEncode ( os );
	}
}

AuthenticationCapability :: ~AuthenticationCapability ( ) {
	delete m_nonStandard;
	delete m_antiSpamAlgorithm;
}

void AuthenticationCapability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_nonStandard ) ) {
		os << std :: setw ( indent + 14 ) << "nonStandard = " << std :: setprecision ( indent );
		m_nonStandard -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_antiSpamAlgorithm ) ) {
		os << std :: setw ( indent + 20 ) << "antiSpamAlgorithm = " << std :: setprecision ( indent );
		m_antiSpamAlgorithm -> Asn :: ObjectId :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

AuthenticationCapability * AuthenticationCapability :: clone ( ) const {
	return new AuthenticationCapability ( * this );
}

//
// IntegrityCapability
//

IntegrityCapability :: IntegrityCapability ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_nonStandard ( 0 ) {
	try {
		if ( hasOptionalField ( e_nonStandard ) )
			m_nonStandard = new NonStandardParameter ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_nonStandard;
		throw;
	}
}

IntegrityCapability :: IntegrityCapability ( ) : Asn :: Sequence ( 1, true, 0 ), m_nonStandard ( 0 ) { }

IntegrityCapability & IntegrityCapability :: operator= ( const IntegrityCapability & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_nonStandard, s.m_nonStandard );
	return * this;
}

IntegrityCapability :: IntegrityCapability ( const IntegrityCapability & s ) : Asn :: Sequence ( s ), m_nonStandard ( 0 ) {
	try {
		if ( s.m_nonStandard )
			m_nonStandard = new NonStandardParameter ( * s.m_nonStandard );
	} catch ( ... ) {
		delete m_nonStandard;
		throw;
	}
}


void IntegrityCapability :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandard:
			assignNew ( m_nonStandard, new NonStandardParameter );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void IntegrityCapability :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandard:
			delete m_nonStandard;
			m_nonStandard = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void IntegrityCapability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_nonStandard ) )
		m_nonStandard -> NonStandardParameter :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

IntegrityCapability :: ~IntegrityCapability ( ) {
	delete m_nonStandard;
}

void IntegrityCapability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_nonStandard ) ) {
		os << std :: setw ( indent + 14 ) << "nonStandard = " << std :: setprecision ( indent );
		m_nonStandard -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

IntegrityCapability * IntegrityCapability :: clone ( ) const {
	return new IntegrityCapability ( * this );
}

//
// ConferenceCapability
//

ConferenceCapability :: ConferenceCapability ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 2 ), m_nonStandardData ( hasOptionalField ( e_nonStandardData ) ? pushTemporaryMember ( new ArrayOf_NonStandardParameter ( is ) ) : 0 ), m_chairControlCapability ( is ), m_videoIndicateMixingCapability ( 0 ), m_multipointVisualizationCapability ( 0 ) {
	clearTemporaryMembers ( );
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_videoIndicateMixingCapability ) )
				m_videoIndicateMixingCapability = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_multipointVisualizationCapability ) )
				m_multipointVisualizationCapability = new Asn :: Boolean ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_videoIndicateMixingCapability;
		delete m_multipointVisualizationCapability;
		throw;
	}
}

ConferenceCapability :: ConferenceCapability ( ) : Asn :: Sequence ( 1, true, 2 ), m_nonStandardData ( 0 ), m_videoIndicateMixingCapability ( 0 ), m_multipointVisualizationCapability ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_videoIndicateMixingCapability );
		m_videoIndicateMixingCapability = new Asn :: Boolean;
	} catch ( ... ) {
		delete m_videoIndicateMixingCapability;
		throw;
	}
}

ConferenceCapability & ConferenceCapability :: operator= ( const ConferenceCapability & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_nonStandardData, s.m_nonStandardData );
	m_chairControlCapability = s.m_chairControlCapability;
	assignCopy ( m_videoIndicateMixingCapability, s.m_videoIndicateMixingCapability );
	assignCopy ( m_multipointVisualizationCapability, s.m_multipointVisualizationCapability );
	return * this;
}

ConferenceCapability :: ConferenceCapability ( const ConferenceCapability & s ) : Asn :: Sequence ( s ), m_nonStandardData ( 0 ), m_chairControlCapability ( s.m_chairControlCapability ), m_videoIndicateMixingCapability ( 0 ), m_multipointVisualizationCapability ( 0 ) {
	try {
		if ( s.m_nonStandardData )
			m_nonStandardData = new ArrayOf_NonStandardParameter ( * s.m_nonStandardData );
		if ( s.m_videoIndicateMixingCapability )
			m_videoIndicateMixingCapability = new Asn :: Boolean ( * s.m_videoIndicateMixingCapability );
		if ( s.m_multipointVisualizationCapability )
			m_multipointVisualizationCapability = new Asn :: Boolean ( * s.m_multipointVisualizationCapability );
	} catch ( ... ) {
		delete m_nonStandardData;
		delete m_videoIndicateMixingCapability;
		delete m_multipointVisualizationCapability;
		throw;
	}
}


void ConferenceCapability :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandardData:
			assignNew ( m_nonStandardData, new ArrayOf_NonStandardParameter );
			break;
		case e_videoIndicateMixingCapability:
			assignNew ( m_videoIndicateMixingCapability, new Asn :: Boolean );
			break;
		case e_multipointVisualizationCapability:
			assignNew ( m_multipointVisualizationCapability, new Asn :: Boolean );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void ConferenceCapability :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandardData:
			delete m_nonStandardData;
			m_nonStandardData = 0;
			break;
		case e_videoIndicateMixingCapability:
			delete m_videoIndicateMixingCapability;
			m_videoIndicateMixingCapability = 0;
			break;
		case e_multipointVisualizationCapability:
			delete m_multipointVisualizationCapability;
			m_multipointVisualizationCapability = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void ConferenceCapability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_nonStandardData ) )
		m_nonStandardData -> ArrayOf_NonStandardParameter :: encode ( os );
	m_chairControlCapability.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_videoIndicateMixingCapability, m_videoIndicateMixingCapability );
		knownExtensionEncode ( os, e_multipointVisualizationCapability, m_multipointVisualizationCapability );
		unknownExtensionsEncode ( os );
	}
}

ConferenceCapability :: ~ConferenceCapability ( ) {
	delete m_nonStandardData;
	delete m_videoIndicateMixingCapability;
	delete m_multipointVisualizationCapability;
}

void ConferenceCapability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_nonStandardData ) ) {
		os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent );
		m_nonStandardData -> ArrayOf_NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 25 ) << "chairControlCapability = " << std :: setprecision ( indent ) << m_chairControlCapability << '\n';
	if ( hasOptionalField ( e_videoIndicateMixingCapability ) ) {
		os << std :: setw ( indent + 32 ) << "videoIndicateMixingCapability = " << std :: setprecision ( indent );
		m_videoIndicateMixingCapability -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_multipointVisualizationCapability ) ) {
		os << std :: setw ( indent + 36 ) << "multipointVisualizationCapability = " << std :: setprecision ( indent );
		m_multipointVisualizationCapability -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

ConferenceCapability * ConferenceCapability :: clone ( ) const {
	return new ConferenceCapability ( * this );
}

//
// NoPTAudioTelephonyEventCapability
//

NoPTAudioTelephonyEventCapability :: NoPTAudioTelephonyEventCapability ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_audioTelephoneEvent ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

NoPTAudioTelephonyEventCapability :: NoPTAudioTelephonyEventCapability ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void NoPTAudioTelephonyEventCapability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_audioTelephoneEvent.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void NoPTAudioTelephonyEventCapability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 22 ) << "audioTelephoneEvent = " << std :: setprecision ( indent ) << m_audioTelephoneEvent << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

NoPTAudioTelephonyEventCapability * NoPTAudioTelephonyEventCapability :: clone ( ) const {
	return new NoPTAudioTelephonyEventCapability ( * this );
}

//
// NoPTAudioToneCapability
//

NoPTAudioToneCapability :: NoPTAudioToneCapability ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

NoPTAudioToneCapability :: NoPTAudioToneCapability ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void NoPTAudioToneCapability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void NoPTAudioToneCapability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

NoPTAudioToneCapability * NoPTAudioToneCapability :: clone ( ) const {
	return new NoPTAudioToneCapability ( * this );
}

//
// FECCapability
//

FECCapability :: FECCapability ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 0 ), m_protectedCapability ( is ), m_fecScheme ( 0 ), m_rfc2733Format ( 0 ) {
	try {
		if ( hasOptionalField ( e_fecScheme ) )
			m_fecScheme = new Asn :: ObjectId ( is );
		if ( hasOptionalField ( e_rfc2733Format ) )
			m_rfc2733Format = new FECCapability_rfc2733Format ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_fecScheme;
		delete m_rfc2733Format;
		throw;
	}
}

FECCapability :: FECCapability ( ) : Asn :: Sequence ( 2, true, 0 ), m_fecScheme ( 0 ), m_rfc2733Format ( 0 ) { }

FECCapability & FECCapability :: operator= ( const FECCapability & s ) {
	Asn :: Sequence :: operator= ( s );
	m_protectedCapability = s.m_protectedCapability;
	assignCopy ( m_fecScheme, s.m_fecScheme );
	assignCopy ( m_rfc2733Format, s.m_rfc2733Format );
	return * this;
}

FECCapability :: FECCapability ( const FECCapability & s ) : Asn :: Sequence ( s ), m_protectedCapability ( s.m_protectedCapability ), m_fecScheme ( 0 ), m_rfc2733Format ( 0 ) {
	try {
		if ( s.m_fecScheme )
			m_fecScheme = new Asn :: ObjectId ( * s.m_fecScheme );
		if ( s.m_rfc2733Format )
			m_rfc2733Format = new FECCapability_rfc2733Format ( * s.m_rfc2733Format );
	} catch ( ... ) {
		delete m_fecScheme;
		delete m_rfc2733Format;
		throw;
	}
}


void FECCapability :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_fecScheme:
			assignNew ( m_fecScheme, new Asn :: ObjectId );
			break;
		case e_rfc2733Format:
			assignNew ( m_rfc2733Format, new FECCapability_rfc2733Format );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void FECCapability :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_fecScheme:
			delete m_fecScheme;
			m_fecScheme = 0;
			break;
		case e_rfc2733Format:
			delete m_rfc2733Format;
			m_rfc2733Format = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void FECCapability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_protectedCapability.encode ( os );
	if ( hasOptionalField ( e_fecScheme ) )
		m_fecScheme -> Asn :: ObjectId :: encode ( os );
	if ( hasOptionalField ( e_rfc2733Format ) )
		m_rfc2733Format -> FECCapability_rfc2733Format :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

FECCapability :: ~FECCapability ( ) {
	delete m_fecScheme;
	delete m_rfc2733Format;
}

void FECCapability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 22 ) << "protectedCapability = " << std :: setprecision ( indent ) << m_protectedCapability << '\n';
	if ( hasOptionalField ( e_fecScheme ) ) {
		os << std :: setw ( indent + 12 ) << "fecScheme = " << std :: setprecision ( indent );
		m_fecScheme -> Asn :: ObjectId :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_rfc2733Format ) ) {
		os << std :: setw ( indent + 16 ) << "rfc2733Format = " << std :: setprecision ( indent );
		m_rfc2733Format -> FECCapability_rfc2733Format :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

FECCapability * FECCapability :: clone ( ) const {
	return new FECCapability ( * this );
}

//
// MaxRedundancy
//

MaxRedundancy :: MaxRedundancy ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, std :: numeric_limits < int > :: max ( ) ) { }

MaxRedundancy :: MaxRedundancy ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, std :: numeric_limits < int > :: max ( ) ) { }

MaxRedundancy * MaxRedundancy :: clone ( ) const {
	return new MaxRedundancy ( * this );
}

//
// LogicalChannelNumber
//

LogicalChannelNumber :: LogicalChannelNumber ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 65535 ) { }

LogicalChannelNumber :: LogicalChannelNumber ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 65535 ) { }

LogicalChannelNumber * LogicalChannelNumber :: clone ( ) const {
	return new LogicalChannelNumber ( * this );
}

//
// V75Parameters
//

V75Parameters :: V75Parameters ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_audioHeaderPresent ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

V75Parameters :: V75Parameters ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void V75Parameters :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_audioHeaderPresent.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void V75Parameters :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 21 ) << "audioHeaderPresent = " << std :: setprecision ( indent ) << m_audioHeaderPresent << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

V75Parameters * V75Parameters :: clone ( ) const {
	return new V75Parameters ( * this );
}

//
// CRCLength
//

CRCLength :: CRCLength ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_crc8bit:
		case e_crc16bit:
		case e_crc32bit:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

CRCLength :: CRCLength ( ) : Asn :: Choice ( 3, true ) { }

void CRCLength :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_crc8bit:
		case e_crc16bit:
		case e_crc32bit:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & CRCLength :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_crc8bit, "crc8bit" },
		{ e_crc16bit, "crc16bit" },
		{ e_crc32bit, "crc32bit" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

CRCLength * CRCLength :: clone ( ) const {
	return new CRCLength ( * this );
}

//
// OpenLogicalChannelAck
//

OpenLogicalChannelAck :: OpenLogicalChannelAck ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 4 ), m_forwardLogicalChannelNumber ( is ), m_reverseLogicalChannelParameters ( 0 ), m_separateStack ( 0 ), m_forwardMultiplexAckParameters ( 0 ), m_encryptionSync ( 0 ), m_genericInformation ( 0 ) {
	try {
		if ( hasOptionalField ( e_reverseLogicalChannelParameters ) )
			m_reverseLogicalChannelParameters = new OpenLogicalChannelAck_reverseLogicalChannelParameters ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_separateStack ) )
				m_separateStack = new NetworkAccessParameters ( is );
			if ( hasKnownExtensionToDecode ( is, e_forwardMultiplexAckParameters ) )
				m_forwardMultiplexAckParameters = new OpenLogicalChannelAck_forwardMultiplexAckParameters ( is );
			if ( hasKnownExtensionToDecode ( is, e_encryptionSync ) )
				m_encryptionSync = new EncryptionSync ( is );
			if ( hasKnownExtensionToDecode ( is, e_genericInformation ) )
				m_genericInformation = new ArrayOf_GenericInformation ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_reverseLogicalChannelParameters;
		delete m_separateStack;
		delete m_forwardMultiplexAckParameters;
		delete m_encryptionSync;
		delete m_genericInformation;
		throw;
	}
}

OpenLogicalChannelAck :: OpenLogicalChannelAck ( ) : Asn :: Sequence ( 1, true, 4 ), m_reverseLogicalChannelParameters ( 0 ), m_separateStack ( 0 ), m_forwardMultiplexAckParameters ( 0 ), m_encryptionSync ( 0 ), m_genericInformation ( 0 ) { }

OpenLogicalChannelAck & OpenLogicalChannelAck :: operator= ( const OpenLogicalChannelAck & s ) {
	Asn :: Sequence :: operator= ( s );
	m_forwardLogicalChannelNumber = s.m_forwardLogicalChannelNumber;
	assignCopy ( m_reverseLogicalChannelParameters, s.m_reverseLogicalChannelParameters );
	assignCopy ( m_separateStack, s.m_separateStack );
	assignCopy ( m_forwardMultiplexAckParameters, s.m_forwardMultiplexAckParameters );
	assignCopy ( m_encryptionSync, s.m_encryptionSync );
	assignCopy ( m_genericInformation, s.m_genericInformation );
	return * this;
}

OpenLogicalChannelAck :: OpenLogicalChannelAck ( const OpenLogicalChannelAck & s ) : Asn :: Sequence ( s ), m_forwardLogicalChannelNumber ( s.m_forwardLogicalChannelNumber ), m_reverseLogicalChannelParameters ( 0 ), m_separateStack ( 0 ), m_forwardMultiplexAckParameters ( 0 ), m_encryptionSync ( 0 ), m_genericInformation ( 0 ) {
	try {
		if ( s.m_reverseLogicalChannelParameters )
			m_reverseLogicalChannelParameters = new OpenLogicalChannelAck_reverseLogicalChannelParameters ( * s.m_reverseLogicalChannelParameters );
		if ( s.m_separateStack )
			m_separateStack = new NetworkAccessParameters ( * s.m_separateStack );
		if ( s.m_forwardMultiplexAckParameters )
			m_forwardMultiplexAckParameters = new OpenLogicalChannelAck_forwardMultiplexAckParameters ( * s.m_forwardMultiplexAckParameters );
		if ( s.m_encryptionSync )
			m_encryptionSync = new EncryptionSync ( * s.m_encryptionSync );
		if ( s.m_genericInformation )
			m_genericInformation = new ArrayOf_GenericInformation ( * s.m_genericInformation );
	} catch ( ... ) {
		delete m_reverseLogicalChannelParameters;
		delete m_separateStack;
		delete m_forwardMultiplexAckParameters;
		delete m_encryptionSync;
		delete m_genericInformation;
		throw;
	}
}


void OpenLogicalChannelAck :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_reverseLogicalChannelParameters:
			assignNew ( m_reverseLogicalChannelParameters, new OpenLogicalChannelAck_reverseLogicalChannelParameters );
			break;
		case e_separateStack:
			assignNew ( m_separateStack, new NetworkAccessParameters );
			break;
		case e_forwardMultiplexAckParameters:
			assignNew ( m_forwardMultiplexAckParameters, new OpenLogicalChannelAck_forwardMultiplexAckParameters );
			break;
		case e_encryptionSync:
			assignNew ( m_encryptionSync, new EncryptionSync );
			break;
		case e_genericInformation:
			assignNew ( m_genericInformation, new ArrayOf_GenericInformation );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void OpenLogicalChannelAck :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_reverseLogicalChannelParameters:
			delete m_reverseLogicalChannelParameters;
			m_reverseLogicalChannelParameters = 0;
			break;
		case e_separateStack:
			delete m_separateStack;
			m_separateStack = 0;
			break;
		case e_forwardMultiplexAckParameters:
			delete m_forwardMultiplexAckParameters;
			m_forwardMultiplexAckParameters = 0;
			break;
		case e_encryptionSync:
			delete m_encryptionSync;
			m_encryptionSync = 0;
			break;
		case e_genericInformation:
			delete m_genericInformation;
			m_genericInformation = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void OpenLogicalChannelAck :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_forwardLogicalChannelNumber.encode ( os );
	if ( hasOptionalField ( e_reverseLogicalChannelParameters ) )
		m_reverseLogicalChannelParameters -> OpenLogicalChannelAck_reverseLogicalChannelParameters :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_separateStack, m_separateStack );
		knownExtensionEncode ( os, e_forwardMultiplexAckParameters, m_forwardMultiplexAckParameters );
		knownExtensionEncode ( os, e_encryptionSync, m_encryptionSync );
		knownExtensionEncode ( os, e_genericInformation, m_genericInformation );
		unknownExtensionsEncode ( os );
	}
}

OpenLogicalChannelAck :: ~OpenLogicalChannelAck ( ) {
	delete m_reverseLogicalChannelParameters;
	delete m_separateStack;
	delete m_forwardMultiplexAckParameters;
	delete m_encryptionSync;
	delete m_genericInformation;
}

void OpenLogicalChannelAck :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 30 ) << "forwardLogicalChannelNumber = " << std :: setprecision ( indent ) << m_forwardLogicalChannelNumber << '\n';
	if ( hasOptionalField ( e_reverseLogicalChannelParameters ) ) {
		os << std :: setw ( indent + 34 ) << "reverseLogicalChannelParameters = " << std :: setprecision ( indent );
		m_reverseLogicalChannelParameters -> OpenLogicalChannelAck_reverseLogicalChannelParameters :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_separateStack ) ) {
		os << std :: setw ( indent + 16 ) << "separateStack = " << std :: setprecision ( indent );
		m_separateStack -> NetworkAccessParameters :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_forwardMultiplexAckParameters ) ) {
		os << std :: setw ( indent + 32 ) << "forwardMultiplexAckParameters = " << std :: setprecision ( indent );
		m_forwardMultiplexAckParameters -> OpenLogicalChannelAck_forwardMultiplexAckParameters :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_encryptionSync ) ) {
		os << std :: setw ( indent + 17 ) << "encryptionSync = " << std :: setprecision ( indent );
		m_encryptionSync -> EncryptionSync :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_genericInformation ) ) {
		os << std :: setw ( indent + 21 ) << "genericInformation = " << std :: setprecision ( indent );
		m_genericInformation -> ArrayOf_GenericInformation :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

OpenLogicalChannelAck * OpenLogicalChannelAck :: clone ( ) const {
	return new OpenLogicalChannelAck ( * this );
}

//
// OpenLogicalChannelConfirm
//

OpenLogicalChannelConfirm :: OpenLogicalChannelConfirm ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 1 ), m_forwardLogicalChannelNumber ( is ), m_genericInformation ( 0 ) {
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_genericInformation ) )
				m_genericInformation = new ArrayOf_GenericInformation ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_genericInformation;
		throw;
	}
}

OpenLogicalChannelConfirm :: OpenLogicalChannelConfirm ( ) : Asn :: Sequence ( 0, true, 1 ), m_genericInformation ( 0 ) { }

OpenLogicalChannelConfirm & OpenLogicalChannelConfirm :: operator= ( const OpenLogicalChannelConfirm & s ) {
	Asn :: Sequence :: operator= ( s );
	m_forwardLogicalChannelNumber = s.m_forwardLogicalChannelNumber;
	assignCopy ( m_genericInformation, s.m_genericInformation );
	return * this;
}

OpenLogicalChannelConfirm :: OpenLogicalChannelConfirm ( const OpenLogicalChannelConfirm & s ) : Asn :: Sequence ( s ), m_forwardLogicalChannelNumber ( s.m_forwardLogicalChannelNumber ), m_genericInformation ( 0 ) {
	try {
		if ( s.m_genericInformation )
			m_genericInformation = new ArrayOf_GenericInformation ( * s.m_genericInformation );
	} catch ( ... ) {
		delete m_genericInformation;
		throw;
	}
}


void OpenLogicalChannelConfirm :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_genericInformation:
			assignNew ( m_genericInformation, new ArrayOf_GenericInformation );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void OpenLogicalChannelConfirm :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_genericInformation:
			delete m_genericInformation;
			m_genericInformation = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void OpenLogicalChannelConfirm :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_forwardLogicalChannelNumber.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_genericInformation, m_genericInformation );
		unknownExtensionsEncode ( os );
	}
}

OpenLogicalChannelConfirm :: ~OpenLogicalChannelConfirm ( ) {
	delete m_genericInformation;
}

void OpenLogicalChannelConfirm :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 30 ) << "forwardLogicalChannelNumber = " << std :: setprecision ( indent ) << m_forwardLogicalChannelNumber << '\n';
	if ( hasOptionalField ( e_genericInformation ) ) {
		os << std :: setw ( indent + 21 ) << "genericInformation = " << std :: setprecision ( indent );
		m_genericInformation -> ArrayOf_GenericInformation :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

OpenLogicalChannelConfirm * OpenLogicalChannelConfirm :: clone ( ) const {
	return new OpenLogicalChannelConfirm ( * this );
}

//
// H2250LogicalChannelAckParameters
//

H2250LogicalChannelAckParameters :: H2250LogicalChannelAckParameters ( Asn :: istream & is ) : Asn :: Sequence ( is, 5, true, 2 ), m_nonStandard ( 0 ), m_sessionID ( 0 ), m_mediaChannel ( 0 ), m_mediaControlChannel ( 0 ), m_dynamicRTPPayloadType ( 0 ), m_flowControlToZero ( 0 ), m_portNumber ( 0 ) {
	try {
		if ( hasOptionalField ( e_nonStandard ) )
			m_nonStandard = new ArrayOf_NonStandardParameter ( is );
		if ( hasOptionalField ( e_sessionID ) )
			m_sessionID = new H2250LogicalChannelAckParameters_sessionID ( is );
		if ( hasOptionalField ( e_mediaChannel ) )
			m_mediaChannel = new TransportAddress ( is );
		if ( hasOptionalField ( e_mediaControlChannel ) )
			m_mediaControlChannel = new TransportAddress ( is );
		if ( hasOptionalField ( e_dynamicRTPPayloadType ) )
			m_dynamicRTPPayloadType = new H2250LogicalChannelAckParameters_dynamicRTPPayloadType ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_flowControlToZero ) )
				m_flowControlToZero = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_portNumber ) )
				m_portNumber = new H2250LogicalChannelAckParameters_portNumber ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandard;
		delete m_sessionID;
		delete m_mediaChannel;
		delete m_mediaControlChannel;
		delete m_dynamicRTPPayloadType;
		delete m_flowControlToZero;
		delete m_portNumber;
		throw;
	}
}

H2250LogicalChannelAckParameters :: H2250LogicalChannelAckParameters ( ) : Asn :: Sequence ( 5, true, 2 ), m_nonStandard ( 0 ), m_sessionID ( 0 ), m_mediaChannel ( 0 ), m_mediaControlChannel ( 0 ), m_dynamicRTPPayloadType ( 0 ), m_flowControlToZero ( 0 ), m_portNumber ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_flowControlToZero );
		m_flowControlToZero = new Asn :: Boolean;
	} catch ( ... ) {
		delete m_flowControlToZero;
		throw;
	}
}

H2250LogicalChannelAckParameters & H2250LogicalChannelAckParameters :: operator= ( const H2250LogicalChannelAckParameters & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_nonStandard, s.m_nonStandard );
	assignCopy ( m_sessionID, s.m_sessionID );
	assignCopy ( m_mediaChannel, s.m_mediaChannel );
	assignCopy ( m_mediaControlChannel, s.m_mediaControlChannel );
	assignCopy ( m_dynamicRTPPayloadType, s.m_dynamicRTPPayloadType );
	assignCopy ( m_flowControlToZero, s.m_flowControlToZero );
	assignCopy ( m_portNumber, s.m_portNumber );
	return * this;
}

H2250LogicalChannelAckParameters :: H2250LogicalChannelAckParameters ( const H2250LogicalChannelAckParameters & s ) : Asn :: Sequence ( s ), m_nonStandard ( 0 ), m_sessionID ( 0 ), m_mediaChannel ( 0 ), m_mediaControlChannel ( 0 ), m_dynamicRTPPayloadType ( 0 ), m_flowControlToZero ( 0 ), m_portNumber ( 0 ) {
	try {
		if ( s.m_nonStandard )
			m_nonStandard = new ArrayOf_NonStandardParameter ( * s.m_nonStandard );
		if ( s.m_sessionID )
			m_sessionID = new H2250LogicalChannelAckParameters_sessionID ( * s.m_sessionID );
		if ( s.m_mediaChannel )
			m_mediaChannel = new TransportAddress ( * s.m_mediaChannel );
		if ( s.m_mediaControlChannel )
			m_mediaControlChannel = new TransportAddress ( * s.m_mediaControlChannel );
		if ( s.m_dynamicRTPPayloadType )
			m_dynamicRTPPayloadType = new H2250LogicalChannelAckParameters_dynamicRTPPayloadType ( * s.m_dynamicRTPPayloadType );
		if ( s.m_flowControlToZero )
			m_flowControlToZero = new Asn :: Boolean ( * s.m_flowControlToZero );
		if ( s.m_portNumber )
			m_portNumber = new H2250LogicalChannelAckParameters_portNumber ( * s.m_portNumber );
	} catch ( ... ) {
		delete m_nonStandard;
		delete m_sessionID;
		delete m_mediaChannel;
		delete m_mediaControlChannel;
		delete m_dynamicRTPPayloadType;
		delete m_flowControlToZero;
		delete m_portNumber;
		throw;
	}
}


void H2250LogicalChannelAckParameters :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandard:
			assignNew ( m_nonStandard, new ArrayOf_NonStandardParameter );
			break;
		case e_sessionID:
			assignNew ( m_sessionID, new H2250LogicalChannelAckParameters_sessionID );
			break;
		case e_mediaChannel:
			assignNew ( m_mediaChannel, new TransportAddress );
			break;
		case e_mediaControlChannel:
			assignNew ( m_mediaControlChannel, new TransportAddress );
			break;
		case e_dynamicRTPPayloadType:
			assignNew ( m_dynamicRTPPayloadType, new H2250LogicalChannelAckParameters_dynamicRTPPayloadType );
			break;
		case e_flowControlToZero:
			assignNew ( m_flowControlToZero, new Asn :: Boolean );
			break;
		case e_portNumber:
			assignNew ( m_portNumber, new H2250LogicalChannelAckParameters_portNumber );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void H2250LogicalChannelAckParameters :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandard:
			delete m_nonStandard;
			m_nonStandard = 0;
			break;
		case e_sessionID:
			delete m_sessionID;
			m_sessionID = 0;
			break;
		case e_mediaChannel:
			delete m_mediaChannel;
			m_mediaChannel = 0;
			break;
		case e_mediaControlChannel:
			delete m_mediaControlChannel;
			m_mediaControlChannel = 0;
			break;
		case e_dynamicRTPPayloadType:
			delete m_dynamicRTPPayloadType;
			m_dynamicRTPPayloadType = 0;
			break;
		case e_flowControlToZero:
			delete m_flowControlToZero;
			m_flowControlToZero = 0;
			break;
		case e_portNumber:
			delete m_portNumber;
			m_portNumber = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void H2250LogicalChannelAckParameters :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_nonStandard ) )
		m_nonStandard -> ArrayOf_NonStandardParameter :: encode ( os );
	if ( hasOptionalField ( e_sessionID ) )
		m_sessionID -> H2250LogicalChannelAckParameters_sessionID :: encode ( os );
	if ( hasOptionalField ( e_mediaChannel ) )
		m_mediaChannel -> TransportAddress :: encode ( os );
	if ( hasOptionalField ( e_mediaControlChannel ) )
		m_mediaControlChannel -> TransportAddress :: encode ( os );
	if ( hasOptionalField ( e_dynamicRTPPayloadType ) )
		m_dynamicRTPPayloadType -> H2250LogicalChannelAckParameters_dynamicRTPPayloadType :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_flowControlToZero, m_flowControlToZero );
		knownExtensionEncode ( os, e_portNumber, m_portNumber );
		unknownExtensionsEncode ( os );
	}
}

H2250LogicalChannelAckParameters :: ~H2250LogicalChannelAckParameters ( ) {
	delete m_nonStandard;
	delete m_sessionID;
	delete m_mediaChannel;
	delete m_mediaControlChannel;
	delete m_dynamicRTPPayloadType;
	delete m_flowControlToZero;
	delete m_portNumber;
}

void H2250LogicalChannelAckParameters :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_nonStandard ) ) {
		os << std :: setw ( indent + 14 ) << "nonStandard = " << std :: setprecision ( indent );
		m_nonStandard -> ArrayOf_NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_sessionID ) ) {
		os << std :: setw ( indent + 12 ) << "sessionID = " << std :: setprecision ( indent );
		m_sessionID -> H2250LogicalChannelAckParameters_sessionID :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_mediaChannel ) ) {
		os << std :: setw ( indent + 15 ) << "mediaChannel = " << std :: setprecision ( indent );
		m_mediaChannel -> TransportAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_mediaControlChannel ) ) {
		os << std :: setw ( indent + 22 ) << "mediaControlChannel = " << std :: setprecision ( indent );
		m_mediaControlChannel -> TransportAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_dynamicRTPPayloadType ) ) {
		os << std :: setw ( indent + 24 ) << "dynamicRTPPayloadType = " << std :: setprecision ( indent );
		m_dynamicRTPPayloadType -> H2250LogicalChannelAckParameters_dynamicRTPPayloadType :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_flowControlToZero ) ) {
		os << std :: setw ( indent + 20 ) << "flowControlToZero = " << std :: setprecision ( indent );
		m_flowControlToZero -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_portNumber ) ) {
		os << std :: setw ( indent + 13 ) << "portNumber = " << std :: setprecision ( indent );
		m_portNumber -> H2250LogicalChannelAckParameters_portNumber :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H2250LogicalChannelAckParameters * H2250LogicalChannelAckParameters :: clone ( ) const {
	return new H2250LogicalChannelAckParameters ( * this );
}

//
// CloseLogicalChannelAck
//

CloseLogicalChannelAck :: CloseLogicalChannelAck ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_forwardLogicalChannelNumber ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

CloseLogicalChannelAck :: CloseLogicalChannelAck ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void CloseLogicalChannelAck :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_forwardLogicalChannelNumber.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void CloseLogicalChannelAck :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 30 ) << "forwardLogicalChannelNumber = " << std :: setprecision ( indent ) << m_forwardLogicalChannelNumber << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

CloseLogicalChannelAck * CloseLogicalChannelAck :: clone ( ) const {
	return new CloseLogicalChannelAck ( * this );
}

//
// RequestChannelClose
//

RequestChannelClose :: RequestChannelClose ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 2 ), m_forwardLogicalChannelNumber ( is ), m_qosCapability ( 0 ), m_reason ( 0 ) {
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_qosCapability ) )
				m_qosCapability = new QOSCapability ( is );
			if ( hasKnownExtensionToDecode ( is, e_reason ) )
				m_reason = new RequestChannelClose_reason ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_qosCapability;
		delete m_reason;
		throw;
	}
}

RequestChannelClose :: RequestChannelClose ( ) : Asn :: Sequence ( 0, true, 2 ), m_qosCapability ( 0 ), m_reason ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_reason );
		m_reason = new RequestChannelClose_reason;
	} catch ( ... ) {
		delete m_reason;
		throw;
	}
}

RequestChannelClose & RequestChannelClose :: operator= ( const RequestChannelClose & s ) {
	Asn :: Sequence :: operator= ( s );
	m_forwardLogicalChannelNumber = s.m_forwardLogicalChannelNumber;
	assignCopy ( m_qosCapability, s.m_qosCapability );
	assignCopy ( m_reason, s.m_reason );
	return * this;
}

RequestChannelClose :: RequestChannelClose ( const RequestChannelClose & s ) : Asn :: Sequence ( s ), m_forwardLogicalChannelNumber ( s.m_forwardLogicalChannelNumber ), m_qosCapability ( 0 ), m_reason ( 0 ) {
	try {
		if ( s.m_qosCapability )
			m_qosCapability = new QOSCapability ( * s.m_qosCapability );
		if ( s.m_reason )
			m_reason = new RequestChannelClose_reason ( * s.m_reason );
	} catch ( ... ) {
		delete m_qosCapability;
		delete m_reason;
		throw;
	}
}


void RequestChannelClose :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_qosCapability:
			assignNew ( m_qosCapability, new QOSCapability );
			break;
		case e_reason:
			assignNew ( m_reason, new RequestChannelClose_reason );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void RequestChannelClose :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_qosCapability:
			delete m_qosCapability;
			m_qosCapability = 0;
			break;
		case e_reason:
			delete m_reason;
			m_reason = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void RequestChannelClose :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_forwardLogicalChannelNumber.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_qosCapability, m_qosCapability );
		knownExtensionEncode ( os, e_reason, m_reason );
		unknownExtensionsEncode ( os );
	}
}

RequestChannelClose :: ~RequestChannelClose ( ) {
	delete m_qosCapability;
	delete m_reason;
}

void RequestChannelClose :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 30 ) << "forwardLogicalChannelNumber = " << std :: setprecision ( indent ) << m_forwardLogicalChannelNumber << '\n';
	if ( hasOptionalField ( e_qosCapability ) ) {
		os << std :: setw ( indent + 16 ) << "qosCapability = " << std :: setprecision ( indent );
		m_qosCapability -> QOSCapability :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_reason ) ) {
		os << std :: setw ( indent + 9 ) << "reason = " << std :: setprecision ( indent );
		m_reason -> RequestChannelClose_reason :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RequestChannelClose * RequestChannelClose :: clone ( ) const {
	return new RequestChannelClose ( * this );
}

//
// RequestChannelCloseAck
//

RequestChannelCloseAck :: RequestChannelCloseAck ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_forwardLogicalChannelNumber ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

RequestChannelCloseAck :: RequestChannelCloseAck ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void RequestChannelCloseAck :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_forwardLogicalChannelNumber.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void RequestChannelCloseAck :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 30 ) << "forwardLogicalChannelNumber = " << std :: setprecision ( indent ) << m_forwardLogicalChannelNumber << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RequestChannelCloseAck * RequestChannelCloseAck :: clone ( ) const {
	return new RequestChannelCloseAck ( * this );
}

//
// RequestChannelCloseRelease
//

RequestChannelCloseRelease :: RequestChannelCloseRelease ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_forwardLogicalChannelNumber ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

RequestChannelCloseRelease :: RequestChannelCloseRelease ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void RequestChannelCloseRelease :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_forwardLogicalChannelNumber.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void RequestChannelCloseRelease :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 30 ) << "forwardLogicalChannelNumber = " << std :: setprecision ( indent ) << m_forwardLogicalChannelNumber << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RequestChannelCloseRelease * RequestChannelCloseRelease :: clone ( ) const {
	return new RequestChannelCloseRelease ( * this );
}

//
// MultiplexTableEntryNumber
//

MultiplexTableEntryNumber :: MultiplexTableEntryNumber ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 15 ) { }

MultiplexTableEntryNumber :: MultiplexTableEntryNumber ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 15 ) { }

MultiplexTableEntryNumber * MultiplexTableEntryNumber :: clone ( ) const {
	return new MultiplexTableEntryNumber ( * this );
}

//
// RequestModeRelease
//

RequestModeRelease :: RequestModeRelease ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

RequestModeRelease :: RequestModeRelease ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void RequestModeRelease :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void RequestModeRelease :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RequestModeRelease * RequestModeRelease :: clone ( ) const {
	return new RequestModeRelease ( * this );
}

//
// ModeDescription
//

ModeDescription :: ModeDescription ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 256 ) { }

ModeDescription :: ModeDescription ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 256 ) { }

ModeDescription :: ModeDescription ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 256 ) { }


Asn :: Object * ModeDescription :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ModeDescription :: createObject ( Asn :: istream & is ) {
	return new ModeElement ( is );
}

Asn :: Object * ModeDescription :: createObject ( ) {
	return new ModeElement ( );
}

ModeElement & ModeDescription :: operator[] ( std :: size_t i ) {
	return dynamic_cast < ModeElement & > ( Asn :: Array :: operator[] ( i ) );
}

void ModeDescription :: push_back ( const ModeElement & o ) {
	Asn :: Array :: push_back ( new ModeElement ( o ) );
}

const ModeElement & ModeDescription :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const ModeElement & > ( Asn :: Array :: operator[] ( i ) );
}

ModeDescription * ModeDescription :: clone ( ) const {
	return new ModeDescription ( * this );
}

//
// MultiplexedStreamModeParameters
//

MultiplexedStreamModeParameters :: MultiplexedStreamModeParameters ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_logicalChannelNumber ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MultiplexedStreamModeParameters :: MultiplexedStreamModeParameters ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MultiplexedStreamModeParameters :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_logicalChannelNumber.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MultiplexedStreamModeParameters :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 23 ) << "logicalChannelNumber = " << std :: setprecision ( indent ) << m_logicalChannelNumber << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MultiplexedStreamModeParameters * MultiplexedStreamModeParameters :: clone ( ) const {
	return new MultiplexedStreamModeParameters ( * this );
}

//
// V76ModeParameters
//

V76ModeParameters :: V76ModeParameters ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_suspendResumewAddress:
		case e_suspendResumewoAddress:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

V76ModeParameters :: V76ModeParameters ( ) : Asn :: Choice ( 2, true ) { }

void V76ModeParameters :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_suspendResumewAddress:
		case e_suspendResumewoAddress:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & V76ModeParameters :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_suspendResumewAddress, "suspendResumewAddress" },
		{ e_suspendResumewoAddress, "suspendResumewoAddress" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

V76ModeParameters * V76ModeParameters :: clone ( ) const {
	return new V76ModeParameters ( * this );
}

//
// H2250ModeParameters
//

H2250ModeParameters :: H2250ModeParameters ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_redundancyEncodingMode ( 0 ) {
	try {
		if ( hasOptionalField ( e_redundancyEncodingMode ) )
			m_redundancyEncodingMode = new RedundancyEncodingMode ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_redundancyEncodingMode;
		throw;
	}
}

H2250ModeParameters :: H2250ModeParameters ( ) : Asn :: Sequence ( 1, true, 0 ), m_redundancyEncodingMode ( 0 ) { }

H2250ModeParameters & H2250ModeParameters :: operator= ( const H2250ModeParameters & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_redundancyEncodingMode, s.m_redundancyEncodingMode );
	return * this;
}

H2250ModeParameters :: H2250ModeParameters ( const H2250ModeParameters & s ) : Asn :: Sequence ( s ), m_redundancyEncodingMode ( 0 ) {
	try {
		if ( s.m_redundancyEncodingMode )
			m_redundancyEncodingMode = new RedundancyEncodingMode ( * s.m_redundancyEncodingMode );
	} catch ( ... ) {
		delete m_redundancyEncodingMode;
		throw;
	}
}


void H2250ModeParameters :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_redundancyEncodingMode:
			assignNew ( m_redundancyEncodingMode, new RedundancyEncodingMode );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void H2250ModeParameters :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_redundancyEncodingMode:
			delete m_redundancyEncodingMode;
			m_redundancyEncodingMode = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void H2250ModeParameters :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_redundancyEncodingMode ) )
		m_redundancyEncodingMode -> RedundancyEncodingMode :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

H2250ModeParameters :: ~H2250ModeParameters ( ) {
	delete m_redundancyEncodingMode;
}

void H2250ModeParameters :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_redundancyEncodingMode ) ) {
		os << std :: setw ( indent + 25 ) << "redundancyEncodingMode = " << std :: setprecision ( indent );
		m_redundancyEncodingMode -> RedundancyEncodingMode :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H2250ModeParameters * H2250ModeParameters :: clone ( ) const {
	return new H2250ModeParameters ( * this );
}

//
// IS11172VideoMode
//

IS11172VideoMode :: IS11172VideoMode ( Asn :: istream & is ) : Asn :: Sequence ( is, 6, true, 0 ), m_constrainedBitstream ( is ), m_videoBitRate ( 0 ), m_vbvBufferSize ( 0 ), m_samplesPerLine ( 0 ), m_linesPerFrame ( 0 ), m_pictureRate ( 0 ), m_luminanceSampleRate ( 0 ) {
	try {
		if ( hasOptionalField ( e_videoBitRate ) )
			m_videoBitRate = new IS11172VideoMode_videoBitRate ( is );
		if ( hasOptionalField ( e_vbvBufferSize ) )
			m_vbvBufferSize = new IS11172VideoMode_vbvBufferSize ( is );
		if ( hasOptionalField ( e_samplesPerLine ) )
			m_samplesPerLine = new IS11172VideoMode_samplesPerLine ( is );
		if ( hasOptionalField ( e_linesPerFrame ) )
			m_linesPerFrame = new IS11172VideoMode_linesPerFrame ( is );
		if ( hasOptionalField ( e_pictureRate ) )
			m_pictureRate = new IS11172VideoMode_pictureRate ( is );
		if ( hasOptionalField ( e_luminanceSampleRate ) )
			m_luminanceSampleRate = new IS11172VideoMode_luminanceSampleRate ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_videoBitRate;
		delete m_vbvBufferSize;
		delete m_samplesPerLine;
		delete m_linesPerFrame;
		delete m_pictureRate;
		delete m_luminanceSampleRate;
		throw;
	}
}

IS11172VideoMode :: IS11172VideoMode ( ) : Asn :: Sequence ( 6, true, 0 ), m_videoBitRate ( 0 ), m_vbvBufferSize ( 0 ), m_samplesPerLine ( 0 ), m_linesPerFrame ( 0 ), m_pictureRate ( 0 ), m_luminanceSampleRate ( 0 ) { }

IS11172VideoMode & IS11172VideoMode :: operator= ( const IS11172VideoMode & s ) {
	Asn :: Sequence :: operator= ( s );
	m_constrainedBitstream = s.m_constrainedBitstream;
	assignCopy ( m_videoBitRate, s.m_videoBitRate );
	assignCopy ( m_vbvBufferSize, s.m_vbvBufferSize );
	assignCopy ( m_samplesPerLine, s.m_samplesPerLine );
	assignCopy ( m_linesPerFrame, s.m_linesPerFrame );
	assignCopy ( m_pictureRate, s.m_pictureRate );
	assignCopy ( m_luminanceSampleRate, s.m_luminanceSampleRate );
	return * this;
}

IS11172VideoMode :: IS11172VideoMode ( const IS11172VideoMode & s ) : Asn :: Sequence ( s ), m_constrainedBitstream ( s.m_constrainedBitstream ), m_videoBitRate ( 0 ), m_vbvBufferSize ( 0 ), m_samplesPerLine ( 0 ), m_linesPerFrame ( 0 ), m_pictureRate ( 0 ), m_luminanceSampleRate ( 0 ) {
	try {
		if ( s.m_videoBitRate )
			m_videoBitRate = new IS11172VideoMode_videoBitRate ( * s.m_videoBitRate );
		if ( s.m_vbvBufferSize )
			m_vbvBufferSize = new IS11172VideoMode_vbvBufferSize ( * s.m_vbvBufferSize );
		if ( s.m_samplesPerLine )
			m_samplesPerLine = new IS11172VideoMode_samplesPerLine ( * s.m_samplesPerLine );
		if ( s.m_linesPerFrame )
			m_linesPerFrame = new IS11172VideoMode_linesPerFrame ( * s.m_linesPerFrame );
		if ( s.m_pictureRate )
			m_pictureRate = new IS11172VideoMode_pictureRate ( * s.m_pictureRate );
		if ( s.m_luminanceSampleRate )
			m_luminanceSampleRate = new IS11172VideoMode_luminanceSampleRate ( * s.m_luminanceSampleRate );
	} catch ( ... ) {
		delete m_videoBitRate;
		delete m_vbvBufferSize;
		delete m_samplesPerLine;
		delete m_linesPerFrame;
		delete m_pictureRate;
		delete m_luminanceSampleRate;
		throw;
	}
}


void IS11172VideoMode :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_videoBitRate:
			assignNew ( m_videoBitRate, new IS11172VideoMode_videoBitRate );
			break;
		case e_vbvBufferSize:
			assignNew ( m_vbvBufferSize, new IS11172VideoMode_vbvBufferSize );
			break;
		case e_samplesPerLine:
			assignNew ( m_samplesPerLine, new IS11172VideoMode_samplesPerLine );
			break;
		case e_linesPerFrame:
			assignNew ( m_linesPerFrame, new IS11172VideoMode_linesPerFrame );
			break;
		case e_pictureRate:
			assignNew ( m_pictureRate, new IS11172VideoMode_pictureRate );
			break;
		case e_luminanceSampleRate:
			assignNew ( m_luminanceSampleRate, new IS11172VideoMode_luminanceSampleRate );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void IS11172VideoMode :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_videoBitRate:
			delete m_videoBitRate;
			m_videoBitRate = 0;
			break;
		case e_vbvBufferSize:
			delete m_vbvBufferSize;
			m_vbvBufferSize = 0;
			break;
		case e_samplesPerLine:
			delete m_samplesPerLine;
			m_samplesPerLine = 0;
			break;
		case e_linesPerFrame:
			delete m_linesPerFrame;
			m_linesPerFrame = 0;
			break;
		case e_pictureRate:
			delete m_pictureRate;
			m_pictureRate = 0;
			break;
		case e_luminanceSampleRate:
			delete m_luminanceSampleRate;
			m_luminanceSampleRate = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void IS11172VideoMode :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_constrainedBitstream.encode ( os );
	if ( hasOptionalField ( e_videoBitRate ) )
		m_videoBitRate -> IS11172VideoMode_videoBitRate :: encode ( os );
	if ( hasOptionalField ( e_vbvBufferSize ) )
		m_vbvBufferSize -> IS11172VideoMode_vbvBufferSize :: encode ( os );
	if ( hasOptionalField ( e_samplesPerLine ) )
		m_samplesPerLine -> IS11172VideoMode_samplesPerLine :: encode ( os );
	if ( hasOptionalField ( e_linesPerFrame ) )
		m_linesPerFrame -> IS11172VideoMode_linesPerFrame :: encode ( os );
	if ( hasOptionalField ( e_pictureRate ) )
		m_pictureRate -> IS11172VideoMode_pictureRate :: encode ( os );
	if ( hasOptionalField ( e_luminanceSampleRate ) )
		m_luminanceSampleRate -> IS11172VideoMode_luminanceSampleRate :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

IS11172VideoMode :: ~IS11172VideoMode ( ) {
	delete m_videoBitRate;
	delete m_vbvBufferSize;
	delete m_samplesPerLine;
	delete m_linesPerFrame;
	delete m_pictureRate;
	delete m_luminanceSampleRate;
}

void IS11172VideoMode :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 23 ) << "constrainedBitstream = " << std :: setprecision ( indent ) << m_constrainedBitstream << '\n';
	if ( hasOptionalField ( e_videoBitRate ) ) {
		os << std :: setw ( indent + 15 ) << "videoBitRate = " << std :: setprecision ( indent );
		m_videoBitRate -> IS11172VideoMode_videoBitRate :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_vbvBufferSize ) ) {
		os << std :: setw ( indent + 16 ) << "vbvBufferSize = " << std :: setprecision ( indent );
		m_vbvBufferSize -> IS11172VideoMode_vbvBufferSize :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_samplesPerLine ) ) {
		os << std :: setw ( indent + 17 ) << "samplesPerLine = " << std :: setprecision ( indent );
		m_samplesPerLine -> IS11172VideoMode_samplesPerLine :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_linesPerFrame ) ) {
		os << std :: setw ( indent + 16 ) << "linesPerFrame = " << std :: setprecision ( indent );
		m_linesPerFrame -> IS11172VideoMode_linesPerFrame :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_pictureRate ) ) {
		os << std :: setw ( indent + 14 ) << "pictureRate = " << std :: setprecision ( indent );
		m_pictureRate -> IS11172VideoMode_pictureRate :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_luminanceSampleRate ) ) {
		os << std :: setw ( indent + 22 ) << "luminanceSampleRate = " << std :: setprecision ( indent );
		m_luminanceSampleRate -> IS11172VideoMode_luminanceSampleRate :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

IS11172VideoMode * IS11172VideoMode :: clone ( ) const {
	return new IS11172VideoMode ( * this );
}

//
// RoundTripDelayRequest
//

RoundTripDelayRequest :: RoundTripDelayRequest ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_sequenceNumber ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

RoundTripDelayRequest :: RoundTripDelayRequest ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void RoundTripDelayRequest :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_sequenceNumber.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void RoundTripDelayRequest :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 17 ) << "sequenceNumber = " << std :: setprecision ( indent ) << m_sequenceNumber << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RoundTripDelayRequest * RoundTripDelayRequest :: clone ( ) const {
	return new RoundTripDelayRequest ( * this );
}

//
// RoundTripDelayResponse
//

RoundTripDelayResponse :: RoundTripDelayResponse ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_sequenceNumber ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

RoundTripDelayResponse :: RoundTripDelayResponse ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void RoundTripDelayResponse :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_sequenceNumber.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void RoundTripDelayResponse :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 17 ) << "sequenceNumber = " << std :: setprecision ( indent ) << m_sequenceNumber << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RoundTripDelayResponse * RoundTripDelayResponse :: clone ( ) const {
	return new RoundTripDelayResponse ( * this );
}

//
// MaintenanceLoopOffCommand
//

MaintenanceLoopOffCommand :: MaintenanceLoopOffCommand ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MaintenanceLoopOffCommand :: MaintenanceLoopOffCommand ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MaintenanceLoopOffCommand :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MaintenanceLoopOffCommand :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MaintenanceLoopOffCommand * MaintenanceLoopOffCommand :: clone ( ) const {
	return new MaintenanceLoopOffCommand ( * this );
}

//
// CommunicationModeRequest
//

CommunicationModeRequest :: CommunicationModeRequest ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

CommunicationModeRequest :: CommunicationModeRequest ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void CommunicationModeRequest :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void CommunicationModeRequest :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

CommunicationModeRequest * CommunicationModeRequest :: clone ( ) const {
	return new CommunicationModeRequest ( * this );
}

//
// CertSelectionCriteria
//

CertSelectionCriteria :: CertSelectionCriteria ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 16 ) { }

CertSelectionCriteria :: CertSelectionCriteria ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 16 ) { }

CertSelectionCriteria :: CertSelectionCriteria ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 16 ) { }


Asn :: Object * CertSelectionCriteria :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * CertSelectionCriteria :: createObject ( Asn :: istream & is ) {
	return new Criteria ( is );
}

Asn :: Object * CertSelectionCriteria :: createObject ( ) {
	return new Criteria ( );
}

Criteria & CertSelectionCriteria :: operator[] ( std :: size_t i ) {
	return dynamic_cast < Criteria & > ( Asn :: Array :: operator[] ( i ) );
}

void CertSelectionCriteria :: push_back ( const Criteria & o ) {
	Asn :: Array :: push_back ( new Criteria ( o ) );
}

const Criteria & CertSelectionCriteria :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const Criteria & > ( Asn :: Array :: operator[] ( i ) );
}

CertSelectionCriteria * CertSelectionCriteria :: clone ( ) const {
	return new CertSelectionCriteria ( * this );
}

//
// McuNumber
//

McuNumber :: McuNumber ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 192 ) { }

McuNumber :: McuNumber ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 192 ) { }

McuNumber * McuNumber :: clone ( ) const {
	return new McuNumber ( * this );
}

//
// TerminalNumber
//

TerminalNumber :: TerminalNumber ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 192 ) { }

TerminalNumber :: TerminalNumber ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 192 ) { }

TerminalNumber * TerminalNumber :: clone ( ) const {
	return new TerminalNumber ( * this );
}

//
// TerminalID
//

TerminalID :: TerminalID ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 1, 128 ) { }

TerminalID :: TerminalID ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 1, 128 ) { }

TerminalID * TerminalID :: clone ( ) const {
	return new TerminalID ( * this );
}

//
// ConferenceID
//

ConferenceID :: ConferenceID ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 1, 32 ) { }

ConferenceID :: ConferenceID ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 1, 32 ) { }

ConferenceID * ConferenceID :: clone ( ) const {
	return new ConferenceID ( * this );
}

//
// Password
//

Password :: Password ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 1, 32 ) { }

Password :: Password ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 1, 32 ) { }

Password * Password :: clone ( ) const {
	return new Password ( * this );
}

//
// RemoteMCRequest
//

RemoteMCRequest :: RemoteMCRequest ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_masterActivate:
		case e_slaveActivate:
		case e_deActivate:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

RemoteMCRequest :: RemoteMCRequest ( ) : Asn :: Choice ( 3, true ) { }

void RemoteMCRequest :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_masterActivate:
		case e_slaveActivate:
		case e_deActivate:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & RemoteMCRequest :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_masterActivate, "masterActivate" },
		{ e_slaveActivate, "slaveActivate" },
		{ e_deActivate, "deActivate" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

RemoteMCRequest * RemoteMCRequest :: clone ( ) const {
	return new RemoteMCRequest ( * this );
}

//
// MaximumBitRate
//

MaximumBitRate :: MaximumBitRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 4294967295U ) { }

MaximumBitRate :: MaximumBitRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 4294967295U ) { }

MaximumBitRate * MaximumBitRate :: clone ( ) const {
	return new MaximumBitRate ( * this );
}

//
// LogicalChannelRateRequest
//

LogicalChannelRateRequest :: LogicalChannelRateRequest ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_sequenceNumber ( is ), m_logicalChannelNumber ( is ), m_maximumBitRate ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

LogicalChannelRateRequest :: LogicalChannelRateRequest ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void LogicalChannelRateRequest :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_sequenceNumber.encode ( os );
	m_logicalChannelNumber.encode ( os );
	m_maximumBitRate.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void LogicalChannelRateRequest :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 17 ) << "sequenceNumber = " << std :: setprecision ( indent ) << m_sequenceNumber << '\n';
	os << std :: setw ( indent + 23 ) << "logicalChannelNumber = " << std :: setprecision ( indent ) << m_logicalChannelNumber << '\n';
	os << std :: setw ( indent + 17 ) << "maximumBitRate = " << std :: setprecision ( indent ) << m_maximumBitRate << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

LogicalChannelRateRequest * LogicalChannelRateRequest :: clone ( ) const {
	return new LogicalChannelRateRequest ( * this );
}

//
// LogicalChannelRateAcknowledge
//

LogicalChannelRateAcknowledge :: LogicalChannelRateAcknowledge ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_sequenceNumber ( is ), m_logicalChannelNumber ( is ), m_maximumBitRate ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

LogicalChannelRateAcknowledge :: LogicalChannelRateAcknowledge ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void LogicalChannelRateAcknowledge :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_sequenceNumber.encode ( os );
	m_logicalChannelNumber.encode ( os );
	m_maximumBitRate.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void LogicalChannelRateAcknowledge :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 17 ) << "sequenceNumber = " << std :: setprecision ( indent ) << m_sequenceNumber << '\n';
	os << std :: setw ( indent + 23 ) << "logicalChannelNumber = " << std :: setprecision ( indent ) << m_logicalChannelNumber << '\n';
	os << std :: setw ( indent + 17 ) << "maximumBitRate = " << std :: setprecision ( indent ) << m_maximumBitRate << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

LogicalChannelRateAcknowledge * LogicalChannelRateAcknowledge :: clone ( ) const {
	return new LogicalChannelRateAcknowledge ( * this );
}

//
// LogicalChannelRateRejectReason
//

LogicalChannelRateRejectReason :: LogicalChannelRateRejectReason ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_undefinedReason:
		case e_insufficientResources:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

LogicalChannelRateRejectReason :: LogicalChannelRateRejectReason ( ) : Asn :: Choice ( 2, true ) { }

void LogicalChannelRateRejectReason :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_undefinedReason:
		case e_insufficientResources:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & LogicalChannelRateRejectReason :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_undefinedReason, "undefinedReason" },
		{ e_insufficientResources, "insufficientResources" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

LogicalChannelRateRejectReason * LogicalChannelRateRejectReason :: clone ( ) const {
	return new LogicalChannelRateRejectReason ( * this );
}

//
// LogicalChannelRateRelease
//

LogicalChannelRateRelease :: LogicalChannelRateRelease ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

LogicalChannelRateRelease :: LogicalChannelRateRelease ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void LogicalChannelRateRelease :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void LogicalChannelRateRelease :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

LogicalChannelRateRelease * LogicalChannelRateRelease :: clone ( ) const {
	return new LogicalChannelRateRelease ( * this );
}

//
// EncryptionUpdateDirection
//

EncryptionUpdateDirection :: EncryptionUpdateDirection ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_masterToSlave:
		case e_slaveToMaster:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

EncryptionUpdateDirection :: EncryptionUpdateDirection ( ) : Asn :: Choice ( 2, true ) { }

void EncryptionUpdateDirection :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_masterToSlave:
		case e_slaveToMaster:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & EncryptionUpdateDirection :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_masterToSlave, "masterToSlave" },
		{ e_slaveToMaster, "slaveToMaster" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

EncryptionUpdateDirection * EncryptionUpdateDirection :: clone ( ) const {
	return new EncryptionUpdateDirection ( * this );
}

//
// KeyProtectionMethod
//

KeyProtectionMethod :: KeyProtectionMethod ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_secureChannel ( is ), m_sharedSecret ( is ), m_certProtectedKey ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

KeyProtectionMethod :: KeyProtectionMethod ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void KeyProtectionMethod :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_secureChannel.encode ( os );
	m_sharedSecret.encode ( os );
	m_certProtectedKey.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void KeyProtectionMethod :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "secureChannel = " << std :: setprecision ( indent ) << m_secureChannel << '\n';
	os << std :: setw ( indent + 15 ) << "sharedSecret = " << std :: setprecision ( indent ) << m_sharedSecret << '\n';
	os << std :: setw ( indent + 19 ) << "certProtectedKey = " << std :: setprecision ( indent ) << m_certProtectedKey << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

KeyProtectionMethod * KeyProtectionMethod :: clone ( ) const {
	return new KeyProtectionMethod ( * this );
}

//
// EncryptionUpdateRequest
//

EncryptionUpdateRequest :: EncryptionUpdateRequest ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 1 ), m_keyProtectionMethod ( 0 ), m_synchFlag ( 0 ) {
	try {
		if ( hasOptionalField ( e_keyProtectionMethod ) )
			m_keyProtectionMethod = new KeyProtectionMethod ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_synchFlag ) )
				m_synchFlag = new EncryptionUpdateRequest_synchFlag ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_keyProtectionMethod;
		delete m_synchFlag;
		throw;
	}
}

EncryptionUpdateRequest :: EncryptionUpdateRequest ( ) : Asn :: Sequence ( 1, true, 1 ), m_keyProtectionMethod ( 0 ), m_synchFlag ( 0 ) { }

EncryptionUpdateRequest & EncryptionUpdateRequest :: operator= ( const EncryptionUpdateRequest & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_keyProtectionMethod, s.m_keyProtectionMethod );
	assignCopy ( m_synchFlag, s.m_synchFlag );
	return * this;
}

EncryptionUpdateRequest :: EncryptionUpdateRequest ( const EncryptionUpdateRequest & s ) : Asn :: Sequence ( s ), m_keyProtectionMethod ( 0 ), m_synchFlag ( 0 ) {
	try {
		if ( s.m_keyProtectionMethod )
			m_keyProtectionMethod = new KeyProtectionMethod ( * s.m_keyProtectionMethod );
		if ( s.m_synchFlag )
			m_synchFlag = new EncryptionUpdateRequest_synchFlag ( * s.m_synchFlag );
	} catch ( ... ) {
		delete m_keyProtectionMethod;
		delete m_synchFlag;
		throw;
	}
}


void EncryptionUpdateRequest :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_keyProtectionMethod:
			assignNew ( m_keyProtectionMethod, new KeyProtectionMethod );
			break;
		case e_synchFlag:
			assignNew ( m_synchFlag, new EncryptionUpdateRequest_synchFlag );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void EncryptionUpdateRequest :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_keyProtectionMethod:
			delete m_keyProtectionMethod;
			m_keyProtectionMethod = 0;
			break;
		case e_synchFlag:
			delete m_synchFlag;
			m_synchFlag = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void EncryptionUpdateRequest :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_keyProtectionMethod ) )
		m_keyProtectionMethod -> KeyProtectionMethod :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_synchFlag, m_synchFlag );
		unknownExtensionsEncode ( os );
	}
}

EncryptionUpdateRequest :: ~EncryptionUpdateRequest ( ) {
	delete m_keyProtectionMethod;
	delete m_synchFlag;
}

void EncryptionUpdateRequest :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_keyProtectionMethod ) ) {
		os << std :: setw ( indent + 22 ) << "keyProtectionMethod = " << std :: setprecision ( indent );
		m_keyProtectionMethod -> KeyProtectionMethod :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_synchFlag ) ) {
		os << std :: setw ( indent + 12 ) << "synchFlag = " << std :: setprecision ( indent );
		m_synchFlag -> EncryptionUpdateRequest_synchFlag :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

EncryptionUpdateRequest * EncryptionUpdateRequest :: clone ( ) const {
	return new EncryptionUpdateRequest ( * this );
}

//
// IV8
//

IV8 :: IV8 ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 8, 8 ) { }

IV8 :: IV8 ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 8, 8 ) { }

IV8 * IV8 :: clone ( ) const {
	return new IV8 ( * this );
}

//
// IV16
//

IV16 :: IV16 ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 16, 16 ) { }

IV16 :: IV16 ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 16, 16 ) { }

IV16 * IV16 :: clone ( ) const {
	return new IV16 ( * this );
}

//
// Params
//

Params :: Params ( Asn :: istream & is ) : Asn :: Sequence ( is, 3, true, 0 ), m_iv8 ( 0 ), m_iv16 ( 0 ), m_iv ( 0 ) {
	try {
		if ( hasOptionalField ( e_iv8 ) )
			m_iv8 = new IV8 ( is );
		if ( hasOptionalField ( e_iv16 ) )
			m_iv16 = new IV16 ( is );
		if ( hasOptionalField ( e_iv ) )
			m_iv = new Asn :: OctetString ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_iv8;
		delete m_iv16;
		delete m_iv;
		throw;
	}
}

Params :: Params ( ) : Asn :: Sequence ( 3, true, 0 ), m_iv8 ( 0 ), m_iv16 ( 0 ), m_iv ( 0 ) { }

Params & Params :: operator= ( const Params & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_iv8, s.m_iv8 );
	assignCopy ( m_iv16, s.m_iv16 );
	assignCopy ( m_iv, s.m_iv );
	return * this;
}

Params :: Params ( const Params & s ) : Asn :: Sequence ( s ), m_iv8 ( 0 ), m_iv16 ( 0 ), m_iv ( 0 ) {
	try {
		if ( s.m_iv8 )
			m_iv8 = new IV8 ( * s.m_iv8 );
		if ( s.m_iv16 )
			m_iv16 = new IV16 ( * s.m_iv16 );
		if ( s.m_iv )
			m_iv = new Asn :: OctetString ( * s.m_iv );
	} catch ( ... ) {
		delete m_iv8;
		delete m_iv16;
		delete m_iv;
		throw;
	}
}


void Params :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_iv8:
			assignNew ( m_iv8, new IV8 );
			break;
		case e_iv16:
			assignNew ( m_iv16, new IV16 );
			break;
		case e_iv:
			assignNew ( m_iv, new Asn :: OctetString );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void Params :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_iv8:
			delete m_iv8;
			m_iv8 = 0;
			break;
		case e_iv16:
			delete m_iv16;
			m_iv16 = 0;
			break;
		case e_iv:
			delete m_iv;
			m_iv = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void Params :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_iv8 ) )
		m_iv8 -> IV8 :: encode ( os );
	if ( hasOptionalField ( e_iv16 ) )
		m_iv16 -> IV16 :: encode ( os );
	if ( hasOptionalField ( e_iv ) )
		m_iv -> Asn :: OctetString :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

Params :: ~Params ( ) {
	delete m_iv8;
	delete m_iv16;
	delete m_iv;
}

void Params :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_iv8 ) ) {
		os << std :: setw ( indent + 6 ) << "iv8 = " << std :: setprecision ( indent );
		m_iv8 -> IV8 :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_iv16 ) ) {
		os << std :: setw ( indent + 7 ) << "iv16 = " << std :: setprecision ( indent );
		m_iv16 -> IV16 :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_iv ) ) {
		os << std :: setw ( indent + 5 ) << "iv = " << std :: setprecision ( indent );
		m_iv -> Asn :: OctetString :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

Params * Params :: clone ( ) const {
	return new Params ( * this );
}

//
// GenericMessage_subMessageIdentifier
//

GenericMessage_subMessageIdentifier :: GenericMessage_subMessageIdentifier ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 127 ) { }

GenericMessage_subMessageIdentifier :: GenericMessage_subMessageIdentifier ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 127 ) { }

GenericMessage_subMessageIdentifier * GenericMessage_subMessageIdentifier :: clone ( ) const {
	return new GenericMessage_subMessageIdentifier ( * this );
}

//
// ArrayOf_GenericParameter
//

ArrayOf_GenericParameter :: ArrayOf_GenericParameter ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_GenericParameter :: ArrayOf_GenericParameter ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_GenericParameter :: ArrayOf_GenericParameter ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_GenericParameter :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_GenericParameter :: createObject ( Asn :: istream & is ) {
	return new GenericParameter ( is );
}

Asn :: Object * ArrayOf_GenericParameter :: createObject ( ) {
	return new GenericParameter ( );
}

GenericParameter & ArrayOf_GenericParameter :: operator[] ( std :: size_t i ) {
	return dynamic_cast < GenericParameter & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_GenericParameter :: push_back ( const GenericParameter & o ) {
	Asn :: Array :: push_back ( new GenericParameter ( o ) );
}

const GenericParameter & ArrayOf_GenericParameter :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const GenericParameter & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_GenericParameter * ArrayOf_GenericParameter :: clone ( ) const {
	return new ArrayOf_GenericParameter ( * this );
}

//
// MasterSlaveDetermination_terminalType
//

MasterSlaveDetermination_terminalType :: MasterSlaveDetermination_terminalType ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 255 ) { }

MasterSlaveDetermination_terminalType :: MasterSlaveDetermination_terminalType ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 255 ) { }

MasterSlaveDetermination_terminalType * MasterSlaveDetermination_terminalType :: clone ( ) const {
	return new MasterSlaveDetermination_terminalType ( * this );
}

//
// MasterSlaveDetermination_statusDeterminationNumber
//

MasterSlaveDetermination_statusDeterminationNumber :: MasterSlaveDetermination_statusDeterminationNumber ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 16777215 ) { }

MasterSlaveDetermination_statusDeterminationNumber :: MasterSlaveDetermination_statusDeterminationNumber ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 16777215 ) { }

MasterSlaveDetermination_statusDeterminationNumber * MasterSlaveDetermination_statusDeterminationNumber :: clone ( ) const {
	return new MasterSlaveDetermination_statusDeterminationNumber ( * this );
}

//
// MasterSlaveDeterminationAck_decision
//

MasterSlaveDeterminationAck_decision :: MasterSlaveDeterminationAck_decision ( Asn :: istream & is ) : Asn :: Choice ( is, 2, false ) {
	switch ( tag ) {
		case e_master:
		case e_slave:
			choice = new Asn :: Null ( is );
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
}

MasterSlaveDeterminationAck_decision :: MasterSlaveDeterminationAck_decision ( ) : Asn :: Choice ( 2, false ) { }

void MasterSlaveDeterminationAck_decision :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_master:
		case e_slave:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & MasterSlaveDeterminationAck_decision :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_master, "master" },
		{ e_slave, "slave" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

MasterSlaveDeterminationAck_decision * MasterSlaveDeterminationAck_decision :: clone ( ) const {
	return new MasterSlaveDeterminationAck_decision ( * this );
}

//
// MasterSlaveDeterminationReject_cause
//

MasterSlaveDeterminationReject_cause :: MasterSlaveDeterminationReject_cause ( Asn :: istream & is ) : Asn :: Choice ( is, 1, true ) {
	switch ( tag ) {
		case e_identicalNumbers:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

MasterSlaveDeterminationReject_cause :: MasterSlaveDeterminationReject_cause ( ) : Asn :: Choice ( 1, true ) { }

void MasterSlaveDeterminationReject_cause :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_identicalNumbers:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & MasterSlaveDeterminationReject_cause :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_identicalNumbers, "identicalNumbers" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

MasterSlaveDeterminationReject_cause * MasterSlaveDeterminationReject_cause :: clone ( ) const {
	return new MasterSlaveDeterminationReject_cause ( * this );
}

//
// TerminalCapabilitySet_capabilityTable
//

TerminalCapabilitySet_capabilityTable :: TerminalCapabilitySet_capabilityTable ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 256 ) { }

TerminalCapabilitySet_capabilityTable :: TerminalCapabilitySet_capabilityTable ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 256 ) { }

TerminalCapabilitySet_capabilityTable :: TerminalCapabilitySet_capabilityTable ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 256 ) { }


Asn :: Object * TerminalCapabilitySet_capabilityTable :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * TerminalCapabilitySet_capabilityTable :: createObject ( Asn :: istream & is ) {
	return new CapabilityTableEntry ( is );
}

Asn :: Object * TerminalCapabilitySet_capabilityTable :: createObject ( ) {
	return new CapabilityTableEntry ( );
}

CapabilityTableEntry & TerminalCapabilitySet_capabilityTable :: operator[] ( std :: size_t i ) {
	return dynamic_cast < CapabilityTableEntry & > ( Asn :: Array :: operator[] ( i ) );
}

void TerminalCapabilitySet_capabilityTable :: push_back ( const CapabilityTableEntry & o ) {
	Asn :: Array :: push_back ( new CapabilityTableEntry ( o ) );
}

const CapabilityTableEntry & TerminalCapabilitySet_capabilityTable :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const CapabilityTableEntry & > ( Asn :: Array :: operator[] ( i ) );
}

TerminalCapabilitySet_capabilityTable * TerminalCapabilitySet_capabilityTable :: clone ( ) const {
	return new TerminalCapabilitySet_capabilityTable ( * this );
}

//
// TerminalCapabilitySet_capabilityDescriptors
//

TerminalCapabilitySet_capabilityDescriptors :: TerminalCapabilitySet_capabilityDescriptors ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 256 ) { }

TerminalCapabilitySet_capabilityDescriptors :: TerminalCapabilitySet_capabilityDescriptors ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 256 ) { }

TerminalCapabilitySet_capabilityDescriptors :: TerminalCapabilitySet_capabilityDescriptors ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 256 ) { }


Asn :: Object * TerminalCapabilitySet_capabilityDescriptors :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * TerminalCapabilitySet_capabilityDescriptors :: createObject ( Asn :: istream & is ) {
	return new CapabilityDescriptor ( is );
}

Asn :: Object * TerminalCapabilitySet_capabilityDescriptors :: createObject ( ) {
	return new CapabilityDescriptor ( );
}

CapabilityDescriptor & TerminalCapabilitySet_capabilityDescriptors :: operator[] ( std :: size_t i ) {
	return dynamic_cast < CapabilityDescriptor & > ( Asn :: Array :: operator[] ( i ) );
}

void TerminalCapabilitySet_capabilityDescriptors :: push_back ( const CapabilityDescriptor & o ) {
	Asn :: Array :: push_back ( new CapabilityDescriptor ( o ) );
}

const CapabilityDescriptor & TerminalCapabilitySet_capabilityDescriptors :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const CapabilityDescriptor & > ( Asn :: Array :: operator[] ( i ) );
}

TerminalCapabilitySet_capabilityDescriptors * TerminalCapabilitySet_capabilityDescriptors :: clone ( ) const {
	return new TerminalCapabilitySet_capabilityDescriptors ( * this );
}

//
// ArrayOf_GenericInformation
//

ArrayOf_GenericInformation :: ArrayOf_GenericInformation ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_GenericInformation :: ArrayOf_GenericInformation ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_GenericInformation :: ArrayOf_GenericInformation ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_GenericInformation :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_GenericInformation :: createObject ( Asn :: istream & is ) {
	return new GenericInformation ( is );
}

Asn :: Object * ArrayOf_GenericInformation :: createObject ( ) {
	return new GenericInformation ( );
}

GenericInformation & ArrayOf_GenericInformation :: operator[] ( std :: size_t i ) {
	return dynamic_cast < GenericInformation & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_GenericInformation :: push_back ( const GenericInformation & o ) {
	Asn :: Array :: push_back ( new GenericInformation ( o ) );
}

const GenericInformation & ArrayOf_GenericInformation :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const GenericInformation & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_GenericInformation * ArrayOf_GenericInformation :: clone ( ) const {
	return new ArrayOf_GenericInformation ( * this );
}

//
// CapabilityDescriptor_simultaneousCapabilities
//

CapabilityDescriptor_simultaneousCapabilities :: CapabilityDescriptor_simultaneousCapabilities ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 256 ) { }

CapabilityDescriptor_simultaneousCapabilities :: CapabilityDescriptor_simultaneousCapabilities ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 256 ) { }

CapabilityDescriptor_simultaneousCapabilities :: CapabilityDescriptor_simultaneousCapabilities ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 256 ) { }


Asn :: Object * CapabilityDescriptor_simultaneousCapabilities :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * CapabilityDescriptor_simultaneousCapabilities :: createObject ( Asn :: istream & is ) {
	return new AlternativeCapabilitySet ( is );
}

Asn :: Object * CapabilityDescriptor_simultaneousCapabilities :: createObject ( ) {
	return new AlternativeCapabilitySet ( );
}

AlternativeCapabilitySet & CapabilityDescriptor_simultaneousCapabilities :: operator[] ( std :: size_t i ) {
	return dynamic_cast < AlternativeCapabilitySet & > ( Asn :: Array :: operator[] ( i ) );
}

void CapabilityDescriptor_simultaneousCapabilities :: push_back ( const AlternativeCapabilitySet & o ) {
	Asn :: Array :: push_back ( new AlternativeCapabilitySet ( o ) );
}

const AlternativeCapabilitySet & CapabilityDescriptor_simultaneousCapabilities :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const AlternativeCapabilitySet & > ( Asn :: Array :: operator[] ( i ) );
}

CapabilityDescriptor_simultaneousCapabilities * CapabilityDescriptor_simultaneousCapabilities :: clone ( ) const {
	return new CapabilityDescriptor_simultaneousCapabilities ( * this );
}

//
// Capability_maxPendingReplacementFor
//

Capability_maxPendingReplacementFor :: Capability_maxPendingReplacementFor ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 255 ) { }

Capability_maxPendingReplacementFor :: Capability_maxPendingReplacementFor ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 255 ) { }

Capability_maxPendingReplacementFor * Capability_maxPendingReplacementFor :: clone ( ) const {
	return new Capability_maxPendingReplacementFor ( * this );
}

//
// H222Capability_numberOfVCs
//

H222Capability_numberOfVCs :: H222Capability_numberOfVCs ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 256 ) { }

H222Capability_numberOfVCs :: H222Capability_numberOfVCs ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 256 ) { }

H222Capability_numberOfVCs * H222Capability_numberOfVCs :: clone ( ) const {
	return new H222Capability_numberOfVCs ( * this );
}

//
// ArrayOf_VCCapability
//

ArrayOf_VCCapability :: ArrayOf_VCCapability ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_VCCapability :: ArrayOf_VCCapability ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_VCCapability :: ArrayOf_VCCapability ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_VCCapability :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_VCCapability :: createObject ( Asn :: istream & is ) {
	return new VCCapability ( is );
}

Asn :: Object * ArrayOf_VCCapability :: createObject ( ) {
	return new VCCapability ( );
}

VCCapability & ArrayOf_VCCapability :: operator[] ( std :: size_t i ) {
	return dynamic_cast < VCCapability & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_VCCapability :: push_back ( const VCCapability & o ) {
	Asn :: Array :: push_back ( new VCCapability ( o ) );
}

const VCCapability & ArrayOf_VCCapability :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const VCCapability & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_VCCapability * ArrayOf_VCCapability :: clone ( ) const {
	return new ArrayOf_VCCapability ( * this );
}

//
// VCCapability_aal1
//

VCCapability_aal1 :: VCCapability_aal1 ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_nullClockRecovery ( is ), m_srtsClockRecovery ( is ), m_adaptiveClockRecovery ( is ), m_nullErrorCorrection ( is ), m_longInterleaver ( is ), m_shortInterleaver ( is ), m_errorCorrectionOnly ( is ), m_structuredDataTransfer ( is ), m_partiallyFilledCells ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

VCCapability_aal1 :: VCCapability_aal1 ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void VCCapability_aal1 :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_nullClockRecovery.encode ( os );
	m_srtsClockRecovery.encode ( os );
	m_adaptiveClockRecovery.encode ( os );
	m_nullErrorCorrection.encode ( os );
	m_longInterleaver.encode ( os );
	m_shortInterleaver.encode ( os );
	m_errorCorrectionOnly.encode ( os );
	m_structuredDataTransfer.encode ( os );
	m_partiallyFilledCells.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void VCCapability_aal1 :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 20 ) << "nullClockRecovery = " << std :: setprecision ( indent ) << m_nullClockRecovery << '\n';
	os << std :: setw ( indent + 20 ) << "srtsClockRecovery = " << std :: setprecision ( indent ) << m_srtsClockRecovery << '\n';
	os << std :: setw ( indent + 24 ) << "adaptiveClockRecovery = " << std :: setprecision ( indent ) << m_adaptiveClockRecovery << '\n';
	os << std :: setw ( indent + 22 ) << "nullErrorCorrection = " << std :: setprecision ( indent ) << m_nullErrorCorrection << '\n';
	os << std :: setw ( indent + 18 ) << "longInterleaver = " << std :: setprecision ( indent ) << m_longInterleaver << '\n';
	os << std :: setw ( indent + 19 ) << "shortInterleaver = " << std :: setprecision ( indent ) << m_shortInterleaver << '\n';
	os << std :: setw ( indent + 22 ) << "errorCorrectionOnly = " << std :: setprecision ( indent ) << m_errorCorrectionOnly << '\n';
	os << std :: setw ( indent + 25 ) << "structuredDataTransfer = " << std :: setprecision ( indent ) << m_structuredDataTransfer << '\n';
	os << std :: setw ( indent + 23 ) << "partiallyFilledCells = " << std :: setprecision ( indent ) << m_partiallyFilledCells << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

VCCapability_aal1 * VCCapability_aal1 :: clone ( ) const {
	return new VCCapability_aal1 ( * this );
}

//
// H223Capability_maximumAl2SDUSize
//

H223Capability_maximumAl2SDUSize :: H223Capability_maximumAl2SDUSize ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

H223Capability_maximumAl2SDUSize :: H223Capability_maximumAl2SDUSize ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

H223Capability_maximumAl2SDUSize * H223Capability_maximumAl2SDUSize :: clone ( ) const {
	return new H223Capability_maximumAl2SDUSize ( * this );
}

//
// H223Capability_maximumAl3SDUSize
//

H223Capability_maximumAl3SDUSize :: H223Capability_maximumAl3SDUSize ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

H223Capability_maximumAl3SDUSize :: H223Capability_maximumAl3SDUSize ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

H223Capability_maximumAl3SDUSize * H223Capability_maximumAl3SDUSize :: clone ( ) const {
	return new H223Capability_maximumAl3SDUSize ( * this );
}

//
// H223Capability_maximumDelayJitter
//

H223Capability_maximumDelayJitter :: H223Capability_maximumDelayJitter ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 1023 ) { }

H223Capability_maximumDelayJitter :: H223Capability_maximumDelayJitter ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 1023 ) { }

H223Capability_maximumDelayJitter * H223Capability_maximumDelayJitter :: clone ( ) const {
	return new H223Capability_maximumDelayJitter ( * this );
}

//
// H223Capability_mobileOperationTransmitCapability
//

H223Capability_mobileOperationTransmitCapability :: H223Capability_mobileOperationTransmitCapability ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_modeChangeCapability ( is ), m_h223AnnexA ( is ), m_h223AnnexADoubleFlag ( is ), m_h223AnnexB ( is ), m_h223AnnexBwithHeader ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

H223Capability_mobileOperationTransmitCapability :: H223Capability_mobileOperationTransmitCapability ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void H223Capability_mobileOperationTransmitCapability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_modeChangeCapability.encode ( os );
	m_h223AnnexA.encode ( os );
	m_h223AnnexADoubleFlag.encode ( os );
	m_h223AnnexB.encode ( os );
	m_h223AnnexBwithHeader.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void H223Capability_mobileOperationTransmitCapability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 23 ) << "modeChangeCapability = " << std :: setprecision ( indent ) << m_modeChangeCapability << '\n';
	os << std :: setw ( indent + 13 ) << "h223AnnexA = " << std :: setprecision ( indent ) << m_h223AnnexA << '\n';
	os << std :: setw ( indent + 23 ) << "h223AnnexADoubleFlag = " << std :: setprecision ( indent ) << m_h223AnnexADoubleFlag << '\n';
	os << std :: setw ( indent + 13 ) << "h223AnnexB = " << std :: setprecision ( indent ) << m_h223AnnexB << '\n';
	os << std :: setw ( indent + 23 ) << "h223AnnexBwithHeader = " << std :: setprecision ( indent ) << m_h223AnnexBwithHeader << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H223Capability_mobileOperationTransmitCapability * H223Capability_mobileOperationTransmitCapability :: clone ( ) const {
	return new H223Capability_mobileOperationTransmitCapability ( * this );
}

//
// H223Capability_bitRate
//

H223Capability_bitRate :: H223Capability_bitRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 19200 ) { }

H223Capability_bitRate :: H223Capability_bitRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 19200 ) { }

H223Capability_bitRate * H223Capability_bitRate :: clone ( ) const {
	return new H223Capability_bitRate ( * this );
}

//
// H223AnnexCCapability_maximumAL1MPDUSize
//

H223AnnexCCapability_maximumAL1MPDUSize :: H223AnnexCCapability_maximumAL1MPDUSize ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

H223AnnexCCapability_maximumAL1MPDUSize :: H223AnnexCCapability_maximumAL1MPDUSize ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

H223AnnexCCapability_maximumAL1MPDUSize * H223AnnexCCapability_maximumAL1MPDUSize :: clone ( ) const {
	return new H223AnnexCCapability_maximumAL1MPDUSize ( * this );
}

//
// H223AnnexCCapability_maximumAL2MSDUSize
//

H223AnnexCCapability_maximumAL2MSDUSize :: H223AnnexCCapability_maximumAL2MSDUSize ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

H223AnnexCCapability_maximumAL2MSDUSize :: H223AnnexCCapability_maximumAL2MSDUSize ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

H223AnnexCCapability_maximumAL2MSDUSize * H223AnnexCCapability_maximumAL2MSDUSize :: clone ( ) const {
	return new H223AnnexCCapability_maximumAL2MSDUSize ( * this );
}

//
// H223AnnexCCapability_maximumAL3MSDUSize
//

H223AnnexCCapability_maximumAL3MSDUSize :: H223AnnexCCapability_maximumAL3MSDUSize ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

H223AnnexCCapability_maximumAL3MSDUSize :: H223AnnexCCapability_maximumAL3MSDUSize ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

H223AnnexCCapability_maximumAL3MSDUSize * H223AnnexCCapability_maximumAL3MSDUSize :: clone ( ) const {
	return new H223AnnexCCapability_maximumAL3MSDUSize ( * this );
}

//
// V76Capability_numOfDLCS
//

V76Capability_numOfDLCS :: V76Capability_numOfDLCS ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 2, 8191 ) { }

V76Capability_numOfDLCS :: V76Capability_numOfDLCS ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 2, 8191 ) { }

V76Capability_numOfDLCS * V76Capability_numOfDLCS :: clone ( ) const {
	return new V76Capability_numOfDLCS ( * this );
}

//
// V76Capability_n401Capability
//

V76Capability_n401Capability :: V76Capability_n401Capability ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 4095 ) { }

V76Capability_n401Capability :: V76Capability_n401Capability ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 4095 ) { }

V76Capability_n401Capability * V76Capability_n401Capability :: clone ( ) const {
	return new V76Capability_n401Capability ( * this );
}

//
// V76Capability_maxWindowSizeCapability
//

V76Capability_maxWindowSizeCapability :: V76Capability_maxWindowSizeCapability ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 127 ) { }

V76Capability_maxWindowSizeCapability :: V76Capability_maxWindowSizeCapability ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 127 ) { }

V76Capability_maxWindowSizeCapability * V76Capability_maxWindowSizeCapability :: clone ( ) const {
	return new V76Capability_maxWindowSizeCapability ( * this );
}

//
// H2250Capability_maximumAudioDelayJitter
//

H2250Capability_maximumAudioDelayJitter :: H2250Capability_maximumAudioDelayJitter ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 1023 ) { }

H2250Capability_maximumAudioDelayJitter :: H2250Capability_maximumAudioDelayJitter ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 1023 ) { }

H2250Capability_maximumAudioDelayJitter * H2250Capability_maximumAudioDelayJitter :: clone ( ) const {
	return new H2250Capability_maximumAudioDelayJitter ( * this );
}

//
// H2250Capability_mcCapability
//

H2250Capability_mcCapability :: H2250Capability_mcCapability ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_centralizedConferenceMC ( is ), m_decentralizedConferenceMC ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

H2250Capability_mcCapability :: H2250Capability_mcCapability ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void H2250Capability_mcCapability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_centralizedConferenceMC.encode ( os );
	m_decentralizedConferenceMC.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void H2250Capability_mcCapability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 26 ) << "centralizedConferenceMC = " << std :: setprecision ( indent ) << m_centralizedConferenceMC << '\n';
	os << std :: setw ( indent + 28 ) << "decentralizedConferenceMC = " << std :: setprecision ( indent ) << m_decentralizedConferenceMC << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H2250Capability_mcCapability * H2250Capability_mcCapability :: clone ( ) const {
	return new H2250Capability_mcCapability ( * this );
}

//
// H2250Capability_redundancyEncodingCapability
//

H2250Capability_redundancyEncodingCapability :: H2250Capability_redundancyEncodingCapability ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 256 ) { }

H2250Capability_redundancyEncodingCapability :: H2250Capability_redundancyEncodingCapability ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 256 ) { }

H2250Capability_redundancyEncodingCapability :: H2250Capability_redundancyEncodingCapability ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 256 ) { }


Asn :: Object * H2250Capability_redundancyEncodingCapability :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * H2250Capability_redundancyEncodingCapability :: createObject ( Asn :: istream & is ) {
	return new RedundancyEncodingCapability ( is );
}

Asn :: Object * H2250Capability_redundancyEncodingCapability :: createObject ( ) {
	return new RedundancyEncodingCapability ( );
}

RedundancyEncodingCapability & H2250Capability_redundancyEncodingCapability :: operator[] ( std :: size_t i ) {
	return dynamic_cast < RedundancyEncodingCapability & > ( Asn :: Array :: operator[] ( i ) );
}

void H2250Capability_redundancyEncodingCapability :: push_back ( const RedundancyEncodingCapability & o ) {
	Asn :: Array :: push_back ( new RedundancyEncodingCapability ( o ) );
}

const RedundancyEncodingCapability & H2250Capability_redundancyEncodingCapability :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const RedundancyEncodingCapability & > ( Asn :: Array :: operator[] ( i ) );
}

H2250Capability_redundancyEncodingCapability * H2250Capability_redundancyEncodingCapability :: clone ( ) const {
	return new H2250Capability_redundancyEncodingCapability ( * this );
}

//
// MediaPacketizationCapability_rtpPayloadType
//

MediaPacketizationCapability_rtpPayloadType :: MediaPacketizationCapability_rtpPayloadType ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 256 ) { }

MediaPacketizationCapability_rtpPayloadType :: MediaPacketizationCapability_rtpPayloadType ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 256 ) { }

MediaPacketizationCapability_rtpPayloadType :: MediaPacketizationCapability_rtpPayloadType ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 256 ) { }


Asn :: Object * MediaPacketizationCapability_rtpPayloadType :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * MediaPacketizationCapability_rtpPayloadType :: createObject ( Asn :: istream & is ) {
	return new RTPPayloadType ( is );
}

Asn :: Object * MediaPacketizationCapability_rtpPayloadType :: createObject ( ) {
	return new RTPPayloadType ( );
}

RTPPayloadType & MediaPacketizationCapability_rtpPayloadType :: operator[] ( std :: size_t i ) {
	return dynamic_cast < RTPPayloadType & > ( Asn :: Array :: operator[] ( i ) );
}

void MediaPacketizationCapability_rtpPayloadType :: push_back ( const RTPPayloadType & o ) {
	Asn :: Array :: push_back ( new RTPPayloadType ( o ) );
}

const RTPPayloadType & MediaPacketizationCapability_rtpPayloadType :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const RTPPayloadType & > ( Asn :: Array :: operator[] ( i ) );
}

MediaPacketizationCapability_rtpPayloadType * MediaPacketizationCapability_rtpPayloadType :: clone ( ) const {
	return new MediaPacketizationCapability_rtpPayloadType ( * this );
}

//
// RSVPParameters_tokenRate
//

RSVPParameters_tokenRate :: RSVPParameters_tokenRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 4294967295U ) { }

RSVPParameters_tokenRate :: RSVPParameters_tokenRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 4294967295U ) { }

RSVPParameters_tokenRate * RSVPParameters_tokenRate :: clone ( ) const {
	return new RSVPParameters_tokenRate ( * this );
}

//
// RSVPParameters_bucketSize
//

RSVPParameters_bucketSize :: RSVPParameters_bucketSize ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 4294967295U ) { }

RSVPParameters_bucketSize :: RSVPParameters_bucketSize ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 4294967295U ) { }

RSVPParameters_bucketSize * RSVPParameters_bucketSize :: clone ( ) const {
	return new RSVPParameters_bucketSize ( * this );
}

//
// RSVPParameters_peakRate
//

RSVPParameters_peakRate :: RSVPParameters_peakRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 4294967295U ) { }

RSVPParameters_peakRate :: RSVPParameters_peakRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 4294967295U ) { }

RSVPParameters_peakRate * RSVPParameters_peakRate :: clone ( ) const {
	return new RSVPParameters_peakRate ( * this );
}

//
// RSVPParameters_minPoliced
//

RSVPParameters_minPoliced :: RSVPParameters_minPoliced ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 4294967295U ) { }

RSVPParameters_minPoliced :: RSVPParameters_minPoliced ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 4294967295U ) { }

RSVPParameters_minPoliced * RSVPParameters_minPoliced :: clone ( ) const {
	return new RSVPParameters_minPoliced ( * this );
}

//
// RSVPParameters_maxPktSize
//

RSVPParameters_maxPktSize :: RSVPParameters_maxPktSize ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 4294967295U ) { }

RSVPParameters_maxPktSize :: RSVPParameters_maxPktSize ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 4294967295U ) { }

RSVPParameters_maxPktSize * RSVPParameters_maxPktSize :: clone ( ) const {
	return new RSVPParameters_maxPktSize ( * this );
}

//
// ATMParameters_maxNTUSize
//

ATMParameters_maxNTUSize :: ATMParameters_maxNTUSize ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

ATMParameters_maxNTUSize :: ATMParameters_maxNTUSize ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

ATMParameters_maxNTUSize * ATMParameters_maxNTUSize :: clone ( ) const {
	return new ATMParameters_maxNTUSize ( * this );
}

//
// GenericTransportParameters_averageRate
//

GenericTransportParameters_averageRate :: GenericTransportParameters_averageRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 4294967295U ) { }

GenericTransportParameters_averageRate :: GenericTransportParameters_averageRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 4294967295U ) { }

GenericTransportParameters_averageRate * GenericTransportParameters_averageRate :: clone ( ) const {
	return new GenericTransportParameters_averageRate ( * this );
}

//
// GenericTransportParameters_burst
//

GenericTransportParameters_burst :: GenericTransportParameters_burst ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 4294967295U ) { }

GenericTransportParameters_burst :: GenericTransportParameters_burst ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 4294967295U ) { }

GenericTransportParameters_burst * GenericTransportParameters_burst :: clone ( ) const {
	return new GenericTransportParameters_burst ( * this );
}

//
// GenericTransportParameters_peakRate
//

GenericTransportParameters_peakRate :: GenericTransportParameters_peakRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 4294967295U ) { }

GenericTransportParameters_peakRate :: GenericTransportParameters_peakRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 4294967295U ) { }

GenericTransportParameters_peakRate * GenericTransportParameters_peakRate :: clone ( ) const {
	return new GenericTransportParameters_peakRate ( * this );
}

//
// GenericTransportParameters_maxPktSize
//

GenericTransportParameters_maxPktSize :: GenericTransportParameters_maxPktSize ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 4294967295U ) { }

GenericTransportParameters_maxPktSize :: GenericTransportParameters_maxPktSize ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 4294967295U ) { }

GenericTransportParameters_maxPktSize * GenericTransportParameters_maxPktSize :: clone ( ) const {
	return new GenericTransportParameters_maxPktSize ( * this );
}

//
// QOSCapability_dscpValue
//

QOSCapability_dscpValue :: QOSCapability_dscpValue ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 63 ) { }

QOSCapability_dscpValue :: QOSCapability_dscpValue ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 63 ) { }

QOSCapability_dscpValue * QOSCapability_dscpValue :: clone ( ) const {
	return new QOSCapability_dscpValue ( * this );
}

//
// MediaTransportType_atm-AAL5-compressed
//

MediaTransportType_atm_AAL5_compressed :: MediaTransportType_atm_AAL5_compressed ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_variable_delta ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MediaTransportType_atm_AAL5_compressed :: MediaTransportType_atm_AAL5_compressed ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MediaTransportType_atm_AAL5_compressed :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_variable_delta.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MediaTransportType_atm_AAL5_compressed :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 17 ) << "variable_delta = " << std :: setprecision ( indent ) << m_variable_delta << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MediaTransportType_atm_AAL5_compressed * MediaTransportType_atm_AAL5_compressed :: clone ( ) const {
	return new MediaTransportType_atm_AAL5_compressed ( * this );
}

//
// TransportCapability_qOSCapabilities
//

TransportCapability_qOSCapabilities :: TransportCapability_qOSCapabilities ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 256 ) { }

TransportCapability_qOSCapabilities :: TransportCapability_qOSCapabilities ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 256 ) { }

TransportCapability_qOSCapabilities :: TransportCapability_qOSCapabilities ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 256 ) { }


Asn :: Object * TransportCapability_qOSCapabilities :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * TransportCapability_qOSCapabilities :: createObject ( Asn :: istream & is ) {
	return new QOSCapability ( is );
}

Asn :: Object * TransportCapability_qOSCapabilities :: createObject ( ) {
	return new QOSCapability ( );
}

QOSCapability & TransportCapability_qOSCapabilities :: operator[] ( std :: size_t i ) {
	return dynamic_cast < QOSCapability & > ( Asn :: Array :: operator[] ( i ) );
}

void TransportCapability_qOSCapabilities :: push_back ( const QOSCapability & o ) {
	Asn :: Array :: push_back ( new QOSCapability ( o ) );
}

const QOSCapability & TransportCapability_qOSCapabilities :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const QOSCapability & > ( Asn :: Array :: operator[] ( i ) );
}

TransportCapability_qOSCapabilities * TransportCapability_qOSCapabilities :: clone ( ) const {
	return new TransportCapability_qOSCapabilities ( * this );
}

//
// TransportCapability_mediaChannelCapabilities
//

TransportCapability_mediaChannelCapabilities :: TransportCapability_mediaChannelCapabilities ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 256 ) { }

TransportCapability_mediaChannelCapabilities :: TransportCapability_mediaChannelCapabilities ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 256 ) { }

TransportCapability_mediaChannelCapabilities :: TransportCapability_mediaChannelCapabilities ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 256 ) { }


Asn :: Object * TransportCapability_mediaChannelCapabilities :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * TransportCapability_mediaChannelCapabilities :: createObject ( Asn :: istream & is ) {
	return new MediaChannelCapability ( is );
}

Asn :: Object * TransportCapability_mediaChannelCapabilities :: createObject ( ) {
	return new MediaChannelCapability ( );
}

MediaChannelCapability & TransportCapability_mediaChannelCapabilities :: operator[] ( std :: size_t i ) {
	return dynamic_cast < MediaChannelCapability & > ( Asn :: Array :: operator[] ( i ) );
}

void TransportCapability_mediaChannelCapabilities :: push_back ( const MediaChannelCapability & o ) {
	Asn :: Array :: push_back ( new MediaChannelCapability ( o ) );
}

const MediaChannelCapability & TransportCapability_mediaChannelCapabilities :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const MediaChannelCapability & > ( Asn :: Array :: operator[] ( i ) );
}

TransportCapability_mediaChannelCapabilities * TransportCapability_mediaChannelCapabilities :: clone ( ) const {
	return new TransportCapability_mediaChannelCapabilities ( * this );
}

//
// RedundancyEncodingCapability_secondaryEncoding
//

RedundancyEncodingCapability_secondaryEncoding :: RedundancyEncodingCapability_secondaryEncoding ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 256 ) { }

RedundancyEncodingCapability_secondaryEncoding :: RedundancyEncodingCapability_secondaryEncoding ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 256 ) { }

RedundancyEncodingCapability_secondaryEncoding :: RedundancyEncodingCapability_secondaryEncoding ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 256 ) { }


Asn :: Object * RedundancyEncodingCapability_secondaryEncoding :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * RedundancyEncodingCapability_secondaryEncoding :: createObject ( Asn :: istream & is ) {
	return new CapabilityTableEntryNumber ( is );
}

Asn :: Object * RedundancyEncodingCapability_secondaryEncoding :: createObject ( ) {
	return new CapabilityTableEntryNumber ( );
}

CapabilityTableEntryNumber & RedundancyEncodingCapability_secondaryEncoding :: operator[] ( std :: size_t i ) {
	return dynamic_cast < CapabilityTableEntryNumber & > ( Asn :: Array :: operator[] ( i ) );
}

void RedundancyEncodingCapability_secondaryEncoding :: push_back ( const CapabilityTableEntryNumber & o ) {
	Asn :: Array :: push_back ( new CapabilityTableEntryNumber ( o ) );
}

const CapabilityTableEntryNumber & RedundancyEncodingCapability_secondaryEncoding :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const CapabilityTableEntryNumber & > ( Asn :: Array :: operator[] ( i ) );
}

RedundancyEncodingCapability_secondaryEncoding * RedundancyEncodingCapability_secondaryEncoding :: clone ( ) const {
	return new RedundancyEncodingCapability_secondaryEncoding ( * this );
}

//
// RTPH263VideoRedundancyEncoding_numberOfThreads
//

RTPH263VideoRedundancyEncoding_numberOfThreads :: RTPH263VideoRedundancyEncoding_numberOfThreads ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 16 ) { }

RTPH263VideoRedundancyEncoding_numberOfThreads :: RTPH263VideoRedundancyEncoding_numberOfThreads ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 16 ) { }

RTPH263VideoRedundancyEncoding_numberOfThreads * RTPH263VideoRedundancyEncoding_numberOfThreads :: clone ( ) const {
	return new RTPH263VideoRedundancyEncoding_numberOfThreads ( * this );
}

//
// RTPH263VideoRedundancyEncoding_framesBetweenSyncPoints
//

RTPH263VideoRedundancyEncoding_framesBetweenSyncPoints :: RTPH263VideoRedundancyEncoding_framesBetweenSyncPoints ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 256 ) { }

RTPH263VideoRedundancyEncoding_framesBetweenSyncPoints :: RTPH263VideoRedundancyEncoding_framesBetweenSyncPoints ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 256 ) { }

RTPH263VideoRedundancyEncoding_framesBetweenSyncPoints * RTPH263VideoRedundancyEncoding_framesBetweenSyncPoints :: clone ( ) const {
	return new RTPH263VideoRedundancyEncoding_framesBetweenSyncPoints ( * this );
}

//
// RTPH263VideoRedundancyEncoding_containedThreads
//

RTPH263VideoRedundancyEncoding_containedThreads :: RTPH263VideoRedundancyEncoding_containedThreads ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 256 ) { }

RTPH263VideoRedundancyEncoding_containedThreads :: RTPH263VideoRedundancyEncoding_containedThreads ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 256 ) { }

RTPH263VideoRedundancyEncoding_containedThreads :: RTPH263VideoRedundancyEncoding_containedThreads ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 256 ) { }


Asn :: Object * RTPH263VideoRedundancyEncoding_containedThreads :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * RTPH263VideoRedundancyEncoding_containedThreads :: createObject ( Asn :: istream & is ) {
	return new RTPH263VideoRedundancyEncoding_containedThreads_subtype ( is );
}

Asn :: Object * RTPH263VideoRedundancyEncoding_containedThreads :: createObject ( ) {
	return new RTPH263VideoRedundancyEncoding_containedThreads_subtype ( );
}

RTPH263VideoRedundancyEncoding_containedThreads_subtype & RTPH263VideoRedundancyEncoding_containedThreads :: operator[] ( std :: size_t i ) {
	return dynamic_cast < RTPH263VideoRedundancyEncoding_containedThreads_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

void RTPH263VideoRedundancyEncoding_containedThreads :: push_back ( const RTPH263VideoRedundancyEncoding_containedThreads_subtype & o ) {
	Asn :: Array :: push_back ( new RTPH263VideoRedundancyEncoding_containedThreads_subtype ( o ) );
}

const RTPH263VideoRedundancyEncoding_containedThreads_subtype & RTPH263VideoRedundancyEncoding_containedThreads :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const RTPH263VideoRedundancyEncoding_containedThreads_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

RTPH263VideoRedundancyEncoding_containedThreads * RTPH263VideoRedundancyEncoding_containedThreads :: clone ( ) const {
	return new RTPH263VideoRedundancyEncoding_containedThreads ( * this );
}

//
// RTPH263VideoRedundancyFrameMapping_threadNumber
//

RTPH263VideoRedundancyFrameMapping_threadNumber :: RTPH263VideoRedundancyFrameMapping_threadNumber ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 15 ) { }

RTPH263VideoRedundancyFrameMapping_threadNumber :: RTPH263VideoRedundancyFrameMapping_threadNumber ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 15 ) { }

RTPH263VideoRedundancyFrameMapping_threadNumber * RTPH263VideoRedundancyFrameMapping_threadNumber :: clone ( ) const {
	return new RTPH263VideoRedundancyFrameMapping_threadNumber ( * this );
}

//
// RTPH263VideoRedundancyFrameMapping_frameSequence
//

RTPH263VideoRedundancyFrameMapping_frameSequence :: RTPH263VideoRedundancyFrameMapping_frameSequence ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 256 ) { }

RTPH263VideoRedundancyFrameMapping_frameSequence :: RTPH263VideoRedundancyFrameMapping_frameSequence ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 256 ) { }

RTPH263VideoRedundancyFrameMapping_frameSequence :: RTPH263VideoRedundancyFrameMapping_frameSequence ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 256 ) { }


Asn :: Object * RTPH263VideoRedundancyFrameMapping_frameSequence :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * RTPH263VideoRedundancyFrameMapping_frameSequence :: createObject ( Asn :: istream & is ) {
	return new RTPH263VideoRedundancyFrameMapping_frameSequence_subtype ( is );
}

Asn :: Object * RTPH263VideoRedundancyFrameMapping_frameSequence :: createObject ( ) {
	return new RTPH263VideoRedundancyFrameMapping_frameSequence_subtype ( );
}

RTPH263VideoRedundancyFrameMapping_frameSequence_subtype & RTPH263VideoRedundancyFrameMapping_frameSequence :: operator[] ( std :: size_t i ) {
	return dynamic_cast < RTPH263VideoRedundancyFrameMapping_frameSequence_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

void RTPH263VideoRedundancyFrameMapping_frameSequence :: push_back ( const RTPH263VideoRedundancyFrameMapping_frameSequence_subtype & o ) {
	Asn :: Array :: push_back ( new RTPH263VideoRedundancyFrameMapping_frameSequence_subtype ( o ) );
}

const RTPH263VideoRedundancyFrameMapping_frameSequence_subtype & RTPH263VideoRedundancyFrameMapping_frameSequence :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const RTPH263VideoRedundancyFrameMapping_frameSequence_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

RTPH263VideoRedundancyFrameMapping_frameSequence * RTPH263VideoRedundancyFrameMapping_frameSequence :: clone ( ) const {
	return new RTPH263VideoRedundancyFrameMapping_frameSequence ( * this );
}

//
// ArrayOf_MediaDistributionCapability
//

ArrayOf_MediaDistributionCapability :: ArrayOf_MediaDistributionCapability ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_MediaDistributionCapability :: ArrayOf_MediaDistributionCapability ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_MediaDistributionCapability :: ArrayOf_MediaDistributionCapability ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_MediaDistributionCapability :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_MediaDistributionCapability :: createObject ( Asn :: istream & is ) {
	return new MediaDistributionCapability ( is );
}

Asn :: Object * ArrayOf_MediaDistributionCapability :: createObject ( ) {
	return new MediaDistributionCapability ( );
}

MediaDistributionCapability & ArrayOf_MediaDistributionCapability :: operator[] ( std :: size_t i ) {
	return dynamic_cast < MediaDistributionCapability & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_MediaDistributionCapability :: push_back ( const MediaDistributionCapability & o ) {
	Asn :: Array :: push_back ( new MediaDistributionCapability ( o ) );
}

const MediaDistributionCapability & ArrayOf_MediaDistributionCapability :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const MediaDistributionCapability & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_MediaDistributionCapability * ArrayOf_MediaDistributionCapability :: clone ( ) const {
	return new ArrayOf_MediaDistributionCapability ( * this );
}

//
// ArrayOf_DataApplicationCapability
//

ArrayOf_DataApplicationCapability :: ArrayOf_DataApplicationCapability ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_DataApplicationCapability :: ArrayOf_DataApplicationCapability ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_DataApplicationCapability :: ArrayOf_DataApplicationCapability ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_DataApplicationCapability :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_DataApplicationCapability :: createObject ( Asn :: istream & is ) {
	return new DataApplicationCapability ( is );
}

Asn :: Object * ArrayOf_DataApplicationCapability :: createObject ( ) {
	return new DataApplicationCapability ( );
}

DataApplicationCapability & ArrayOf_DataApplicationCapability :: operator[] ( std :: size_t i ) {
	return dynamic_cast < DataApplicationCapability & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_DataApplicationCapability :: push_back ( const DataApplicationCapability & o ) {
	Asn :: Array :: push_back ( new DataApplicationCapability ( o ) );
}

const DataApplicationCapability & ArrayOf_DataApplicationCapability :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const DataApplicationCapability & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_DataApplicationCapability * ArrayOf_DataApplicationCapability :: clone ( ) const {
	return new ArrayOf_DataApplicationCapability ( * this );
}

//
// ArrayOf_VideoCapability
//

ArrayOf_VideoCapability :: ArrayOf_VideoCapability ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_VideoCapability :: ArrayOf_VideoCapability ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_VideoCapability :: ArrayOf_VideoCapability ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_VideoCapability :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_VideoCapability :: createObject ( Asn :: istream & is ) {
	return new VideoCapability ( is );
}

Asn :: Object * ArrayOf_VideoCapability :: createObject ( ) {
	return new VideoCapability ( );
}

VideoCapability & ArrayOf_VideoCapability :: operator[] ( std :: size_t i ) {
	return dynamic_cast < VideoCapability & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_VideoCapability :: push_back ( const VideoCapability & o ) {
	Asn :: Array :: push_back ( new VideoCapability ( o ) );
}

const VideoCapability & ArrayOf_VideoCapability :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const VideoCapability & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_VideoCapability * ArrayOf_VideoCapability :: clone ( ) const {
	return new ArrayOf_VideoCapability ( * this );
}

//
// ArrayOf_GenericCapability
//

ArrayOf_GenericCapability :: ArrayOf_GenericCapability ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_GenericCapability :: ArrayOf_GenericCapability ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_GenericCapability :: ArrayOf_GenericCapability ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_GenericCapability :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_GenericCapability :: createObject ( Asn :: istream & is ) {
	return new GenericCapability ( is );
}

Asn :: Object * ArrayOf_GenericCapability :: createObject ( ) {
	return new GenericCapability ( );
}

GenericCapability & ArrayOf_GenericCapability :: operator[] ( std :: size_t i ) {
	return dynamic_cast < GenericCapability & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_GenericCapability :: push_back ( const GenericCapability & o ) {
	Asn :: Array :: push_back ( new GenericCapability ( o ) );
}

const GenericCapability & ArrayOf_GenericCapability :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const GenericCapability & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_GenericCapability * ArrayOf_GenericCapability :: clone ( ) const {
	return new ArrayOf_GenericCapability ( * this );
}

//
// H261VideoCapability_qcifMPI
//

H261VideoCapability_qcifMPI :: H261VideoCapability_qcifMPI ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 4 ) { }

H261VideoCapability_qcifMPI :: H261VideoCapability_qcifMPI ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 4 ) { }

H261VideoCapability_qcifMPI * H261VideoCapability_qcifMPI :: clone ( ) const {
	return new H261VideoCapability_qcifMPI ( * this );
}

//
// H261VideoCapability_cifMPI
//

H261VideoCapability_cifMPI :: H261VideoCapability_cifMPI ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 4 ) { }

H261VideoCapability_cifMPI :: H261VideoCapability_cifMPI ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 4 ) { }

H261VideoCapability_cifMPI * H261VideoCapability_cifMPI :: clone ( ) const {
	return new H261VideoCapability_cifMPI ( * this );
}

//
// H261VideoCapability_maxBitRate
//

H261VideoCapability_maxBitRate :: H261VideoCapability_maxBitRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 19200 ) { }

H261VideoCapability_maxBitRate :: H261VideoCapability_maxBitRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 19200 ) { }

H261VideoCapability_maxBitRate * H261VideoCapability_maxBitRate :: clone ( ) const {
	return new H261VideoCapability_maxBitRate ( * this );
}

//
// H262VideoCapability_videoBitRate
//

H262VideoCapability_videoBitRate :: H262VideoCapability_videoBitRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 1073741823 ) { }

H262VideoCapability_videoBitRate :: H262VideoCapability_videoBitRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 1073741823 ) { }

H262VideoCapability_videoBitRate * H262VideoCapability_videoBitRate :: clone ( ) const {
	return new H262VideoCapability_videoBitRate ( * this );
}

//
// H262VideoCapability_vbvBufferSize
//

H262VideoCapability_vbvBufferSize :: H262VideoCapability_vbvBufferSize ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 262143 ) { }

H262VideoCapability_vbvBufferSize :: H262VideoCapability_vbvBufferSize ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 262143 ) { }

H262VideoCapability_vbvBufferSize * H262VideoCapability_vbvBufferSize :: clone ( ) const {
	return new H262VideoCapability_vbvBufferSize ( * this );
}

//
// H262VideoCapability_samplesPerLine
//

H262VideoCapability_samplesPerLine :: H262VideoCapability_samplesPerLine ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 16383 ) { }

H262VideoCapability_samplesPerLine :: H262VideoCapability_samplesPerLine ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 16383 ) { }

H262VideoCapability_samplesPerLine * H262VideoCapability_samplesPerLine :: clone ( ) const {
	return new H262VideoCapability_samplesPerLine ( * this );
}

//
// H262VideoCapability_linesPerFrame
//

H262VideoCapability_linesPerFrame :: H262VideoCapability_linesPerFrame ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 16383 ) { }

H262VideoCapability_linesPerFrame :: H262VideoCapability_linesPerFrame ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 16383 ) { }

H262VideoCapability_linesPerFrame * H262VideoCapability_linesPerFrame :: clone ( ) const {
	return new H262VideoCapability_linesPerFrame ( * this );
}

//
// H262VideoCapability_framesPerSecond
//

H262VideoCapability_framesPerSecond :: H262VideoCapability_framesPerSecond ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 15 ) { }

H262VideoCapability_framesPerSecond :: H262VideoCapability_framesPerSecond ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 15 ) { }

H262VideoCapability_framesPerSecond * H262VideoCapability_framesPerSecond :: clone ( ) const {
	return new H262VideoCapability_framesPerSecond ( * this );
}

//
// H262VideoCapability_luminanceSampleRate
//

H262VideoCapability_luminanceSampleRate :: H262VideoCapability_luminanceSampleRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 4294967295U ) { }

H262VideoCapability_luminanceSampleRate :: H262VideoCapability_luminanceSampleRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 4294967295U ) { }

H262VideoCapability_luminanceSampleRate * H262VideoCapability_luminanceSampleRate :: clone ( ) const {
	return new H262VideoCapability_luminanceSampleRate ( * this );
}

//
// H263VideoCapability_sqcifMPI
//

H263VideoCapability_sqcifMPI :: H263VideoCapability_sqcifMPI ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 32 ) { }

H263VideoCapability_sqcifMPI :: H263VideoCapability_sqcifMPI ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 32 ) { }

H263VideoCapability_sqcifMPI * H263VideoCapability_sqcifMPI :: clone ( ) const {
	return new H263VideoCapability_sqcifMPI ( * this );
}

//
// H263VideoCapability_qcifMPI
//

H263VideoCapability_qcifMPI :: H263VideoCapability_qcifMPI ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 32 ) { }

H263VideoCapability_qcifMPI :: H263VideoCapability_qcifMPI ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 32 ) { }

H263VideoCapability_qcifMPI * H263VideoCapability_qcifMPI :: clone ( ) const {
	return new H263VideoCapability_qcifMPI ( * this );
}

//
// H263VideoCapability_cifMPI
//

H263VideoCapability_cifMPI :: H263VideoCapability_cifMPI ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 32 ) { }

H263VideoCapability_cifMPI :: H263VideoCapability_cifMPI ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 32 ) { }

H263VideoCapability_cifMPI * H263VideoCapability_cifMPI :: clone ( ) const {
	return new H263VideoCapability_cifMPI ( * this );
}

//
// H263VideoCapability_cif4MPI
//

H263VideoCapability_cif4MPI :: H263VideoCapability_cif4MPI ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 32 ) { }

H263VideoCapability_cif4MPI :: H263VideoCapability_cif4MPI ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 32 ) { }

H263VideoCapability_cif4MPI * H263VideoCapability_cif4MPI :: clone ( ) const {
	return new H263VideoCapability_cif4MPI ( * this );
}

//
// H263VideoCapability_cif16MPI
//

H263VideoCapability_cif16MPI :: H263VideoCapability_cif16MPI ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 32 ) { }

H263VideoCapability_cif16MPI :: H263VideoCapability_cif16MPI ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 32 ) { }

H263VideoCapability_cif16MPI * H263VideoCapability_cif16MPI :: clone ( ) const {
	return new H263VideoCapability_cif16MPI ( * this );
}

//
// H263VideoCapability_maxBitRate
//

H263VideoCapability_maxBitRate :: H263VideoCapability_maxBitRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 192400 ) { }

H263VideoCapability_maxBitRate :: H263VideoCapability_maxBitRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 192400 ) { }

H263VideoCapability_maxBitRate * H263VideoCapability_maxBitRate :: clone ( ) const {
	return new H263VideoCapability_maxBitRate ( * this );
}

//
// H263VideoCapability_hrd-B
//

H263VideoCapability_hrd_B :: H263VideoCapability_hrd_B ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 524287 ) { }

H263VideoCapability_hrd_B :: H263VideoCapability_hrd_B ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 524287 ) { }

H263VideoCapability_hrd_B * H263VideoCapability_hrd_B :: clone ( ) const {
	return new H263VideoCapability_hrd_B ( * this );
}

//
// H263VideoCapability_bppMaxKb
//

H263VideoCapability_bppMaxKb :: H263VideoCapability_bppMaxKb ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

H263VideoCapability_bppMaxKb :: H263VideoCapability_bppMaxKb ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

H263VideoCapability_bppMaxKb * H263VideoCapability_bppMaxKb :: clone ( ) const {
	return new H263VideoCapability_bppMaxKb ( * this );
}

//
// H263VideoCapability_slowSqcifMPI
//

H263VideoCapability_slowSqcifMPI :: H263VideoCapability_slowSqcifMPI ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 3600 ) { }

H263VideoCapability_slowSqcifMPI :: H263VideoCapability_slowSqcifMPI ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 3600 ) { }

H263VideoCapability_slowSqcifMPI * H263VideoCapability_slowSqcifMPI :: clone ( ) const {
	return new H263VideoCapability_slowSqcifMPI ( * this );
}

//
// H263VideoCapability_slowQcifMPI
//

H263VideoCapability_slowQcifMPI :: H263VideoCapability_slowQcifMPI ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 3600 ) { }

H263VideoCapability_slowQcifMPI :: H263VideoCapability_slowQcifMPI ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 3600 ) { }

H263VideoCapability_slowQcifMPI * H263VideoCapability_slowQcifMPI :: clone ( ) const {
	return new H263VideoCapability_slowQcifMPI ( * this );
}

//
// H263VideoCapability_slowCifMPI
//

H263VideoCapability_slowCifMPI :: H263VideoCapability_slowCifMPI ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 3600 ) { }

H263VideoCapability_slowCifMPI :: H263VideoCapability_slowCifMPI ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 3600 ) { }

H263VideoCapability_slowCifMPI * H263VideoCapability_slowCifMPI :: clone ( ) const {
	return new H263VideoCapability_slowCifMPI ( * this );
}

//
// H263VideoCapability_slowCif4MPI
//

H263VideoCapability_slowCif4MPI :: H263VideoCapability_slowCif4MPI ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 3600 ) { }

H263VideoCapability_slowCif4MPI :: H263VideoCapability_slowCif4MPI ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 3600 ) { }

H263VideoCapability_slowCif4MPI * H263VideoCapability_slowCif4MPI :: clone ( ) const {
	return new H263VideoCapability_slowCif4MPI ( * this );
}

//
// H263VideoCapability_slowCif16MPI
//

H263VideoCapability_slowCif16MPI :: H263VideoCapability_slowCif16MPI ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 3600 ) { }

H263VideoCapability_slowCif16MPI :: H263VideoCapability_slowCif16MPI ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 3600 ) { }

H263VideoCapability_slowCif16MPI * H263VideoCapability_slowCif16MPI :: clone ( ) const {
	return new H263VideoCapability_slowCif16MPI ( * this );
}

//
// EnhancementLayerInfo_snrEnhancement
//

EnhancementLayerInfo_snrEnhancement :: EnhancementLayerInfo_snrEnhancement ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 14 ) { }

EnhancementLayerInfo_snrEnhancement :: EnhancementLayerInfo_snrEnhancement ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 14 ) { }

EnhancementLayerInfo_snrEnhancement :: EnhancementLayerInfo_snrEnhancement ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 14 ) { }


Asn :: Object * EnhancementLayerInfo_snrEnhancement :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * EnhancementLayerInfo_snrEnhancement :: createObject ( Asn :: istream & is ) {
	return new EnhancementOptions ( is );
}

Asn :: Object * EnhancementLayerInfo_snrEnhancement :: createObject ( ) {
	return new EnhancementOptions ( );
}

EnhancementOptions & EnhancementLayerInfo_snrEnhancement :: operator[] ( std :: size_t i ) {
	return dynamic_cast < EnhancementOptions & > ( Asn :: Array :: operator[] ( i ) );
}

void EnhancementLayerInfo_snrEnhancement :: push_back ( const EnhancementOptions & o ) {
	Asn :: Array :: push_back ( new EnhancementOptions ( o ) );
}

const EnhancementOptions & EnhancementLayerInfo_snrEnhancement :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const EnhancementOptions & > ( Asn :: Array :: operator[] ( i ) );
}

EnhancementLayerInfo_snrEnhancement * EnhancementLayerInfo_snrEnhancement :: clone ( ) const {
	return new EnhancementLayerInfo_snrEnhancement ( * this );
}

//
// EnhancementLayerInfo_spatialEnhancement
//

EnhancementLayerInfo_spatialEnhancement :: EnhancementLayerInfo_spatialEnhancement ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 14 ) { }

EnhancementLayerInfo_spatialEnhancement :: EnhancementLayerInfo_spatialEnhancement ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 14 ) { }

EnhancementLayerInfo_spatialEnhancement :: EnhancementLayerInfo_spatialEnhancement ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 14 ) { }


Asn :: Object * EnhancementLayerInfo_spatialEnhancement :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * EnhancementLayerInfo_spatialEnhancement :: createObject ( Asn :: istream & is ) {
	return new EnhancementOptions ( is );
}

Asn :: Object * EnhancementLayerInfo_spatialEnhancement :: createObject ( ) {
	return new EnhancementOptions ( );
}

EnhancementOptions & EnhancementLayerInfo_spatialEnhancement :: operator[] ( std :: size_t i ) {
	return dynamic_cast < EnhancementOptions & > ( Asn :: Array :: operator[] ( i ) );
}

void EnhancementLayerInfo_spatialEnhancement :: push_back ( const EnhancementOptions & o ) {
	Asn :: Array :: push_back ( new EnhancementOptions ( o ) );
}

const EnhancementOptions & EnhancementLayerInfo_spatialEnhancement :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const EnhancementOptions & > ( Asn :: Array :: operator[] ( i ) );
}

EnhancementLayerInfo_spatialEnhancement * EnhancementLayerInfo_spatialEnhancement :: clone ( ) const {
	return new EnhancementLayerInfo_spatialEnhancement ( * this );
}

//
// EnhancementLayerInfo_bPictureEnhancement
//

EnhancementLayerInfo_bPictureEnhancement :: EnhancementLayerInfo_bPictureEnhancement ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 14 ) { }

EnhancementLayerInfo_bPictureEnhancement :: EnhancementLayerInfo_bPictureEnhancement ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 14 ) { }

EnhancementLayerInfo_bPictureEnhancement :: EnhancementLayerInfo_bPictureEnhancement ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 14 ) { }


Asn :: Object * EnhancementLayerInfo_bPictureEnhancement :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * EnhancementLayerInfo_bPictureEnhancement :: createObject ( Asn :: istream & is ) {
	return new BEnhancementParameters ( is );
}

Asn :: Object * EnhancementLayerInfo_bPictureEnhancement :: createObject ( ) {
	return new BEnhancementParameters ( );
}

BEnhancementParameters & EnhancementLayerInfo_bPictureEnhancement :: operator[] ( std :: size_t i ) {
	return dynamic_cast < BEnhancementParameters & > ( Asn :: Array :: operator[] ( i ) );
}

void EnhancementLayerInfo_bPictureEnhancement :: push_back ( const BEnhancementParameters & o ) {
	Asn :: Array :: push_back ( new BEnhancementParameters ( o ) );
}

const BEnhancementParameters & EnhancementLayerInfo_bPictureEnhancement :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const BEnhancementParameters & > ( Asn :: Array :: operator[] ( i ) );
}

EnhancementLayerInfo_bPictureEnhancement * EnhancementLayerInfo_bPictureEnhancement :: clone ( ) const {
	return new EnhancementLayerInfo_bPictureEnhancement ( * this );
}

//
// BEnhancementParameters_numberOfBPictures
//

BEnhancementParameters_numberOfBPictures :: BEnhancementParameters_numberOfBPictures ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 64 ) { }

BEnhancementParameters_numberOfBPictures :: BEnhancementParameters_numberOfBPictures ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 64 ) { }

BEnhancementParameters_numberOfBPictures * BEnhancementParameters_numberOfBPictures :: clone ( ) const {
	return new BEnhancementParameters_numberOfBPictures ( * this );
}

//
// EnhancementOptions_sqcifMPI
//

EnhancementOptions_sqcifMPI :: EnhancementOptions_sqcifMPI ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 32 ) { }

EnhancementOptions_sqcifMPI :: EnhancementOptions_sqcifMPI ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 32 ) { }

EnhancementOptions_sqcifMPI * EnhancementOptions_sqcifMPI :: clone ( ) const {
	return new EnhancementOptions_sqcifMPI ( * this );
}

//
// EnhancementOptions_qcifMPI
//

EnhancementOptions_qcifMPI :: EnhancementOptions_qcifMPI ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 32 ) { }

EnhancementOptions_qcifMPI :: EnhancementOptions_qcifMPI ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 32 ) { }

EnhancementOptions_qcifMPI * EnhancementOptions_qcifMPI :: clone ( ) const {
	return new EnhancementOptions_qcifMPI ( * this );
}

//
// EnhancementOptions_cifMPI
//

EnhancementOptions_cifMPI :: EnhancementOptions_cifMPI ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 32 ) { }

EnhancementOptions_cifMPI :: EnhancementOptions_cifMPI ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 32 ) { }

EnhancementOptions_cifMPI * EnhancementOptions_cifMPI :: clone ( ) const {
	return new EnhancementOptions_cifMPI ( * this );
}

//
// EnhancementOptions_cif4MPI
//

EnhancementOptions_cif4MPI :: EnhancementOptions_cif4MPI ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 32 ) { }

EnhancementOptions_cif4MPI :: EnhancementOptions_cif4MPI ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 32 ) { }

EnhancementOptions_cif4MPI * EnhancementOptions_cif4MPI :: clone ( ) const {
	return new EnhancementOptions_cif4MPI ( * this );
}

//
// EnhancementOptions_cif16MPI
//

EnhancementOptions_cif16MPI :: EnhancementOptions_cif16MPI ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 32 ) { }

EnhancementOptions_cif16MPI :: EnhancementOptions_cif16MPI ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 32 ) { }

EnhancementOptions_cif16MPI * EnhancementOptions_cif16MPI :: clone ( ) const {
	return new EnhancementOptions_cif16MPI ( * this );
}

//
// EnhancementOptions_maxBitRate
//

EnhancementOptions_maxBitRate :: EnhancementOptions_maxBitRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 192400 ) { }

EnhancementOptions_maxBitRate :: EnhancementOptions_maxBitRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 192400 ) { }

EnhancementOptions_maxBitRate * EnhancementOptions_maxBitRate :: clone ( ) const {
	return new EnhancementOptions_maxBitRate ( * this );
}

//
// EnhancementOptions_slowSqcifMPI
//

EnhancementOptions_slowSqcifMPI :: EnhancementOptions_slowSqcifMPI ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 3600 ) { }

EnhancementOptions_slowSqcifMPI :: EnhancementOptions_slowSqcifMPI ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 3600 ) { }

EnhancementOptions_slowSqcifMPI * EnhancementOptions_slowSqcifMPI :: clone ( ) const {
	return new EnhancementOptions_slowSqcifMPI ( * this );
}

//
// EnhancementOptions_slowQcifMPI
//

EnhancementOptions_slowQcifMPI :: EnhancementOptions_slowQcifMPI ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 3600 ) { }

EnhancementOptions_slowQcifMPI :: EnhancementOptions_slowQcifMPI ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 3600 ) { }

EnhancementOptions_slowQcifMPI * EnhancementOptions_slowQcifMPI :: clone ( ) const {
	return new EnhancementOptions_slowQcifMPI ( * this );
}

//
// EnhancementOptions_slowCifMPI
//

EnhancementOptions_slowCifMPI :: EnhancementOptions_slowCifMPI ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 3600 ) { }

EnhancementOptions_slowCifMPI :: EnhancementOptions_slowCifMPI ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 3600 ) { }

EnhancementOptions_slowCifMPI * EnhancementOptions_slowCifMPI :: clone ( ) const {
	return new EnhancementOptions_slowCifMPI ( * this );
}

//
// EnhancementOptions_slowCif4MPI
//

EnhancementOptions_slowCif4MPI :: EnhancementOptions_slowCif4MPI ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 3600 ) { }

EnhancementOptions_slowCif4MPI :: EnhancementOptions_slowCif4MPI ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 3600 ) { }

EnhancementOptions_slowCif4MPI * EnhancementOptions_slowCif4MPI :: clone ( ) const {
	return new EnhancementOptions_slowCif4MPI ( * this );
}

//
// EnhancementOptions_slowCif16MPI
//

EnhancementOptions_slowCif16MPI :: EnhancementOptions_slowCif16MPI ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 3600 ) { }

EnhancementOptions_slowCif16MPI :: EnhancementOptions_slowCif16MPI ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 3600 ) { }

EnhancementOptions_slowCif16MPI * EnhancementOptions_slowCif16MPI :: clone ( ) const {
	return new EnhancementOptions_slowCif16MPI ( * this );
}

//
// H263Options_customPictureClockFrequency
//

H263Options_customPictureClockFrequency :: H263Options_customPictureClockFrequency ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 16 ) { }

H263Options_customPictureClockFrequency :: H263Options_customPictureClockFrequency ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 16 ) { }

H263Options_customPictureClockFrequency :: H263Options_customPictureClockFrequency ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 16 ) { }


Asn :: Object * H263Options_customPictureClockFrequency :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * H263Options_customPictureClockFrequency :: createObject ( Asn :: istream & is ) {
	return new CustomPictureClockFrequency ( is );
}

Asn :: Object * H263Options_customPictureClockFrequency :: createObject ( ) {
	return new CustomPictureClockFrequency ( );
}

CustomPictureClockFrequency & H263Options_customPictureClockFrequency :: operator[] ( std :: size_t i ) {
	return dynamic_cast < CustomPictureClockFrequency & > ( Asn :: Array :: operator[] ( i ) );
}

void H263Options_customPictureClockFrequency :: push_back ( const CustomPictureClockFrequency & o ) {
	Asn :: Array :: push_back ( new CustomPictureClockFrequency ( o ) );
}

const CustomPictureClockFrequency & H263Options_customPictureClockFrequency :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const CustomPictureClockFrequency & > ( Asn :: Array :: operator[] ( i ) );
}

H263Options_customPictureClockFrequency * H263Options_customPictureClockFrequency :: clone ( ) const {
	return new H263Options_customPictureClockFrequency ( * this );
}

//
// H263Options_customPictureFormat
//

H263Options_customPictureFormat :: H263Options_customPictureFormat ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 16 ) { }

H263Options_customPictureFormat :: H263Options_customPictureFormat ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 16 ) { }

H263Options_customPictureFormat :: H263Options_customPictureFormat ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 16 ) { }


Asn :: Object * H263Options_customPictureFormat :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * H263Options_customPictureFormat :: createObject ( Asn :: istream & is ) {
	return new CustomPictureFormat ( is );
}

Asn :: Object * H263Options_customPictureFormat :: createObject ( ) {
	return new CustomPictureFormat ( );
}

CustomPictureFormat & H263Options_customPictureFormat :: operator[] ( std :: size_t i ) {
	return dynamic_cast < CustomPictureFormat & > ( Asn :: Array :: operator[] ( i ) );
}

void H263Options_customPictureFormat :: push_back ( const CustomPictureFormat & o ) {
	Asn :: Array :: push_back ( new CustomPictureFormat ( o ) );
}

const CustomPictureFormat & H263Options_customPictureFormat :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const CustomPictureFormat & > ( Asn :: Array :: operator[] ( i ) );
}

H263Options_customPictureFormat * H263Options_customPictureFormat :: clone ( ) const {
	return new H263Options_customPictureFormat ( * this );
}

//
// H263Options_modeCombos
//

H263Options_modeCombos :: H263Options_modeCombos ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 16 ) { }

H263Options_modeCombos :: H263Options_modeCombos ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 16 ) { }

H263Options_modeCombos :: H263Options_modeCombos ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 16 ) { }


Asn :: Object * H263Options_modeCombos :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * H263Options_modeCombos :: createObject ( Asn :: istream & is ) {
	return new H263VideoModeCombos ( is );
}

Asn :: Object * H263Options_modeCombos :: createObject ( ) {
	return new H263VideoModeCombos ( );
}

H263VideoModeCombos & H263Options_modeCombos :: operator[] ( std :: size_t i ) {
	return dynamic_cast < H263VideoModeCombos & > ( Asn :: Array :: operator[] ( i ) );
}

void H263Options_modeCombos :: push_back ( const H263VideoModeCombos & o ) {
	Asn :: Array :: push_back ( new H263VideoModeCombos ( o ) );
}

const H263VideoModeCombos & H263Options_modeCombos :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const H263VideoModeCombos & > ( Asn :: Array :: operator[] ( i ) );
}

H263Options_modeCombos * H263Options_modeCombos :: clone ( ) const {
	return new H263Options_modeCombos ( * this );
}

//
// TransparencyParameters_presentationOrder
//

TransparencyParameters_presentationOrder :: TransparencyParameters_presentationOrder ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 256 ) { }

TransparencyParameters_presentationOrder :: TransparencyParameters_presentationOrder ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 256 ) { }

TransparencyParameters_presentationOrder * TransparencyParameters_presentationOrder :: clone ( ) const {
	return new TransparencyParameters_presentationOrder ( * this );
}

//
// TransparencyParameters_offset-x
//

TransparencyParameters_offset_x :: TransparencyParameters_offset_x ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, -262144, 262143 ) { }

TransparencyParameters_offset_x :: TransparencyParameters_offset_x ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, -262144, 262143 ) { }

TransparencyParameters_offset_x * TransparencyParameters_offset_x :: clone ( ) const {
	return new TransparencyParameters_offset_x ( * this );
}

//
// TransparencyParameters_offset-y
//

TransparencyParameters_offset_y :: TransparencyParameters_offset_y ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, -262144, 262143 ) { }

TransparencyParameters_offset_y :: TransparencyParameters_offset_y ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, -262144, 262143 ) { }

TransparencyParameters_offset_y * TransparencyParameters_offset_y :: clone ( ) const {
	return new TransparencyParameters_offset_y ( * this );
}

//
// TransparencyParameters_scale-x
//

TransparencyParameters_scale_x :: TransparencyParameters_scale_x ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 255 ) { }

TransparencyParameters_scale_x :: TransparencyParameters_scale_x ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 255 ) { }

TransparencyParameters_scale_x * TransparencyParameters_scale_x :: clone ( ) const {
	return new TransparencyParameters_scale_x ( * this );
}

//
// TransparencyParameters_scale-y
//

TransparencyParameters_scale_y :: TransparencyParameters_scale_y ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 255 ) { }

TransparencyParameters_scale_y :: TransparencyParameters_scale_y ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 255 ) { }

TransparencyParameters_scale_y * TransparencyParameters_scale_y :: clone ( ) const {
	return new TransparencyParameters_scale_y ( * this );
}

//
// RefPictureSelection_additionalPictureMemory
//

RefPictureSelection_additionalPictureMemory :: RefPictureSelection_additionalPictureMemory ( Asn :: istream & is ) : Asn :: Sequence ( is, 6, true, 0 ), m_sqcifAdditionalPictureMemory ( 0 ), m_qcifAdditionalPictureMemory ( 0 ), m_cifAdditionalPictureMemory ( 0 ), m_cif4AdditionalPictureMemory ( 0 ), m_cif16AdditionalPictureMemory ( 0 ), m_bigCpfAdditionalPictureMemory ( 0 ) {
	try {
		if ( hasOptionalField ( e_sqcifAdditionalPictureMemory ) )
			m_sqcifAdditionalPictureMemory = new RefPictureSelection_additionalPictureMemory_sqcifAdditionalPictureMemory ( is );
		if ( hasOptionalField ( e_qcifAdditionalPictureMemory ) )
			m_qcifAdditionalPictureMemory = new RefPictureSelection_additionalPictureMemory_qcifAdditionalPictureMemory ( is );
		if ( hasOptionalField ( e_cifAdditionalPictureMemory ) )
			m_cifAdditionalPictureMemory = new RefPictureSelection_additionalPictureMemory_cifAdditionalPictureMemory ( is );
		if ( hasOptionalField ( e_cif4AdditionalPictureMemory ) )
			m_cif4AdditionalPictureMemory = new RefPictureSelection_additionalPictureMemory_cif4AdditionalPictureMemory ( is );
		if ( hasOptionalField ( e_cif16AdditionalPictureMemory ) )
			m_cif16AdditionalPictureMemory = new RefPictureSelection_additionalPictureMemory_cif16AdditionalPictureMemory ( is );
		if ( hasOptionalField ( e_bigCpfAdditionalPictureMemory ) )
			m_bigCpfAdditionalPictureMemory = new RefPictureSelection_additionalPictureMemory_bigCpfAdditionalPictureMemory ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_sqcifAdditionalPictureMemory;
		delete m_qcifAdditionalPictureMemory;
		delete m_cifAdditionalPictureMemory;
		delete m_cif4AdditionalPictureMemory;
		delete m_cif16AdditionalPictureMemory;
		delete m_bigCpfAdditionalPictureMemory;
		throw;
	}
}

RefPictureSelection_additionalPictureMemory :: RefPictureSelection_additionalPictureMemory ( ) : Asn :: Sequence ( 6, true, 0 ), m_sqcifAdditionalPictureMemory ( 0 ), m_qcifAdditionalPictureMemory ( 0 ), m_cifAdditionalPictureMemory ( 0 ), m_cif4AdditionalPictureMemory ( 0 ), m_cif16AdditionalPictureMemory ( 0 ), m_bigCpfAdditionalPictureMemory ( 0 ) { }

RefPictureSelection_additionalPictureMemory & RefPictureSelection_additionalPictureMemory :: operator= ( const RefPictureSelection_additionalPictureMemory & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_sqcifAdditionalPictureMemory, s.m_sqcifAdditionalPictureMemory );
	assignCopy ( m_qcifAdditionalPictureMemory, s.m_qcifAdditionalPictureMemory );
	assignCopy ( m_cifAdditionalPictureMemory, s.m_cifAdditionalPictureMemory );
	assignCopy ( m_cif4AdditionalPictureMemory, s.m_cif4AdditionalPictureMemory );
	assignCopy ( m_cif16AdditionalPictureMemory, s.m_cif16AdditionalPictureMemory );
	assignCopy ( m_bigCpfAdditionalPictureMemory, s.m_bigCpfAdditionalPictureMemory );
	return * this;
}

RefPictureSelection_additionalPictureMemory :: RefPictureSelection_additionalPictureMemory ( const RefPictureSelection_additionalPictureMemory & s ) : Asn :: Sequence ( s ), m_sqcifAdditionalPictureMemory ( 0 ), m_qcifAdditionalPictureMemory ( 0 ), m_cifAdditionalPictureMemory ( 0 ), m_cif4AdditionalPictureMemory ( 0 ), m_cif16AdditionalPictureMemory ( 0 ), m_bigCpfAdditionalPictureMemory ( 0 ) {
	try {
		if ( s.m_sqcifAdditionalPictureMemory )
			m_sqcifAdditionalPictureMemory = new RefPictureSelection_additionalPictureMemory_sqcifAdditionalPictureMemory ( * s.m_sqcifAdditionalPictureMemory );
		if ( s.m_qcifAdditionalPictureMemory )
			m_qcifAdditionalPictureMemory = new RefPictureSelection_additionalPictureMemory_qcifAdditionalPictureMemory ( * s.m_qcifAdditionalPictureMemory );
		if ( s.m_cifAdditionalPictureMemory )
			m_cifAdditionalPictureMemory = new RefPictureSelection_additionalPictureMemory_cifAdditionalPictureMemory ( * s.m_cifAdditionalPictureMemory );
		if ( s.m_cif4AdditionalPictureMemory )
			m_cif4AdditionalPictureMemory = new RefPictureSelection_additionalPictureMemory_cif4AdditionalPictureMemory ( * s.m_cif4AdditionalPictureMemory );
		if ( s.m_cif16AdditionalPictureMemory )
			m_cif16AdditionalPictureMemory = new RefPictureSelection_additionalPictureMemory_cif16AdditionalPictureMemory ( * s.m_cif16AdditionalPictureMemory );
		if ( s.m_bigCpfAdditionalPictureMemory )
			m_bigCpfAdditionalPictureMemory = new RefPictureSelection_additionalPictureMemory_bigCpfAdditionalPictureMemory ( * s.m_bigCpfAdditionalPictureMemory );
	} catch ( ... ) {
		delete m_sqcifAdditionalPictureMemory;
		delete m_qcifAdditionalPictureMemory;
		delete m_cifAdditionalPictureMemory;
		delete m_cif4AdditionalPictureMemory;
		delete m_cif16AdditionalPictureMemory;
		delete m_bigCpfAdditionalPictureMemory;
		throw;
	}
}


void RefPictureSelection_additionalPictureMemory :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_sqcifAdditionalPictureMemory:
			assignNew ( m_sqcifAdditionalPictureMemory, new RefPictureSelection_additionalPictureMemory_sqcifAdditionalPictureMemory );
			break;
		case e_qcifAdditionalPictureMemory:
			assignNew ( m_qcifAdditionalPictureMemory, new RefPictureSelection_additionalPictureMemory_qcifAdditionalPictureMemory );
			break;
		case e_cifAdditionalPictureMemory:
			assignNew ( m_cifAdditionalPictureMemory, new RefPictureSelection_additionalPictureMemory_cifAdditionalPictureMemory );
			break;
		case e_cif4AdditionalPictureMemory:
			assignNew ( m_cif4AdditionalPictureMemory, new RefPictureSelection_additionalPictureMemory_cif4AdditionalPictureMemory );
			break;
		case e_cif16AdditionalPictureMemory:
			assignNew ( m_cif16AdditionalPictureMemory, new RefPictureSelection_additionalPictureMemory_cif16AdditionalPictureMemory );
			break;
		case e_bigCpfAdditionalPictureMemory:
			assignNew ( m_bigCpfAdditionalPictureMemory, new RefPictureSelection_additionalPictureMemory_bigCpfAdditionalPictureMemory );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void RefPictureSelection_additionalPictureMemory :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_sqcifAdditionalPictureMemory:
			delete m_sqcifAdditionalPictureMemory;
			m_sqcifAdditionalPictureMemory = 0;
			break;
		case e_qcifAdditionalPictureMemory:
			delete m_qcifAdditionalPictureMemory;
			m_qcifAdditionalPictureMemory = 0;
			break;
		case e_cifAdditionalPictureMemory:
			delete m_cifAdditionalPictureMemory;
			m_cifAdditionalPictureMemory = 0;
			break;
		case e_cif4AdditionalPictureMemory:
			delete m_cif4AdditionalPictureMemory;
			m_cif4AdditionalPictureMemory = 0;
			break;
		case e_cif16AdditionalPictureMemory:
			delete m_cif16AdditionalPictureMemory;
			m_cif16AdditionalPictureMemory = 0;
			break;
		case e_bigCpfAdditionalPictureMemory:
			delete m_bigCpfAdditionalPictureMemory;
			m_bigCpfAdditionalPictureMemory = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void RefPictureSelection_additionalPictureMemory :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_sqcifAdditionalPictureMemory ) )
		m_sqcifAdditionalPictureMemory -> RefPictureSelection_additionalPictureMemory_sqcifAdditionalPictureMemory :: encode ( os );
	if ( hasOptionalField ( e_qcifAdditionalPictureMemory ) )
		m_qcifAdditionalPictureMemory -> RefPictureSelection_additionalPictureMemory_qcifAdditionalPictureMemory :: encode ( os );
	if ( hasOptionalField ( e_cifAdditionalPictureMemory ) )
		m_cifAdditionalPictureMemory -> RefPictureSelection_additionalPictureMemory_cifAdditionalPictureMemory :: encode ( os );
	if ( hasOptionalField ( e_cif4AdditionalPictureMemory ) )
		m_cif4AdditionalPictureMemory -> RefPictureSelection_additionalPictureMemory_cif4AdditionalPictureMemory :: encode ( os );
	if ( hasOptionalField ( e_cif16AdditionalPictureMemory ) )
		m_cif16AdditionalPictureMemory -> RefPictureSelection_additionalPictureMemory_cif16AdditionalPictureMemory :: encode ( os );
	if ( hasOptionalField ( e_bigCpfAdditionalPictureMemory ) )
		m_bigCpfAdditionalPictureMemory -> RefPictureSelection_additionalPictureMemory_bigCpfAdditionalPictureMemory :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

RefPictureSelection_additionalPictureMemory :: ~RefPictureSelection_additionalPictureMemory ( ) {
	delete m_sqcifAdditionalPictureMemory;
	delete m_qcifAdditionalPictureMemory;
	delete m_cifAdditionalPictureMemory;
	delete m_cif4AdditionalPictureMemory;
	delete m_cif16AdditionalPictureMemory;
	delete m_bigCpfAdditionalPictureMemory;
}

void RefPictureSelection_additionalPictureMemory :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_sqcifAdditionalPictureMemory ) ) {
		os << std :: setw ( indent + 31 ) << "sqcifAdditionalPictureMemory = " << std :: setprecision ( indent );
		m_sqcifAdditionalPictureMemory -> RefPictureSelection_additionalPictureMemory_sqcifAdditionalPictureMemory :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_qcifAdditionalPictureMemory ) ) {
		os << std :: setw ( indent + 30 ) << "qcifAdditionalPictureMemory = " << std :: setprecision ( indent );
		m_qcifAdditionalPictureMemory -> RefPictureSelection_additionalPictureMemory_qcifAdditionalPictureMemory :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cifAdditionalPictureMemory ) ) {
		os << std :: setw ( indent + 29 ) << "cifAdditionalPictureMemory = " << std :: setprecision ( indent );
		m_cifAdditionalPictureMemory -> RefPictureSelection_additionalPictureMemory_cifAdditionalPictureMemory :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cif4AdditionalPictureMemory ) ) {
		os << std :: setw ( indent + 30 ) << "cif4AdditionalPictureMemory = " << std :: setprecision ( indent );
		m_cif4AdditionalPictureMemory -> RefPictureSelection_additionalPictureMemory_cif4AdditionalPictureMemory :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cif16AdditionalPictureMemory ) ) {
		os << std :: setw ( indent + 31 ) << "cif16AdditionalPictureMemory = " << std :: setprecision ( indent );
		m_cif16AdditionalPictureMemory -> RefPictureSelection_additionalPictureMemory_cif16AdditionalPictureMemory :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_bigCpfAdditionalPictureMemory ) ) {
		os << std :: setw ( indent + 32 ) << "bigCpfAdditionalPictureMemory = " << std :: setprecision ( indent );
		m_bigCpfAdditionalPictureMemory -> RefPictureSelection_additionalPictureMemory_bigCpfAdditionalPictureMemory :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RefPictureSelection_additionalPictureMemory * RefPictureSelection_additionalPictureMemory :: clone ( ) const {
	return new RefPictureSelection_additionalPictureMemory ( * this );
}

//
// RefPictureSelection_videoBackChannelSend
//

RefPictureSelection_videoBackChannelSend :: RefPictureSelection_videoBackChannelSend ( Asn :: istream & is ) : Asn :: Choice ( is, 5, true ) {
	switch ( tag ) {
		case e_none:
		case e_ackMessageOnly:
		case e_nackMessageOnly:
		case e_ackOrNackMessageOnly:
		case e_ackAndNackMessage:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

RefPictureSelection_videoBackChannelSend :: RefPictureSelection_videoBackChannelSend ( ) : Asn :: Choice ( 5, true ) { }

void RefPictureSelection_videoBackChannelSend :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_none:
		case e_ackMessageOnly:
		case e_nackMessageOnly:
		case e_ackOrNackMessageOnly:
		case e_ackAndNackMessage:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & RefPictureSelection_videoBackChannelSend :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_none, "none" },
		{ e_ackMessageOnly, "ackMessageOnly" },
		{ e_nackMessageOnly, "nackMessageOnly" },
		{ e_ackOrNackMessageOnly, "ackOrNackMessageOnly" },
		{ e_ackAndNackMessage, "ackAndNackMessage" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

RefPictureSelection_videoBackChannelSend * RefPictureSelection_videoBackChannelSend :: clone ( ) const {
	return new RefPictureSelection_videoBackChannelSend ( * this );
}

//
// RefPictureSelection_enhancedReferencePicSelect
//

RefPictureSelection_enhancedReferencePicSelect :: RefPictureSelection_enhancedReferencePicSelect ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_subPictureRemovalParameters ( 0 ) {
	try {
		if ( hasOptionalField ( e_subPictureRemovalParameters ) )
			m_subPictureRemovalParameters = new RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_subPictureRemovalParameters;
		throw;
	}
}

RefPictureSelection_enhancedReferencePicSelect :: RefPictureSelection_enhancedReferencePicSelect ( ) : Asn :: Sequence ( 1, true, 0 ), m_subPictureRemovalParameters ( 0 ) { }

RefPictureSelection_enhancedReferencePicSelect & RefPictureSelection_enhancedReferencePicSelect :: operator= ( const RefPictureSelection_enhancedReferencePicSelect & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_subPictureRemovalParameters, s.m_subPictureRemovalParameters );
	return * this;
}

RefPictureSelection_enhancedReferencePicSelect :: RefPictureSelection_enhancedReferencePicSelect ( const RefPictureSelection_enhancedReferencePicSelect & s ) : Asn :: Sequence ( s ), m_subPictureRemovalParameters ( 0 ) {
	try {
		if ( s.m_subPictureRemovalParameters )
			m_subPictureRemovalParameters = new RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters ( * s.m_subPictureRemovalParameters );
	} catch ( ... ) {
		delete m_subPictureRemovalParameters;
		throw;
	}
}


void RefPictureSelection_enhancedReferencePicSelect :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_subPictureRemovalParameters:
			assignNew ( m_subPictureRemovalParameters, new RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void RefPictureSelection_enhancedReferencePicSelect :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_subPictureRemovalParameters:
			delete m_subPictureRemovalParameters;
			m_subPictureRemovalParameters = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void RefPictureSelection_enhancedReferencePicSelect :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_subPictureRemovalParameters ) )
		m_subPictureRemovalParameters -> RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

RefPictureSelection_enhancedReferencePicSelect :: ~RefPictureSelection_enhancedReferencePicSelect ( ) {
	delete m_subPictureRemovalParameters;
}

void RefPictureSelection_enhancedReferencePicSelect :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_subPictureRemovalParameters ) ) {
		os << std :: setw ( indent + 30 ) << "subPictureRemovalParameters = " << std :: setprecision ( indent );
		m_subPictureRemovalParameters -> RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RefPictureSelection_enhancedReferencePicSelect * RefPictureSelection_enhancedReferencePicSelect :: clone ( ) const {
	return new RefPictureSelection_enhancedReferencePicSelect ( * this );
}

//
// CustomPictureClockFrequency_clockConversionCode
//

CustomPictureClockFrequency_clockConversionCode :: CustomPictureClockFrequency_clockConversionCode ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1000, 1001 ) { }

CustomPictureClockFrequency_clockConversionCode :: CustomPictureClockFrequency_clockConversionCode ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1000, 1001 ) { }

CustomPictureClockFrequency_clockConversionCode * CustomPictureClockFrequency_clockConversionCode :: clone ( ) const {
	return new CustomPictureClockFrequency_clockConversionCode ( * this );
}

//
// CustomPictureClockFrequency_clockDivisor
//

CustomPictureClockFrequency_clockDivisor :: CustomPictureClockFrequency_clockDivisor ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 127 ) { }

CustomPictureClockFrequency_clockDivisor :: CustomPictureClockFrequency_clockDivisor ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 127 ) { }

CustomPictureClockFrequency_clockDivisor * CustomPictureClockFrequency_clockDivisor :: clone ( ) const {
	return new CustomPictureClockFrequency_clockDivisor ( * this );
}

//
// CustomPictureClockFrequency_sqcifMPI
//

CustomPictureClockFrequency_sqcifMPI :: CustomPictureClockFrequency_sqcifMPI ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 2048 ) { }

CustomPictureClockFrequency_sqcifMPI :: CustomPictureClockFrequency_sqcifMPI ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 2048 ) { }

CustomPictureClockFrequency_sqcifMPI * CustomPictureClockFrequency_sqcifMPI :: clone ( ) const {
	return new CustomPictureClockFrequency_sqcifMPI ( * this );
}

//
// CustomPictureClockFrequency_qcifMPI
//

CustomPictureClockFrequency_qcifMPI :: CustomPictureClockFrequency_qcifMPI ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 2048 ) { }

CustomPictureClockFrequency_qcifMPI :: CustomPictureClockFrequency_qcifMPI ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 2048 ) { }

CustomPictureClockFrequency_qcifMPI * CustomPictureClockFrequency_qcifMPI :: clone ( ) const {
	return new CustomPictureClockFrequency_qcifMPI ( * this );
}

//
// CustomPictureClockFrequency_cifMPI
//

CustomPictureClockFrequency_cifMPI :: CustomPictureClockFrequency_cifMPI ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 2048 ) { }

CustomPictureClockFrequency_cifMPI :: CustomPictureClockFrequency_cifMPI ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 2048 ) { }

CustomPictureClockFrequency_cifMPI * CustomPictureClockFrequency_cifMPI :: clone ( ) const {
	return new CustomPictureClockFrequency_cifMPI ( * this );
}

//
// CustomPictureClockFrequency_cif4MPI
//

CustomPictureClockFrequency_cif4MPI :: CustomPictureClockFrequency_cif4MPI ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 2048 ) { }

CustomPictureClockFrequency_cif4MPI :: CustomPictureClockFrequency_cif4MPI ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 2048 ) { }

CustomPictureClockFrequency_cif4MPI * CustomPictureClockFrequency_cif4MPI :: clone ( ) const {
	return new CustomPictureClockFrequency_cif4MPI ( * this );
}

//
// CustomPictureClockFrequency_cif16MPI
//

CustomPictureClockFrequency_cif16MPI :: CustomPictureClockFrequency_cif16MPI ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 2048 ) { }

CustomPictureClockFrequency_cif16MPI :: CustomPictureClockFrequency_cif16MPI ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 2048 ) { }

CustomPictureClockFrequency_cif16MPI * CustomPictureClockFrequency_cif16MPI :: clone ( ) const {
	return new CustomPictureClockFrequency_cif16MPI ( * this );
}

//
// CustomPictureFormat_maxCustomPictureWidth
//

CustomPictureFormat_maxCustomPictureWidth :: CustomPictureFormat_maxCustomPictureWidth ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 2048 ) { }

CustomPictureFormat_maxCustomPictureWidth :: CustomPictureFormat_maxCustomPictureWidth ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 2048 ) { }

CustomPictureFormat_maxCustomPictureWidth * CustomPictureFormat_maxCustomPictureWidth :: clone ( ) const {
	return new CustomPictureFormat_maxCustomPictureWidth ( * this );
}

//
// CustomPictureFormat_maxCustomPictureHeight
//

CustomPictureFormat_maxCustomPictureHeight :: CustomPictureFormat_maxCustomPictureHeight ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 2048 ) { }

CustomPictureFormat_maxCustomPictureHeight :: CustomPictureFormat_maxCustomPictureHeight ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 2048 ) { }

CustomPictureFormat_maxCustomPictureHeight * CustomPictureFormat_maxCustomPictureHeight :: clone ( ) const {
	return new CustomPictureFormat_maxCustomPictureHeight ( * this );
}

//
// CustomPictureFormat_minCustomPictureWidth
//

CustomPictureFormat_minCustomPictureWidth :: CustomPictureFormat_minCustomPictureWidth ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 2048 ) { }

CustomPictureFormat_minCustomPictureWidth :: CustomPictureFormat_minCustomPictureWidth ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 2048 ) { }

CustomPictureFormat_minCustomPictureWidth * CustomPictureFormat_minCustomPictureWidth :: clone ( ) const {
	return new CustomPictureFormat_minCustomPictureWidth ( * this );
}

//
// CustomPictureFormat_minCustomPictureHeight
//

CustomPictureFormat_minCustomPictureHeight :: CustomPictureFormat_minCustomPictureHeight ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 2048 ) { }

CustomPictureFormat_minCustomPictureHeight :: CustomPictureFormat_minCustomPictureHeight ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 2048 ) { }

CustomPictureFormat_minCustomPictureHeight * CustomPictureFormat_minCustomPictureHeight :: clone ( ) const {
	return new CustomPictureFormat_minCustomPictureHeight ( * this );
}

//
// CustomPictureFormat_mPI
//

CustomPictureFormat_mPI :: CustomPictureFormat_mPI ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 0 ), m_standardMPI ( 0 ), m_customPCF ( 0 ) {
	try {
		if ( hasOptionalField ( e_standardMPI ) )
			m_standardMPI = new CustomPictureFormat_mPI_standardMPI ( is );
		if ( hasOptionalField ( e_customPCF ) )
			m_customPCF = new CustomPictureFormat_mPI_customPCF ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_standardMPI;
		delete m_customPCF;
		throw;
	}
}

CustomPictureFormat_mPI :: CustomPictureFormat_mPI ( ) : Asn :: Sequence ( 2, true, 0 ), m_standardMPI ( 0 ), m_customPCF ( 0 ) { }

CustomPictureFormat_mPI & CustomPictureFormat_mPI :: operator= ( const CustomPictureFormat_mPI & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_standardMPI, s.m_standardMPI );
	assignCopy ( m_customPCF, s.m_customPCF );
	return * this;
}

CustomPictureFormat_mPI :: CustomPictureFormat_mPI ( const CustomPictureFormat_mPI & s ) : Asn :: Sequence ( s ), m_standardMPI ( 0 ), m_customPCF ( 0 ) {
	try {
		if ( s.m_standardMPI )
			m_standardMPI = new CustomPictureFormat_mPI_standardMPI ( * s.m_standardMPI );
		if ( s.m_customPCF )
			m_customPCF = new CustomPictureFormat_mPI_customPCF ( * s.m_customPCF );
	} catch ( ... ) {
		delete m_standardMPI;
		delete m_customPCF;
		throw;
	}
}


void CustomPictureFormat_mPI :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_standardMPI:
			assignNew ( m_standardMPI, new CustomPictureFormat_mPI_standardMPI );
			break;
		case e_customPCF:
			assignNew ( m_customPCF, new CustomPictureFormat_mPI_customPCF );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void CustomPictureFormat_mPI :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_standardMPI:
			delete m_standardMPI;
			m_standardMPI = 0;
			break;
		case e_customPCF:
			delete m_customPCF;
			m_customPCF = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void CustomPictureFormat_mPI :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_standardMPI ) )
		m_standardMPI -> CustomPictureFormat_mPI_standardMPI :: encode ( os );
	if ( hasOptionalField ( e_customPCF ) )
		m_customPCF -> CustomPictureFormat_mPI_customPCF :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

CustomPictureFormat_mPI :: ~CustomPictureFormat_mPI ( ) {
	delete m_standardMPI;
	delete m_customPCF;
}

void CustomPictureFormat_mPI :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_standardMPI ) ) {
		os << std :: setw ( indent + 14 ) << "standardMPI = " << std :: setprecision ( indent );
		m_standardMPI -> CustomPictureFormat_mPI_standardMPI :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_customPCF ) ) {
		os << std :: setw ( indent + 12 ) << "customPCF = " << std :: setprecision ( indent );
		m_customPCF -> CustomPictureFormat_mPI_customPCF :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

CustomPictureFormat_mPI * CustomPictureFormat_mPI :: clone ( ) const {
	return new CustomPictureFormat_mPI ( * this );
}

//
// H263VideoModeCombos_h263VideoCoupledModes
//

H263VideoModeCombos_h263VideoCoupledModes :: H263VideoModeCombos_h263VideoCoupledModes ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 16 ) { }

H263VideoModeCombos_h263VideoCoupledModes :: H263VideoModeCombos_h263VideoCoupledModes ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 16 ) { }

H263VideoModeCombos_h263VideoCoupledModes :: H263VideoModeCombos_h263VideoCoupledModes ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 16 ) { }


Asn :: Object * H263VideoModeCombos_h263VideoCoupledModes :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * H263VideoModeCombos_h263VideoCoupledModes :: createObject ( Asn :: istream & is ) {
	return new H263ModeComboFlags ( is );
}

Asn :: Object * H263VideoModeCombos_h263VideoCoupledModes :: createObject ( ) {
	return new H263ModeComboFlags ( );
}

H263ModeComboFlags & H263VideoModeCombos_h263VideoCoupledModes :: operator[] ( std :: size_t i ) {
	return dynamic_cast < H263ModeComboFlags & > ( Asn :: Array :: operator[] ( i ) );
}

void H263VideoModeCombos_h263VideoCoupledModes :: push_back ( const H263ModeComboFlags & o ) {
	Asn :: Array :: push_back ( new H263ModeComboFlags ( o ) );
}

const H263ModeComboFlags & H263VideoModeCombos_h263VideoCoupledModes :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const H263ModeComboFlags & > ( Asn :: Array :: operator[] ( i ) );
}

H263VideoModeCombos_h263VideoCoupledModes * H263VideoModeCombos_h263VideoCoupledModes :: clone ( ) const {
	return new H263VideoModeCombos_h263VideoCoupledModes ( * this );
}

//
// IS11172VideoCapability_videoBitRate
//

IS11172VideoCapability_videoBitRate :: IS11172VideoCapability_videoBitRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 1073741823 ) { }

IS11172VideoCapability_videoBitRate :: IS11172VideoCapability_videoBitRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 1073741823 ) { }

IS11172VideoCapability_videoBitRate * IS11172VideoCapability_videoBitRate :: clone ( ) const {
	return new IS11172VideoCapability_videoBitRate ( * this );
}

//
// IS11172VideoCapability_vbvBufferSize
//

IS11172VideoCapability_vbvBufferSize :: IS11172VideoCapability_vbvBufferSize ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 262143 ) { }

IS11172VideoCapability_vbvBufferSize :: IS11172VideoCapability_vbvBufferSize ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 262143 ) { }

IS11172VideoCapability_vbvBufferSize * IS11172VideoCapability_vbvBufferSize :: clone ( ) const {
	return new IS11172VideoCapability_vbvBufferSize ( * this );
}

//
// IS11172VideoCapability_samplesPerLine
//

IS11172VideoCapability_samplesPerLine :: IS11172VideoCapability_samplesPerLine ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 16383 ) { }

IS11172VideoCapability_samplesPerLine :: IS11172VideoCapability_samplesPerLine ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 16383 ) { }

IS11172VideoCapability_samplesPerLine * IS11172VideoCapability_samplesPerLine :: clone ( ) const {
	return new IS11172VideoCapability_samplesPerLine ( * this );
}

//
// IS11172VideoCapability_linesPerFrame
//

IS11172VideoCapability_linesPerFrame :: IS11172VideoCapability_linesPerFrame ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 16383 ) { }

IS11172VideoCapability_linesPerFrame :: IS11172VideoCapability_linesPerFrame ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 16383 ) { }

IS11172VideoCapability_linesPerFrame * IS11172VideoCapability_linesPerFrame :: clone ( ) const {
	return new IS11172VideoCapability_linesPerFrame ( * this );
}

//
// IS11172VideoCapability_pictureRate
//

IS11172VideoCapability_pictureRate :: IS11172VideoCapability_pictureRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 15 ) { }

IS11172VideoCapability_pictureRate :: IS11172VideoCapability_pictureRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 15 ) { }

IS11172VideoCapability_pictureRate * IS11172VideoCapability_pictureRate :: clone ( ) const {
	return new IS11172VideoCapability_pictureRate ( * this );
}

//
// IS11172VideoCapability_luminanceSampleRate
//

IS11172VideoCapability_luminanceSampleRate :: IS11172VideoCapability_luminanceSampleRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 4294967295U ) { }

IS11172VideoCapability_luminanceSampleRate :: IS11172VideoCapability_luminanceSampleRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 4294967295U ) { }

IS11172VideoCapability_luminanceSampleRate * IS11172VideoCapability_luminanceSampleRate :: clone ( ) const {
	return new IS11172VideoCapability_luminanceSampleRate ( * this );
}

//
// AudioCapability_g711Alaw64k
//

AudioCapability_g711Alaw64k :: AudioCapability_g711Alaw64k ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 256 ) { }

AudioCapability_g711Alaw64k :: AudioCapability_g711Alaw64k ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 256 ) { }

AudioCapability_g711Alaw64k * AudioCapability_g711Alaw64k :: clone ( ) const {
	return new AudioCapability_g711Alaw64k ( * this );
}

//
// AudioCapability_g711Alaw56k
//

AudioCapability_g711Alaw56k :: AudioCapability_g711Alaw56k ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 256 ) { }

AudioCapability_g711Alaw56k :: AudioCapability_g711Alaw56k ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 256 ) { }

AudioCapability_g711Alaw56k * AudioCapability_g711Alaw56k :: clone ( ) const {
	return new AudioCapability_g711Alaw56k ( * this );
}

//
// AudioCapability_g711Ulaw64k
//

AudioCapability_g711Ulaw64k :: AudioCapability_g711Ulaw64k ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 256 ) { }

AudioCapability_g711Ulaw64k :: AudioCapability_g711Ulaw64k ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 256 ) { }

AudioCapability_g711Ulaw64k * AudioCapability_g711Ulaw64k :: clone ( ) const {
	return new AudioCapability_g711Ulaw64k ( * this );
}

//
// AudioCapability_g711Ulaw56k
//

AudioCapability_g711Ulaw56k :: AudioCapability_g711Ulaw56k ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 256 ) { }

AudioCapability_g711Ulaw56k :: AudioCapability_g711Ulaw56k ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 256 ) { }

AudioCapability_g711Ulaw56k * AudioCapability_g711Ulaw56k :: clone ( ) const {
	return new AudioCapability_g711Ulaw56k ( * this );
}

//
// AudioCapability_g722-64k
//

AudioCapability_g722_64k :: AudioCapability_g722_64k ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 256 ) { }

AudioCapability_g722_64k :: AudioCapability_g722_64k ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 256 ) { }

AudioCapability_g722_64k * AudioCapability_g722_64k :: clone ( ) const {
	return new AudioCapability_g722_64k ( * this );
}

//
// AudioCapability_g722-56k
//

AudioCapability_g722_56k :: AudioCapability_g722_56k ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 256 ) { }

AudioCapability_g722_56k :: AudioCapability_g722_56k ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 256 ) { }

AudioCapability_g722_56k * AudioCapability_g722_56k :: clone ( ) const {
	return new AudioCapability_g722_56k ( * this );
}

//
// AudioCapability_g722-48k
//

AudioCapability_g722_48k :: AudioCapability_g722_48k ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 256 ) { }

AudioCapability_g722_48k :: AudioCapability_g722_48k ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 256 ) { }

AudioCapability_g722_48k * AudioCapability_g722_48k :: clone ( ) const {
	return new AudioCapability_g722_48k ( * this );
}

//
// AudioCapability_g728
//

AudioCapability_g728 :: AudioCapability_g728 ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 256 ) { }

AudioCapability_g728 :: AudioCapability_g728 ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 256 ) { }

AudioCapability_g728 * AudioCapability_g728 :: clone ( ) const {
	return new AudioCapability_g728 ( * this );
}

//
// AudioCapability_g729
//

AudioCapability_g729 :: AudioCapability_g729 ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 256 ) { }

AudioCapability_g729 :: AudioCapability_g729 ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 256 ) { }

AudioCapability_g729 * AudioCapability_g729 :: clone ( ) const {
	return new AudioCapability_g729 ( * this );
}

//
// AudioCapability_g729AnnexA
//

AudioCapability_g729AnnexA :: AudioCapability_g729AnnexA ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 256 ) { }

AudioCapability_g729AnnexA :: AudioCapability_g729AnnexA ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 256 ) { }

AudioCapability_g729AnnexA * AudioCapability_g729AnnexA :: clone ( ) const {
	return new AudioCapability_g729AnnexA ( * this );
}

//
// AudioCapability_g729wAnnexB
//

AudioCapability_g729wAnnexB :: AudioCapability_g729wAnnexB ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 256 ) { }

AudioCapability_g729wAnnexB :: AudioCapability_g729wAnnexB ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 256 ) { }

AudioCapability_g729wAnnexB * AudioCapability_g729wAnnexB :: clone ( ) const {
	return new AudioCapability_g729wAnnexB ( * this );
}

//
// AudioCapability_g729AnnexAwAnnexB
//

AudioCapability_g729AnnexAwAnnexB :: AudioCapability_g729AnnexAwAnnexB ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 256 ) { }

AudioCapability_g729AnnexAwAnnexB :: AudioCapability_g729AnnexAwAnnexB ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 256 ) { }

AudioCapability_g729AnnexAwAnnexB * AudioCapability_g729AnnexAwAnnexB :: clone ( ) const {
	return new AudioCapability_g729AnnexAwAnnexB ( * this );
}

//
// G729Extensions_audioUnit
//

G729Extensions_audioUnit :: G729Extensions_audioUnit ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 256 ) { }

G729Extensions_audioUnit :: G729Extensions_audioUnit ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 256 ) { }

G729Extensions_audioUnit * G729Extensions_audioUnit :: clone ( ) const {
	return new G729Extensions_audioUnit ( * this );
}

//
// G7231AnnexCCapability_maxAl-sduAudioFrames
//

G7231AnnexCCapability_maxAl_sduAudioFrames :: G7231AnnexCCapability_maxAl_sduAudioFrames ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 256 ) { }

G7231AnnexCCapability_maxAl_sduAudioFrames :: G7231AnnexCCapability_maxAl_sduAudioFrames ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 256 ) { }

G7231AnnexCCapability_maxAl_sduAudioFrames * G7231AnnexCCapability_maxAl_sduAudioFrames :: clone ( ) const {
	return new G7231AnnexCCapability_maxAl_sduAudioFrames ( * this );
}

//
// IS11172AudioCapability_bitRate
//

IS11172AudioCapability_bitRate :: IS11172AudioCapability_bitRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 448 ) { }

IS11172AudioCapability_bitRate :: IS11172AudioCapability_bitRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 448 ) { }

IS11172AudioCapability_bitRate * IS11172AudioCapability_bitRate :: clone ( ) const {
	return new IS11172AudioCapability_bitRate ( * this );
}

//
// IS13818AudioCapability_bitRate
//

IS13818AudioCapability_bitRate :: IS13818AudioCapability_bitRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 1130 ) { }

IS13818AudioCapability_bitRate :: IS13818AudioCapability_bitRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 1130 ) { }

IS13818AudioCapability_bitRate * IS13818AudioCapability_bitRate :: clone ( ) const {
	return new IS13818AudioCapability_bitRate ( * this );
}

//
// GSMAudioCapability_audioUnitSize
//

GSMAudioCapability_audioUnitSize :: GSMAudioCapability_audioUnitSize ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 256 ) { }

GSMAudioCapability_audioUnitSize :: GSMAudioCapability_audioUnitSize ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 256 ) { }

GSMAudioCapability_audioUnitSize * GSMAudioCapability_audioUnitSize :: clone ( ) const {
	return new GSMAudioCapability_audioUnitSize ( * this );
}

//
// DataApplicationCapability_maxBitRate
//

DataApplicationCapability_maxBitRate :: DataApplicationCapability_maxBitRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 4294967295U ) { }

DataApplicationCapability_maxBitRate :: DataApplicationCapability_maxBitRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 4294967295U ) { }

DataApplicationCapability_maxBitRate * DataApplicationCapability_maxBitRate :: clone ( ) const {
	return new DataApplicationCapability_maxBitRate ( * this );
}

//
// V42bis_numberOfCodewords
//

V42bis_numberOfCodewords :: V42bis_numberOfCodewords ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 65536 ) { }

V42bis_numberOfCodewords :: V42bis_numberOfCodewords ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 65536 ) { }

V42bis_numberOfCodewords * V42bis_numberOfCodewords :: clone ( ) const {
	return new V42bis_numberOfCodewords ( * this );
}

//
// V42bis_maximumStringLength
//

V42bis_maximumStringLength :: V42bis_maximumStringLength ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 256 ) { }

V42bis_maximumStringLength :: V42bis_maximumStringLength ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 256 ) { }

V42bis_maximumStringLength * V42bis_maximumStringLength :: clone ( ) const {
	return new V42bis_maximumStringLength ( * this );
}

//
// T84Profile_t84Restricted
//

T84Profile_t84Restricted :: T84Profile_t84Restricted ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_qcif ( is ), m_cif ( is ), m_ccir601Seq ( is ), m_ccir601Prog ( is ), m_hdtvSeq ( is ), m_hdtvProg ( is ), m_g3FacsMH200x100 ( is ), m_g3FacsMH200x200 ( is ), m_g4FacsMMR200x100 ( is ), m_g4FacsMMR200x200 ( is ), m_jbig200x200Seq ( is ), m_jbig200x200Prog ( is ), m_jbig300x300Seq ( is ), m_jbig300x300Prog ( is ), m_digPhotoLow ( is ), m_digPhotoMedSeq ( is ), m_digPhotoMedProg ( is ), m_digPhotoHighSeq ( is ), m_digPhotoHighProg ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

T84Profile_t84Restricted :: T84Profile_t84Restricted ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void T84Profile_t84Restricted :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_qcif.encode ( os );
	m_cif.encode ( os );
	m_ccir601Seq.encode ( os );
	m_ccir601Prog.encode ( os );
	m_hdtvSeq.encode ( os );
	m_hdtvProg.encode ( os );
	m_g3FacsMH200x100.encode ( os );
	m_g3FacsMH200x200.encode ( os );
	m_g4FacsMMR200x100.encode ( os );
	m_g4FacsMMR200x200.encode ( os );
	m_jbig200x200Seq.encode ( os );
	m_jbig200x200Prog.encode ( os );
	m_jbig300x300Seq.encode ( os );
	m_jbig300x300Prog.encode ( os );
	m_digPhotoLow.encode ( os );
	m_digPhotoMedSeq.encode ( os );
	m_digPhotoMedProg.encode ( os );
	m_digPhotoHighSeq.encode ( os );
	m_digPhotoHighProg.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void T84Profile_t84Restricted :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 7 ) << "qcif = " << std :: setprecision ( indent ) << m_qcif << '\n';
	os << std :: setw ( indent + 6 ) << "cif = " << std :: setprecision ( indent ) << m_cif << '\n';
	os << std :: setw ( indent + 13 ) << "ccir601Seq = " << std :: setprecision ( indent ) << m_ccir601Seq << '\n';
	os << std :: setw ( indent + 14 ) << "ccir601Prog = " << std :: setprecision ( indent ) << m_ccir601Prog << '\n';
	os << std :: setw ( indent + 10 ) << "hdtvSeq = " << std :: setprecision ( indent ) << m_hdtvSeq << '\n';
	os << std :: setw ( indent + 11 ) << "hdtvProg = " << std :: setprecision ( indent ) << m_hdtvProg << '\n';
	os << std :: setw ( indent + 18 ) << "g3FacsMH200x100 = " << std :: setprecision ( indent ) << m_g3FacsMH200x100 << '\n';
	os << std :: setw ( indent + 18 ) << "g3FacsMH200x200 = " << std :: setprecision ( indent ) << m_g3FacsMH200x200 << '\n';
	os << std :: setw ( indent + 19 ) << "g4FacsMMR200x100 = " << std :: setprecision ( indent ) << m_g4FacsMMR200x100 << '\n';
	os << std :: setw ( indent + 19 ) << "g4FacsMMR200x200 = " << std :: setprecision ( indent ) << m_g4FacsMMR200x200 << '\n';
	os << std :: setw ( indent + 17 ) << "jbig200x200Seq = " << std :: setprecision ( indent ) << m_jbig200x200Seq << '\n';
	os << std :: setw ( indent + 18 ) << "jbig200x200Prog = " << std :: setprecision ( indent ) << m_jbig200x200Prog << '\n';
	os << std :: setw ( indent + 17 ) << "jbig300x300Seq = " << std :: setprecision ( indent ) << m_jbig300x300Seq << '\n';
	os << std :: setw ( indent + 18 ) << "jbig300x300Prog = " << std :: setprecision ( indent ) << m_jbig300x300Prog << '\n';
	os << std :: setw ( indent + 14 ) << "digPhotoLow = " << std :: setprecision ( indent ) << m_digPhotoLow << '\n';
	os << std :: setw ( indent + 17 ) << "digPhotoMedSeq = " << std :: setprecision ( indent ) << m_digPhotoMedSeq << '\n';
	os << std :: setw ( indent + 18 ) << "digPhotoMedProg = " << std :: setprecision ( indent ) << m_digPhotoMedProg << '\n';
	os << std :: setw ( indent + 18 ) << "digPhotoHighSeq = " << std :: setprecision ( indent ) << m_digPhotoHighSeq << '\n';
	os << std :: setw ( indent + 19 ) << "digPhotoHighProg = " << std :: setprecision ( indent ) << m_digPhotoHighProg << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

T84Profile_t84Restricted * T84Profile_t84Restricted :: clone ( ) const {
	return new T84Profile_t84Restricted ( * this );
}

//
// T38FaxProfile_version
//

T38FaxProfile_version :: T38FaxProfile_version ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 255 ) { }

T38FaxProfile_version :: T38FaxProfile_version ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 255 ) { }

T38FaxProfile_version * T38FaxProfile_version :: clone ( ) const {
	return new T38FaxProfile_version ( * this );
}

//
// T38FaxUdpOptions_t38FaxUdpEC
//

T38FaxUdpOptions_t38FaxUdpEC :: T38FaxUdpOptions_t38FaxUdpEC ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_t38UDPFEC:
		case e_t38UDPRedundancy:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

T38FaxUdpOptions_t38FaxUdpEC :: T38FaxUdpOptions_t38FaxUdpEC ( ) : Asn :: Choice ( 2, true ) { }

void T38FaxUdpOptions_t38FaxUdpEC :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_t38UDPFEC:
		case e_t38UDPRedundancy:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & T38FaxUdpOptions_t38FaxUdpEC :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_t38UDPFEC, "t38UDPFEC" },
		{ e_t38UDPRedundancy, "t38UDPRedundancy" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

T38FaxUdpOptions_t38FaxUdpEC * T38FaxUdpOptions_t38FaxUdpEC :: clone ( ) const {
	return new T38FaxUdpOptions_t38FaxUdpEC ( * this );
}

//
// UserInputCapability_nonStandard
//

UserInputCapability_nonStandard :: UserInputCapability_nonStandard ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 16 ) { }

UserInputCapability_nonStandard :: UserInputCapability_nonStandard ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 16 ) { }

UserInputCapability_nonStandard :: UserInputCapability_nonStandard ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 16 ) { }


Asn :: Object * UserInputCapability_nonStandard :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * UserInputCapability_nonStandard :: createObject ( Asn :: istream & is ) {
	return new NonStandardParameter ( is );
}

Asn :: Object * UserInputCapability_nonStandard :: createObject ( ) {
	return new NonStandardParameter ( );
}

NonStandardParameter & UserInputCapability_nonStandard :: operator[] ( std :: size_t i ) {
	return dynamic_cast < NonStandardParameter & > ( Asn :: Array :: operator[] ( i ) );
}

void UserInputCapability_nonStandard :: push_back ( const NonStandardParameter & o ) {
	Asn :: Array :: push_back ( new NonStandardParameter ( o ) );
}

const NonStandardParameter & UserInputCapability_nonStandard :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const NonStandardParameter & > ( Asn :: Array :: operator[] ( i ) );
}

UserInputCapability_nonStandard * UserInputCapability_nonStandard :: clone ( ) const {
	return new UserInputCapability_nonStandard ( * this );
}

//
// ArrayOf_NonStandardParameter
//

ArrayOf_NonStandardParameter :: ArrayOf_NonStandardParameter ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_NonStandardParameter :: ArrayOf_NonStandardParameter ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_NonStandardParameter :: ArrayOf_NonStandardParameter ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_NonStandardParameter :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_NonStandardParameter :: createObject ( Asn :: istream & is ) {
	return new NonStandardParameter ( is );
}

Asn :: Object * ArrayOf_NonStandardParameter :: createObject ( ) {
	return new NonStandardParameter ( );
}

NonStandardParameter & ArrayOf_NonStandardParameter :: operator[] ( std :: size_t i ) {
	return dynamic_cast < NonStandardParameter & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_NonStandardParameter :: push_back ( const NonStandardParameter & o ) {
	Asn :: Array :: push_back ( new NonStandardParameter ( o ) );
}

const NonStandardParameter & ArrayOf_NonStandardParameter :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const NonStandardParameter & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_NonStandardParameter * ArrayOf_NonStandardParameter :: clone ( ) const {
	return new ArrayOf_NonStandardParameter ( * this );
}

//
// GenericCapability_maxBitRate
//

GenericCapability_maxBitRate :: GenericCapability_maxBitRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 4294967295U ) { }

GenericCapability_maxBitRate :: GenericCapability_maxBitRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 4294967295U ) { }

GenericCapability_maxBitRate * GenericCapability_maxBitRate :: clone ( ) const {
	return new GenericCapability_maxBitRate ( * this );
}

//
// CapabilityIdentifier_uuid
//

CapabilityIdentifier_uuid :: CapabilityIdentifier_uuid ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 16, 16 ) { }

CapabilityIdentifier_uuid :: CapabilityIdentifier_uuid ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 16, 16 ) { }

CapabilityIdentifier_uuid * CapabilityIdentifier_uuid :: clone ( ) const {
	return new CapabilityIdentifier_uuid ( * this );
}

//
// CapabilityIdentifier_domainBased
//

CapabilityIdentifier_domainBased :: CapabilityIdentifier_domainBased ( Asn :: istream & is ) : Asn :: IA5String ( is, Asn :: fixedConstraint, 1, 64 ) { }

CapabilityIdentifier_domainBased :: CapabilityIdentifier_domainBased ( const Asn :: string & v ) : Asn :: IA5String ( v, Asn :: fixedConstraint, 1, 64 ) { }

CapabilityIdentifier_domainBased * CapabilityIdentifier_domainBased :: clone ( ) const {
	return new CapabilityIdentifier_domainBased ( * this );
}

//
// ArrayOf_ParameterIdentifier
//

ArrayOf_ParameterIdentifier :: ArrayOf_ParameterIdentifier ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_ParameterIdentifier :: ArrayOf_ParameterIdentifier ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_ParameterIdentifier :: ArrayOf_ParameterIdentifier ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_ParameterIdentifier :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_ParameterIdentifier :: createObject ( Asn :: istream & is ) {
	return new ParameterIdentifier ( is );
}

Asn :: Object * ArrayOf_ParameterIdentifier :: createObject ( ) {
	return new ParameterIdentifier ( );
}

ParameterIdentifier & ArrayOf_ParameterIdentifier :: operator[] ( std :: size_t i ) {
	return dynamic_cast < ParameterIdentifier & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_ParameterIdentifier :: push_back ( const ParameterIdentifier & o ) {
	Asn :: Array :: push_back ( new ParameterIdentifier ( o ) );
}

const ParameterIdentifier & ArrayOf_ParameterIdentifier :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const ParameterIdentifier & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_ParameterIdentifier * ArrayOf_ParameterIdentifier :: clone ( ) const {
	return new ArrayOf_ParameterIdentifier ( * this );
}

//
// ParameterIdentifier_standard
//

ParameterIdentifier_standard :: ParameterIdentifier_standard ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 127 ) { }

ParameterIdentifier_standard :: ParameterIdentifier_standard ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 127 ) { }

ParameterIdentifier_standard * ParameterIdentifier_standard :: clone ( ) const {
	return new ParameterIdentifier_standard ( * this );
}

//
// ParameterIdentifier_uuid
//

ParameterIdentifier_uuid :: ParameterIdentifier_uuid ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 16, 16 ) { }

ParameterIdentifier_uuid :: ParameterIdentifier_uuid ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 16, 16 ) { }

ParameterIdentifier_uuid * ParameterIdentifier_uuid :: clone ( ) const {
	return new ParameterIdentifier_uuid ( * this );
}

//
// ParameterIdentifier_domainBased
//

ParameterIdentifier_domainBased :: ParameterIdentifier_domainBased ( Asn :: istream & is ) : Asn :: IA5String ( is, Asn :: fixedConstraint, 1, 64 ) { }

ParameterIdentifier_domainBased :: ParameterIdentifier_domainBased ( const Asn :: string & v ) : Asn :: IA5String ( v, Asn :: fixedConstraint, 1, 64 ) { }

ParameterIdentifier_domainBased * ParameterIdentifier_domainBased :: clone ( ) const {
	return new ParameterIdentifier_domainBased ( * this );
}

//
// ParameterValue_booleanArray
//

ParameterValue_booleanArray :: ParameterValue_booleanArray ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 255 ) { }

ParameterValue_booleanArray :: ParameterValue_booleanArray ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 255 ) { }

ParameterValue_booleanArray * ParameterValue_booleanArray :: clone ( ) const {
	return new ParameterValue_booleanArray ( * this );
}

//
// ParameterValue_unsignedMin
//

ParameterValue_unsignedMin :: ParameterValue_unsignedMin ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

ParameterValue_unsignedMin :: ParameterValue_unsignedMin ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

ParameterValue_unsignedMin * ParameterValue_unsignedMin :: clone ( ) const {
	return new ParameterValue_unsignedMin ( * this );
}

//
// ParameterValue_unsignedMax
//

ParameterValue_unsignedMax :: ParameterValue_unsignedMax ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

ParameterValue_unsignedMax :: ParameterValue_unsignedMax ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

ParameterValue_unsignedMax * ParameterValue_unsignedMax :: clone ( ) const {
	return new ParameterValue_unsignedMax ( * this );
}

//
// ParameterValue_unsigned32Min
//

ParameterValue_unsigned32Min :: ParameterValue_unsigned32Min ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 4294967295U ) { }

ParameterValue_unsigned32Min :: ParameterValue_unsigned32Min ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 4294967295U ) { }

ParameterValue_unsigned32Min * ParameterValue_unsigned32Min :: clone ( ) const {
	return new ParameterValue_unsigned32Min ( * this );
}

//
// ParameterValue_unsigned32Max
//

ParameterValue_unsigned32Max :: ParameterValue_unsigned32Max ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 4294967295U ) { }

ParameterValue_unsigned32Max :: ParameterValue_unsigned32Max ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 4294967295U ) { }

ParameterValue_unsigned32Max * ParameterValue_unsigned32Max :: clone ( ) const {
	return new ParameterValue_unsigned32Max ( * this );
}

//
// MultiplexedStreamCapability_capabilityOnMuxStream
//

MultiplexedStreamCapability_capabilityOnMuxStream :: MultiplexedStreamCapability_capabilityOnMuxStream ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 256 ) { }

MultiplexedStreamCapability_capabilityOnMuxStream :: MultiplexedStreamCapability_capabilityOnMuxStream ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 256 ) { }

MultiplexedStreamCapability_capabilityOnMuxStream :: MultiplexedStreamCapability_capabilityOnMuxStream ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 256 ) { }


Asn :: Object * MultiplexedStreamCapability_capabilityOnMuxStream :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * MultiplexedStreamCapability_capabilityOnMuxStream :: createObject ( Asn :: istream & is ) {
	return new AlternativeCapabilitySet ( is );
}

Asn :: Object * MultiplexedStreamCapability_capabilityOnMuxStream :: createObject ( ) {
	return new AlternativeCapabilitySet ( );
}

AlternativeCapabilitySet & MultiplexedStreamCapability_capabilityOnMuxStream :: operator[] ( std :: size_t i ) {
	return dynamic_cast < AlternativeCapabilitySet & > ( Asn :: Array :: operator[] ( i ) );
}

void MultiplexedStreamCapability_capabilityOnMuxStream :: push_back ( const AlternativeCapabilitySet & o ) {
	Asn :: Array :: push_back ( new AlternativeCapabilitySet ( o ) );
}

const AlternativeCapabilitySet & MultiplexedStreamCapability_capabilityOnMuxStream :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const AlternativeCapabilitySet & > ( Asn :: Array :: operator[] ( i ) );
}

MultiplexedStreamCapability_capabilityOnMuxStream * MultiplexedStreamCapability_capabilityOnMuxStream :: clone ( ) const {
	return new MultiplexedStreamCapability_capabilityOnMuxStream ( * this );
}

//
// AudioTelephonyEventCapability_dynamicRTPPayloadType
//

AudioTelephonyEventCapability_dynamicRTPPayloadType :: AudioTelephonyEventCapability_dynamicRTPPayloadType ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 96, 127 ) { }

AudioTelephonyEventCapability_dynamicRTPPayloadType :: AudioTelephonyEventCapability_dynamicRTPPayloadType ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 96, 127 ) { }

AudioTelephonyEventCapability_dynamicRTPPayloadType * AudioTelephonyEventCapability_dynamicRTPPayloadType :: clone ( ) const {
	return new AudioTelephonyEventCapability_dynamicRTPPayloadType ( * this );
}

//
// AudioToneCapability_dynamicRTPPayloadType
//

AudioToneCapability_dynamicRTPPayloadType :: AudioToneCapability_dynamicRTPPayloadType ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 96, 127 ) { }

AudioToneCapability_dynamicRTPPayloadType :: AudioToneCapability_dynamicRTPPayloadType ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 96, 127 ) { }

AudioToneCapability_dynamicRTPPayloadType * AudioToneCapability_dynamicRTPPayloadType :: clone ( ) const {
	return new AudioToneCapability_dynamicRTPPayloadType ( * this );
}

//
// MultiplePayloadStreamCapability_capabilities
//

MultiplePayloadStreamCapability_capabilities :: MultiplePayloadStreamCapability_capabilities ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 256 ) { }

MultiplePayloadStreamCapability_capabilities :: MultiplePayloadStreamCapability_capabilities ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 256 ) { }

MultiplePayloadStreamCapability_capabilities :: MultiplePayloadStreamCapability_capabilities ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 256 ) { }


Asn :: Object * MultiplePayloadStreamCapability_capabilities :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * MultiplePayloadStreamCapability_capabilities :: createObject ( Asn :: istream & is ) {
	return new AlternativeCapabilitySet ( is );
}

Asn :: Object * MultiplePayloadStreamCapability_capabilities :: createObject ( ) {
	return new AlternativeCapabilitySet ( );
}

AlternativeCapabilitySet & MultiplePayloadStreamCapability_capabilities :: operator[] ( std :: size_t i ) {
	return dynamic_cast < AlternativeCapabilitySet & > ( Asn :: Array :: operator[] ( i ) );
}

void MultiplePayloadStreamCapability_capabilities :: push_back ( const AlternativeCapabilitySet & o ) {
	Asn :: Array :: push_back ( new AlternativeCapabilitySet ( o ) );
}

const AlternativeCapabilitySet & MultiplePayloadStreamCapability_capabilities :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const AlternativeCapabilitySet & > ( Asn :: Array :: operator[] ( i ) );
}

MultiplePayloadStreamCapability_capabilities * MultiplePayloadStreamCapability_capabilities :: clone ( ) const {
	return new MultiplePayloadStreamCapability_capabilities ( * this );
}

//
// FECCapability_rfc2733Format
//

FECCapability_rfc2733Format :: FECCapability_rfc2733Format ( Asn :: istream & is ) : Asn :: Choice ( is, 3, false ) {
	switch ( tag ) {
		case e_rfc2733rfc2198:
		case e_rfc2733sameport:
		case e_rfc2733diffport:
			choice = new MaxRedundancy ( is );
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
}

FECCapability_rfc2733Format :: FECCapability_rfc2733Format ( ) : Asn :: Choice ( 3, false ) { }

void FECCapability_rfc2733Format :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_rfc2733rfc2198:
		case e_rfc2733sameport:
		case e_rfc2733diffport:
			o = new MaxRedundancy;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & FECCapability_rfc2733Format :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_rfc2733rfc2198, "rfc2733rfc2198" },
		{ e_rfc2733sameport, "rfc2733sameport" },
		{ e_rfc2733diffport, "rfc2733diffport" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

FECCapability_rfc2733Format * FECCapability_rfc2733Format :: clone ( ) const {
	return new FECCapability_rfc2733Format ( * this );
}

//
// NetworkAccessParameters_distribution
//

NetworkAccessParameters_distribution :: NetworkAccessParameters_distribution ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_unicast:
		case e_multicast:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

NetworkAccessParameters_distribution :: NetworkAccessParameters_distribution ( ) : Asn :: Choice ( 2, true ) { }

void NetworkAccessParameters_distribution :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_unicast:
		case e_multicast:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & NetworkAccessParameters_distribution :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_unicast, "unicast" },
		{ e_multicast, "multicast" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

NetworkAccessParameters_distribution * NetworkAccessParameters_distribution :: clone ( ) const {
	return new NetworkAccessParameters_distribution ( * this );
}

//
// NetworkAccessParameters_externalReference
//

NetworkAccessParameters_externalReference :: NetworkAccessParameters_externalReference ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 1, 255 ) { }

NetworkAccessParameters_externalReference :: NetworkAccessParameters_externalReference ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 1, 255 ) { }

NetworkAccessParameters_externalReference * NetworkAccessParameters_externalReference :: clone ( ) const {
	return new NetworkAccessParameters_externalReference ( * this );
}

//
// NetworkAccessParameters_t120SetupProcedure
//

NetworkAccessParameters_t120SetupProcedure :: NetworkAccessParameters_t120SetupProcedure ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_originateCall:
		case e_waitForCall:
		case e_issueQuery:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

NetworkAccessParameters_t120SetupProcedure :: NetworkAccessParameters_t120SetupProcedure ( ) : Asn :: Choice ( 3, true ) { }

void NetworkAccessParameters_t120SetupProcedure :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_originateCall:
		case e_waitForCall:
		case e_issueQuery:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & NetworkAccessParameters_t120SetupProcedure :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_originateCall, "originateCall" },
		{ e_waitForCall, "waitForCall" },
		{ e_issueQuery, "issueQuery" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

NetworkAccessParameters_t120SetupProcedure * NetworkAccessParameters_t120SetupProcedure :: clone ( ) const {
	return new NetworkAccessParameters_t120SetupProcedure ( * this );
}

//
// Q2931Address_subaddress
//

Q2931Address_subaddress :: Q2931Address_subaddress ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 1, 20 ) { }

Q2931Address_subaddress :: Q2931Address_subaddress ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 1, 20 ) { }

Q2931Address_subaddress * Q2931Address_subaddress :: clone ( ) const {
	return new Q2931Address_subaddress ( * this );
}

//
// H222LogicalChannelParameters_resourceID
//

H222LogicalChannelParameters_resourceID :: H222LogicalChannelParameters_resourceID ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

H222LogicalChannelParameters_resourceID :: H222LogicalChannelParameters_resourceID ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

H222LogicalChannelParameters_resourceID * H222LogicalChannelParameters_resourceID :: clone ( ) const {
	return new H222LogicalChannelParameters_resourceID ( * this );
}

//
// H222LogicalChannelParameters_subChannelID
//

H222LogicalChannelParameters_subChannelID :: H222LogicalChannelParameters_subChannelID ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 8191 ) { }

H222LogicalChannelParameters_subChannelID :: H222LogicalChannelParameters_subChannelID ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 8191 ) { }

H222LogicalChannelParameters_subChannelID * H222LogicalChannelParameters_subChannelID :: clone ( ) const {
	return new H222LogicalChannelParameters_subChannelID ( * this );
}

//
// H222LogicalChannelParameters_pcr-pid
//

H222LogicalChannelParameters_pcr_pid :: H222LogicalChannelParameters_pcr_pid ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 8191 ) { }

H222LogicalChannelParameters_pcr_pid :: H222LogicalChannelParameters_pcr_pid ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 8191 ) { }

H222LogicalChannelParameters_pcr_pid * H222LogicalChannelParameters_pcr_pid :: clone ( ) const {
	return new H222LogicalChannelParameters_pcr_pid ( * this );
}

//
// H223AL1MParameters_transferMode
//

H223AL1MParameters_transferMode :: H223AL1MParameters_transferMode ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_framed:
		case e_unframed:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

H223AL1MParameters_transferMode :: H223AL1MParameters_transferMode ( ) : Asn :: Choice ( 2, true ) { }

void H223AL1MParameters_transferMode :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_framed:
		case e_unframed:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & H223AL1MParameters_transferMode :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_framed, "framed" },
		{ e_unframed, "unframed" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

H223AL1MParameters_transferMode * H223AL1MParameters_transferMode :: clone ( ) const {
	return new H223AL1MParameters_transferMode ( * this );
}

//
// H223AL1MParameters_headerFEC
//

H223AL1MParameters_headerFEC :: H223AL1MParameters_headerFEC ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_sebch16_7:
		case e_golay24_12:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

H223AL1MParameters_headerFEC :: H223AL1MParameters_headerFEC ( ) : Asn :: Choice ( 2, true ) { }

void H223AL1MParameters_headerFEC :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_sebch16_7:
		case e_golay24_12:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & H223AL1MParameters_headerFEC :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_sebch16_7, "sebch16_7" },
		{ e_golay24_12, "golay24_12" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

H223AL1MParameters_headerFEC * H223AL1MParameters_headerFEC :: clone ( ) const {
	return new H223AL1MParameters_headerFEC ( * this );
}

//
// H223AL1MParameters_crcLength
//

H223AL1MParameters_crcLength :: H223AL1MParameters_crcLength ( Asn :: istream & is ) : Asn :: Choice ( is, 4, true ) {
	switch ( tag ) {
		case e_crc4bit:
		case e_crc12bit:
		case e_crc20bit:
		case e_crc28bit:
		case e_crc8bit:
		case e_crc16bit:
		case e_crc32bit:
		case e_crcNotUsed:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

H223AL1MParameters_crcLength :: H223AL1MParameters_crcLength ( ) : Asn :: Choice ( 4, true ) { }

void H223AL1MParameters_crcLength :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_crc4bit:
		case e_crc12bit:
		case e_crc20bit:
		case e_crc28bit:
		case e_crc8bit:
		case e_crc16bit:
		case e_crc32bit:
		case e_crcNotUsed:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & H223AL1MParameters_crcLength :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_crc4bit, "crc4bit" },
		{ e_crc12bit, "crc12bit" },
		{ e_crc20bit, "crc20bit" },
		{ e_crc28bit, "crc28bit" },
		{ e_crc8bit, "crc8bit" },
		{ e_crc16bit, "crc16bit" },
		{ e_crc32bit, "crc32bit" },
		{ e_crcNotUsed, "crcNotUsed" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

H223AL1MParameters_crcLength * H223AL1MParameters_crcLength :: clone ( ) const {
	return new H223AL1MParameters_crcLength ( * this );
}

//
// H223AL1MParameters_rcpcCodeRate
//

H223AL1MParameters_rcpcCodeRate :: H223AL1MParameters_rcpcCodeRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 8, 32 ) { }

H223AL1MParameters_rcpcCodeRate :: H223AL1MParameters_rcpcCodeRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 8, 32 ) { }

H223AL1MParameters_rcpcCodeRate * H223AL1MParameters_rcpcCodeRate :: clone ( ) const {
	return new H223AL1MParameters_rcpcCodeRate ( * this );
}

//
// H223AL1MParameters_rsCodeCorrection
//

H223AL1MParameters_rsCodeCorrection :: H223AL1MParameters_rsCodeCorrection ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 127 ) { }

H223AL1MParameters_rsCodeCorrection :: H223AL1MParameters_rsCodeCorrection ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 127 ) { }

H223AL1MParameters_rsCodeCorrection * H223AL1MParameters_rsCodeCorrection :: clone ( ) const {
	return new H223AL1MParameters_rsCodeCorrection ( * this );
}

//
// H223AL2MParameters_headerFEC
//

H223AL2MParameters_headerFEC :: H223AL2MParameters_headerFEC ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_sebch16_5:
		case e_golay24_12:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

H223AL2MParameters_headerFEC :: H223AL2MParameters_headerFEC ( ) : Asn :: Choice ( 2, true ) { }

void H223AL2MParameters_headerFEC :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_sebch16_5:
		case e_golay24_12:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & H223AL2MParameters_headerFEC :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_sebch16_5, "sebch16_5" },
		{ e_golay24_12, "golay24_12" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

H223AL2MParameters_headerFEC * H223AL2MParameters_headerFEC :: clone ( ) const {
	return new H223AL2MParameters_headerFEC ( * this );
}

//
// H223AL3MParameters_headerFormat
//

H223AL3MParameters_headerFormat :: H223AL3MParameters_headerFormat ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_sebch16_7:
		case e_golay24_12:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

H223AL3MParameters_headerFormat :: H223AL3MParameters_headerFormat ( ) : Asn :: Choice ( 2, true ) { }

void H223AL3MParameters_headerFormat :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_sebch16_7:
		case e_golay24_12:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & H223AL3MParameters_headerFormat :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_sebch16_7, "sebch16_7" },
		{ e_golay24_12, "golay24_12" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

H223AL3MParameters_headerFormat * H223AL3MParameters_headerFormat :: clone ( ) const {
	return new H223AL3MParameters_headerFormat ( * this );
}

//
// H223AL3MParameters_crcLength
//

H223AL3MParameters_crcLength :: H223AL3MParameters_crcLength ( Asn :: istream & is ) : Asn :: Choice ( is, 4, true ) {
	switch ( tag ) {
		case e_crc4bit:
		case e_crc12bit:
		case e_crc20bit:
		case e_crc28bit:
		case e_crc8bit:
		case e_crc16bit:
		case e_crc32bit:
		case e_crcNotUsed:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

H223AL3MParameters_crcLength :: H223AL3MParameters_crcLength ( ) : Asn :: Choice ( 4, true ) { }

void H223AL3MParameters_crcLength :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_crc4bit:
		case e_crc12bit:
		case e_crc20bit:
		case e_crc28bit:
		case e_crc8bit:
		case e_crc16bit:
		case e_crc32bit:
		case e_crcNotUsed:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & H223AL3MParameters_crcLength :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_crc4bit, "crc4bit" },
		{ e_crc12bit, "crc12bit" },
		{ e_crc20bit, "crc20bit" },
		{ e_crc28bit, "crc28bit" },
		{ e_crc8bit, "crc8bit" },
		{ e_crc16bit, "crc16bit" },
		{ e_crc32bit, "crc32bit" },
		{ e_crcNotUsed, "crcNotUsed" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

H223AL3MParameters_crcLength * H223AL3MParameters_crcLength :: clone ( ) const {
	return new H223AL3MParameters_crcLength ( * this );
}

//
// H223AL3MParameters_rcpcCodeRate
//

H223AL3MParameters_rcpcCodeRate :: H223AL3MParameters_rcpcCodeRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 8, 32 ) { }

H223AL3MParameters_rcpcCodeRate :: H223AL3MParameters_rcpcCodeRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 8, 32 ) { }

H223AL3MParameters_rcpcCodeRate * H223AL3MParameters_rcpcCodeRate :: clone ( ) const {
	return new H223AL3MParameters_rcpcCodeRate ( * this );
}

//
// H223AL3MParameters_rsCodeCorrection
//

H223AL3MParameters_rsCodeCorrection :: H223AL3MParameters_rsCodeCorrection ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 127 ) { }

H223AL3MParameters_rsCodeCorrection :: H223AL3MParameters_rsCodeCorrection ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 127 ) { }

H223AL3MParameters_rsCodeCorrection * H223AL3MParameters_rsCodeCorrection :: clone ( ) const {
	return new H223AL3MParameters_rsCodeCorrection ( * this );
}

//
// H223AnnexCArqParameters_sendBufferSize
//

H223AnnexCArqParameters_sendBufferSize :: H223AnnexCArqParameters_sendBufferSize ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 16777215 ) { }

H223AnnexCArqParameters_sendBufferSize :: H223AnnexCArqParameters_sendBufferSize ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 16777215 ) { }

H223AnnexCArqParameters_sendBufferSize * H223AnnexCArqParameters_sendBufferSize :: clone ( ) const {
	return new H223AnnexCArqParameters_sendBufferSize ( * this );
}

//
// V76LogicalChannelParameters_suspendResume
//

V76LogicalChannelParameters_suspendResume :: V76LogicalChannelParameters_suspendResume ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_noSuspendResume:
		case e_suspendResumewAddress:
		case e_suspendResumewoAddress:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

V76LogicalChannelParameters_suspendResume :: V76LogicalChannelParameters_suspendResume ( ) : Asn :: Choice ( 3, true ) { }

void V76LogicalChannelParameters_suspendResume :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_noSuspendResume:
		case e_suspendResumewAddress:
		case e_suspendResumewoAddress:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & V76LogicalChannelParameters_suspendResume :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_noSuspendResume, "noSuspendResume" },
		{ e_suspendResumewAddress, "suspendResumewAddress" },
		{ e_suspendResumewoAddress, "suspendResumewoAddress" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

V76LogicalChannelParameters_suspendResume * V76LogicalChannelParameters_suspendResume :: clone ( ) const {
	return new V76LogicalChannelParameters_suspendResume ( * this );
}

//
// V76HDLCParameters_n401
//

V76HDLCParameters_n401 :: V76HDLCParameters_n401 ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 4095 ) { }

V76HDLCParameters_n401 :: V76HDLCParameters_n401 ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 4095 ) { }

V76HDLCParameters_n401 * V76HDLCParameters_n401 :: clone ( ) const {
	return new V76HDLCParameters_n401 ( * this );
}

//
// H2250LogicalChannelParameters_sessionID
//

H2250LogicalChannelParameters_sessionID :: H2250LogicalChannelParameters_sessionID ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 255 ) { }

H2250LogicalChannelParameters_sessionID :: H2250LogicalChannelParameters_sessionID ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 255 ) { }

H2250LogicalChannelParameters_sessionID * H2250LogicalChannelParameters_sessionID :: clone ( ) const {
	return new H2250LogicalChannelParameters_sessionID ( * this );
}

//
// H2250LogicalChannelParameters_associatedSessionID
//

H2250LogicalChannelParameters_associatedSessionID :: H2250LogicalChannelParameters_associatedSessionID ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 255 ) { }

H2250LogicalChannelParameters_associatedSessionID :: H2250LogicalChannelParameters_associatedSessionID ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 255 ) { }

H2250LogicalChannelParameters_associatedSessionID * H2250LogicalChannelParameters_associatedSessionID :: clone ( ) const {
	return new H2250LogicalChannelParameters_associatedSessionID ( * this );
}

//
// H2250LogicalChannelParameters_dynamicRTPPayloadType
//

H2250LogicalChannelParameters_dynamicRTPPayloadType :: H2250LogicalChannelParameters_dynamicRTPPayloadType ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 96, 127 ) { }

H2250LogicalChannelParameters_dynamicRTPPayloadType :: H2250LogicalChannelParameters_dynamicRTPPayloadType ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 96, 127 ) { }

H2250LogicalChannelParameters_dynamicRTPPayloadType * H2250LogicalChannelParameters_dynamicRTPPayloadType :: clone ( ) const {
	return new H2250LogicalChannelParameters_dynamicRTPPayloadType ( * this );
}

//
// RTPPayloadType_payloadType
//

RTPPayloadType_payloadType :: RTPPayloadType_payloadType ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 127 ) { }

RTPPayloadType_payloadType :: RTPPayloadType_payloadType ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 127 ) { }

RTPPayloadType_payloadType * RTPPayloadType_payloadType :: clone ( ) const {
	return new RTPPayloadType_payloadType ( * this );
}

//
// RedundancyEncoding_rtpRedundancyEncoding
//

RedundancyEncoding_rtpRedundancyEncoding :: RedundancyEncoding_rtpRedundancyEncoding ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 0 ), m_primary ( 0 ), m_secondary ( 0 ) {
	try {
		if ( hasOptionalField ( e_primary ) )
			m_primary = new RedundancyEncodingElement ( is );
		if ( hasOptionalField ( e_secondary ) )
			m_secondary = new ArrayOf_RedundancyEncodingElement ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_primary;
		delete m_secondary;
		throw;
	}
}

RedundancyEncoding_rtpRedundancyEncoding :: RedundancyEncoding_rtpRedundancyEncoding ( ) : Asn :: Sequence ( 2, true, 0 ), m_primary ( 0 ), m_secondary ( 0 ) { }

RedundancyEncoding_rtpRedundancyEncoding & RedundancyEncoding_rtpRedundancyEncoding :: operator= ( const RedundancyEncoding_rtpRedundancyEncoding & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_primary, s.m_primary );
	assignCopy ( m_secondary, s.m_secondary );
	return * this;
}

RedundancyEncoding_rtpRedundancyEncoding :: RedundancyEncoding_rtpRedundancyEncoding ( const RedundancyEncoding_rtpRedundancyEncoding & s ) : Asn :: Sequence ( s ), m_primary ( 0 ), m_secondary ( 0 ) {
	try {
		if ( s.m_primary )
			m_primary = new RedundancyEncodingElement ( * s.m_primary );
		if ( s.m_secondary )
			m_secondary = new ArrayOf_RedundancyEncodingElement ( * s.m_secondary );
	} catch ( ... ) {
		delete m_primary;
		delete m_secondary;
		throw;
	}
}


void RedundancyEncoding_rtpRedundancyEncoding :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_primary:
			assignNew ( m_primary, new RedundancyEncodingElement );
			break;
		case e_secondary:
			assignNew ( m_secondary, new ArrayOf_RedundancyEncodingElement );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void RedundancyEncoding_rtpRedundancyEncoding :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_primary:
			delete m_primary;
			m_primary = 0;
			break;
		case e_secondary:
			delete m_secondary;
			m_secondary = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void RedundancyEncoding_rtpRedundancyEncoding :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_primary ) )
		m_primary -> RedundancyEncodingElement :: encode ( os );
	if ( hasOptionalField ( e_secondary ) )
		m_secondary -> ArrayOf_RedundancyEncodingElement :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

RedundancyEncoding_rtpRedundancyEncoding :: ~RedundancyEncoding_rtpRedundancyEncoding ( ) {
	delete m_primary;
	delete m_secondary;
}

void RedundancyEncoding_rtpRedundancyEncoding :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_primary ) ) {
		os << std :: setw ( indent + 10 ) << "primary = " << std :: setprecision ( indent );
		m_primary -> RedundancyEncodingElement :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_secondary ) ) {
		os << std :: setw ( indent + 12 ) << "secondary = " << std :: setprecision ( indent );
		m_secondary -> ArrayOf_RedundancyEncodingElement :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RedundancyEncoding_rtpRedundancyEncoding * RedundancyEncoding_rtpRedundancyEncoding :: clone ( ) const {
	return new RedundancyEncoding_rtpRedundancyEncoding ( * this );
}

//
// RedundancyEncodingElement_payloadType
//

RedundancyEncodingElement_payloadType :: RedundancyEncodingElement_payloadType ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 127 ) { }

RedundancyEncodingElement_payloadType :: RedundancyEncodingElement_payloadType ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 127 ) { }

RedundancyEncodingElement_payloadType * RedundancyEncodingElement_payloadType :: clone ( ) const {
	return new RedundancyEncodingElement_payloadType ( * this );
}

//
// ArrayOf_MultiplePayloadStreamElement
//

ArrayOf_MultiplePayloadStreamElement :: ArrayOf_MultiplePayloadStreamElement ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_MultiplePayloadStreamElement :: ArrayOf_MultiplePayloadStreamElement ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_MultiplePayloadStreamElement :: ArrayOf_MultiplePayloadStreamElement ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_MultiplePayloadStreamElement :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_MultiplePayloadStreamElement :: createObject ( Asn :: istream & is ) {
	return new MultiplePayloadStreamElement ( is );
}

Asn :: Object * ArrayOf_MultiplePayloadStreamElement :: createObject ( ) {
	return new MultiplePayloadStreamElement ( );
}

MultiplePayloadStreamElement & ArrayOf_MultiplePayloadStreamElement :: operator[] ( std :: size_t i ) {
	return dynamic_cast < MultiplePayloadStreamElement & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_MultiplePayloadStreamElement :: push_back ( const MultiplePayloadStreamElement & o ) {
	Asn :: Array :: push_back ( new MultiplePayloadStreamElement ( o ) );
}

const MultiplePayloadStreamElement & ArrayOf_MultiplePayloadStreamElement :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const MultiplePayloadStreamElement & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_MultiplePayloadStreamElement * ArrayOf_MultiplePayloadStreamElement :: clone ( ) const {
	return new ArrayOf_MultiplePayloadStreamElement ( * this );
}

//
// MultiplePayloadStreamElement_payloadType
//

MultiplePayloadStreamElement_payloadType :: MultiplePayloadStreamElement_payloadType ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 127 ) { }

MultiplePayloadStreamElement_payloadType :: MultiplePayloadStreamElement_payloadType ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 127 ) { }

MultiplePayloadStreamElement_payloadType * MultiplePayloadStreamElement_payloadType :: clone ( ) const {
	return new MultiplePayloadStreamElement_payloadType ( * this );
}

//
// UnicastAddress_netBios
//

UnicastAddress_netBios :: UnicastAddress_netBios ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 16, 16 ) { }

UnicastAddress_netBios :: UnicastAddress_netBios ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 16, 16 ) { }

UnicastAddress_netBios * UnicastAddress_netBios :: clone ( ) const {
	return new UnicastAddress_netBios ( * this );
}

//
// UnicastAddress_nsap
//

UnicastAddress_nsap :: UnicastAddress_nsap ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 1, 20 ) { }

UnicastAddress_nsap :: UnicastAddress_nsap ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 1, 20 ) { }

UnicastAddress_nsap * UnicastAddress_nsap :: clone ( ) const {
	return new UnicastAddress_nsap ( * this );
}

//
// MulticastAddress_nsap
//

MulticastAddress_nsap :: MulticastAddress_nsap ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 1, 20 ) { }

MulticastAddress_nsap :: MulticastAddress_nsap ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 1, 20 ) { }

MulticastAddress_nsap * MulticastAddress_nsap :: clone ( ) const {
	return new MulticastAddress_nsap ( * this );
}

//
// EncryptionSync_synchFlag
//

EncryptionSync_synchFlag :: EncryptionSync_synchFlag ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 255 ) { }

EncryptionSync_synchFlag :: EncryptionSync_synchFlag ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 255 ) { }

EncryptionSync_synchFlag * EncryptionSync_synchFlag :: clone ( ) const {
	return new EncryptionSync_synchFlag ( * this );
}

//
// EncryptionSync_h235Key
//

EncryptionSync_h235Key :: EncryptionSync_h235Key ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 1, 65535 ) { }

EncryptionSync_h235Key :: EncryptionSync_h235Key ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 1, 65535 ) { }

EncryptionSync_h235Key * EncryptionSync_h235Key :: clone ( ) const {
	return new EncryptionSync_h235Key ( * this );
}

//
// EncryptionSync_escrowentry
//

EncryptionSync_escrowentry :: EncryptionSync_escrowentry ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 256 ) { }

EncryptionSync_escrowentry :: EncryptionSync_escrowentry ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 256 ) { }

EncryptionSync_escrowentry :: EncryptionSync_escrowentry ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 256 ) { }


Asn :: Object * EncryptionSync_escrowentry :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * EncryptionSync_escrowentry :: createObject ( Asn :: istream & is ) {
	return new EscrowData ( is );
}

Asn :: Object * EncryptionSync_escrowentry :: createObject ( ) {
	return new EscrowData ( );
}

EscrowData & EncryptionSync_escrowentry :: operator[] ( std :: size_t i ) {
	return dynamic_cast < EscrowData & > ( Asn :: Array :: operator[] ( i ) );
}

void EncryptionSync_escrowentry :: push_back ( const EscrowData & o ) {
	Asn :: Array :: push_back ( new EscrowData ( o ) );
}

const EscrowData & EncryptionSync_escrowentry :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const EscrowData & > ( Asn :: Array :: operator[] ( i ) );
}

EncryptionSync_escrowentry * EncryptionSync_escrowentry :: clone ( ) const {
	return new EncryptionSync_escrowentry ( * this );
}

//
// EscrowData_escrowValue
//

EscrowData_escrowValue :: EscrowData_escrowValue ( Asn :: istream & is ) : Asn :: BitString ( is, Asn :: fixedConstraint, 1, 65535 ) { }

EscrowData_escrowValue :: EscrowData_escrowValue ( const Asn :: string & v, unsigned b ) : Asn :: BitString ( b ? : unsigned ( v.size ( ) * 8 ), v, Asn :: fixedConstraint, 1, 65535 ) {
}

EscrowData_escrowValue * EscrowData_escrowValue :: clone ( ) const {
	return new EscrowData_escrowValue ( * this );
}

//
// OpenLogicalChannelAck_reverseLogicalChannelParameters
//

OpenLogicalChannelAck_reverseLogicalChannelParameters :: OpenLogicalChannelAck_reverseLogicalChannelParameters ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 1 ), m_reverseLogicalChannelNumber ( is ), m_portNumber ( 0 ), m_multiplexParameters ( 0 ), m_replacementFor ( 0 ) {
	try {
		if ( hasOptionalField ( e_portNumber ) )
			m_portNumber = new OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber ( is );
		if ( hasOptionalField ( e_multiplexParameters ) )
			m_multiplexParameters = new OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_replacementFor ) )
				m_replacementFor = new LogicalChannelNumber ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_portNumber;
		delete m_multiplexParameters;
		delete m_replacementFor;
		throw;
	}
}

OpenLogicalChannelAck_reverseLogicalChannelParameters :: OpenLogicalChannelAck_reverseLogicalChannelParameters ( ) : Asn :: Sequence ( 2, true, 1 ), m_portNumber ( 0 ), m_multiplexParameters ( 0 ), m_replacementFor ( 0 ) { }

OpenLogicalChannelAck_reverseLogicalChannelParameters & OpenLogicalChannelAck_reverseLogicalChannelParameters :: operator= ( const OpenLogicalChannelAck_reverseLogicalChannelParameters & s ) {
	Asn :: Sequence :: operator= ( s );
	m_reverseLogicalChannelNumber = s.m_reverseLogicalChannelNumber;
	assignCopy ( m_portNumber, s.m_portNumber );
	assignCopy ( m_multiplexParameters, s.m_multiplexParameters );
	assignCopy ( m_replacementFor, s.m_replacementFor );
	return * this;
}

OpenLogicalChannelAck_reverseLogicalChannelParameters :: OpenLogicalChannelAck_reverseLogicalChannelParameters ( const OpenLogicalChannelAck_reverseLogicalChannelParameters & s ) : Asn :: Sequence ( s ), m_reverseLogicalChannelNumber ( s.m_reverseLogicalChannelNumber ), m_portNumber ( 0 ), m_multiplexParameters ( 0 ), m_replacementFor ( 0 ) {
	try {
		if ( s.m_portNumber )
			m_portNumber = new OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber ( * s.m_portNumber );
		if ( s.m_multiplexParameters )
			m_multiplexParameters = new OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters ( * s.m_multiplexParameters );
		if ( s.m_replacementFor )
			m_replacementFor = new LogicalChannelNumber ( * s.m_replacementFor );
	} catch ( ... ) {
		delete m_portNumber;
		delete m_multiplexParameters;
		delete m_replacementFor;
		throw;
	}
}


void OpenLogicalChannelAck_reverseLogicalChannelParameters :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_portNumber:
			assignNew ( m_portNumber, new OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber );
			break;
		case e_multiplexParameters:
			assignNew ( m_multiplexParameters, new OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters );
			break;
		case e_replacementFor:
			assignNew ( m_replacementFor, new LogicalChannelNumber );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void OpenLogicalChannelAck_reverseLogicalChannelParameters :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_portNumber:
			delete m_portNumber;
			m_portNumber = 0;
			break;
		case e_multiplexParameters:
			delete m_multiplexParameters;
			m_multiplexParameters = 0;
			break;
		case e_replacementFor:
			delete m_replacementFor;
			m_replacementFor = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void OpenLogicalChannelAck_reverseLogicalChannelParameters :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_reverseLogicalChannelNumber.encode ( os );
	if ( hasOptionalField ( e_portNumber ) )
		m_portNumber -> OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber :: encode ( os );
	if ( hasOptionalField ( e_multiplexParameters ) )
		m_multiplexParameters -> OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_replacementFor, m_replacementFor );
		unknownExtensionsEncode ( os );
	}
}

OpenLogicalChannelAck_reverseLogicalChannelParameters :: ~OpenLogicalChannelAck_reverseLogicalChannelParameters ( ) {
	delete m_portNumber;
	delete m_multiplexParameters;
	delete m_replacementFor;
}

void OpenLogicalChannelAck_reverseLogicalChannelParameters :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 30 ) << "reverseLogicalChannelNumber = " << std :: setprecision ( indent ) << m_reverseLogicalChannelNumber << '\n';
	if ( hasOptionalField ( e_portNumber ) ) {
		os << std :: setw ( indent + 13 ) << "portNumber = " << std :: setprecision ( indent );
		m_portNumber -> OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_multiplexParameters ) ) {
		os << std :: setw ( indent + 22 ) << "multiplexParameters = " << std :: setprecision ( indent );
		m_multiplexParameters -> OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_replacementFor ) ) {
		os << std :: setw ( indent + 17 ) << "replacementFor = " << std :: setprecision ( indent );
		m_replacementFor -> LogicalChannelNumber :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

OpenLogicalChannelAck_reverseLogicalChannelParameters * OpenLogicalChannelAck_reverseLogicalChannelParameters :: clone ( ) const {
	return new OpenLogicalChannelAck_reverseLogicalChannelParameters ( * this );
}

//
// OpenLogicalChannelAck_forwardMultiplexAckParameters
//

OpenLogicalChannelAck_forwardMultiplexAckParameters :: OpenLogicalChannelAck_forwardMultiplexAckParameters ( Asn :: istream & is ) : Asn :: Choice ( is, 1, true ) {
	switch ( tag ) {
		case e_h2250LogicalChannelAckParameters:
			choice = new H2250LogicalChannelAckParameters ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

OpenLogicalChannelAck_forwardMultiplexAckParameters :: OpenLogicalChannelAck_forwardMultiplexAckParameters ( ) : Asn :: Choice ( 1, true ) { }

void OpenLogicalChannelAck_forwardMultiplexAckParameters :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_h2250LogicalChannelAckParameters:
			o = new H2250LogicalChannelAckParameters;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & OpenLogicalChannelAck_forwardMultiplexAckParameters :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_h2250LogicalChannelAckParameters, "h2250LogicalChannelAckParameters" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

OpenLogicalChannelAck_forwardMultiplexAckParameters * OpenLogicalChannelAck_forwardMultiplexAckParameters :: clone ( ) const {
	return new OpenLogicalChannelAck_forwardMultiplexAckParameters ( * this );
}

//
// OpenLogicalChannelReject_cause
//

OpenLogicalChannelReject_cause :: OpenLogicalChannelReject_cause ( Asn :: istream & is ) : Asn :: Choice ( is, 6, true ) {
	switch ( tag ) {
		case e_unspecified:
		case e_unsuitableReverseParameters:
		case e_dataTypeNotSupported:
		case e_dataTypeNotAvailable:
		case e_unknownDataType:
		case e_dataTypeALCombinationNotSupported:
		case e_multicastChannelNotAllowed:
		case e_insufficientBandwidth:
		case e_separateStackEstablishmentFailed:
		case e_invalidSessionID:
		case e_masterSlaveConflict:
		case e_waitForCommunicationMode:
		case e_invalidDependentChannel:
		case e_replacementForRejected:
		case e_securityDenied:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

OpenLogicalChannelReject_cause :: OpenLogicalChannelReject_cause ( ) : Asn :: Choice ( 6, true ) { }

void OpenLogicalChannelReject_cause :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_unspecified:
		case e_unsuitableReverseParameters:
		case e_dataTypeNotSupported:
		case e_dataTypeNotAvailable:
		case e_unknownDataType:
		case e_dataTypeALCombinationNotSupported:
		case e_multicastChannelNotAllowed:
		case e_insufficientBandwidth:
		case e_separateStackEstablishmentFailed:
		case e_invalidSessionID:
		case e_masterSlaveConflict:
		case e_waitForCommunicationMode:
		case e_invalidDependentChannel:
		case e_replacementForRejected:
		case e_securityDenied:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & OpenLogicalChannelReject_cause :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_unspecified, "unspecified" },
		{ e_unsuitableReverseParameters, "unsuitableReverseParameters" },
		{ e_dataTypeNotSupported, "dataTypeNotSupported" },
		{ e_dataTypeNotAvailable, "dataTypeNotAvailable" },
		{ e_unknownDataType, "unknownDataType" },
		{ e_dataTypeALCombinationNotSupported, "dataTypeALCombinationNotSupported" },
		{ e_multicastChannelNotAllowed, "multicastChannelNotAllowed" },
		{ e_insufficientBandwidth, "insufficientBandwidth" },
		{ e_separateStackEstablishmentFailed, "separateStackEstablishmentFailed" },
		{ e_invalidSessionID, "invalidSessionID" },
		{ e_masterSlaveConflict, "masterSlaveConflict" },
		{ e_waitForCommunicationMode, "waitForCommunicationMode" },
		{ e_invalidDependentChannel, "invalidDependentChannel" },
		{ e_replacementForRejected, "replacementForRejected" },
		{ e_securityDenied, "securityDenied" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

OpenLogicalChannelReject_cause * OpenLogicalChannelReject_cause :: clone ( ) const {
	return new OpenLogicalChannelReject_cause ( * this );
}

//
// H2250LogicalChannelAckParameters_sessionID
//

H2250LogicalChannelAckParameters_sessionID :: H2250LogicalChannelAckParameters_sessionID ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 255 ) { }

H2250LogicalChannelAckParameters_sessionID :: H2250LogicalChannelAckParameters_sessionID ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 255 ) { }

H2250LogicalChannelAckParameters_sessionID * H2250LogicalChannelAckParameters_sessionID :: clone ( ) const {
	return new H2250LogicalChannelAckParameters_sessionID ( * this );
}

//
// H2250LogicalChannelAckParameters_dynamicRTPPayloadType
//

H2250LogicalChannelAckParameters_dynamicRTPPayloadType :: H2250LogicalChannelAckParameters_dynamicRTPPayloadType ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 96, 127 ) { }

H2250LogicalChannelAckParameters_dynamicRTPPayloadType :: H2250LogicalChannelAckParameters_dynamicRTPPayloadType ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 96, 127 ) { }

H2250LogicalChannelAckParameters_dynamicRTPPayloadType * H2250LogicalChannelAckParameters_dynamicRTPPayloadType :: clone ( ) const {
	return new H2250LogicalChannelAckParameters_dynamicRTPPayloadType ( * this );
}

//
// H2250LogicalChannelAckParameters_portNumber
//

H2250LogicalChannelAckParameters_portNumber :: H2250LogicalChannelAckParameters_portNumber ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

H2250LogicalChannelAckParameters_portNumber :: H2250LogicalChannelAckParameters_portNumber ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

H2250LogicalChannelAckParameters_portNumber * H2250LogicalChannelAckParameters_portNumber :: clone ( ) const {
	return new H2250LogicalChannelAckParameters_portNumber ( * this );
}

//
// CloseLogicalChannel_source
//

CloseLogicalChannel_source :: CloseLogicalChannel_source ( Asn :: istream & is ) : Asn :: Choice ( is, 2, false ) {
	switch ( tag ) {
		case e_user:
		case e_lcse:
			choice = new Asn :: Null ( is );
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
}

CloseLogicalChannel_source :: CloseLogicalChannel_source ( ) : Asn :: Choice ( 2, false ) { }

void CloseLogicalChannel_source :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_user:
		case e_lcse:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & CloseLogicalChannel_source :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_user, "user" },
		{ e_lcse, "lcse" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

CloseLogicalChannel_source * CloseLogicalChannel_source :: clone ( ) const {
	return new CloseLogicalChannel_source ( * this );
}

//
// CloseLogicalChannel_reason
//

CloseLogicalChannel_reason :: CloseLogicalChannel_reason ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_unknown:
		case e_reopen:
		case e_reservationFailure:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

CloseLogicalChannel_reason :: CloseLogicalChannel_reason ( ) : Asn :: Choice ( 3, true ) { }

void CloseLogicalChannel_reason :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_unknown:
		case e_reopen:
		case e_reservationFailure:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & CloseLogicalChannel_reason :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_unknown, "unknown" },
		{ e_reopen, "reopen" },
		{ e_reservationFailure, "reservationFailure" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

CloseLogicalChannel_reason * CloseLogicalChannel_reason :: clone ( ) const {
	return new CloseLogicalChannel_reason ( * this );
}

//
// RequestChannelClose_reason
//

RequestChannelClose_reason :: RequestChannelClose_reason ( Asn :: istream & is ) : Asn :: Choice ( is, 4, true ) {
	switch ( tag ) {
		case e_unknown:
		case e_normal:
		case e_reopen:
		case e_reservationFailure:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

RequestChannelClose_reason :: RequestChannelClose_reason ( ) : Asn :: Choice ( 4, true ) { }

void RequestChannelClose_reason :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_unknown:
		case e_normal:
		case e_reopen:
		case e_reservationFailure:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & RequestChannelClose_reason :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_unknown, "unknown" },
		{ e_normal, "normal" },
		{ e_reopen, "reopen" },
		{ e_reservationFailure, "reservationFailure" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

RequestChannelClose_reason * RequestChannelClose_reason :: clone ( ) const {
	return new RequestChannelClose_reason ( * this );
}

//
// RequestChannelCloseReject_cause
//

RequestChannelCloseReject_cause :: RequestChannelCloseReject_cause ( Asn :: istream & is ) : Asn :: Choice ( is, 1, true ) {
	switch ( tag ) {
		case e_unspecified:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

RequestChannelCloseReject_cause :: RequestChannelCloseReject_cause ( ) : Asn :: Choice ( 1, true ) { }

void RequestChannelCloseReject_cause :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_unspecified:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & RequestChannelCloseReject_cause :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_unspecified, "unspecified" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

RequestChannelCloseReject_cause * RequestChannelCloseReject_cause :: clone ( ) const {
	return new RequestChannelCloseReject_cause ( * this );
}

//
// MultiplexEntrySend_multiplexEntryDescriptors
//

MultiplexEntrySend_multiplexEntryDescriptors :: MultiplexEntrySend_multiplexEntryDescriptors ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 15 ) { }

MultiplexEntrySend_multiplexEntryDescriptors :: MultiplexEntrySend_multiplexEntryDescriptors ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 15 ) { }

MultiplexEntrySend_multiplexEntryDescriptors :: MultiplexEntrySend_multiplexEntryDescriptors ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 15 ) { }


Asn :: Object * MultiplexEntrySend_multiplexEntryDescriptors :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * MultiplexEntrySend_multiplexEntryDescriptors :: createObject ( Asn :: istream & is ) {
	return new MultiplexEntryDescriptor ( is );
}

Asn :: Object * MultiplexEntrySend_multiplexEntryDescriptors :: createObject ( ) {
	return new MultiplexEntryDescriptor ( );
}

MultiplexEntryDescriptor & MultiplexEntrySend_multiplexEntryDescriptors :: operator[] ( std :: size_t i ) {
	return dynamic_cast < MultiplexEntryDescriptor & > ( Asn :: Array :: operator[] ( i ) );
}

void MultiplexEntrySend_multiplexEntryDescriptors :: push_back ( const MultiplexEntryDescriptor & o ) {
	Asn :: Array :: push_back ( new MultiplexEntryDescriptor ( o ) );
}

const MultiplexEntryDescriptor & MultiplexEntrySend_multiplexEntryDescriptors :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const MultiplexEntryDescriptor & > ( Asn :: Array :: operator[] ( i ) );
}

MultiplexEntrySend_multiplexEntryDescriptors * MultiplexEntrySend_multiplexEntryDescriptors :: clone ( ) const {
	return new MultiplexEntrySend_multiplexEntryDescriptors ( * this );
}

//
// MultiplexEntryDescriptor_elementList
//

MultiplexEntryDescriptor_elementList :: MultiplexEntryDescriptor_elementList ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 256 ) { }

MultiplexEntryDescriptor_elementList :: MultiplexEntryDescriptor_elementList ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 256 ) { }

MultiplexEntryDescriptor_elementList :: MultiplexEntryDescriptor_elementList ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 256 ) { }


Asn :: Object * MultiplexEntryDescriptor_elementList :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * MultiplexEntryDescriptor_elementList :: createObject ( Asn :: istream & is ) {
	return new MultiplexElement ( is );
}

Asn :: Object * MultiplexEntryDescriptor_elementList :: createObject ( ) {
	return new MultiplexElement ( );
}

MultiplexElement & MultiplexEntryDescriptor_elementList :: operator[] ( std :: size_t i ) {
	return dynamic_cast < MultiplexElement & > ( Asn :: Array :: operator[] ( i ) );
}

void MultiplexEntryDescriptor_elementList :: push_back ( const MultiplexElement & o ) {
	Asn :: Array :: push_back ( new MultiplexElement ( o ) );
}

const MultiplexElement & MultiplexEntryDescriptor_elementList :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const MultiplexElement & > ( Asn :: Array :: operator[] ( i ) );
}

MultiplexEntryDescriptor_elementList * MultiplexEntryDescriptor_elementList :: clone ( ) const {
	return new MultiplexEntryDescriptor_elementList ( * this );
}

//
// MultiplexEntrySendAck_multiplexTableEntryNumber
//

MultiplexEntrySendAck_multiplexTableEntryNumber :: MultiplexEntrySendAck_multiplexTableEntryNumber ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 15 ) { }

MultiplexEntrySendAck_multiplexTableEntryNumber :: MultiplexEntrySendAck_multiplexTableEntryNumber ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 15 ) { }

MultiplexEntrySendAck_multiplexTableEntryNumber :: MultiplexEntrySendAck_multiplexTableEntryNumber ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 15 ) { }


Asn :: Object * MultiplexEntrySendAck_multiplexTableEntryNumber :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * MultiplexEntrySendAck_multiplexTableEntryNumber :: createObject ( Asn :: istream & is ) {
	return new MultiplexTableEntryNumber ( is );
}

Asn :: Object * MultiplexEntrySendAck_multiplexTableEntryNumber :: createObject ( ) {
	return new MultiplexTableEntryNumber ( );
}

MultiplexTableEntryNumber & MultiplexEntrySendAck_multiplexTableEntryNumber :: operator[] ( std :: size_t i ) {
	return dynamic_cast < MultiplexTableEntryNumber & > ( Asn :: Array :: operator[] ( i ) );
}

void MultiplexEntrySendAck_multiplexTableEntryNumber :: push_back ( const MultiplexTableEntryNumber & o ) {
	Asn :: Array :: push_back ( new MultiplexTableEntryNumber ( o ) );
}

const MultiplexTableEntryNumber & MultiplexEntrySendAck_multiplexTableEntryNumber :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const MultiplexTableEntryNumber & > ( Asn :: Array :: operator[] ( i ) );
}

MultiplexEntrySendAck_multiplexTableEntryNumber * MultiplexEntrySendAck_multiplexTableEntryNumber :: clone ( ) const {
	return new MultiplexEntrySendAck_multiplexTableEntryNumber ( * this );
}

//
// MultiplexEntrySendReject_rejectionDescriptions
//

MultiplexEntrySendReject_rejectionDescriptions :: MultiplexEntrySendReject_rejectionDescriptions ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 15 ) { }

MultiplexEntrySendReject_rejectionDescriptions :: MultiplexEntrySendReject_rejectionDescriptions ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 15 ) { }

MultiplexEntrySendReject_rejectionDescriptions :: MultiplexEntrySendReject_rejectionDescriptions ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 15 ) { }


Asn :: Object * MultiplexEntrySendReject_rejectionDescriptions :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * MultiplexEntrySendReject_rejectionDescriptions :: createObject ( Asn :: istream & is ) {
	return new MultiplexEntryRejectionDescriptions ( is );
}

Asn :: Object * MultiplexEntrySendReject_rejectionDescriptions :: createObject ( ) {
	return new MultiplexEntryRejectionDescriptions ( );
}

MultiplexEntryRejectionDescriptions & MultiplexEntrySendReject_rejectionDescriptions :: operator[] ( std :: size_t i ) {
	return dynamic_cast < MultiplexEntryRejectionDescriptions & > ( Asn :: Array :: operator[] ( i ) );
}

void MultiplexEntrySendReject_rejectionDescriptions :: push_back ( const MultiplexEntryRejectionDescriptions & o ) {
	Asn :: Array :: push_back ( new MultiplexEntryRejectionDescriptions ( o ) );
}

const MultiplexEntryRejectionDescriptions & MultiplexEntrySendReject_rejectionDescriptions :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const MultiplexEntryRejectionDescriptions & > ( Asn :: Array :: operator[] ( i ) );
}

MultiplexEntrySendReject_rejectionDescriptions * MultiplexEntrySendReject_rejectionDescriptions :: clone ( ) const {
	return new MultiplexEntrySendReject_rejectionDescriptions ( * this );
}

//
// MultiplexEntryRejectionDescriptions_cause
//

MultiplexEntryRejectionDescriptions_cause :: MultiplexEntryRejectionDescriptions_cause ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_unspecifiedCause:
		case e_descriptorTooComplex:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

MultiplexEntryRejectionDescriptions_cause :: MultiplexEntryRejectionDescriptions_cause ( ) : Asn :: Choice ( 2, true ) { }

void MultiplexEntryRejectionDescriptions_cause :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_unspecifiedCause:
		case e_descriptorTooComplex:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & MultiplexEntryRejectionDescriptions_cause :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_unspecifiedCause, "unspecifiedCause" },
		{ e_descriptorTooComplex, "descriptorTooComplex" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

MultiplexEntryRejectionDescriptions_cause * MultiplexEntryRejectionDescriptions_cause :: clone ( ) const {
	return new MultiplexEntryRejectionDescriptions_cause ( * this );
}

//
// MultiplexEntrySendRelease_multiplexTableEntryNumber
//

MultiplexEntrySendRelease_multiplexTableEntryNumber :: MultiplexEntrySendRelease_multiplexTableEntryNumber ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 15 ) { }

MultiplexEntrySendRelease_multiplexTableEntryNumber :: MultiplexEntrySendRelease_multiplexTableEntryNumber ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 15 ) { }

MultiplexEntrySendRelease_multiplexTableEntryNumber :: MultiplexEntrySendRelease_multiplexTableEntryNumber ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 15 ) { }


Asn :: Object * MultiplexEntrySendRelease_multiplexTableEntryNumber :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * MultiplexEntrySendRelease_multiplexTableEntryNumber :: createObject ( Asn :: istream & is ) {
	return new MultiplexTableEntryNumber ( is );
}

Asn :: Object * MultiplexEntrySendRelease_multiplexTableEntryNumber :: createObject ( ) {
	return new MultiplexTableEntryNumber ( );
}

MultiplexTableEntryNumber & MultiplexEntrySendRelease_multiplexTableEntryNumber :: operator[] ( std :: size_t i ) {
	return dynamic_cast < MultiplexTableEntryNumber & > ( Asn :: Array :: operator[] ( i ) );
}

void MultiplexEntrySendRelease_multiplexTableEntryNumber :: push_back ( const MultiplexTableEntryNumber & o ) {
	Asn :: Array :: push_back ( new MultiplexTableEntryNumber ( o ) );
}

const MultiplexTableEntryNumber & MultiplexEntrySendRelease_multiplexTableEntryNumber :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const MultiplexTableEntryNumber & > ( Asn :: Array :: operator[] ( i ) );
}

MultiplexEntrySendRelease_multiplexTableEntryNumber * MultiplexEntrySendRelease_multiplexTableEntryNumber :: clone ( ) const {
	return new MultiplexEntrySendRelease_multiplexTableEntryNumber ( * this );
}

//
// RequestMultiplexEntry_entryNumbers
//

RequestMultiplexEntry_entryNumbers :: RequestMultiplexEntry_entryNumbers ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 15 ) { }

RequestMultiplexEntry_entryNumbers :: RequestMultiplexEntry_entryNumbers ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 15 ) { }

RequestMultiplexEntry_entryNumbers :: RequestMultiplexEntry_entryNumbers ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 15 ) { }


Asn :: Object * RequestMultiplexEntry_entryNumbers :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * RequestMultiplexEntry_entryNumbers :: createObject ( Asn :: istream & is ) {
	return new MultiplexTableEntryNumber ( is );
}

Asn :: Object * RequestMultiplexEntry_entryNumbers :: createObject ( ) {
	return new MultiplexTableEntryNumber ( );
}

MultiplexTableEntryNumber & RequestMultiplexEntry_entryNumbers :: operator[] ( std :: size_t i ) {
	return dynamic_cast < MultiplexTableEntryNumber & > ( Asn :: Array :: operator[] ( i ) );
}

void RequestMultiplexEntry_entryNumbers :: push_back ( const MultiplexTableEntryNumber & o ) {
	Asn :: Array :: push_back ( new MultiplexTableEntryNumber ( o ) );
}

const MultiplexTableEntryNumber & RequestMultiplexEntry_entryNumbers :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const MultiplexTableEntryNumber & > ( Asn :: Array :: operator[] ( i ) );
}

RequestMultiplexEntry_entryNumbers * RequestMultiplexEntry_entryNumbers :: clone ( ) const {
	return new RequestMultiplexEntry_entryNumbers ( * this );
}

//
// RequestMultiplexEntryAck_entryNumbers
//

RequestMultiplexEntryAck_entryNumbers :: RequestMultiplexEntryAck_entryNumbers ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 15 ) { }

RequestMultiplexEntryAck_entryNumbers :: RequestMultiplexEntryAck_entryNumbers ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 15 ) { }

RequestMultiplexEntryAck_entryNumbers :: RequestMultiplexEntryAck_entryNumbers ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 15 ) { }


Asn :: Object * RequestMultiplexEntryAck_entryNumbers :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * RequestMultiplexEntryAck_entryNumbers :: createObject ( Asn :: istream & is ) {
	return new MultiplexTableEntryNumber ( is );
}

Asn :: Object * RequestMultiplexEntryAck_entryNumbers :: createObject ( ) {
	return new MultiplexTableEntryNumber ( );
}

MultiplexTableEntryNumber & RequestMultiplexEntryAck_entryNumbers :: operator[] ( std :: size_t i ) {
	return dynamic_cast < MultiplexTableEntryNumber & > ( Asn :: Array :: operator[] ( i ) );
}

void RequestMultiplexEntryAck_entryNumbers :: push_back ( const MultiplexTableEntryNumber & o ) {
	Asn :: Array :: push_back ( new MultiplexTableEntryNumber ( o ) );
}

const MultiplexTableEntryNumber & RequestMultiplexEntryAck_entryNumbers :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const MultiplexTableEntryNumber & > ( Asn :: Array :: operator[] ( i ) );
}

RequestMultiplexEntryAck_entryNumbers * RequestMultiplexEntryAck_entryNumbers :: clone ( ) const {
	return new RequestMultiplexEntryAck_entryNumbers ( * this );
}

//
// RequestMultiplexEntryReject_entryNumbers
//

RequestMultiplexEntryReject_entryNumbers :: RequestMultiplexEntryReject_entryNumbers ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 15 ) { }

RequestMultiplexEntryReject_entryNumbers :: RequestMultiplexEntryReject_entryNumbers ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 15 ) { }

RequestMultiplexEntryReject_entryNumbers :: RequestMultiplexEntryReject_entryNumbers ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 15 ) { }


Asn :: Object * RequestMultiplexEntryReject_entryNumbers :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * RequestMultiplexEntryReject_entryNumbers :: createObject ( Asn :: istream & is ) {
	return new MultiplexTableEntryNumber ( is );
}

Asn :: Object * RequestMultiplexEntryReject_entryNumbers :: createObject ( ) {
	return new MultiplexTableEntryNumber ( );
}

MultiplexTableEntryNumber & RequestMultiplexEntryReject_entryNumbers :: operator[] ( std :: size_t i ) {
	return dynamic_cast < MultiplexTableEntryNumber & > ( Asn :: Array :: operator[] ( i ) );
}

void RequestMultiplexEntryReject_entryNumbers :: push_back ( const MultiplexTableEntryNumber & o ) {
	Asn :: Array :: push_back ( new MultiplexTableEntryNumber ( o ) );
}

const MultiplexTableEntryNumber & RequestMultiplexEntryReject_entryNumbers :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const MultiplexTableEntryNumber & > ( Asn :: Array :: operator[] ( i ) );
}

RequestMultiplexEntryReject_entryNumbers * RequestMultiplexEntryReject_entryNumbers :: clone ( ) const {
	return new RequestMultiplexEntryReject_entryNumbers ( * this );
}

//
// RequestMultiplexEntryReject_rejectionDescriptions
//

RequestMultiplexEntryReject_rejectionDescriptions :: RequestMultiplexEntryReject_rejectionDescriptions ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 15 ) { }

RequestMultiplexEntryReject_rejectionDescriptions :: RequestMultiplexEntryReject_rejectionDescriptions ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 15 ) { }

RequestMultiplexEntryReject_rejectionDescriptions :: RequestMultiplexEntryReject_rejectionDescriptions ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 15 ) { }


Asn :: Object * RequestMultiplexEntryReject_rejectionDescriptions :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * RequestMultiplexEntryReject_rejectionDescriptions :: createObject ( Asn :: istream & is ) {
	return new RequestMultiplexEntryRejectionDescriptions ( is );
}

Asn :: Object * RequestMultiplexEntryReject_rejectionDescriptions :: createObject ( ) {
	return new RequestMultiplexEntryRejectionDescriptions ( );
}

RequestMultiplexEntryRejectionDescriptions & RequestMultiplexEntryReject_rejectionDescriptions :: operator[] ( std :: size_t i ) {
	return dynamic_cast < RequestMultiplexEntryRejectionDescriptions & > ( Asn :: Array :: operator[] ( i ) );
}

void RequestMultiplexEntryReject_rejectionDescriptions :: push_back ( const RequestMultiplexEntryRejectionDescriptions & o ) {
	Asn :: Array :: push_back ( new RequestMultiplexEntryRejectionDescriptions ( o ) );
}

const RequestMultiplexEntryRejectionDescriptions & RequestMultiplexEntryReject_rejectionDescriptions :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const RequestMultiplexEntryRejectionDescriptions & > ( Asn :: Array :: operator[] ( i ) );
}

RequestMultiplexEntryReject_rejectionDescriptions * RequestMultiplexEntryReject_rejectionDescriptions :: clone ( ) const {
	return new RequestMultiplexEntryReject_rejectionDescriptions ( * this );
}

//
// RequestMultiplexEntryRejectionDescriptions_cause
//

RequestMultiplexEntryRejectionDescriptions_cause :: RequestMultiplexEntryRejectionDescriptions_cause ( Asn :: istream & is ) : Asn :: Choice ( is, 1, true ) {
	switch ( tag ) {
		case e_unspecifiedCause:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

RequestMultiplexEntryRejectionDescriptions_cause :: RequestMultiplexEntryRejectionDescriptions_cause ( ) : Asn :: Choice ( 1, true ) { }

void RequestMultiplexEntryRejectionDescriptions_cause :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_unspecifiedCause:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & RequestMultiplexEntryRejectionDescriptions_cause :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_unspecifiedCause, "unspecifiedCause" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

RequestMultiplexEntryRejectionDescriptions_cause * RequestMultiplexEntryRejectionDescriptions_cause :: clone ( ) const {
	return new RequestMultiplexEntryRejectionDescriptions_cause ( * this );
}

//
// RequestMultiplexEntryRelease_entryNumbers
//

RequestMultiplexEntryRelease_entryNumbers :: RequestMultiplexEntryRelease_entryNumbers ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 15 ) { }

RequestMultiplexEntryRelease_entryNumbers :: RequestMultiplexEntryRelease_entryNumbers ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 15 ) { }

RequestMultiplexEntryRelease_entryNumbers :: RequestMultiplexEntryRelease_entryNumbers ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 15 ) { }


Asn :: Object * RequestMultiplexEntryRelease_entryNumbers :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * RequestMultiplexEntryRelease_entryNumbers :: createObject ( Asn :: istream & is ) {
	return new MultiplexTableEntryNumber ( is );
}

Asn :: Object * RequestMultiplexEntryRelease_entryNumbers :: createObject ( ) {
	return new MultiplexTableEntryNumber ( );
}

MultiplexTableEntryNumber & RequestMultiplexEntryRelease_entryNumbers :: operator[] ( std :: size_t i ) {
	return dynamic_cast < MultiplexTableEntryNumber & > ( Asn :: Array :: operator[] ( i ) );
}

void RequestMultiplexEntryRelease_entryNumbers :: push_back ( const MultiplexTableEntryNumber & o ) {
	Asn :: Array :: push_back ( new MultiplexTableEntryNumber ( o ) );
}

const MultiplexTableEntryNumber & RequestMultiplexEntryRelease_entryNumbers :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const MultiplexTableEntryNumber & > ( Asn :: Array :: operator[] ( i ) );
}

RequestMultiplexEntryRelease_entryNumbers * RequestMultiplexEntryRelease_entryNumbers :: clone ( ) const {
	return new RequestMultiplexEntryRelease_entryNumbers ( * this );
}

//
// RequestMode_requestedModes
//

RequestMode_requestedModes :: RequestMode_requestedModes ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 256 ) { }

RequestMode_requestedModes :: RequestMode_requestedModes ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 256 ) { }

RequestMode_requestedModes :: RequestMode_requestedModes ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 256 ) { }


Asn :: Object * RequestMode_requestedModes :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * RequestMode_requestedModes :: createObject ( Asn :: istream & is ) {
	return new ModeDescription ( is );
}

Asn :: Object * RequestMode_requestedModes :: createObject ( ) {
	return new ModeDescription ( );
}

ModeDescription & RequestMode_requestedModes :: operator[] ( std :: size_t i ) {
	return dynamic_cast < ModeDescription & > ( Asn :: Array :: operator[] ( i ) );
}

void RequestMode_requestedModes :: push_back ( const ModeDescription & o ) {
	Asn :: Array :: push_back ( new ModeDescription ( o ) );
}

const ModeDescription & RequestMode_requestedModes :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const ModeDescription & > ( Asn :: Array :: operator[] ( i ) );
}

RequestMode_requestedModes * RequestMode_requestedModes :: clone ( ) const {
	return new RequestMode_requestedModes ( * this );
}

//
// RequestModeAck_response
//

RequestModeAck_response :: RequestModeAck_response ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_willTransmitMostPreferredMode:
		case e_willTransmitLessPreferredMode:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

RequestModeAck_response :: RequestModeAck_response ( ) : Asn :: Choice ( 2, true ) { }

void RequestModeAck_response :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_willTransmitMostPreferredMode:
		case e_willTransmitLessPreferredMode:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & RequestModeAck_response :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_willTransmitMostPreferredMode, "willTransmitMostPreferredMode" },
		{ e_willTransmitLessPreferredMode, "willTransmitLessPreferredMode" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

RequestModeAck_response * RequestModeAck_response :: clone ( ) const {
	return new RequestModeAck_response ( * this );
}

//
// RequestModeReject_cause
//

RequestModeReject_cause :: RequestModeReject_cause ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_modeUnavailable:
		case e_multipointConstraint:
		case e_requestDenied:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

RequestModeReject_cause :: RequestModeReject_cause ( ) : Asn :: Choice ( 3, true ) { }

void RequestModeReject_cause :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_modeUnavailable:
		case e_multipointConstraint:
		case e_requestDenied:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & RequestModeReject_cause :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_modeUnavailable, "modeUnavailable" },
		{ e_multipointConstraint, "multipointConstraint" },
		{ e_requestDenied, "requestDenied" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

RequestModeReject_cause * RequestModeReject_cause :: clone ( ) const {
	return new RequestModeReject_cause ( * this );
}

//
// ArrayOf_RedundancyEncodingDTModeElement
//

ArrayOf_RedundancyEncodingDTModeElement :: ArrayOf_RedundancyEncodingDTModeElement ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_RedundancyEncodingDTModeElement :: ArrayOf_RedundancyEncodingDTModeElement ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_RedundancyEncodingDTModeElement :: ArrayOf_RedundancyEncodingDTModeElement ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_RedundancyEncodingDTModeElement :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_RedundancyEncodingDTModeElement :: createObject ( Asn :: istream & is ) {
	return new RedundancyEncodingDTModeElement ( is );
}

Asn :: Object * ArrayOf_RedundancyEncodingDTModeElement :: createObject ( ) {
	return new RedundancyEncodingDTModeElement ( );
}

RedundancyEncodingDTModeElement & ArrayOf_RedundancyEncodingDTModeElement :: operator[] ( std :: size_t i ) {
	return dynamic_cast < RedundancyEncodingDTModeElement & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_RedundancyEncodingDTModeElement :: push_back ( const RedundancyEncodingDTModeElement & o ) {
	Asn :: Array :: push_back ( new RedundancyEncodingDTModeElement ( o ) );
}

const RedundancyEncodingDTModeElement & ArrayOf_RedundancyEncodingDTModeElement :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const RedundancyEncodingDTModeElement & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_RedundancyEncodingDTModeElement * ArrayOf_RedundancyEncodingDTModeElement :: clone ( ) const {
	return new ArrayOf_RedundancyEncodingDTModeElement ( * this );
}

//
// ArrayOf_MultiplePayloadStreamElementMode
//

ArrayOf_MultiplePayloadStreamElementMode :: ArrayOf_MultiplePayloadStreamElementMode ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_MultiplePayloadStreamElementMode :: ArrayOf_MultiplePayloadStreamElementMode ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_MultiplePayloadStreamElementMode :: ArrayOf_MultiplePayloadStreamElementMode ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_MultiplePayloadStreamElementMode :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_MultiplePayloadStreamElementMode :: createObject ( Asn :: istream & is ) {
	return new MultiplePayloadStreamElementMode ( is );
}

Asn :: Object * ArrayOf_MultiplePayloadStreamElementMode :: createObject ( ) {
	return new MultiplePayloadStreamElementMode ( );
}

MultiplePayloadStreamElementMode & ArrayOf_MultiplePayloadStreamElementMode :: operator[] ( std :: size_t i ) {
	return dynamic_cast < MultiplePayloadStreamElementMode & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_MultiplePayloadStreamElementMode :: push_back ( const MultiplePayloadStreamElementMode & o ) {
	Asn :: Array :: push_back ( new MultiplePayloadStreamElementMode ( o ) );
}

const MultiplePayloadStreamElementMode & ArrayOf_MultiplePayloadStreamElementMode :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const MultiplePayloadStreamElementMode & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_MultiplePayloadStreamElementMode * ArrayOf_MultiplePayloadStreamElementMode :: clone ( ) const {
	return new ArrayOf_MultiplePayloadStreamElementMode ( * this );
}

//
// FECMode_rfc2733Format
//

FECMode_rfc2733Format :: FECMode_rfc2733Format ( Asn :: istream & is ) : Asn :: Choice ( is, 3, false ) {
	switch ( tag ) {
		case e_rfc2733rfc2198:
		case e_rfc2733sameport:
		case e_rfc2733diffport:
			choice = new MaxRedundancy ( is );
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
}

FECMode_rfc2733Format :: FECMode_rfc2733Format ( ) : Asn :: Choice ( 3, false ) { }

void FECMode_rfc2733Format :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_rfc2733rfc2198:
		case e_rfc2733sameport:
		case e_rfc2733diffport:
			o = new MaxRedundancy;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & FECMode_rfc2733Format :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_rfc2733rfc2198, "rfc2733rfc2198" },
		{ e_rfc2733sameport, "rfc2733sameport" },
		{ e_rfc2733diffport, "rfc2733diffport" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

FECMode_rfc2733Format * FECMode_rfc2733Format :: clone ( ) const {
	return new FECMode_rfc2733Format ( * this );
}

//
// H261VideoMode_resolution
//

H261VideoMode_resolution :: H261VideoMode_resolution ( Asn :: istream & is ) : Asn :: Choice ( is, 2, false ) {
	switch ( tag ) {
		case e_qcif:
		case e_cif:
			choice = new Asn :: Null ( is );
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
}

H261VideoMode_resolution :: H261VideoMode_resolution ( ) : Asn :: Choice ( 2, false ) { }

void H261VideoMode_resolution :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_qcif:
		case e_cif:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & H261VideoMode_resolution :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_qcif, "qcif" },
		{ e_cif, "cif" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

H261VideoMode_resolution * H261VideoMode_resolution :: clone ( ) const {
	return new H261VideoMode_resolution ( * this );
}

//
// H261VideoMode_bitRate
//

H261VideoMode_bitRate :: H261VideoMode_bitRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 19200 ) { }

H261VideoMode_bitRate :: H261VideoMode_bitRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 19200 ) { }

H261VideoMode_bitRate * H261VideoMode_bitRate :: clone ( ) const {
	return new H261VideoMode_bitRate ( * this );
}

//
// H262VideoMode_profileAndLevel
//

H262VideoMode_profileAndLevel :: H262VideoMode_profileAndLevel ( Asn :: istream & is ) : Asn :: Choice ( is, 11, true ) {
	switch ( tag ) {
		case e_profileAndLevel_SPatML:
		case e_profileAndLevel_MPatLL:
		case e_profileAndLevel_MPatML:
		case e_profileAndLevel_MPatH_14:
		case e_profileAndLevel_MPatHL:
		case e_profileAndLevel_SNRatLL:
		case e_profileAndLevel_SNRatML:
		case e_profileAndLevel_SpatialatH_14:
		case e_profileAndLevel_HPatML:
		case e_profileAndLevel_HPatH_14:
		case e_profileAndLevel_HPatHL:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

H262VideoMode_profileAndLevel :: H262VideoMode_profileAndLevel ( ) : Asn :: Choice ( 11, true ) { }

void H262VideoMode_profileAndLevel :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_profileAndLevel_SPatML:
		case e_profileAndLevel_MPatLL:
		case e_profileAndLevel_MPatML:
		case e_profileAndLevel_MPatH_14:
		case e_profileAndLevel_MPatHL:
		case e_profileAndLevel_SNRatLL:
		case e_profileAndLevel_SNRatML:
		case e_profileAndLevel_SpatialatH_14:
		case e_profileAndLevel_HPatML:
		case e_profileAndLevel_HPatH_14:
		case e_profileAndLevel_HPatHL:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & H262VideoMode_profileAndLevel :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_profileAndLevel_SPatML, "profileAndLevel_SPatML" },
		{ e_profileAndLevel_MPatLL, "profileAndLevel_MPatLL" },
		{ e_profileAndLevel_MPatML, "profileAndLevel_MPatML" },
		{ e_profileAndLevel_MPatH_14, "profileAndLevel_MPatH_14" },
		{ e_profileAndLevel_MPatHL, "profileAndLevel_MPatHL" },
		{ e_profileAndLevel_SNRatLL, "profileAndLevel_SNRatLL" },
		{ e_profileAndLevel_SNRatML, "profileAndLevel_SNRatML" },
		{ e_profileAndLevel_SpatialatH_14, "profileAndLevel_SpatialatH_14" },
		{ e_profileAndLevel_HPatML, "profileAndLevel_HPatML" },
		{ e_profileAndLevel_HPatH_14, "profileAndLevel_HPatH_14" },
		{ e_profileAndLevel_HPatHL, "profileAndLevel_HPatHL" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

H262VideoMode_profileAndLevel * H262VideoMode_profileAndLevel :: clone ( ) const {
	return new H262VideoMode_profileAndLevel ( * this );
}

//
// H262VideoMode_videoBitRate
//

H262VideoMode_videoBitRate :: H262VideoMode_videoBitRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 1073741823 ) { }

H262VideoMode_videoBitRate :: H262VideoMode_videoBitRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 1073741823 ) { }

H262VideoMode_videoBitRate * H262VideoMode_videoBitRate :: clone ( ) const {
	return new H262VideoMode_videoBitRate ( * this );
}

//
// H262VideoMode_vbvBufferSize
//

H262VideoMode_vbvBufferSize :: H262VideoMode_vbvBufferSize ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 262143 ) { }

H262VideoMode_vbvBufferSize :: H262VideoMode_vbvBufferSize ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 262143 ) { }

H262VideoMode_vbvBufferSize * H262VideoMode_vbvBufferSize :: clone ( ) const {
	return new H262VideoMode_vbvBufferSize ( * this );
}

//
// H262VideoMode_samplesPerLine
//

H262VideoMode_samplesPerLine :: H262VideoMode_samplesPerLine ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 16383 ) { }

H262VideoMode_samplesPerLine :: H262VideoMode_samplesPerLine ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 16383 ) { }

H262VideoMode_samplesPerLine * H262VideoMode_samplesPerLine :: clone ( ) const {
	return new H262VideoMode_samplesPerLine ( * this );
}

//
// H262VideoMode_linesPerFrame
//

H262VideoMode_linesPerFrame :: H262VideoMode_linesPerFrame ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 16383 ) { }

H262VideoMode_linesPerFrame :: H262VideoMode_linesPerFrame ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 16383 ) { }

H262VideoMode_linesPerFrame * H262VideoMode_linesPerFrame :: clone ( ) const {
	return new H262VideoMode_linesPerFrame ( * this );
}

//
// H262VideoMode_framesPerSecond
//

H262VideoMode_framesPerSecond :: H262VideoMode_framesPerSecond ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 15 ) { }

H262VideoMode_framesPerSecond :: H262VideoMode_framesPerSecond ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 15 ) { }

H262VideoMode_framesPerSecond * H262VideoMode_framesPerSecond :: clone ( ) const {
	return new H262VideoMode_framesPerSecond ( * this );
}

//
// H262VideoMode_luminanceSampleRate
//

H262VideoMode_luminanceSampleRate :: H262VideoMode_luminanceSampleRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 4294967295U ) { }

H262VideoMode_luminanceSampleRate :: H262VideoMode_luminanceSampleRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 4294967295U ) { }

H262VideoMode_luminanceSampleRate * H262VideoMode_luminanceSampleRate :: clone ( ) const {
	return new H262VideoMode_luminanceSampleRate ( * this );
}

//
// H263VideoMode_resolution
//

H263VideoMode_resolution :: H263VideoMode_resolution ( Asn :: istream & is ) : Asn :: Choice ( is, 5, true ) {
	switch ( tag ) {
		case e_sqcif:
		case e_qcif:
		case e_cif:
		case e_cif4:
		case e_cif16:
		case e_custom:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

H263VideoMode_resolution :: H263VideoMode_resolution ( ) : Asn :: Choice ( 5, true ) { }

void H263VideoMode_resolution :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_sqcif:
		case e_qcif:
		case e_cif:
		case e_cif4:
		case e_cif16:
		case e_custom:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & H263VideoMode_resolution :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_sqcif, "sqcif" },
		{ e_qcif, "qcif" },
		{ e_cif, "cif" },
		{ e_cif4, "cif4" },
		{ e_cif16, "cif16" },
		{ e_custom, "custom" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

H263VideoMode_resolution * H263VideoMode_resolution :: clone ( ) const {
	return new H263VideoMode_resolution ( * this );
}

//
// H263VideoMode_bitRate
//

H263VideoMode_bitRate :: H263VideoMode_bitRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 19200 ) { }

H263VideoMode_bitRate :: H263VideoMode_bitRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 19200 ) { }

H263VideoMode_bitRate * H263VideoMode_bitRate :: clone ( ) const {
	return new H263VideoMode_bitRate ( * this );
}

//
// IS11172VideoMode_videoBitRate
//

IS11172VideoMode_videoBitRate :: IS11172VideoMode_videoBitRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 1073741823 ) { }

IS11172VideoMode_videoBitRate :: IS11172VideoMode_videoBitRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 1073741823 ) { }

IS11172VideoMode_videoBitRate * IS11172VideoMode_videoBitRate :: clone ( ) const {
	return new IS11172VideoMode_videoBitRate ( * this );
}

//
// IS11172VideoMode_vbvBufferSize
//

IS11172VideoMode_vbvBufferSize :: IS11172VideoMode_vbvBufferSize ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 262143 ) { }

IS11172VideoMode_vbvBufferSize :: IS11172VideoMode_vbvBufferSize ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 262143 ) { }

IS11172VideoMode_vbvBufferSize * IS11172VideoMode_vbvBufferSize :: clone ( ) const {
	return new IS11172VideoMode_vbvBufferSize ( * this );
}

//
// IS11172VideoMode_samplesPerLine
//

IS11172VideoMode_samplesPerLine :: IS11172VideoMode_samplesPerLine ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 16383 ) { }

IS11172VideoMode_samplesPerLine :: IS11172VideoMode_samplesPerLine ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 16383 ) { }

IS11172VideoMode_samplesPerLine * IS11172VideoMode_samplesPerLine :: clone ( ) const {
	return new IS11172VideoMode_samplesPerLine ( * this );
}

//
// IS11172VideoMode_linesPerFrame
//

IS11172VideoMode_linesPerFrame :: IS11172VideoMode_linesPerFrame ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 16383 ) { }

IS11172VideoMode_linesPerFrame :: IS11172VideoMode_linesPerFrame ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 16383 ) { }

IS11172VideoMode_linesPerFrame * IS11172VideoMode_linesPerFrame :: clone ( ) const {
	return new IS11172VideoMode_linesPerFrame ( * this );
}

//
// IS11172VideoMode_pictureRate
//

IS11172VideoMode_pictureRate :: IS11172VideoMode_pictureRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 15 ) { }

IS11172VideoMode_pictureRate :: IS11172VideoMode_pictureRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 15 ) { }

IS11172VideoMode_pictureRate * IS11172VideoMode_pictureRate :: clone ( ) const {
	return new IS11172VideoMode_pictureRate ( * this );
}

//
// IS11172VideoMode_luminanceSampleRate
//

IS11172VideoMode_luminanceSampleRate :: IS11172VideoMode_luminanceSampleRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 4294967295U ) { }

IS11172VideoMode_luminanceSampleRate :: IS11172VideoMode_luminanceSampleRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 4294967295U ) { }

IS11172VideoMode_luminanceSampleRate * IS11172VideoMode_luminanceSampleRate :: clone ( ) const {
	return new IS11172VideoMode_luminanceSampleRate ( * this );
}

//
// AudioMode_g7231
//

AudioMode_g7231 :: AudioMode_g7231 ( Asn :: istream & is ) : Asn :: Choice ( is, 4, false ) {
	switch ( tag ) {
		case e_noSilenceSuppressionLowRate:
		case e_noSilenceSuppressionHighRate:
		case e_silenceSuppressionLowRate:
		case e_silenceSuppressionHighRate:
			choice = new Asn :: Null ( is );
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
}

AudioMode_g7231 :: AudioMode_g7231 ( ) : Asn :: Choice ( 4, false ) { }

void AudioMode_g7231 :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_noSilenceSuppressionLowRate:
		case e_noSilenceSuppressionHighRate:
		case e_silenceSuppressionLowRate:
		case e_silenceSuppressionHighRate:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & AudioMode_g7231 :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_noSilenceSuppressionLowRate, "noSilenceSuppressionLowRate" },
		{ e_noSilenceSuppressionHighRate, "noSilenceSuppressionHighRate" },
		{ e_silenceSuppressionLowRate, "silenceSuppressionLowRate" },
		{ e_silenceSuppressionHighRate, "silenceSuppressionHighRate" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

AudioMode_g7231 * AudioMode_g7231 :: clone ( ) const {
	return new AudioMode_g7231 ( * this );
}

//
// AudioMode_g729wAnnexB
//

AudioMode_g729wAnnexB :: AudioMode_g729wAnnexB ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 256 ) { }

AudioMode_g729wAnnexB :: AudioMode_g729wAnnexB ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 256 ) { }

AudioMode_g729wAnnexB * AudioMode_g729wAnnexB :: clone ( ) const {
	return new AudioMode_g729wAnnexB ( * this );
}

//
// AudioMode_g729AnnexAwAnnexB
//

AudioMode_g729AnnexAwAnnexB :: AudioMode_g729AnnexAwAnnexB ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 256 ) { }

AudioMode_g729AnnexAwAnnexB :: AudioMode_g729AnnexAwAnnexB ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 256 ) { }

AudioMode_g729AnnexAwAnnexB * AudioMode_g729AnnexAwAnnexB :: clone ( ) const {
	return new AudioMode_g729AnnexAwAnnexB ( * this );
}

//
// IS11172AudioMode_audioLayer
//

IS11172AudioMode_audioLayer :: IS11172AudioMode_audioLayer ( Asn :: istream & is ) : Asn :: Choice ( is, 3, false ) {
	switch ( tag ) {
		case e_audioLayer1:
		case e_audioLayer2:
		case e_audioLayer3:
			choice = new Asn :: Null ( is );
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
}

IS11172AudioMode_audioLayer :: IS11172AudioMode_audioLayer ( ) : Asn :: Choice ( 3, false ) { }

void IS11172AudioMode_audioLayer :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_audioLayer1:
		case e_audioLayer2:
		case e_audioLayer3:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & IS11172AudioMode_audioLayer :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_audioLayer1, "audioLayer1" },
		{ e_audioLayer2, "audioLayer2" },
		{ e_audioLayer3, "audioLayer3" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

IS11172AudioMode_audioLayer * IS11172AudioMode_audioLayer :: clone ( ) const {
	return new IS11172AudioMode_audioLayer ( * this );
}

//
// IS11172AudioMode_audioSampling
//

IS11172AudioMode_audioSampling :: IS11172AudioMode_audioSampling ( Asn :: istream & is ) : Asn :: Choice ( is, 3, false ) {
	switch ( tag ) {
		case e_audioSampling32k:
		case e_audioSampling44k1:
		case e_audioSampling48k:
			choice = new Asn :: Null ( is );
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
}

IS11172AudioMode_audioSampling :: IS11172AudioMode_audioSampling ( ) : Asn :: Choice ( 3, false ) { }

void IS11172AudioMode_audioSampling :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_audioSampling32k:
		case e_audioSampling44k1:
		case e_audioSampling48k:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & IS11172AudioMode_audioSampling :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_audioSampling32k, "audioSampling32k" },
		{ e_audioSampling44k1, "audioSampling44k1" },
		{ e_audioSampling48k, "audioSampling48k" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

IS11172AudioMode_audioSampling * IS11172AudioMode_audioSampling :: clone ( ) const {
	return new IS11172AudioMode_audioSampling ( * this );
}

//
// IS11172AudioMode_multichannelType
//

IS11172AudioMode_multichannelType :: IS11172AudioMode_multichannelType ( Asn :: istream & is ) : Asn :: Choice ( is, 3, false ) {
	switch ( tag ) {
		case e_singleChannel:
		case e_twoChannelStereo:
		case e_twoChannelDual:
			choice = new Asn :: Null ( is );
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
}

IS11172AudioMode_multichannelType :: IS11172AudioMode_multichannelType ( ) : Asn :: Choice ( 3, false ) { }

void IS11172AudioMode_multichannelType :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_singleChannel:
		case e_twoChannelStereo:
		case e_twoChannelDual:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & IS11172AudioMode_multichannelType :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_singleChannel, "singleChannel" },
		{ e_twoChannelStereo, "twoChannelStereo" },
		{ e_twoChannelDual, "twoChannelDual" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

IS11172AudioMode_multichannelType * IS11172AudioMode_multichannelType :: clone ( ) const {
	return new IS11172AudioMode_multichannelType ( * this );
}

//
// IS11172AudioMode_bitRate
//

IS11172AudioMode_bitRate :: IS11172AudioMode_bitRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 448 ) { }

IS11172AudioMode_bitRate :: IS11172AudioMode_bitRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 448 ) { }

IS11172AudioMode_bitRate * IS11172AudioMode_bitRate :: clone ( ) const {
	return new IS11172AudioMode_bitRate ( * this );
}

//
// IS13818AudioMode_audioLayer
//

IS13818AudioMode_audioLayer :: IS13818AudioMode_audioLayer ( Asn :: istream & is ) : Asn :: Choice ( is, 3, false ) {
	switch ( tag ) {
		case e_audioLayer1:
		case e_audioLayer2:
		case e_audioLayer3:
			choice = new Asn :: Null ( is );
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
}

IS13818AudioMode_audioLayer :: IS13818AudioMode_audioLayer ( ) : Asn :: Choice ( 3, false ) { }

void IS13818AudioMode_audioLayer :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_audioLayer1:
		case e_audioLayer2:
		case e_audioLayer3:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & IS13818AudioMode_audioLayer :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_audioLayer1, "audioLayer1" },
		{ e_audioLayer2, "audioLayer2" },
		{ e_audioLayer3, "audioLayer3" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

IS13818AudioMode_audioLayer * IS13818AudioMode_audioLayer :: clone ( ) const {
	return new IS13818AudioMode_audioLayer ( * this );
}

//
// IS13818AudioMode_audioSampling
//

IS13818AudioMode_audioSampling :: IS13818AudioMode_audioSampling ( Asn :: istream & is ) : Asn :: Choice ( is, 6, false ) {
	switch ( tag ) {
		case e_audioSampling16k:
		case e_audioSampling22k05:
		case e_audioSampling24k:
		case e_audioSampling32k:
		case e_audioSampling44k1:
		case e_audioSampling48k:
			choice = new Asn :: Null ( is );
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
}

IS13818AudioMode_audioSampling :: IS13818AudioMode_audioSampling ( ) : Asn :: Choice ( 6, false ) { }

void IS13818AudioMode_audioSampling :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_audioSampling16k:
		case e_audioSampling22k05:
		case e_audioSampling24k:
		case e_audioSampling32k:
		case e_audioSampling44k1:
		case e_audioSampling48k:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & IS13818AudioMode_audioSampling :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_audioSampling16k, "audioSampling16k" },
		{ e_audioSampling22k05, "audioSampling22k05" },
		{ e_audioSampling24k, "audioSampling24k" },
		{ e_audioSampling32k, "audioSampling32k" },
		{ e_audioSampling44k1, "audioSampling44k1" },
		{ e_audioSampling48k, "audioSampling48k" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

IS13818AudioMode_audioSampling * IS13818AudioMode_audioSampling :: clone ( ) const {
	return new IS13818AudioMode_audioSampling ( * this );
}

//
// IS13818AudioMode_multichannelType
//

IS13818AudioMode_multichannelType :: IS13818AudioMode_multichannelType ( Asn :: istream & is ) : Asn :: Choice ( is, 10, false ) {
	switch ( tag ) {
		case e_singleChannel:
		case e_twoChannelStereo:
		case e_twoChannelDual:
		case e_threeChannels2_1:
		case e_threeChannels3_0:
		case e_fourChannels2_0_2_0:
		case e_fourChannels2_2:
		case e_fourChannels3_1:
		case e_fiveChannels3_0_2_0:
		case e_fiveChannels3_2:
			choice = new Asn :: Null ( is );
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
}

IS13818AudioMode_multichannelType :: IS13818AudioMode_multichannelType ( ) : Asn :: Choice ( 10, false ) { }

void IS13818AudioMode_multichannelType :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_singleChannel:
		case e_twoChannelStereo:
		case e_twoChannelDual:
		case e_threeChannels2_1:
		case e_threeChannels3_0:
		case e_fourChannels2_0_2_0:
		case e_fourChannels2_2:
		case e_fourChannels3_1:
		case e_fiveChannels3_0_2_0:
		case e_fiveChannels3_2:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & IS13818AudioMode_multichannelType :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_singleChannel, "singleChannel" },
		{ e_twoChannelStereo, "twoChannelStereo" },
		{ e_twoChannelDual, "twoChannelDual" },
		{ e_threeChannels2_1, "threeChannels2_1" },
		{ e_threeChannels3_0, "threeChannels3_0" },
		{ e_fourChannels2_0_2_0, "fourChannels2_0_2_0" },
		{ e_fourChannels2_2, "fourChannels2_2" },
		{ e_fourChannels3_1, "fourChannels3_1" },
		{ e_fiveChannels3_0_2_0, "fiveChannels3_0_2_0" },
		{ e_fiveChannels3_2, "fiveChannels3_2" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

IS13818AudioMode_multichannelType * IS13818AudioMode_multichannelType :: clone ( ) const {
	return new IS13818AudioMode_multichannelType ( * this );
}

//
// IS13818AudioMode_bitRate
//

IS13818AudioMode_bitRate :: IS13818AudioMode_bitRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 1130 ) { }

IS13818AudioMode_bitRate :: IS13818AudioMode_bitRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 1130 ) { }

IS13818AudioMode_bitRate * IS13818AudioMode_bitRate :: clone ( ) const {
	return new IS13818AudioMode_bitRate ( * this );
}

//
// G7231AnnexCMode_maxAl-sduAudioFrames
//

G7231AnnexCMode_maxAl_sduAudioFrames :: G7231AnnexCMode_maxAl_sduAudioFrames ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 256 ) { }

G7231AnnexCMode_maxAl_sduAudioFrames :: G7231AnnexCMode_maxAl_sduAudioFrames ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 256 ) { }

G7231AnnexCMode_maxAl_sduAudioFrames * G7231AnnexCMode_maxAl_sduAudioFrames :: clone ( ) const {
	return new G7231AnnexCMode_maxAl_sduAudioFrames ( * this );
}

//
// DataMode_bitRate
//

DataMode_bitRate :: DataMode_bitRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 4294967295U ) { }

DataMode_bitRate :: DataMode_bitRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 4294967295U ) { }

DataMode_bitRate * DataMode_bitRate :: clone ( ) const {
	return new DataMode_bitRate ( * this );
}

//
// MaintenanceLoopRequest_type
//

MaintenanceLoopRequest_type :: MaintenanceLoopRequest_type ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_systemLoop:
			choice = new Asn :: Null ( is );
			break;
		case e_mediaLoop:
		case e_logicalChannelLoop:
			choice = new LogicalChannelNumber ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

MaintenanceLoopRequest_type :: MaintenanceLoopRequest_type ( ) : Asn :: Choice ( 3, true ) { }

void MaintenanceLoopRequest_type :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_systemLoop:
			o = new Asn :: Null;
			break;
		case e_mediaLoop:
		case e_logicalChannelLoop:
			o = new LogicalChannelNumber;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & MaintenanceLoopRequest_type :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_systemLoop, "systemLoop" },
		{ e_mediaLoop, "mediaLoop" },
		{ e_logicalChannelLoop, "logicalChannelLoop" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

MaintenanceLoopRequest_type * MaintenanceLoopRequest_type :: clone ( ) const {
	return new MaintenanceLoopRequest_type ( * this );
}

//
// MaintenanceLoopAck_type
//

MaintenanceLoopAck_type :: MaintenanceLoopAck_type ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_systemLoop:
			choice = new Asn :: Null ( is );
			break;
		case e_mediaLoop:
		case e_logicalChannelLoop:
			choice = new LogicalChannelNumber ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

MaintenanceLoopAck_type :: MaintenanceLoopAck_type ( ) : Asn :: Choice ( 3, true ) { }

void MaintenanceLoopAck_type :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_systemLoop:
			o = new Asn :: Null;
			break;
		case e_mediaLoop:
		case e_logicalChannelLoop:
			o = new LogicalChannelNumber;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & MaintenanceLoopAck_type :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_systemLoop, "systemLoop" },
		{ e_mediaLoop, "mediaLoop" },
		{ e_logicalChannelLoop, "logicalChannelLoop" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

MaintenanceLoopAck_type * MaintenanceLoopAck_type :: clone ( ) const {
	return new MaintenanceLoopAck_type ( * this );
}

//
// MaintenanceLoopReject_type
//

MaintenanceLoopReject_type :: MaintenanceLoopReject_type ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_systemLoop:
			choice = new Asn :: Null ( is );
			break;
		case e_mediaLoop:
		case e_logicalChannelLoop:
			choice = new LogicalChannelNumber ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

MaintenanceLoopReject_type :: MaintenanceLoopReject_type ( ) : Asn :: Choice ( 3, true ) { }

void MaintenanceLoopReject_type :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_systemLoop:
			o = new Asn :: Null;
			break;
		case e_mediaLoop:
		case e_logicalChannelLoop:
			o = new LogicalChannelNumber;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & MaintenanceLoopReject_type :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_systemLoop, "systemLoop" },
		{ e_mediaLoop, "mediaLoop" },
		{ e_logicalChannelLoop, "logicalChannelLoop" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

MaintenanceLoopReject_type * MaintenanceLoopReject_type :: clone ( ) const {
	return new MaintenanceLoopReject_type ( * this );
}

//
// MaintenanceLoopReject_cause
//

MaintenanceLoopReject_cause :: MaintenanceLoopReject_cause ( Asn :: istream & is ) : Asn :: Choice ( is, 1, true ) {
	switch ( tag ) {
		case e_canNotPerformLoop:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

MaintenanceLoopReject_cause :: MaintenanceLoopReject_cause ( ) : Asn :: Choice ( 1, true ) { }

void MaintenanceLoopReject_cause :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_canNotPerformLoop:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & MaintenanceLoopReject_cause :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_canNotPerformLoop, "canNotPerformLoop" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

MaintenanceLoopReject_cause * MaintenanceLoopReject_cause :: clone ( ) const {
	return new MaintenanceLoopReject_cause ( * this );
}

//
// CommunicationModeCommand_communicationModeTable
//

CommunicationModeCommand_communicationModeTable :: CommunicationModeCommand_communicationModeTable ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 256 ) { }

CommunicationModeCommand_communicationModeTable :: CommunicationModeCommand_communicationModeTable ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 256 ) { }

CommunicationModeCommand_communicationModeTable :: CommunicationModeCommand_communicationModeTable ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 256 ) { }


Asn :: Object * CommunicationModeCommand_communicationModeTable :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * CommunicationModeCommand_communicationModeTable :: createObject ( Asn :: istream & is ) {
	return new CommunicationModeTableEntry ( is );
}

Asn :: Object * CommunicationModeCommand_communicationModeTable :: createObject ( ) {
	return new CommunicationModeTableEntry ( );
}

CommunicationModeTableEntry & CommunicationModeCommand_communicationModeTable :: operator[] ( std :: size_t i ) {
	return dynamic_cast < CommunicationModeTableEntry & > ( Asn :: Array :: operator[] ( i ) );
}

void CommunicationModeCommand_communicationModeTable :: push_back ( const CommunicationModeTableEntry & o ) {
	Asn :: Array :: push_back ( new CommunicationModeTableEntry ( o ) );
}

const CommunicationModeTableEntry & CommunicationModeCommand_communicationModeTable :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const CommunicationModeTableEntry & > ( Asn :: Array :: operator[] ( i ) );
}

CommunicationModeCommand_communicationModeTable * CommunicationModeCommand_communicationModeTable :: clone ( ) const {
	return new CommunicationModeCommand_communicationModeTable ( * this );
}

//
// CommunicationModeResponse_communicationModeTable
//

CommunicationModeResponse_communicationModeTable :: CommunicationModeResponse_communicationModeTable ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 256 ) { }

CommunicationModeResponse_communicationModeTable :: CommunicationModeResponse_communicationModeTable ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 256 ) { }

CommunicationModeResponse_communicationModeTable :: CommunicationModeResponse_communicationModeTable ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 256 ) { }


Asn :: Object * CommunicationModeResponse_communicationModeTable :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * CommunicationModeResponse_communicationModeTable :: createObject ( Asn :: istream & is ) {
	return new CommunicationModeTableEntry ( is );
}

Asn :: Object * CommunicationModeResponse_communicationModeTable :: createObject ( ) {
	return new CommunicationModeTableEntry ( );
}

CommunicationModeTableEntry & CommunicationModeResponse_communicationModeTable :: operator[] ( std :: size_t i ) {
	return dynamic_cast < CommunicationModeTableEntry & > ( Asn :: Array :: operator[] ( i ) );
}

void CommunicationModeResponse_communicationModeTable :: push_back ( const CommunicationModeTableEntry & o ) {
	Asn :: Array :: push_back ( new CommunicationModeTableEntry ( o ) );
}

const CommunicationModeTableEntry & CommunicationModeResponse_communicationModeTable :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const CommunicationModeTableEntry & > ( Asn :: Array :: operator[] ( i ) );
}

CommunicationModeResponse_communicationModeTable * CommunicationModeResponse_communicationModeTable :: clone ( ) const {
	return new CommunicationModeResponse_communicationModeTable ( * this );
}

//
// CommunicationModeTableEntry_sessionID
//

CommunicationModeTableEntry_sessionID :: CommunicationModeTableEntry_sessionID ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 255 ) { }

CommunicationModeTableEntry_sessionID :: CommunicationModeTableEntry_sessionID ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 255 ) { }

CommunicationModeTableEntry_sessionID * CommunicationModeTableEntry_sessionID :: clone ( ) const {
	return new CommunicationModeTableEntry_sessionID ( * this );
}

//
// CommunicationModeTableEntry_associatedSessionID
//

CommunicationModeTableEntry_associatedSessionID :: CommunicationModeTableEntry_associatedSessionID ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 255 ) { }

CommunicationModeTableEntry_associatedSessionID :: CommunicationModeTableEntry_associatedSessionID ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 255 ) { }

CommunicationModeTableEntry_associatedSessionID * CommunicationModeTableEntry_associatedSessionID :: clone ( ) const {
	return new CommunicationModeTableEntry_associatedSessionID ( * this );
}

//
// CommunicationModeTableEntry_sessionDescription
//

CommunicationModeTableEntry_sessionDescription :: CommunicationModeTableEntry_sessionDescription ( Asn :: istream & is ) : Asn :: BMPString ( is, Asn :: fixedConstraint, 1, 128 ) { }

CommunicationModeTableEntry_sessionDescription :: CommunicationModeTableEntry_sessionDescription ( const Asn :: string & v ) : Asn :: BMPString ( v, Asn :: fixedConstraint, 1, 128 ) { }

CommunicationModeTableEntry_sessionDescription * CommunicationModeTableEntry_sessionDescription :: clone ( ) const {
	return new CommunicationModeTableEntry_sessionDescription ( * this );
}

//
// CommunicationModeTableEntry_sessionDependency
//

CommunicationModeTableEntry_sessionDependency :: CommunicationModeTableEntry_sessionDependency ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 255 ) { }

CommunicationModeTableEntry_sessionDependency :: CommunicationModeTableEntry_sessionDependency ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 255 ) { }

CommunicationModeTableEntry_sessionDependency * CommunicationModeTableEntry_sessionDependency :: clone ( ) const {
	return new CommunicationModeTableEntry_sessionDependency ( * this );
}

//
// ConferenceRequest_requestTerminalCertificate
//

ConferenceRequest_requestTerminalCertificate :: ConferenceRequest_requestTerminalCertificate ( Asn :: istream & is ) : Asn :: Sequence ( is, 3, true, 0 ), m_terminalLabel ( 0 ), m_certSelectionCriteria ( 0 ), m_sRandom ( 0 ) {
	try {
		if ( hasOptionalField ( e_terminalLabel ) )
			m_terminalLabel = new TerminalLabel ( is );
		if ( hasOptionalField ( e_certSelectionCriteria ) )
			m_certSelectionCriteria = new CertSelectionCriteria ( is );
		if ( hasOptionalField ( e_sRandom ) )
			m_sRandom = new ConferenceRequest_requestTerminalCertificate_sRandom ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_terminalLabel;
		delete m_certSelectionCriteria;
		delete m_sRandom;
		throw;
	}
}

ConferenceRequest_requestTerminalCertificate :: ConferenceRequest_requestTerminalCertificate ( ) : Asn :: Sequence ( 3, true, 0 ), m_terminalLabel ( 0 ), m_certSelectionCriteria ( 0 ), m_sRandom ( 0 ) { }

ConferenceRequest_requestTerminalCertificate & ConferenceRequest_requestTerminalCertificate :: operator= ( const ConferenceRequest_requestTerminalCertificate & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_terminalLabel, s.m_terminalLabel );
	assignCopy ( m_certSelectionCriteria, s.m_certSelectionCriteria );
	assignCopy ( m_sRandom, s.m_sRandom );
	return * this;
}

ConferenceRequest_requestTerminalCertificate :: ConferenceRequest_requestTerminalCertificate ( const ConferenceRequest_requestTerminalCertificate & s ) : Asn :: Sequence ( s ), m_terminalLabel ( 0 ), m_certSelectionCriteria ( 0 ), m_sRandom ( 0 ) {
	try {
		if ( s.m_terminalLabel )
			m_terminalLabel = new TerminalLabel ( * s.m_terminalLabel );
		if ( s.m_certSelectionCriteria )
			m_certSelectionCriteria = new CertSelectionCriteria ( * s.m_certSelectionCriteria );
		if ( s.m_sRandom )
			m_sRandom = new ConferenceRequest_requestTerminalCertificate_sRandom ( * s.m_sRandom );
	} catch ( ... ) {
		delete m_terminalLabel;
		delete m_certSelectionCriteria;
		delete m_sRandom;
		throw;
	}
}


void ConferenceRequest_requestTerminalCertificate :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_terminalLabel:
			assignNew ( m_terminalLabel, new TerminalLabel );
			break;
		case e_certSelectionCriteria:
			assignNew ( m_certSelectionCriteria, new CertSelectionCriteria );
			break;
		case e_sRandom:
			assignNew ( m_sRandom, new ConferenceRequest_requestTerminalCertificate_sRandom );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void ConferenceRequest_requestTerminalCertificate :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_terminalLabel:
			delete m_terminalLabel;
			m_terminalLabel = 0;
			break;
		case e_certSelectionCriteria:
			delete m_certSelectionCriteria;
			m_certSelectionCriteria = 0;
			break;
		case e_sRandom:
			delete m_sRandom;
			m_sRandom = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void ConferenceRequest_requestTerminalCertificate :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_terminalLabel ) )
		m_terminalLabel -> TerminalLabel :: encode ( os );
	if ( hasOptionalField ( e_certSelectionCriteria ) )
		m_certSelectionCriteria -> CertSelectionCriteria :: encode ( os );
	if ( hasOptionalField ( e_sRandom ) )
		m_sRandom -> ConferenceRequest_requestTerminalCertificate_sRandom :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

ConferenceRequest_requestTerminalCertificate :: ~ConferenceRequest_requestTerminalCertificate ( ) {
	delete m_terminalLabel;
	delete m_certSelectionCriteria;
	delete m_sRandom;
}

void ConferenceRequest_requestTerminalCertificate :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_terminalLabel ) ) {
		os << std :: setw ( indent + 16 ) << "terminalLabel = " << std :: setprecision ( indent );
		m_terminalLabel -> TerminalLabel :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_certSelectionCriteria ) ) {
		os << std :: setw ( indent + 24 ) << "certSelectionCriteria = " << std :: setprecision ( indent );
		m_certSelectionCriteria -> CertSelectionCriteria :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_sRandom ) ) {
		os << std :: setw ( indent + 10 ) << "sRandom = " << std :: setprecision ( indent );
		m_sRandom -> ConferenceRequest_requestTerminalCertificate_sRandom :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

ConferenceRequest_requestTerminalCertificate * ConferenceRequest_requestTerminalCertificate :: clone ( ) const {
	return new ConferenceRequest_requestTerminalCertificate ( * this );
}

//
// Criteria_value
//

Criteria_value :: Criteria_value ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 1, 65535 ) { }

Criteria_value :: Criteria_value ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 1, 65535 ) { }

Criteria_value * Criteria_value :: clone ( ) const {
	return new Criteria_value ( * this );
}

//
// ConferenceResponse_terminalListResponse
//

ConferenceResponse_terminalListResponse :: ConferenceResponse_terminalListResponse ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 256 ) { }

ConferenceResponse_terminalListResponse :: ConferenceResponse_terminalListResponse ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 256 ) { }

ConferenceResponse_terminalListResponse :: ConferenceResponse_terminalListResponse ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 256 ) { }


Asn :: Object * ConferenceResponse_terminalListResponse :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ConferenceResponse_terminalListResponse :: createObject ( Asn :: istream & is ) {
	return new TerminalLabel ( is );
}

Asn :: Object * ConferenceResponse_terminalListResponse :: createObject ( ) {
	return new TerminalLabel ( );
}

TerminalLabel & ConferenceResponse_terminalListResponse :: operator[] ( std :: size_t i ) {
	return dynamic_cast < TerminalLabel & > ( Asn :: Array :: operator[] ( i ) );
}

void ConferenceResponse_terminalListResponse :: push_back ( const TerminalLabel & o ) {
	Asn :: Array :: push_back ( new TerminalLabel ( o ) );
}

const TerminalLabel & ConferenceResponse_terminalListResponse :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const TerminalLabel & > ( Asn :: Array :: operator[] ( i ) );
}

ConferenceResponse_terminalListResponse * ConferenceResponse_terminalListResponse :: clone ( ) const {
	return new ConferenceResponse_terminalListResponse ( * this );
}

//
// ConferenceResponse_makeMeChairResponse
//

ConferenceResponse_makeMeChairResponse :: ConferenceResponse_makeMeChairResponse ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_grantedChairToken:
		case e_deniedChairToken:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

ConferenceResponse_makeMeChairResponse :: ConferenceResponse_makeMeChairResponse ( ) : Asn :: Choice ( 2, true ) { }

void ConferenceResponse_makeMeChairResponse :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_grantedChairToken:
		case e_deniedChairToken:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & ConferenceResponse_makeMeChairResponse :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_grantedChairToken, "grantedChairToken" },
		{ e_deniedChairToken, "deniedChairToken" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

ConferenceResponse_makeMeChairResponse * ConferenceResponse_makeMeChairResponse :: clone ( ) const {
	return new ConferenceResponse_makeMeChairResponse ( * this );
}

//
// ConferenceResponse_extensionAddressResponse
//

ConferenceResponse_extensionAddressResponse :: ConferenceResponse_extensionAddressResponse ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_extensionAddress ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

ConferenceResponse_extensionAddressResponse :: ConferenceResponse_extensionAddressResponse ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void ConferenceResponse_extensionAddressResponse :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_extensionAddress.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void ConferenceResponse_extensionAddressResponse :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 19 ) << "extensionAddress = " << std :: setprecision ( indent ) << m_extensionAddress << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

ConferenceResponse_extensionAddressResponse * ConferenceResponse_extensionAddressResponse :: clone ( ) const {
	return new ConferenceResponse_extensionAddressResponse ( * this );
}

//
// ConferenceResponse_terminalCertificateResponse
//

ConferenceResponse_terminalCertificateResponse :: ConferenceResponse_terminalCertificateResponse ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 0 ), m_terminalLabel ( 0 ), m_certificateResponse ( 0 ) {
	try {
		if ( hasOptionalField ( e_terminalLabel ) )
			m_terminalLabel = new TerminalLabel ( is );
		if ( hasOptionalField ( e_certificateResponse ) )
			m_certificateResponse = new ConferenceResponse_terminalCertificateResponse_certificateResponse ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_terminalLabel;
		delete m_certificateResponse;
		throw;
	}
}

ConferenceResponse_terminalCertificateResponse :: ConferenceResponse_terminalCertificateResponse ( ) : Asn :: Sequence ( 2, true, 0 ), m_terminalLabel ( 0 ), m_certificateResponse ( 0 ) { }

ConferenceResponse_terminalCertificateResponse & ConferenceResponse_terminalCertificateResponse :: operator= ( const ConferenceResponse_terminalCertificateResponse & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_terminalLabel, s.m_terminalLabel );
	assignCopy ( m_certificateResponse, s.m_certificateResponse );
	return * this;
}

ConferenceResponse_terminalCertificateResponse :: ConferenceResponse_terminalCertificateResponse ( const ConferenceResponse_terminalCertificateResponse & s ) : Asn :: Sequence ( s ), m_terminalLabel ( 0 ), m_certificateResponse ( 0 ) {
	try {
		if ( s.m_terminalLabel )
			m_terminalLabel = new TerminalLabel ( * s.m_terminalLabel );
		if ( s.m_certificateResponse )
			m_certificateResponse = new ConferenceResponse_terminalCertificateResponse_certificateResponse ( * s.m_certificateResponse );
	} catch ( ... ) {
		delete m_terminalLabel;
		delete m_certificateResponse;
		throw;
	}
}


void ConferenceResponse_terminalCertificateResponse :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_terminalLabel:
			assignNew ( m_terminalLabel, new TerminalLabel );
			break;
		case e_certificateResponse:
			assignNew ( m_certificateResponse, new ConferenceResponse_terminalCertificateResponse_certificateResponse );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void ConferenceResponse_terminalCertificateResponse :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_terminalLabel:
			delete m_terminalLabel;
			m_terminalLabel = 0;
			break;
		case e_certificateResponse:
			delete m_certificateResponse;
			m_certificateResponse = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void ConferenceResponse_terminalCertificateResponse :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_terminalLabel ) )
		m_terminalLabel -> TerminalLabel :: encode ( os );
	if ( hasOptionalField ( e_certificateResponse ) )
		m_certificateResponse -> ConferenceResponse_terminalCertificateResponse_certificateResponse :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

ConferenceResponse_terminalCertificateResponse :: ~ConferenceResponse_terminalCertificateResponse ( ) {
	delete m_terminalLabel;
	delete m_certificateResponse;
}

void ConferenceResponse_terminalCertificateResponse :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_terminalLabel ) ) {
		os << std :: setw ( indent + 16 ) << "terminalLabel = " << std :: setprecision ( indent );
		m_terminalLabel -> TerminalLabel :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_certificateResponse ) ) {
		os << std :: setw ( indent + 22 ) << "certificateResponse = " << std :: setprecision ( indent );
		m_certificateResponse -> ConferenceResponse_terminalCertificateResponse_certificateResponse :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

ConferenceResponse_terminalCertificateResponse * ConferenceResponse_terminalCertificateResponse :: clone ( ) const {
	return new ConferenceResponse_terminalCertificateResponse ( * this );
}

//
// ConferenceResponse_broadcastMyLogicalChannelResponse
//

ConferenceResponse_broadcastMyLogicalChannelResponse :: ConferenceResponse_broadcastMyLogicalChannelResponse ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_grantedBroadcastMyLogicalChannel:
		case e_deniedBroadcastMyLogicalChannel:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

ConferenceResponse_broadcastMyLogicalChannelResponse :: ConferenceResponse_broadcastMyLogicalChannelResponse ( ) : Asn :: Choice ( 2, true ) { }

void ConferenceResponse_broadcastMyLogicalChannelResponse :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_grantedBroadcastMyLogicalChannel:
		case e_deniedBroadcastMyLogicalChannel:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & ConferenceResponse_broadcastMyLogicalChannelResponse :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_grantedBroadcastMyLogicalChannel, "grantedBroadcastMyLogicalChannel" },
		{ e_deniedBroadcastMyLogicalChannel, "deniedBroadcastMyLogicalChannel" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

ConferenceResponse_broadcastMyLogicalChannelResponse * ConferenceResponse_broadcastMyLogicalChannelResponse :: clone ( ) const {
	return new ConferenceResponse_broadcastMyLogicalChannelResponse ( * this );
}

//
// ConferenceResponse_makeTerminalBroadcasterResponse
//

ConferenceResponse_makeTerminalBroadcasterResponse :: ConferenceResponse_makeTerminalBroadcasterResponse ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_grantedMakeTerminalBroadcaster:
		case e_deniedMakeTerminalBroadcaster:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

ConferenceResponse_makeTerminalBroadcasterResponse :: ConferenceResponse_makeTerminalBroadcasterResponse ( ) : Asn :: Choice ( 2, true ) { }

void ConferenceResponse_makeTerminalBroadcasterResponse :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_grantedMakeTerminalBroadcaster:
		case e_deniedMakeTerminalBroadcaster:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & ConferenceResponse_makeTerminalBroadcasterResponse :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_grantedMakeTerminalBroadcaster, "grantedMakeTerminalBroadcaster" },
		{ e_deniedMakeTerminalBroadcaster, "deniedMakeTerminalBroadcaster" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

ConferenceResponse_makeTerminalBroadcasterResponse * ConferenceResponse_makeTerminalBroadcasterResponse :: clone ( ) const {
	return new ConferenceResponse_makeTerminalBroadcasterResponse ( * this );
}

//
// ConferenceResponse_sendThisSourceResponse
//

ConferenceResponse_sendThisSourceResponse :: ConferenceResponse_sendThisSourceResponse ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_grantedSendThisSource:
		case e_deniedSendThisSource:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

ConferenceResponse_sendThisSourceResponse :: ConferenceResponse_sendThisSourceResponse ( ) : Asn :: Choice ( 2, true ) { }

void ConferenceResponse_sendThisSourceResponse :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_grantedSendThisSource:
		case e_deniedSendThisSource:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & ConferenceResponse_sendThisSourceResponse :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_grantedSendThisSource, "grantedSendThisSource" },
		{ e_deniedSendThisSource, "deniedSendThisSource" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

ConferenceResponse_sendThisSourceResponse * ConferenceResponse_sendThisSourceResponse :: clone ( ) const {
	return new ConferenceResponse_sendThisSourceResponse ( * this );
}

//
// ArrayOf_TerminalInformation
//

ArrayOf_TerminalInformation :: ArrayOf_TerminalInformation ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_TerminalInformation :: ArrayOf_TerminalInformation ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_TerminalInformation :: ArrayOf_TerminalInformation ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_TerminalInformation :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_TerminalInformation :: createObject ( Asn :: istream & is ) {
	return new TerminalInformation ( is );
}

Asn :: Object * ArrayOf_TerminalInformation :: createObject ( ) {
	return new TerminalInformation ( );
}

TerminalInformation & ArrayOf_TerminalInformation :: operator[] ( std :: size_t i ) {
	return dynamic_cast < TerminalInformation & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_TerminalInformation :: push_back ( const TerminalInformation & o ) {
	Asn :: Array :: push_back ( new TerminalInformation ( o ) );
}

const TerminalInformation & ArrayOf_TerminalInformation :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const TerminalInformation & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_TerminalInformation * ArrayOf_TerminalInformation :: clone ( ) const {
	return new ArrayOf_TerminalInformation ( * this );
}

//
// RemoteMCResponse_reject
//

RemoteMCResponse_reject :: RemoteMCResponse_reject ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_unspecified:
		case e_functionNotSupported:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

RemoteMCResponse_reject :: RemoteMCResponse_reject ( ) : Asn :: Choice ( 2, true ) { }

void RemoteMCResponse_reject :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_unspecified:
		case e_functionNotSupported:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & RemoteMCResponse_reject :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_unspecified, "unspecified" },
		{ e_functionNotSupported, "functionNotSupported" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

RemoteMCResponse_reject * RemoteMCResponse_reject :: clone ( ) const {
	return new RemoteMCResponse_reject ( * this );
}

//
// MultilinkIndication_crcDesired
//

MultilinkIndication_crcDesired :: MultilinkIndication_crcDesired ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MultilinkIndication_crcDesired :: MultilinkIndication_crcDesired ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MultilinkIndication_crcDesired :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MultilinkIndication_crcDesired :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MultilinkIndication_crcDesired * MultilinkIndication_crcDesired :: clone ( ) const {
	return new MultilinkIndication_crcDesired ( * this );
}

//
// DialingInformation_differential
//

DialingInformation_differential :: DialingInformation_differential ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 65535 ) { }

DialingInformation_differential :: DialingInformation_differential ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 65535 ) { }

DialingInformation_differential :: DialingInformation_differential ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 65535 ) { }


Asn :: Object * DialingInformation_differential :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * DialingInformation_differential :: createObject ( Asn :: istream & is ) {
	return new DialingInformationNumber ( is );
}

Asn :: Object * DialingInformation_differential :: createObject ( ) {
	return new DialingInformationNumber ( );
}

DialingInformationNumber & DialingInformation_differential :: operator[] ( std :: size_t i ) {
	return dynamic_cast < DialingInformationNumber & > ( Asn :: Array :: operator[] ( i ) );
}

void DialingInformation_differential :: push_back ( const DialingInformationNumber & o ) {
	Asn :: Array :: push_back ( new DialingInformationNumber ( o ) );
}

const DialingInformationNumber & DialingInformation_differential :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const DialingInformationNumber & > ( Asn :: Array :: operator[] ( i ) );
}

DialingInformation_differential * DialingInformation_differential :: clone ( ) const {
	return new DialingInformation_differential ( * this );
}

//
// DialingInformation_infoNotAvailable
//

DialingInformation_infoNotAvailable :: DialingInformation_infoNotAvailable ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 65535 ) { }

DialingInformation_infoNotAvailable :: DialingInformation_infoNotAvailable ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 65535 ) { }

DialingInformation_infoNotAvailable * DialingInformation_infoNotAvailable :: clone ( ) const {
	return new DialingInformation_infoNotAvailable ( * this );
}

//
// DialingInformationNumber_networkAddress
//

DialingInformationNumber_networkAddress :: DialingInformationNumber_networkAddress ( Asn :: istream & is ) : Asn :: NumericString ( is, Asn :: fixedConstraint, 0, 40 ) { }

DialingInformationNumber_networkAddress :: DialingInformationNumber_networkAddress ( const Asn :: string & v ) : Asn :: NumericString ( v, Asn :: fixedConstraint, 0, 40 ) { }

DialingInformationNumber_networkAddress * DialingInformationNumber_networkAddress :: clone ( ) const {
	return new DialingInformationNumber_networkAddress ( * this );
}

//
// DialingInformationNumber_subAddress
//

DialingInformationNumber_subAddress :: DialingInformationNumber_subAddress ( Asn :: istream & is ) : Asn :: IA5String ( is, Asn :: fixedConstraint, 1, 40 ) { }

DialingInformationNumber_subAddress :: DialingInformationNumber_subAddress ( const Asn :: string & v ) : Asn :: IA5String ( v, Asn :: fixedConstraint, 1, 40 ) { }

DialingInformationNumber_subAddress * DialingInformationNumber_subAddress :: clone ( ) const {
	return new DialingInformationNumber_subAddress ( * this );
}

//
// DialingInformationNumber_networkType
//

DialingInformationNumber_networkType :: DialingInformationNumber_networkType ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 255 ) { }

DialingInformationNumber_networkType :: DialingInformationNumber_networkType ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 255 ) { }

DialingInformationNumber_networkType :: DialingInformationNumber_networkType ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 255 ) { }


Asn :: Object * DialingInformationNumber_networkType :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * DialingInformationNumber_networkType :: createObject ( Asn :: istream & is ) {
	return new DialingInformationNetworkType ( is );
}

Asn :: Object * DialingInformationNumber_networkType :: createObject ( ) {
	return new DialingInformationNetworkType ( );
}

DialingInformationNetworkType & DialingInformationNumber_networkType :: operator[] ( std :: size_t i ) {
	return dynamic_cast < DialingInformationNetworkType & > ( Asn :: Array :: operator[] ( i ) );
}

void DialingInformationNumber_networkType :: push_back ( const DialingInformationNetworkType & o ) {
	Asn :: Array :: push_back ( new DialingInformationNetworkType ( o ) );
}

const DialingInformationNetworkType & DialingInformationNumber_networkType :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const DialingInformationNetworkType & > ( Asn :: Array :: operator[] ( i ) );
}

DialingInformationNumber_networkType * DialingInformationNumber_networkType :: clone ( ) const {
	return new DialingInformationNumber_networkType ( * this );
}

//
// ConnectionIdentifier_channelTag
//

ConnectionIdentifier_channelTag :: ConnectionIdentifier_channelTag ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 4294967295U ) { }

ConnectionIdentifier_channelTag :: ConnectionIdentifier_channelTag ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 4294967295U ) { }

ConnectionIdentifier_channelTag * ConnectionIdentifier_channelTag :: clone ( ) const {
	return new ConnectionIdentifier_channelTag ( * this );
}

//
// ConnectionIdentifier_sequenceNumber
//

ConnectionIdentifier_sequenceNumber :: ConnectionIdentifier_sequenceNumber ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 4294967295U ) { }

ConnectionIdentifier_sequenceNumber :: ConnectionIdentifier_sequenceNumber ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 4294967295U ) { }

ConnectionIdentifier_sequenceNumber * ConnectionIdentifier_sequenceNumber :: clone ( ) const {
	return new ConnectionIdentifier_sequenceNumber ( * this );
}

//
// SendTerminalCapabilitySet_specificRequest
//

SendTerminalCapabilitySet_specificRequest :: SendTerminalCapabilitySet_specificRequest ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 0 ), m_multiplexCapability ( is ), m_capabilityTableEntryNumbers ( 0 ), m_capabilityDescriptorNumbers ( 0 ) {
	try {
		if ( hasOptionalField ( e_capabilityTableEntryNumbers ) )
			m_capabilityTableEntryNumbers = new SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers ( is );
		if ( hasOptionalField ( e_capabilityDescriptorNumbers ) )
			m_capabilityDescriptorNumbers = new SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_capabilityTableEntryNumbers;
		delete m_capabilityDescriptorNumbers;
		throw;
	}
}

SendTerminalCapabilitySet_specificRequest :: SendTerminalCapabilitySet_specificRequest ( ) : Asn :: Sequence ( 2, true, 0 ), m_capabilityTableEntryNumbers ( 0 ), m_capabilityDescriptorNumbers ( 0 ) { }

SendTerminalCapabilitySet_specificRequest & SendTerminalCapabilitySet_specificRequest :: operator= ( const SendTerminalCapabilitySet_specificRequest & s ) {
	Asn :: Sequence :: operator= ( s );
	m_multiplexCapability = s.m_multiplexCapability;
	assignCopy ( m_capabilityTableEntryNumbers, s.m_capabilityTableEntryNumbers );
	assignCopy ( m_capabilityDescriptorNumbers, s.m_capabilityDescriptorNumbers );
	return * this;
}

SendTerminalCapabilitySet_specificRequest :: SendTerminalCapabilitySet_specificRequest ( const SendTerminalCapabilitySet_specificRequest & s ) : Asn :: Sequence ( s ), m_multiplexCapability ( s.m_multiplexCapability ), m_capabilityTableEntryNumbers ( 0 ), m_capabilityDescriptorNumbers ( 0 ) {
	try {
		if ( s.m_capabilityTableEntryNumbers )
			m_capabilityTableEntryNumbers = new SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers ( * s.m_capabilityTableEntryNumbers );
		if ( s.m_capabilityDescriptorNumbers )
			m_capabilityDescriptorNumbers = new SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers ( * s.m_capabilityDescriptorNumbers );
	} catch ( ... ) {
		delete m_capabilityTableEntryNumbers;
		delete m_capabilityDescriptorNumbers;
		throw;
	}
}


void SendTerminalCapabilitySet_specificRequest :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_capabilityTableEntryNumbers:
			assignNew ( m_capabilityTableEntryNumbers, new SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers );
			break;
		case e_capabilityDescriptorNumbers:
			assignNew ( m_capabilityDescriptorNumbers, new SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void SendTerminalCapabilitySet_specificRequest :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_capabilityTableEntryNumbers:
			delete m_capabilityTableEntryNumbers;
			m_capabilityTableEntryNumbers = 0;
			break;
		case e_capabilityDescriptorNumbers:
			delete m_capabilityDescriptorNumbers;
			m_capabilityDescriptorNumbers = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void SendTerminalCapabilitySet_specificRequest :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_multiplexCapability.encode ( os );
	if ( hasOptionalField ( e_capabilityTableEntryNumbers ) )
		m_capabilityTableEntryNumbers -> SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers :: encode ( os );
	if ( hasOptionalField ( e_capabilityDescriptorNumbers ) )
		m_capabilityDescriptorNumbers -> SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

SendTerminalCapabilitySet_specificRequest :: ~SendTerminalCapabilitySet_specificRequest ( ) {
	delete m_capabilityTableEntryNumbers;
	delete m_capabilityDescriptorNumbers;
}

void SendTerminalCapabilitySet_specificRequest :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 22 ) << "multiplexCapability = " << std :: setprecision ( indent ) << m_multiplexCapability << '\n';
	if ( hasOptionalField ( e_capabilityTableEntryNumbers ) ) {
		os << std :: setw ( indent + 30 ) << "capabilityTableEntryNumbers = " << std :: setprecision ( indent );
		m_capabilityTableEntryNumbers -> SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_capabilityDescriptorNumbers ) ) {
		os << std :: setw ( indent + 30 ) << "capabilityDescriptorNumbers = " << std :: setprecision ( indent );
		m_capabilityDescriptorNumbers -> SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

SendTerminalCapabilitySet_specificRequest * SendTerminalCapabilitySet_specificRequest :: clone ( ) const {
	return new SendTerminalCapabilitySet_specificRequest ( * this );
}

//
// EndSessionCommand_gstnOptions
//

EndSessionCommand_gstnOptions :: EndSessionCommand_gstnOptions ( Asn :: istream & is ) : Asn :: Choice ( is, 5, true ) {
	switch ( tag ) {
		case e_telephonyMode:
		case e_v8bis:
		case e_v34DSVD:
		case e_v34DuplexFAX:
		case e_v34H324:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

EndSessionCommand_gstnOptions :: EndSessionCommand_gstnOptions ( ) : Asn :: Choice ( 5, true ) { }

void EndSessionCommand_gstnOptions :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_telephonyMode:
		case e_v8bis:
		case e_v34DSVD:
		case e_v34DuplexFAX:
		case e_v34H324:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & EndSessionCommand_gstnOptions :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_telephonyMode, "telephonyMode" },
		{ e_v8bis, "v8bis" },
		{ e_v34DSVD, "v34DSVD" },
		{ e_v34DuplexFAX, "v34DuplexFAX" },
		{ e_v34H324, "v34H324" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

EndSessionCommand_gstnOptions * EndSessionCommand_gstnOptions :: clone ( ) const {
	return new EndSessionCommand_gstnOptions ( * this );
}

//
// EndSessionCommand_isdnOptions
//

EndSessionCommand_isdnOptions :: EndSessionCommand_isdnOptions ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_telephonyMode:
		case e_v140:
		case e_terminalOnHold:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

EndSessionCommand_isdnOptions :: EndSessionCommand_isdnOptions ( ) : Asn :: Choice ( 3, true ) { }

void EndSessionCommand_isdnOptions :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_telephonyMode:
		case e_v140:
		case e_terminalOnHold:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & EndSessionCommand_isdnOptions :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_telephonyMode, "telephonyMode" },
		{ e_v140, "v140" },
		{ e_terminalOnHold, "terminalOnHold" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

EndSessionCommand_isdnOptions * EndSessionCommand_isdnOptions :: clone ( ) const {
	return new EndSessionCommand_isdnOptions ( * this );
}

//
// SubstituteConferenceIDCommand_conferenceIdentifier
//

SubstituteConferenceIDCommand_conferenceIdentifier :: SubstituteConferenceIDCommand_conferenceIdentifier ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 16, 16 ) { }

SubstituteConferenceIDCommand_conferenceIdentifier :: SubstituteConferenceIDCommand_conferenceIdentifier ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 16, 16 ) { }

SubstituteConferenceIDCommand_conferenceIdentifier * SubstituteConferenceIDCommand_conferenceIdentifier :: clone ( ) const {
	return new SubstituteConferenceIDCommand_conferenceIdentifier ( * this );
}

//
// EncryptionUpdateRequest_synchFlag
//

EncryptionUpdateRequest_synchFlag :: EncryptionUpdateRequest_synchFlag ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 255 ) { }

EncryptionUpdateRequest_synchFlag :: EncryptionUpdateRequest_synchFlag ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 255 ) { }

EncryptionUpdateRequest_synchFlag * EncryptionUpdateRequest_synchFlag :: clone ( ) const {
	return new EncryptionUpdateRequest_synchFlag ( * this );
}

//
// PictureReference_pictureNumber
//

PictureReference_pictureNumber :: PictureReference_pictureNumber ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 1023 ) { }

PictureReference_pictureNumber :: PictureReference_pictureNumber ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 1023 ) { }

PictureReference_pictureNumber * PictureReference_pictureNumber :: clone ( ) const {
	return new PictureReference_pictureNumber ( * this );
}

//
// PictureReference_longTermPictureIndex
//

PictureReference_longTermPictureIndex :: PictureReference_longTermPictureIndex ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 255 ) { }

PictureReference_longTermPictureIndex :: PictureReference_longTermPictureIndex ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 255 ) { }

PictureReference_longTermPictureIndex * PictureReference_longTermPictureIndex :: clone ( ) const {
	return new PictureReference_longTermPictureIndex ( * this );
}

//
// H223MultiplexReconfiguration_h223ModeChange
//

H223MultiplexReconfiguration_h223ModeChange :: H223MultiplexReconfiguration_h223ModeChange ( Asn :: istream & is ) : Asn :: Choice ( is, 4, true ) {
	switch ( tag ) {
		case e_toLevel0:
		case e_toLevel1:
		case e_toLevel2:
		case e_toLevel2withOptionalHeader:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

H223MultiplexReconfiguration_h223ModeChange :: H223MultiplexReconfiguration_h223ModeChange ( ) : Asn :: Choice ( 4, true ) { }

void H223MultiplexReconfiguration_h223ModeChange :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_toLevel0:
		case e_toLevel1:
		case e_toLevel2:
		case e_toLevel2withOptionalHeader:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & H223MultiplexReconfiguration_h223ModeChange :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_toLevel0, "toLevel0" },
		{ e_toLevel1, "toLevel1" },
		{ e_toLevel2, "toLevel2" },
		{ e_toLevel2withOptionalHeader, "toLevel2withOptionalHeader" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

H223MultiplexReconfiguration_h223ModeChange * H223MultiplexReconfiguration_h223ModeChange :: clone ( ) const {
	return new H223MultiplexReconfiguration_h223ModeChange ( * this );
}

//
// H223MultiplexReconfiguration_h223AnnexADoubleFlag
//

H223MultiplexReconfiguration_h223AnnexADoubleFlag :: H223MultiplexReconfiguration_h223AnnexADoubleFlag ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_start:
		case e_stop:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

H223MultiplexReconfiguration_h223AnnexADoubleFlag :: H223MultiplexReconfiguration_h223AnnexADoubleFlag ( ) : Asn :: Choice ( 2, true ) { }

void H223MultiplexReconfiguration_h223AnnexADoubleFlag :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_start:
		case e_stop:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & H223MultiplexReconfiguration_h223AnnexADoubleFlag :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_start, "start" },
		{ e_stop, "stop" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

H223MultiplexReconfiguration_h223AnnexADoubleFlag * H223MultiplexReconfiguration_h223AnnexADoubleFlag :: clone ( ) const {
	return new H223MultiplexReconfiguration_h223AnnexADoubleFlag ( * this );
}

//
// NewATMVCCommand_resourceID
//

NewATMVCCommand_resourceID :: NewATMVCCommand_resourceID ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

NewATMVCCommand_resourceID :: NewATMVCCommand_resourceID ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

NewATMVCCommand_resourceID * NewATMVCCommand_resourceID :: clone ( ) const {
	return new NewATMVCCommand_resourceID ( * this );
}

//
// NewATMVCCommand_bitRate
//

NewATMVCCommand_bitRate :: NewATMVCCommand_bitRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 65535 ) { }

NewATMVCCommand_bitRate :: NewATMVCCommand_bitRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 65535 ) { }

NewATMVCCommand_bitRate * NewATMVCCommand_bitRate :: clone ( ) const {
	return new NewATMVCCommand_bitRate ( * this );
}

//
// NewATMVCCommand_multiplex
//

NewATMVCCommand_multiplex :: NewATMVCCommand_multiplex ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_noMultiplex:
		case e_transportStream:
		case e_programStream:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

NewATMVCCommand_multiplex :: NewATMVCCommand_multiplex ( ) : Asn :: Choice ( 3, true ) { }

void NewATMVCCommand_multiplex :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_noMultiplex:
		case e_transportStream:
		case e_programStream:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & NewATMVCCommand_multiplex :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_noMultiplex, "noMultiplex" },
		{ e_transportStream, "transportStream" },
		{ e_programStream, "programStream" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

NewATMVCCommand_multiplex * NewATMVCCommand_multiplex :: clone ( ) const {
	return new NewATMVCCommand_multiplex ( * this );
}

//
// MobileMultilinkReconfigurationCommand_sampleSize
//

MobileMultilinkReconfigurationCommand_sampleSize :: MobileMultilinkReconfigurationCommand_sampleSize ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 255 ) { }

MobileMultilinkReconfigurationCommand_sampleSize :: MobileMultilinkReconfigurationCommand_sampleSize ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 255 ) { }

MobileMultilinkReconfigurationCommand_sampleSize * MobileMultilinkReconfigurationCommand_sampleSize :: clone ( ) const {
	return new MobileMultilinkReconfigurationCommand_sampleSize ( * this );
}

//
// MobileMultilinkReconfigurationCommand_samplesPerFrame
//

MobileMultilinkReconfigurationCommand_samplesPerFrame :: MobileMultilinkReconfigurationCommand_samplesPerFrame ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 255 ) { }

MobileMultilinkReconfigurationCommand_samplesPerFrame :: MobileMultilinkReconfigurationCommand_samplesPerFrame ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 255 ) { }

MobileMultilinkReconfigurationCommand_samplesPerFrame * MobileMultilinkReconfigurationCommand_samplesPerFrame :: clone ( ) const {
	return new MobileMultilinkReconfigurationCommand_samplesPerFrame ( * this );
}

//
// MobileMultilinkReconfigurationCommand_status
//

MobileMultilinkReconfigurationCommand_status :: MobileMultilinkReconfigurationCommand_status ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_synchronized:
		case e_reconfiguration:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

MobileMultilinkReconfigurationCommand_status :: MobileMultilinkReconfigurationCommand_status ( ) : Asn :: Choice ( 2, true ) { }

void MobileMultilinkReconfigurationCommand_status :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_synchronized:
		case e_reconfiguration:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & MobileMultilinkReconfigurationCommand_status :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_synchronized, "synchronized" },
		{ e_reconfiguration, "reconfiguration" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

MobileMultilinkReconfigurationCommand_status * MobileMultilinkReconfigurationCommand_status :: clone ( ) const {
	return new MobileMultilinkReconfigurationCommand_status ( * this );
}

//
// FunctionNotSupported_cause
//

FunctionNotSupported_cause :: FunctionNotSupported_cause ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_syntaxError:
		case e_semanticError:
		case e_unknownFunction:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

FunctionNotSupported_cause :: FunctionNotSupported_cause ( ) : Asn :: Choice ( 3, true ) { }

void FunctionNotSupported_cause :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_syntaxError:
		case e_semanticError:
		case e_unknownFunction:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & FunctionNotSupported_cause :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_syntaxError, "syntaxError" },
		{ e_semanticError, "semanticError" },
		{ e_unknownFunction, "unknownFunction" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

FunctionNotSupported_cause * FunctionNotSupported_cause :: clone ( ) const {
	return new FunctionNotSupported_cause ( * this );
}

//
// ConferenceIndication_sbeNumber
//

ConferenceIndication_sbeNumber :: ConferenceIndication_sbeNumber ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 9 ) { }

ConferenceIndication_sbeNumber :: ConferenceIndication_sbeNumber ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 9 ) { }

ConferenceIndication_sbeNumber * ConferenceIndication_sbeNumber :: clone ( ) const {
	return new ConferenceIndication_sbeNumber ( * this );
}

//
// TerminalYouAreSeeingInSubPictureNumber_subPictureNumber
//

TerminalYouAreSeeingInSubPictureNumber_subPictureNumber :: TerminalYouAreSeeingInSubPictureNumber_subPictureNumber ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 255 ) { }

TerminalYouAreSeeingInSubPictureNumber_subPictureNumber :: TerminalYouAreSeeingInSubPictureNumber_subPictureNumber ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 255 ) { }

TerminalYouAreSeeingInSubPictureNumber_subPictureNumber * TerminalYouAreSeeingInSubPictureNumber_subPictureNumber :: clone ( ) const {
	return new TerminalYouAreSeeingInSubPictureNumber_subPictureNumber ( * this );
}

//
// VideoIndicateCompose_compositionNumber
//

VideoIndicateCompose_compositionNumber :: VideoIndicateCompose_compositionNumber ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 255 ) { }

VideoIndicateCompose_compositionNumber :: VideoIndicateCompose_compositionNumber ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 255 ) { }

VideoIndicateCompose_compositionNumber * VideoIndicateCompose_compositionNumber :: clone ( ) const {
	return new VideoIndicateCompose_compositionNumber ( * this );
}

//
// JitterIndication_estimatedReceivedJitterMantissa
//

JitterIndication_estimatedReceivedJitterMantissa :: JitterIndication_estimatedReceivedJitterMantissa ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 3 ) { }

JitterIndication_estimatedReceivedJitterMantissa :: JitterIndication_estimatedReceivedJitterMantissa ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 3 ) { }

JitterIndication_estimatedReceivedJitterMantissa * JitterIndication_estimatedReceivedJitterMantissa :: clone ( ) const {
	return new JitterIndication_estimatedReceivedJitterMantissa ( * this );
}

//
// JitterIndication_estimatedReceivedJitterExponent
//

JitterIndication_estimatedReceivedJitterExponent :: JitterIndication_estimatedReceivedJitterExponent ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 7 ) { }

JitterIndication_estimatedReceivedJitterExponent :: JitterIndication_estimatedReceivedJitterExponent ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 7 ) { }

JitterIndication_estimatedReceivedJitterExponent * JitterIndication_estimatedReceivedJitterExponent :: clone ( ) const {
	return new JitterIndication_estimatedReceivedJitterExponent ( * this );
}

//
// JitterIndication_skippedFrameCount
//

JitterIndication_skippedFrameCount :: JitterIndication_skippedFrameCount ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 15 ) { }

JitterIndication_skippedFrameCount :: JitterIndication_skippedFrameCount ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 15 ) { }

JitterIndication_skippedFrameCount * JitterIndication_skippedFrameCount :: clone ( ) const {
	return new JitterIndication_skippedFrameCount ( * this );
}

//
// JitterIndication_additionalDecoderBuffer
//

JitterIndication_additionalDecoderBuffer :: JitterIndication_additionalDecoderBuffer ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 262143 ) { }

JitterIndication_additionalDecoderBuffer :: JitterIndication_additionalDecoderBuffer ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 262143 ) { }

JitterIndication_additionalDecoderBuffer * JitterIndication_additionalDecoderBuffer :: clone ( ) const {
	return new JitterIndication_additionalDecoderBuffer ( * this );
}

//
// H223SkewIndication_skew
//

H223SkewIndication_skew :: H223SkewIndication_skew ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 4095 ) { }

H223SkewIndication_skew :: H223SkewIndication_skew ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 4095 ) { }

H223SkewIndication_skew * H223SkewIndication_skew :: clone ( ) const {
	return new H223SkewIndication_skew ( * this );
}

//
// H2250MaximumSkewIndication_maximumSkew
//

H2250MaximumSkewIndication_maximumSkew :: H2250MaximumSkewIndication_maximumSkew ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 4095 ) { }

H2250MaximumSkewIndication_maximumSkew :: H2250MaximumSkewIndication_maximumSkew ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 4095 ) { }

H2250MaximumSkewIndication_maximumSkew * H2250MaximumSkewIndication_maximumSkew :: clone ( ) const {
	return new H2250MaximumSkewIndication_maximumSkew ( * this );
}

//
// VendorIdentification_productNumber
//

VendorIdentification_productNumber :: VendorIdentification_productNumber ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 1, 256 ) { }

VendorIdentification_productNumber :: VendorIdentification_productNumber ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 1, 256 ) { }

VendorIdentification_productNumber * VendorIdentification_productNumber :: clone ( ) const {
	return new VendorIdentification_productNumber ( * this );
}

//
// VendorIdentification_versionNumber
//

VendorIdentification_versionNumber :: VendorIdentification_versionNumber ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 1, 256 ) { }

VendorIdentification_versionNumber :: VendorIdentification_versionNumber ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 1, 256 ) { }

VendorIdentification_versionNumber * VendorIdentification_versionNumber :: clone ( ) const {
	return new VendorIdentification_versionNumber ( * this );
}

//
// NewATMVCIndication_resourceID
//

NewATMVCIndication_resourceID :: NewATMVCIndication_resourceID ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

NewATMVCIndication_resourceID :: NewATMVCIndication_resourceID ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

NewATMVCIndication_resourceID * NewATMVCIndication_resourceID :: clone ( ) const {
	return new NewATMVCIndication_resourceID ( * this );
}

//
// NewATMVCIndication_bitRate
//

NewATMVCIndication_bitRate :: NewATMVCIndication_bitRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 65535 ) { }

NewATMVCIndication_bitRate :: NewATMVCIndication_bitRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 65535 ) { }

NewATMVCIndication_bitRate * NewATMVCIndication_bitRate :: clone ( ) const {
	return new NewATMVCIndication_bitRate ( * this );
}

//
// NewATMVCIndication_multiplex
//

NewATMVCIndication_multiplex :: NewATMVCIndication_multiplex ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_noMultiplex:
		case e_transportStream:
		case e_programStream:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

NewATMVCIndication_multiplex :: NewATMVCIndication_multiplex ( ) : Asn :: Choice ( 3, true ) { }

void NewATMVCIndication_multiplex :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_noMultiplex:
		case e_transportStream:
		case e_programStream:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & NewATMVCIndication_multiplex :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_noMultiplex, "noMultiplex" },
		{ e_transportStream, "transportStream" },
		{ e_programStream, "programStream" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

NewATMVCIndication_multiplex * NewATMVCIndication_multiplex :: clone ( ) const {
	return new NewATMVCIndication_multiplex ( * this );
}

//
// UserInputIndication_extendedAlphanumeric
//

UserInputIndication_extendedAlphanumeric :: UserInputIndication_extendedAlphanumeric ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 1 ), m_alphanumeric ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ), m_rtpPayloadIndication ( 0 ), m_encryptedAlphanumeric ( 0 ) {
	try {
		if ( hasOptionalField ( e_rtpPayloadIndication ) )
			m_rtpPayloadIndication = new Asn :: Null ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_encryptedAlphanumeric ) )
				m_encryptedAlphanumeric = new UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_rtpPayloadIndication;
		delete m_encryptedAlphanumeric;
		throw;
	}
}

UserInputIndication_extendedAlphanumeric :: UserInputIndication_extendedAlphanumeric ( ) : Asn :: Sequence ( 1, true, 1 ), m_rtpPayloadIndication ( 0 ), m_encryptedAlphanumeric ( 0 ) { }

UserInputIndication_extendedAlphanumeric & UserInputIndication_extendedAlphanumeric :: operator= ( const UserInputIndication_extendedAlphanumeric & s ) {
	Asn :: Sequence :: operator= ( s );
	m_alphanumeric = s.m_alphanumeric;
	assignCopy ( m_rtpPayloadIndication, s.m_rtpPayloadIndication );
	assignCopy ( m_encryptedAlphanumeric, s.m_encryptedAlphanumeric );
	return * this;
}

UserInputIndication_extendedAlphanumeric :: UserInputIndication_extendedAlphanumeric ( const UserInputIndication_extendedAlphanumeric & s ) : Asn :: Sequence ( s ), m_alphanumeric ( s.m_alphanumeric ), m_rtpPayloadIndication ( 0 ), m_encryptedAlphanumeric ( 0 ) {
	try {
		if ( s.m_rtpPayloadIndication )
			m_rtpPayloadIndication = new Asn :: Null ( * s.m_rtpPayloadIndication );
		if ( s.m_encryptedAlphanumeric )
			m_encryptedAlphanumeric = new UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric ( * s.m_encryptedAlphanumeric );
	} catch ( ... ) {
		delete m_rtpPayloadIndication;
		delete m_encryptedAlphanumeric;
		throw;
	}
}


void UserInputIndication_extendedAlphanumeric :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_rtpPayloadIndication:
			assignNew ( m_rtpPayloadIndication, new Asn :: Null );
			break;
		case e_encryptedAlphanumeric:
			assignNew ( m_encryptedAlphanumeric, new UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void UserInputIndication_extendedAlphanumeric :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_rtpPayloadIndication:
			delete m_rtpPayloadIndication;
			m_rtpPayloadIndication = 0;
			break;
		case e_encryptedAlphanumeric:
			delete m_encryptedAlphanumeric;
			m_encryptedAlphanumeric = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void UserInputIndication_extendedAlphanumeric :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_alphanumeric.encode ( os );
	if ( hasOptionalField ( e_rtpPayloadIndication ) )
		m_rtpPayloadIndication -> Asn :: Null :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_encryptedAlphanumeric, m_encryptedAlphanumeric );
		unknownExtensionsEncode ( os );
	}
}

UserInputIndication_extendedAlphanumeric :: ~UserInputIndication_extendedAlphanumeric ( ) {
	delete m_rtpPayloadIndication;
	delete m_encryptedAlphanumeric;
}

void UserInputIndication_extendedAlphanumeric :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 15 ) << "alphanumeric = " << std :: setprecision ( indent ) << m_alphanumeric << '\n';
	if ( hasOptionalField ( e_rtpPayloadIndication ) ) {
		os << std :: setw ( indent + 23 ) << "rtpPayloadIndication = " << std :: setprecision ( indent );
		m_rtpPayloadIndication -> Asn :: Null :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_encryptedAlphanumeric ) ) {
		os << std :: setw ( indent + 24 ) << "encryptedAlphanumeric = " << std :: setprecision ( indent );
		m_encryptedAlphanumeric -> UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

UserInputIndication_extendedAlphanumeric * UserInputIndication_extendedAlphanumeric :: clone ( ) const {
	return new UserInputIndication_extendedAlphanumeric ( * this );
}

//
// UserInputIndication_encryptedAlphanumeric
//

UserInputIndication_encryptedAlphanumeric :: UserInputIndication_encryptedAlphanumeric ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_algorithmOID ( is ), m_paramS ( hasOptionalField ( e_paramS ) ? pushTemporaryMember ( new Params ( is ) ) : 0 ), m_encrypted ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) {
	clearTemporaryMembers ( );
	try {
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_paramS;
		throw;
	}
}

UserInputIndication_encryptedAlphanumeric :: UserInputIndication_encryptedAlphanumeric ( ) : Asn :: Sequence ( 1, true, 0 ), m_paramS ( 0 ) { }

UserInputIndication_encryptedAlphanumeric & UserInputIndication_encryptedAlphanumeric :: operator= ( const UserInputIndication_encryptedAlphanumeric & s ) {
	Asn :: Sequence :: operator= ( s );
	m_algorithmOID = s.m_algorithmOID;
	assignCopy ( m_paramS, s.m_paramS );
	m_encrypted = s.m_encrypted;
	return * this;
}

UserInputIndication_encryptedAlphanumeric :: UserInputIndication_encryptedAlphanumeric ( const UserInputIndication_encryptedAlphanumeric & s ) : Asn :: Sequence ( s ), m_algorithmOID ( s.m_algorithmOID ), m_paramS ( 0 ), m_encrypted ( s.m_encrypted ) {
	try {
		if ( s.m_paramS )
			m_paramS = new Params ( * s.m_paramS );
	} catch ( ... ) {
		delete m_paramS;
		throw;
	}
}


void UserInputIndication_encryptedAlphanumeric :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_paramS:
			assignNew ( m_paramS, new Params );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void UserInputIndication_encryptedAlphanumeric :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_paramS:
			delete m_paramS;
			m_paramS = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void UserInputIndication_encryptedAlphanumeric :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_algorithmOID.encode ( os );
	if ( hasOptionalField ( e_paramS ) )
		m_paramS -> Params :: encode ( os );
	m_encrypted.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

UserInputIndication_encryptedAlphanumeric :: ~UserInputIndication_encryptedAlphanumeric ( ) {
	delete m_paramS;
}

void UserInputIndication_encryptedAlphanumeric :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 15 ) << "algorithmOID = " << std :: setprecision ( indent ) << m_algorithmOID << '\n';
	if ( hasOptionalField ( e_paramS ) ) {
		os << std :: setw ( indent + 9 ) << "paramS = " << std :: setprecision ( indent );
		m_paramS -> Params :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 12 ) << "encrypted = " << std :: setprecision ( indent ) << m_encrypted << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

UserInputIndication_encryptedAlphanumeric * UserInputIndication_encryptedAlphanumeric :: clone ( ) const {
	return new UserInputIndication_encryptedAlphanumeric ( * this );
}

//
// MobileMultilinkReconfigurationIndication_sampleSize
//

MobileMultilinkReconfigurationIndication_sampleSize :: MobileMultilinkReconfigurationIndication_sampleSize ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 255 ) { }

MobileMultilinkReconfigurationIndication_sampleSize :: MobileMultilinkReconfigurationIndication_sampleSize ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 255 ) { }

MobileMultilinkReconfigurationIndication_sampleSize * MobileMultilinkReconfigurationIndication_sampleSize :: clone ( ) const {
	return new MobileMultilinkReconfigurationIndication_sampleSize ( * this );
}

//
// MobileMultilinkReconfigurationIndication_samplesPerFrame
//

MobileMultilinkReconfigurationIndication_samplesPerFrame :: MobileMultilinkReconfigurationIndication_samplesPerFrame ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 255 ) { }

MobileMultilinkReconfigurationIndication_samplesPerFrame :: MobileMultilinkReconfigurationIndication_samplesPerFrame ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 255 ) { }

MobileMultilinkReconfigurationIndication_samplesPerFrame * MobileMultilinkReconfigurationIndication_samplesPerFrame :: clone ( ) const {
	return new MobileMultilinkReconfigurationIndication_samplesPerFrame ( * this );
}

//
// NonStandardIdentifier_h221NonStandard_t35CountryCode
//

NonStandardIdentifier_h221NonStandard_t35CountryCode :: NonStandardIdentifier_h221NonStandard_t35CountryCode ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 255 ) { }

NonStandardIdentifier_h221NonStandard_t35CountryCode :: NonStandardIdentifier_h221NonStandard_t35CountryCode ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 255 ) { }

NonStandardIdentifier_h221NonStandard_t35CountryCode * NonStandardIdentifier_h221NonStandard_t35CountryCode :: clone ( ) const {
	return new NonStandardIdentifier_h221NonStandard_t35CountryCode ( * this );
}

//
// NonStandardIdentifier_h221NonStandard_t35Extension
//

NonStandardIdentifier_h221NonStandard_t35Extension :: NonStandardIdentifier_h221NonStandard_t35Extension ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 255 ) { }

NonStandardIdentifier_h221NonStandard_t35Extension :: NonStandardIdentifier_h221NonStandard_t35Extension ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 255 ) { }

NonStandardIdentifier_h221NonStandard_t35Extension * NonStandardIdentifier_h221NonStandard_t35Extension :: clone ( ) const {
	return new NonStandardIdentifier_h221NonStandard_t35Extension ( * this );
}

//
// NonStandardIdentifier_h221NonStandard_manufacturerCode
//

NonStandardIdentifier_h221NonStandard_manufacturerCode :: NonStandardIdentifier_h221NonStandard_manufacturerCode ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

NonStandardIdentifier_h221NonStandard_manufacturerCode :: NonStandardIdentifier_h221NonStandard_manufacturerCode ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

NonStandardIdentifier_h221NonStandard_manufacturerCode * NonStandardIdentifier_h221NonStandard_manufacturerCode :: clone ( ) const {
	return new NonStandardIdentifier_h221NonStandard_manufacturerCode ( * this );
}

//
// TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded
//

TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded :: TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded ( Asn :: istream & is ) : Asn :: Choice ( is, 2, false ) {
	switch ( tag ) {
		case e_highestEntryNumberProcessed:
			choice = new CapabilityTableEntryNumber ( is );
			break;
		case e_noneProcessed:
			choice = new Asn :: Null ( is );
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
}

TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded :: TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded ( ) : Asn :: Choice ( 2, false ) { }

void TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_highestEntryNumberProcessed:
			o = new CapabilityTableEntryNumber;
			break;
		case e_noneProcessed:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_highestEntryNumberProcessed, "highestEntryNumberProcessed" },
		{ e_noneProcessed, "noneProcessed" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded * TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded :: clone ( ) const {
	return new TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded ( * this );
}

//
// Capability_h233EncryptionReceiveCapability_h233IVResponseTime
//

Capability_h233EncryptionReceiveCapability_h233IVResponseTime :: Capability_h233EncryptionReceiveCapability_h233IVResponseTime ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 255 ) { }

Capability_h233EncryptionReceiveCapability_h233IVResponseTime :: Capability_h233EncryptionReceiveCapability_h233IVResponseTime ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 255 ) { }

Capability_h233EncryptionReceiveCapability_h233IVResponseTime * Capability_h233EncryptionReceiveCapability_h233IVResponseTime :: clone ( ) const {
	return new Capability_h233EncryptionReceiveCapability_h233IVResponseTime ( * this );
}

//
// VCCapability_aal5_forwardMaximumSDUSize
//

VCCapability_aal5_forwardMaximumSDUSize :: VCCapability_aal5_forwardMaximumSDUSize ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

VCCapability_aal5_forwardMaximumSDUSize :: VCCapability_aal5_forwardMaximumSDUSize ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

VCCapability_aal5_forwardMaximumSDUSize * VCCapability_aal5_forwardMaximumSDUSize :: clone ( ) const {
	return new VCCapability_aal5_forwardMaximumSDUSize ( * this );
}

//
// VCCapability_aal5_backwardMaximumSDUSize
//

VCCapability_aal5_backwardMaximumSDUSize :: VCCapability_aal5_backwardMaximumSDUSize ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

VCCapability_aal5_backwardMaximumSDUSize :: VCCapability_aal5_backwardMaximumSDUSize ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

VCCapability_aal5_backwardMaximumSDUSize * VCCapability_aal5_backwardMaximumSDUSize :: clone ( ) const {
	return new VCCapability_aal5_backwardMaximumSDUSize ( * this );
}

//
// VCCapability_aal1ViaGateway_gatewayAddress
//

VCCapability_aal1ViaGateway_gatewayAddress :: VCCapability_aal1ViaGateway_gatewayAddress ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 256 ) { }

VCCapability_aal1ViaGateway_gatewayAddress :: VCCapability_aal1ViaGateway_gatewayAddress ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 256 ) { }

VCCapability_aal1ViaGateway_gatewayAddress :: VCCapability_aal1ViaGateway_gatewayAddress ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 256 ) { }


Asn :: Object * VCCapability_aal1ViaGateway_gatewayAddress :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * VCCapability_aal1ViaGateway_gatewayAddress :: createObject ( Asn :: istream & is ) {
	return new Q2931Address ( is );
}

Asn :: Object * VCCapability_aal1ViaGateway_gatewayAddress :: createObject ( ) {
	return new Q2931Address ( );
}

Q2931Address & VCCapability_aal1ViaGateway_gatewayAddress :: operator[] ( std :: size_t i ) {
	return dynamic_cast < Q2931Address & > ( Asn :: Array :: operator[] ( i ) );
}

void VCCapability_aal1ViaGateway_gatewayAddress :: push_back ( const Q2931Address & o ) {
	Asn :: Array :: push_back ( new Q2931Address ( o ) );
}

const Q2931Address & VCCapability_aal1ViaGateway_gatewayAddress :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const Q2931Address & > ( Asn :: Array :: operator[] ( i ) );
}

VCCapability_aal1ViaGateway_gatewayAddress * VCCapability_aal1ViaGateway_gatewayAddress :: clone ( ) const {
	return new VCCapability_aal1ViaGateway_gatewayAddress ( * this );
}

//
// H223Capability_mobileMultilinkFrameCapability_maximumSampleSize
//

H223Capability_mobileMultilinkFrameCapability_maximumSampleSize :: H223Capability_mobileMultilinkFrameCapability_maximumSampleSize ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 255 ) { }

H223Capability_mobileMultilinkFrameCapability_maximumSampleSize :: H223Capability_mobileMultilinkFrameCapability_maximumSampleSize ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 255 ) { }

H223Capability_mobileMultilinkFrameCapability_maximumSampleSize * H223Capability_mobileMultilinkFrameCapability_maximumSampleSize :: clone ( ) const {
	return new H223Capability_mobileMultilinkFrameCapability_maximumSampleSize ( * this );
}

//
// H223Capability_mobileMultilinkFrameCapability_maximumPayloadLength
//

H223Capability_mobileMultilinkFrameCapability_maximumPayloadLength :: H223Capability_mobileMultilinkFrameCapability_maximumPayloadLength ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 65025 ) { }

H223Capability_mobileMultilinkFrameCapability_maximumPayloadLength :: H223Capability_mobileMultilinkFrameCapability_maximumPayloadLength ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 65025 ) { }

H223Capability_mobileMultilinkFrameCapability_maximumPayloadLength * H223Capability_mobileMultilinkFrameCapability_maximumPayloadLength :: clone ( ) const {
	return new H223Capability_mobileMultilinkFrameCapability_maximumPayloadLength ( * this );
}

//
// RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom
//

RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom :: RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 256 ) { }

RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom :: RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 256 ) { }

RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom :: RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 256 ) { }


Asn :: Object * RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom :: createObject ( Asn :: istream & is ) {
	return new RTPH263VideoRedundancyFrameMapping ( is );
}

Asn :: Object * RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom :: createObject ( ) {
	return new RTPH263VideoRedundancyFrameMapping ( );
}

RTPH263VideoRedundancyFrameMapping & RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom :: operator[] ( std :: size_t i ) {
	return dynamic_cast < RTPH263VideoRedundancyFrameMapping & > ( Asn :: Array :: operator[] ( i ) );
}

void RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom :: push_back ( const RTPH263VideoRedundancyFrameMapping & o ) {
	Asn :: Array :: push_back ( new RTPH263VideoRedundancyFrameMapping ( o ) );
}

const RTPH263VideoRedundancyFrameMapping & RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const RTPH263VideoRedundancyFrameMapping & > ( Asn :: Array :: operator[] ( i ) );
}

RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom * RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom :: clone ( ) const {
	return new RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom ( * this );
}

//
// RTPH263VideoRedundancyEncoding_containedThreads_subtype
//

RTPH263VideoRedundancyEncoding_containedThreads_subtype :: RTPH263VideoRedundancyEncoding_containedThreads_subtype ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 15 ) { }

RTPH263VideoRedundancyEncoding_containedThreads_subtype :: RTPH263VideoRedundancyEncoding_containedThreads_subtype ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 15 ) { }

RTPH263VideoRedundancyEncoding_containedThreads_subtype * RTPH263VideoRedundancyEncoding_containedThreads_subtype :: clone ( ) const {
	return new RTPH263VideoRedundancyEncoding_containedThreads_subtype ( * this );
}

//
// RTPH263VideoRedundancyFrameMapping_frameSequence_subtype
//

RTPH263VideoRedundancyFrameMapping_frameSequence_subtype :: RTPH263VideoRedundancyFrameMapping_frameSequence_subtype ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 255 ) { }

RTPH263VideoRedundancyFrameMapping_frameSequence_subtype :: RTPH263VideoRedundancyFrameMapping_frameSequence_subtype ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 255 ) { }

RTPH263VideoRedundancyFrameMapping_frameSequence_subtype * RTPH263VideoRedundancyFrameMapping_frameSequence_subtype :: clone ( ) const {
	return new RTPH263VideoRedundancyFrameMapping_frameSequence_subtype ( * this );
}

//
// RefPictureSelection_additionalPictureMemory_sqcifAdditionalPictureMemory
//

RefPictureSelection_additionalPictureMemory_sqcifAdditionalPictureMemory :: RefPictureSelection_additionalPictureMemory_sqcifAdditionalPictureMemory ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 256 ) { }

RefPictureSelection_additionalPictureMemory_sqcifAdditionalPictureMemory :: RefPictureSelection_additionalPictureMemory_sqcifAdditionalPictureMemory ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 256 ) { }

RefPictureSelection_additionalPictureMemory_sqcifAdditionalPictureMemory * RefPictureSelection_additionalPictureMemory_sqcifAdditionalPictureMemory :: clone ( ) const {
	return new RefPictureSelection_additionalPictureMemory_sqcifAdditionalPictureMemory ( * this );
}

//
// RefPictureSelection_additionalPictureMemory_qcifAdditionalPictureMemory
//

RefPictureSelection_additionalPictureMemory_qcifAdditionalPictureMemory :: RefPictureSelection_additionalPictureMemory_qcifAdditionalPictureMemory ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 256 ) { }

RefPictureSelection_additionalPictureMemory_qcifAdditionalPictureMemory :: RefPictureSelection_additionalPictureMemory_qcifAdditionalPictureMemory ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 256 ) { }

RefPictureSelection_additionalPictureMemory_qcifAdditionalPictureMemory * RefPictureSelection_additionalPictureMemory_qcifAdditionalPictureMemory :: clone ( ) const {
	return new RefPictureSelection_additionalPictureMemory_qcifAdditionalPictureMemory ( * this );
}

//
// RefPictureSelection_additionalPictureMemory_cifAdditionalPictureMemory
//

RefPictureSelection_additionalPictureMemory_cifAdditionalPictureMemory :: RefPictureSelection_additionalPictureMemory_cifAdditionalPictureMemory ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 256 ) { }

RefPictureSelection_additionalPictureMemory_cifAdditionalPictureMemory :: RefPictureSelection_additionalPictureMemory_cifAdditionalPictureMemory ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 256 ) { }

RefPictureSelection_additionalPictureMemory_cifAdditionalPictureMemory * RefPictureSelection_additionalPictureMemory_cifAdditionalPictureMemory :: clone ( ) const {
	return new RefPictureSelection_additionalPictureMemory_cifAdditionalPictureMemory ( * this );
}

//
// RefPictureSelection_additionalPictureMemory_cif4AdditionalPictureMemory
//

RefPictureSelection_additionalPictureMemory_cif4AdditionalPictureMemory :: RefPictureSelection_additionalPictureMemory_cif4AdditionalPictureMemory ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 256 ) { }

RefPictureSelection_additionalPictureMemory_cif4AdditionalPictureMemory :: RefPictureSelection_additionalPictureMemory_cif4AdditionalPictureMemory ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 256 ) { }

RefPictureSelection_additionalPictureMemory_cif4AdditionalPictureMemory * RefPictureSelection_additionalPictureMemory_cif4AdditionalPictureMemory :: clone ( ) const {
	return new RefPictureSelection_additionalPictureMemory_cif4AdditionalPictureMemory ( * this );
}

//
// RefPictureSelection_additionalPictureMemory_cif16AdditionalPictureMemory
//

RefPictureSelection_additionalPictureMemory_cif16AdditionalPictureMemory :: RefPictureSelection_additionalPictureMemory_cif16AdditionalPictureMemory ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 256 ) { }

RefPictureSelection_additionalPictureMemory_cif16AdditionalPictureMemory :: RefPictureSelection_additionalPictureMemory_cif16AdditionalPictureMemory ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 256 ) { }

RefPictureSelection_additionalPictureMemory_cif16AdditionalPictureMemory * RefPictureSelection_additionalPictureMemory_cif16AdditionalPictureMemory :: clone ( ) const {
	return new RefPictureSelection_additionalPictureMemory_cif16AdditionalPictureMemory ( * this );
}

//
// RefPictureSelection_additionalPictureMemory_bigCpfAdditionalPictureMemory
//

RefPictureSelection_additionalPictureMemory_bigCpfAdditionalPictureMemory :: RefPictureSelection_additionalPictureMemory_bigCpfAdditionalPictureMemory ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 256 ) { }

RefPictureSelection_additionalPictureMemory_bigCpfAdditionalPictureMemory :: RefPictureSelection_additionalPictureMemory_bigCpfAdditionalPictureMemory ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 256 ) { }

RefPictureSelection_additionalPictureMemory_bigCpfAdditionalPictureMemory * RefPictureSelection_additionalPictureMemory_bigCpfAdditionalPictureMemory :: clone ( ) const {
	return new RefPictureSelection_additionalPictureMemory_bigCpfAdditionalPictureMemory ( * this );
}

//
// CustomPictureFormat_mPI_standardMPI
//

CustomPictureFormat_mPI_standardMPI :: CustomPictureFormat_mPI_standardMPI ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 31 ) { }

CustomPictureFormat_mPI_standardMPI :: CustomPictureFormat_mPI_standardMPI ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 31 ) { }

CustomPictureFormat_mPI_standardMPI * CustomPictureFormat_mPI_standardMPI :: clone ( ) const {
	return new CustomPictureFormat_mPI_standardMPI ( * this );
}

//
// CustomPictureFormat_mPI_customPCF
//

CustomPictureFormat_mPI_customPCF :: CustomPictureFormat_mPI_customPCF ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 16 ) { }

CustomPictureFormat_mPI_customPCF :: CustomPictureFormat_mPI_customPCF ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 16 ) { }

CustomPictureFormat_mPI_customPCF :: CustomPictureFormat_mPI_customPCF ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 16 ) { }


Asn :: Object * CustomPictureFormat_mPI_customPCF :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * CustomPictureFormat_mPI_customPCF :: createObject ( Asn :: istream & is ) {
	return new CustomPictureFormat_mPI_customPCF_subtype ( is );
}

Asn :: Object * CustomPictureFormat_mPI_customPCF :: createObject ( ) {
	return new CustomPictureFormat_mPI_customPCF_subtype ( );
}

CustomPictureFormat_mPI_customPCF_subtype & CustomPictureFormat_mPI_customPCF :: operator[] ( std :: size_t i ) {
	return dynamic_cast < CustomPictureFormat_mPI_customPCF_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

void CustomPictureFormat_mPI_customPCF :: push_back ( const CustomPictureFormat_mPI_customPCF_subtype & o ) {
	Asn :: Array :: push_back ( new CustomPictureFormat_mPI_customPCF_subtype ( o ) );
}

const CustomPictureFormat_mPI_customPCF_subtype & CustomPictureFormat_mPI_customPCF :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const CustomPictureFormat_mPI_customPCF_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

CustomPictureFormat_mPI_customPCF * CustomPictureFormat_mPI_customPCF :: clone ( ) const {
	return new CustomPictureFormat_mPI_customPCF ( * this );
}

//
// CustomPictureFormat_pixelAspectInformation_pixelAspectCode
//

CustomPictureFormat_pixelAspectInformation_pixelAspectCode :: CustomPictureFormat_pixelAspectInformation_pixelAspectCode ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 14 ) { }

CustomPictureFormat_pixelAspectInformation_pixelAspectCode :: CustomPictureFormat_pixelAspectInformation_pixelAspectCode ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 14 ) { }

CustomPictureFormat_pixelAspectInformation_pixelAspectCode :: CustomPictureFormat_pixelAspectInformation_pixelAspectCode ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 14 ) { }


Asn :: Object * CustomPictureFormat_pixelAspectInformation_pixelAspectCode :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * CustomPictureFormat_pixelAspectInformation_pixelAspectCode :: createObject ( Asn :: istream & is ) {
	return new CustomPictureFormat_pixelAspectInformation_pixelAspectCode_subtype ( is );
}

Asn :: Object * CustomPictureFormat_pixelAspectInformation_pixelAspectCode :: createObject ( ) {
	return new CustomPictureFormat_pixelAspectInformation_pixelAspectCode_subtype ( );
}

CustomPictureFormat_pixelAspectInformation_pixelAspectCode_subtype & CustomPictureFormat_pixelAspectInformation_pixelAspectCode :: operator[] ( std :: size_t i ) {
	return dynamic_cast < CustomPictureFormat_pixelAspectInformation_pixelAspectCode_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

void CustomPictureFormat_pixelAspectInformation_pixelAspectCode :: push_back ( const CustomPictureFormat_pixelAspectInformation_pixelAspectCode_subtype & o ) {
	Asn :: Array :: push_back ( new CustomPictureFormat_pixelAspectInformation_pixelAspectCode_subtype ( o ) );
}

const CustomPictureFormat_pixelAspectInformation_pixelAspectCode_subtype & CustomPictureFormat_pixelAspectInformation_pixelAspectCode :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const CustomPictureFormat_pixelAspectInformation_pixelAspectCode_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

CustomPictureFormat_pixelAspectInformation_pixelAspectCode * CustomPictureFormat_pixelAspectInformation_pixelAspectCode :: clone ( ) const {
	return new CustomPictureFormat_pixelAspectInformation_pixelAspectCode ( * this );
}

//
// CustomPictureFormat_pixelAspectInformation_extendedPAR
//

CustomPictureFormat_pixelAspectInformation_extendedPAR :: CustomPictureFormat_pixelAspectInformation_extendedPAR ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 256 ) { }

CustomPictureFormat_pixelAspectInformation_extendedPAR :: CustomPictureFormat_pixelAspectInformation_extendedPAR ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 256 ) { }

CustomPictureFormat_pixelAspectInformation_extendedPAR :: CustomPictureFormat_pixelAspectInformation_extendedPAR ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 256 ) { }


Asn :: Object * CustomPictureFormat_pixelAspectInformation_extendedPAR :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * CustomPictureFormat_pixelAspectInformation_extendedPAR :: createObject ( Asn :: istream & is ) {
	return new CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype ( is );
}

Asn :: Object * CustomPictureFormat_pixelAspectInformation_extendedPAR :: createObject ( ) {
	return new CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype ( );
}

CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype & CustomPictureFormat_pixelAspectInformation_extendedPAR :: operator[] ( std :: size_t i ) {
	return dynamic_cast < CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

void CustomPictureFormat_pixelAspectInformation_extendedPAR :: push_back ( const CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype & o ) {
	Asn :: Array :: push_back ( new CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype ( o ) );
}

const CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype & CustomPictureFormat_pixelAspectInformation_extendedPAR :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

CustomPictureFormat_pixelAspectInformation_extendedPAR * CustomPictureFormat_pixelAspectInformation_extendedPAR :: clone ( ) const {
	return new CustomPictureFormat_pixelAspectInformation_extendedPAR ( * this );
}

//
// AudioCapability_g7231_maxAl-sduAudioFrames
//

AudioCapability_g7231_maxAl_sduAudioFrames :: AudioCapability_g7231_maxAl_sduAudioFrames ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 256 ) { }

AudioCapability_g7231_maxAl_sduAudioFrames :: AudioCapability_g7231_maxAl_sduAudioFrames ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 256 ) { }

AudioCapability_g7231_maxAl_sduAudioFrames * AudioCapability_g7231_maxAl_sduAudioFrames :: clone ( ) const {
	return new AudioCapability_g7231_maxAl_sduAudioFrames ( * this );
}

//
// G7231AnnexCCapability_g723AnnexCAudioMode_highRateMode0
//

G7231AnnexCCapability_g723AnnexCAudioMode_highRateMode0 :: G7231AnnexCCapability_g723AnnexCAudioMode_highRateMode0 ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 27, 78 ) { }

G7231AnnexCCapability_g723AnnexCAudioMode_highRateMode0 :: G7231AnnexCCapability_g723AnnexCAudioMode_highRateMode0 ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 27, 78 ) { }

G7231AnnexCCapability_g723AnnexCAudioMode_highRateMode0 * G7231AnnexCCapability_g723AnnexCAudioMode_highRateMode0 :: clone ( ) const {
	return new G7231AnnexCCapability_g723AnnexCAudioMode_highRateMode0 ( * this );
}

//
// G7231AnnexCCapability_g723AnnexCAudioMode_highRateMode1
//

G7231AnnexCCapability_g723AnnexCAudioMode_highRateMode1 :: G7231AnnexCCapability_g723AnnexCAudioMode_highRateMode1 ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 27, 78 ) { }

G7231AnnexCCapability_g723AnnexCAudioMode_highRateMode1 :: G7231AnnexCCapability_g723AnnexCAudioMode_highRateMode1 ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 27, 78 ) { }

G7231AnnexCCapability_g723AnnexCAudioMode_highRateMode1 * G7231AnnexCCapability_g723AnnexCAudioMode_highRateMode1 :: clone ( ) const {
	return new G7231AnnexCCapability_g723AnnexCAudioMode_highRateMode1 ( * this );
}

//
// G7231AnnexCCapability_g723AnnexCAudioMode_lowRateMode0
//

G7231AnnexCCapability_g723AnnexCAudioMode_lowRateMode0 :: G7231AnnexCCapability_g723AnnexCAudioMode_lowRateMode0 ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 23, 66 ) { }

G7231AnnexCCapability_g723AnnexCAudioMode_lowRateMode0 :: G7231AnnexCCapability_g723AnnexCAudioMode_lowRateMode0 ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 23, 66 ) { }

G7231AnnexCCapability_g723AnnexCAudioMode_lowRateMode0 * G7231AnnexCCapability_g723AnnexCAudioMode_lowRateMode0 :: clone ( ) const {
	return new G7231AnnexCCapability_g723AnnexCAudioMode_lowRateMode0 ( * this );
}

//
// G7231AnnexCCapability_g723AnnexCAudioMode_lowRateMode1
//

G7231AnnexCCapability_g723AnnexCAudioMode_lowRateMode1 :: G7231AnnexCCapability_g723AnnexCAudioMode_lowRateMode1 ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 23, 66 ) { }

G7231AnnexCCapability_g723AnnexCAudioMode_lowRateMode1 :: G7231AnnexCCapability_g723AnnexCAudioMode_lowRateMode1 ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 23, 66 ) { }

G7231AnnexCCapability_g723AnnexCAudioMode_lowRateMode1 * G7231AnnexCCapability_g723AnnexCAudioMode_lowRateMode1 :: clone ( ) const {
	return new G7231AnnexCCapability_g723AnnexCAudioMode_lowRateMode1 ( * this );
}

//
// G7231AnnexCCapability_g723AnnexCAudioMode_sidMode0
//

G7231AnnexCCapability_g723AnnexCAudioMode_sidMode0 :: G7231AnnexCCapability_g723AnnexCAudioMode_sidMode0 ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 6, 17 ) { }

G7231AnnexCCapability_g723AnnexCAudioMode_sidMode0 :: G7231AnnexCCapability_g723AnnexCAudioMode_sidMode0 ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 6, 17 ) { }

G7231AnnexCCapability_g723AnnexCAudioMode_sidMode0 * G7231AnnexCCapability_g723AnnexCAudioMode_sidMode0 :: clone ( ) const {
	return new G7231AnnexCCapability_g723AnnexCAudioMode_sidMode0 ( * this );
}

//
// G7231AnnexCCapability_g723AnnexCAudioMode_sidMode1
//

G7231AnnexCCapability_g723AnnexCAudioMode_sidMode1 :: G7231AnnexCCapability_g723AnnexCAudioMode_sidMode1 ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 6, 17 ) { }

G7231AnnexCCapability_g723AnnexCAudioMode_sidMode1 :: G7231AnnexCCapability_g723AnnexCAudioMode_sidMode1 ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 6, 17 ) { }

G7231AnnexCCapability_g723AnnexCAudioMode_sidMode1 * G7231AnnexCCapability_g723AnnexCAudioMode_sidMode1 :: clone ( ) const {
	return new G7231AnnexCCapability_g723AnnexCAudioMode_sidMode1 ( * this );
}

//
// DepFECCapability_rfc2733_separateStream
//

DepFECCapability_rfc2733_separateStream :: DepFECCapability_rfc2733_separateStream ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_separatePort ( is ), m_samePort ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

DepFECCapability_rfc2733_separateStream :: DepFECCapability_rfc2733_separateStream ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void DepFECCapability_rfc2733_separateStream :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_separatePort.encode ( os );
	m_samePort.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void DepFECCapability_rfc2733_separateStream :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 15 ) << "separatePort = " << std :: setprecision ( indent ) << m_separatePort << '\n';
	os << std :: setw ( indent + 11 ) << "samePort = " << std :: setprecision ( indent ) << m_samePort << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

DepFECCapability_rfc2733_separateStream * DepFECCapability_rfc2733_separateStream :: clone ( ) const {
	return new DepFECCapability_rfc2733_separateStream ( * this );
}

//
// OpenLogicalChannel_forwardLogicalChannelParameters_portNumber
//

OpenLogicalChannel_forwardLogicalChannelParameters_portNumber :: OpenLogicalChannel_forwardLogicalChannelParameters_portNumber ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

OpenLogicalChannel_forwardLogicalChannelParameters_portNumber :: OpenLogicalChannel_forwardLogicalChannelParameters_portNumber ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

OpenLogicalChannel_forwardLogicalChannelParameters_portNumber * OpenLogicalChannel_forwardLogicalChannelParameters_portNumber :: clone ( ) const {
	return new OpenLogicalChannel_forwardLogicalChannelParameters_portNumber ( * this );
}

//
// NetworkAccessParameters_networkAddress_e164Address
//

NetworkAccessParameters_networkAddress_e164Address :: NetworkAccessParameters_networkAddress_e164Address ( Asn :: istream & is ) : Asn :: IA5String ( is, Asn :: fixedConstraint, 1, 128, "#*,0123456789", sizeof ( "0123456789#*," ) > 17 ? 8 : 4 ) { }

NetworkAccessParameters_networkAddress_e164Address :: NetworkAccessParameters_networkAddress_e164Address ( const Asn :: string & v ) : Asn :: IA5String ( v, Asn :: fixedConstraint, 1, 128, "#*,0123456789", sizeof ( "0123456789#*," ) > 17 ? 8 : 4 ) { }

NetworkAccessParameters_networkAddress_e164Address * NetworkAccessParameters_networkAddress_e164Address :: clone ( ) const {
	return new NetworkAccessParameters_networkAddress_e164Address ( * this );
}

//
// Q2931Address_address_internationalNumber
//

Q2931Address_address_internationalNumber :: Q2931Address_address_internationalNumber ( Asn :: istream & is ) : Asn :: NumericString ( is, Asn :: fixedConstraint, 1, 16 ) { }

Q2931Address_address_internationalNumber :: Q2931Address_address_internationalNumber ( const Asn :: string & v ) : Asn :: NumericString ( v, Asn :: fixedConstraint, 1, 16 ) { }

Q2931Address_address_internationalNumber * Q2931Address_address_internationalNumber :: clone ( ) const {
	return new Q2931Address_address_internationalNumber ( * this );
}

//
// Q2931Address_address_nsapAddress
//

Q2931Address_address_nsapAddress :: Q2931Address_address_nsapAddress ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 1, 20 ) { }

Q2931Address_address_nsapAddress :: Q2931Address_address_nsapAddress ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 1, 20 ) { }

Q2931Address_address_nsapAddress * Q2931Address_address_nsapAddress :: clone ( ) const {
	return new Q2931Address_address_nsapAddress ( * this );
}

//
// H223AnnexCArqParameters_numberOfRetransmissions_finite
//

H223AnnexCArqParameters_numberOfRetransmissions_finite :: H223AnnexCArqParameters_numberOfRetransmissions_finite ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 16 ) { }

H223AnnexCArqParameters_numberOfRetransmissions_finite :: H223AnnexCArqParameters_numberOfRetransmissions_finite ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 16 ) { }

H223AnnexCArqParameters_numberOfRetransmissions_finite * H223AnnexCArqParameters_numberOfRetransmissions_finite :: clone ( ) const {
	return new H223AnnexCArqParameters_numberOfRetransmissions_finite ( * this );
}

//
// RTPPayloadType_payloadDescriptor_rfc-number
//

RTPPayloadType_payloadDescriptor_rfc_number :: RTPPayloadType_payloadDescriptor_rfc_number ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: extendableConstraint, 1, 32768 ) { }

RTPPayloadType_payloadDescriptor_rfc_number :: RTPPayloadType_payloadDescriptor_rfc_number ( unsigned v ) : Asn :: Integer ( v, Asn :: extendableConstraint, 1, 32768 ) { }

RTPPayloadType_payloadDescriptor_rfc_number * RTPPayloadType_payloadDescriptor_rfc_number :: clone ( ) const {
	return new RTPPayloadType_payloadDescriptor_rfc_number ( * this );
}

//
// ArrayOf_RedundancyEncodingElement
//

ArrayOf_RedundancyEncodingElement :: ArrayOf_RedundancyEncodingElement ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_RedundancyEncodingElement :: ArrayOf_RedundancyEncodingElement ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_RedundancyEncodingElement :: ArrayOf_RedundancyEncodingElement ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_RedundancyEncodingElement :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_RedundancyEncodingElement :: createObject ( Asn :: istream & is ) {
	return new RedundancyEncodingElement ( is );
}

Asn :: Object * ArrayOf_RedundancyEncodingElement :: createObject ( ) {
	return new RedundancyEncodingElement ( );
}

RedundancyEncodingElement & ArrayOf_RedundancyEncodingElement :: operator[] ( std :: size_t i ) {
	return dynamic_cast < RedundancyEncodingElement & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_RedundancyEncodingElement :: push_back ( const RedundancyEncodingElement & o ) {
	Asn :: Array :: push_back ( new RedundancyEncodingElement ( o ) );
}

const RedundancyEncodingElement & ArrayOf_RedundancyEncodingElement :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const RedundancyEncodingElement & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_RedundancyEncodingElement * ArrayOf_RedundancyEncodingElement :: clone ( ) const {
	return new ArrayOf_RedundancyEncodingElement ( * this );
}

//
// FECData_rfc2733_protectedPayloadType
//

FECData_rfc2733_protectedPayloadType :: FECData_rfc2733_protectedPayloadType ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 127 ) { }

FECData_rfc2733_protectedPayloadType :: FECData_rfc2733_protectedPayloadType ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 127 ) { }

FECData_rfc2733_protectedPayloadType * FECData_rfc2733_protectedPayloadType :: clone ( ) const {
	return new FECData_rfc2733_protectedPayloadType ( * this );
}

//
// UnicastAddress_iPAddress_network
//

UnicastAddress_iPAddress_network :: UnicastAddress_iPAddress_network ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 4, 4 ) { }

UnicastAddress_iPAddress_network :: UnicastAddress_iPAddress_network ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 4, 4 ) { }

UnicastAddress_iPAddress_network * UnicastAddress_iPAddress_network :: clone ( ) const {
	return new UnicastAddress_iPAddress_network ( * this );
}

//
// UnicastAddress_iPAddress_tsapIdentifier
//

UnicastAddress_iPAddress_tsapIdentifier :: UnicastAddress_iPAddress_tsapIdentifier ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

UnicastAddress_iPAddress_tsapIdentifier :: UnicastAddress_iPAddress_tsapIdentifier ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

UnicastAddress_iPAddress_tsapIdentifier * UnicastAddress_iPAddress_tsapIdentifier :: clone ( ) const {
	return new UnicastAddress_iPAddress_tsapIdentifier ( * this );
}

//
// UnicastAddress_iPXAddress_node
//

UnicastAddress_iPXAddress_node :: UnicastAddress_iPXAddress_node ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 6, 6 ) { }

UnicastAddress_iPXAddress_node :: UnicastAddress_iPXAddress_node ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 6, 6 ) { }

UnicastAddress_iPXAddress_node * UnicastAddress_iPXAddress_node :: clone ( ) const {
	return new UnicastAddress_iPXAddress_node ( * this );
}

//
// UnicastAddress_iPXAddress_netnum
//

UnicastAddress_iPXAddress_netnum :: UnicastAddress_iPXAddress_netnum ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 4, 4 ) { }

UnicastAddress_iPXAddress_netnum :: UnicastAddress_iPXAddress_netnum ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 4, 4 ) { }

UnicastAddress_iPXAddress_netnum * UnicastAddress_iPXAddress_netnum :: clone ( ) const {
	return new UnicastAddress_iPXAddress_netnum ( * this );
}

//
// UnicastAddress_iPXAddress_tsapIdentifier
//

UnicastAddress_iPXAddress_tsapIdentifier :: UnicastAddress_iPXAddress_tsapIdentifier ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 2, 2 ) { }

UnicastAddress_iPXAddress_tsapIdentifier :: UnicastAddress_iPXAddress_tsapIdentifier ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 2, 2 ) { }

UnicastAddress_iPXAddress_tsapIdentifier * UnicastAddress_iPXAddress_tsapIdentifier :: clone ( ) const {
	return new UnicastAddress_iPXAddress_tsapIdentifier ( * this );
}

//
// UnicastAddress_iP6Address_network
//

UnicastAddress_iP6Address_network :: UnicastAddress_iP6Address_network ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 16, 16 ) { }

UnicastAddress_iP6Address_network :: UnicastAddress_iP6Address_network ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 16, 16 ) { }

UnicastAddress_iP6Address_network * UnicastAddress_iP6Address_network :: clone ( ) const {
	return new UnicastAddress_iP6Address_network ( * this );
}

//
// UnicastAddress_iP6Address_tsapIdentifier
//

UnicastAddress_iP6Address_tsapIdentifier :: UnicastAddress_iP6Address_tsapIdentifier ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

UnicastAddress_iP6Address_tsapIdentifier :: UnicastAddress_iP6Address_tsapIdentifier ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

UnicastAddress_iP6Address_tsapIdentifier * UnicastAddress_iP6Address_tsapIdentifier :: clone ( ) const {
	return new UnicastAddress_iP6Address_tsapIdentifier ( * this );
}

//
// UnicastAddress_iPSourceRouteAddress_routing
//

UnicastAddress_iPSourceRouteAddress_routing :: UnicastAddress_iPSourceRouteAddress_routing ( Asn :: istream & is ) : Asn :: Choice ( is, 2, false ) {
	switch ( tag ) {
		case e_strict:
		case e_loose:
			choice = new Asn :: Null ( is );
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
}

UnicastAddress_iPSourceRouteAddress_routing :: UnicastAddress_iPSourceRouteAddress_routing ( ) : Asn :: Choice ( 2, false ) { }

void UnicastAddress_iPSourceRouteAddress_routing :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_strict:
		case e_loose:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & UnicastAddress_iPSourceRouteAddress_routing :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_strict, "strict" },
		{ e_loose, "loose" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

UnicastAddress_iPSourceRouteAddress_routing * UnicastAddress_iPSourceRouteAddress_routing :: clone ( ) const {
	return new UnicastAddress_iPSourceRouteAddress_routing ( * this );
}

//
// UnicastAddress_iPSourceRouteAddress_network
//

UnicastAddress_iPSourceRouteAddress_network :: UnicastAddress_iPSourceRouteAddress_network ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 4, 4 ) { }

UnicastAddress_iPSourceRouteAddress_network :: UnicastAddress_iPSourceRouteAddress_network ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 4, 4 ) { }

UnicastAddress_iPSourceRouteAddress_network * UnicastAddress_iPSourceRouteAddress_network :: clone ( ) const {
	return new UnicastAddress_iPSourceRouteAddress_network ( * this );
}

//
// UnicastAddress_iPSourceRouteAddress_tsapIdentifier
//

UnicastAddress_iPSourceRouteAddress_tsapIdentifier :: UnicastAddress_iPSourceRouteAddress_tsapIdentifier ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

UnicastAddress_iPSourceRouteAddress_tsapIdentifier :: UnicastAddress_iPSourceRouteAddress_tsapIdentifier ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

UnicastAddress_iPSourceRouteAddress_tsapIdentifier * UnicastAddress_iPSourceRouteAddress_tsapIdentifier :: clone ( ) const {
	return new UnicastAddress_iPSourceRouteAddress_tsapIdentifier ( * this );
}

//
// UnicastAddress_iPSourceRouteAddress_route
//

UnicastAddress_iPSourceRouteAddress_route :: UnicastAddress_iPSourceRouteAddress_route ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

UnicastAddress_iPSourceRouteAddress_route :: UnicastAddress_iPSourceRouteAddress_route ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

UnicastAddress_iPSourceRouteAddress_route :: UnicastAddress_iPSourceRouteAddress_route ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * UnicastAddress_iPSourceRouteAddress_route :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * UnicastAddress_iPSourceRouteAddress_route :: createObject ( Asn :: istream & is ) {
	return new UnicastAddress_iPSourceRouteAddress_route_subtype ( is );
}

Asn :: Object * UnicastAddress_iPSourceRouteAddress_route :: createObject ( ) {
	return new UnicastAddress_iPSourceRouteAddress_route_subtype ( );
}

UnicastAddress_iPSourceRouteAddress_route_subtype & UnicastAddress_iPSourceRouteAddress_route :: operator[] ( std :: size_t i ) {
	return dynamic_cast < UnicastAddress_iPSourceRouteAddress_route_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

void UnicastAddress_iPSourceRouteAddress_route :: push_back ( const UnicastAddress_iPSourceRouteAddress_route_subtype & o ) {
	Asn :: Array :: push_back ( new UnicastAddress_iPSourceRouteAddress_route_subtype ( o ) );
}

const UnicastAddress_iPSourceRouteAddress_route_subtype & UnicastAddress_iPSourceRouteAddress_route :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const UnicastAddress_iPSourceRouteAddress_route_subtype & > ( Asn :: Array :: operator[] ( i ) );
}

UnicastAddress_iPSourceRouteAddress_route * UnicastAddress_iPSourceRouteAddress_route :: clone ( ) const {
	return new UnicastAddress_iPSourceRouteAddress_route ( * this );
}

//
// MulticastAddress_iPAddress_network
//

MulticastAddress_iPAddress_network :: MulticastAddress_iPAddress_network ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 4, 4 ) { }

MulticastAddress_iPAddress_network :: MulticastAddress_iPAddress_network ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 4, 4 ) { }

MulticastAddress_iPAddress_network * MulticastAddress_iPAddress_network :: clone ( ) const {
	return new MulticastAddress_iPAddress_network ( * this );
}

//
// MulticastAddress_iPAddress_tsapIdentifier
//

MulticastAddress_iPAddress_tsapIdentifier :: MulticastAddress_iPAddress_tsapIdentifier ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

MulticastAddress_iPAddress_tsapIdentifier :: MulticastAddress_iPAddress_tsapIdentifier ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

MulticastAddress_iPAddress_tsapIdentifier * MulticastAddress_iPAddress_tsapIdentifier :: clone ( ) const {
	return new MulticastAddress_iPAddress_tsapIdentifier ( * this );
}

//
// MulticastAddress_iP6Address_network
//

MulticastAddress_iP6Address_network :: MulticastAddress_iP6Address_network ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 16, 16 ) { }

MulticastAddress_iP6Address_network :: MulticastAddress_iP6Address_network ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 16, 16 ) { }

MulticastAddress_iP6Address_network * MulticastAddress_iP6Address_network :: clone ( ) const {
	return new MulticastAddress_iP6Address_network ( * this );
}

//
// MulticastAddress_iP6Address_tsapIdentifier
//

MulticastAddress_iP6Address_tsapIdentifier :: MulticastAddress_iP6Address_tsapIdentifier ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

MulticastAddress_iP6Address_tsapIdentifier :: MulticastAddress_iP6Address_tsapIdentifier ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

MulticastAddress_iP6Address_tsapIdentifier * MulticastAddress_iP6Address_tsapIdentifier :: clone ( ) const {
	return new MulticastAddress_iP6Address_tsapIdentifier ( * this );
}

//
// OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber
//

OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber :: OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber :: OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber * OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber :: clone ( ) const {
	return new OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber ( * this );
}

//
// MultiplexElement_type_logicalChannelNumber
//

MultiplexElement_type_logicalChannelNumber :: MultiplexElement_type_logicalChannelNumber ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

MultiplexElement_type_logicalChannelNumber :: MultiplexElement_type_logicalChannelNumber ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

MultiplexElement_type_logicalChannelNumber * MultiplexElement_type_logicalChannelNumber :: clone ( ) const {
	return new MultiplexElement_type_logicalChannelNumber ( * this );
}

//
// MultiplexElement_type_subElementList
//

MultiplexElement_type_subElementList :: MultiplexElement_type_subElementList ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 2, 255 ) { }

MultiplexElement_type_subElementList :: MultiplexElement_type_subElementList ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 2, 255 ) { }

MultiplexElement_type_subElementList :: MultiplexElement_type_subElementList ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 2, 255 ) { }


Asn :: Object * MultiplexElement_type_subElementList :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * MultiplexElement_type_subElementList :: createObject ( Asn :: istream & is ) {
	return new MultiplexElement ( is );
}

Asn :: Object * MultiplexElement_type_subElementList :: createObject ( ) {
	return new MultiplexElement ( );
}

MultiplexElement & MultiplexElement_type_subElementList :: operator[] ( std :: size_t i ) {
	return dynamic_cast < MultiplexElement & > ( Asn :: Array :: operator[] ( i ) );
}

void MultiplexElement_type_subElementList :: push_back ( const MultiplexElement & o ) {
	Asn :: Array :: push_back ( new MultiplexElement ( o ) );
}

const MultiplexElement & MultiplexElement_type_subElementList :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const MultiplexElement & > ( Asn :: Array :: operator[] ( i ) );
}

MultiplexElement_type_subElementList * MultiplexElement_type_subElementList :: clone ( ) const {
	return new MultiplexElement_type_subElementList ( * this );
}

//
// MultiplexElement_repeatCount_finite
//

MultiplexElement_repeatCount_finite :: MultiplexElement_repeatCount_finite ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 65535 ) { }

MultiplexElement_repeatCount_finite :: MultiplexElement_repeatCount_finite ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 65535 ) { }

MultiplexElement_repeatCount_finite * MultiplexElement_repeatCount_finite :: clone ( ) const {
	return new MultiplexElement_repeatCount_finite ( * this );
}

//
// G7231AnnexCMode_g723AnnexCAudioMode_highRateMode0
//

G7231AnnexCMode_g723AnnexCAudioMode_highRateMode0 :: G7231AnnexCMode_g723AnnexCAudioMode_highRateMode0 ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 27, 78 ) { }

G7231AnnexCMode_g723AnnexCAudioMode_highRateMode0 :: G7231AnnexCMode_g723AnnexCAudioMode_highRateMode0 ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 27, 78 ) { }

G7231AnnexCMode_g723AnnexCAudioMode_highRateMode0 * G7231AnnexCMode_g723AnnexCAudioMode_highRateMode0 :: clone ( ) const {
	return new G7231AnnexCMode_g723AnnexCAudioMode_highRateMode0 ( * this );
}

//
// G7231AnnexCMode_g723AnnexCAudioMode_highRateMode1
//

G7231AnnexCMode_g723AnnexCAudioMode_highRateMode1 :: G7231AnnexCMode_g723AnnexCAudioMode_highRateMode1 ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 27, 78 ) { }

G7231AnnexCMode_g723AnnexCAudioMode_highRateMode1 :: G7231AnnexCMode_g723AnnexCAudioMode_highRateMode1 ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 27, 78 ) { }

G7231AnnexCMode_g723AnnexCAudioMode_highRateMode1 * G7231AnnexCMode_g723AnnexCAudioMode_highRateMode1 :: clone ( ) const {
	return new G7231AnnexCMode_g723AnnexCAudioMode_highRateMode1 ( * this );
}

//
// G7231AnnexCMode_g723AnnexCAudioMode_lowRateMode0
//

G7231AnnexCMode_g723AnnexCAudioMode_lowRateMode0 :: G7231AnnexCMode_g723AnnexCAudioMode_lowRateMode0 ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 23, 66 ) { }

G7231AnnexCMode_g723AnnexCAudioMode_lowRateMode0 :: G7231AnnexCMode_g723AnnexCAudioMode_lowRateMode0 ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 23, 66 ) { }

G7231AnnexCMode_g723AnnexCAudioMode_lowRateMode0 * G7231AnnexCMode_g723AnnexCAudioMode_lowRateMode0 :: clone ( ) const {
	return new G7231AnnexCMode_g723AnnexCAudioMode_lowRateMode0 ( * this );
}

//
// G7231AnnexCMode_g723AnnexCAudioMode_lowRateMode1
//

G7231AnnexCMode_g723AnnexCAudioMode_lowRateMode1 :: G7231AnnexCMode_g723AnnexCAudioMode_lowRateMode1 ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 23, 66 ) { }

G7231AnnexCMode_g723AnnexCAudioMode_lowRateMode1 :: G7231AnnexCMode_g723AnnexCAudioMode_lowRateMode1 ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 23, 66 ) { }

G7231AnnexCMode_g723AnnexCAudioMode_lowRateMode1 * G7231AnnexCMode_g723AnnexCAudioMode_lowRateMode1 :: clone ( ) const {
	return new G7231AnnexCMode_g723AnnexCAudioMode_lowRateMode1 ( * this );
}

//
// G7231AnnexCMode_g723AnnexCAudioMode_sidMode0
//

G7231AnnexCMode_g723AnnexCAudioMode_sidMode0 :: G7231AnnexCMode_g723AnnexCAudioMode_sidMode0 ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 6, 17 ) { }

G7231AnnexCMode_g723AnnexCAudioMode_sidMode0 :: G7231AnnexCMode_g723AnnexCAudioMode_sidMode0 ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 6, 17 ) { }

G7231AnnexCMode_g723AnnexCAudioMode_sidMode0 * G7231AnnexCMode_g723AnnexCAudioMode_sidMode0 :: clone ( ) const {
	return new G7231AnnexCMode_g723AnnexCAudioMode_sidMode0 ( * this );
}

//
// G7231AnnexCMode_g723AnnexCAudioMode_sidMode1
//

G7231AnnexCMode_g723AnnexCAudioMode_sidMode1 :: G7231AnnexCMode_g723AnnexCAudioMode_sidMode1 ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 6, 17 ) { }

G7231AnnexCMode_g723AnnexCAudioMode_sidMode1 :: G7231AnnexCMode_g723AnnexCAudioMode_sidMode1 ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 6, 17 ) { }

G7231AnnexCMode_g723AnnexCAudioMode_sidMode1 * G7231AnnexCMode_g723AnnexCAudioMode_sidMode1 :: clone ( ) const {
	return new G7231AnnexCMode_g723AnnexCAudioMode_sidMode1 ( * this );
}

//
// ConferenceRequest_requestTerminalCertificate_sRandom
//

ConferenceRequest_requestTerminalCertificate_sRandom :: ConferenceRequest_requestTerminalCertificate_sRandom ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 4294967295U ) { }

ConferenceRequest_requestTerminalCertificate_sRandom :: ConferenceRequest_requestTerminalCertificate_sRandom ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 4294967295U ) { }

ConferenceRequest_requestTerminalCertificate_sRandom * ConferenceRequest_requestTerminalCertificate_sRandom :: clone ( ) const {
	return new ConferenceRequest_requestTerminalCertificate_sRandom ( * this );
}

//
// ConferenceResponse_terminalCertificateResponse_certificateResponse
//

ConferenceResponse_terminalCertificateResponse_certificateResponse :: ConferenceResponse_terminalCertificateResponse_certificateResponse ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 1, 65535 ) { }

ConferenceResponse_terminalCertificateResponse_certificateResponse :: ConferenceResponse_terminalCertificateResponse_certificateResponse ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 1, 65535 ) { }

ConferenceResponse_terminalCertificateResponse_certificateResponse * ConferenceResponse_terminalCertificateResponse_certificateResponse :: clone ( ) const {
	return new ConferenceResponse_terminalCertificateResponse_certificateResponse ( * this );
}

//
// MultilinkRequest_callInformation_maxNumberOfAdditionalConnections
//

MultilinkRequest_callInformation_maxNumberOfAdditionalConnections :: MultilinkRequest_callInformation_maxNumberOfAdditionalConnections ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 65535 ) { }

MultilinkRequest_callInformation_maxNumberOfAdditionalConnections :: MultilinkRequest_callInformation_maxNumberOfAdditionalConnections ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 65535 ) { }

MultilinkRequest_callInformation_maxNumberOfAdditionalConnections * MultilinkRequest_callInformation_maxNumberOfAdditionalConnections :: clone ( ) const {
	return new MultilinkRequest_callInformation_maxNumberOfAdditionalConnections ( * this );
}

//
// MultilinkResponse_callInformation_callAssociationNumber
//

MultilinkResponse_callInformation_callAssociationNumber :: MultilinkResponse_callInformation_callAssociationNumber ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 4294967295U ) { }

MultilinkResponse_callInformation_callAssociationNumber :: MultilinkResponse_callInformation_callAssociationNumber ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 4294967295U ) { }

MultilinkResponse_callInformation_callAssociationNumber * MultilinkResponse_callInformation_callAssociationNumber :: clone ( ) const {
	return new MultilinkResponse_callInformation_callAssociationNumber ( * this );
}

//
// MultilinkResponse_maximumHeaderInterval_currentInterval
//

MultilinkResponse_maximumHeaderInterval_currentInterval :: MultilinkResponse_maximumHeaderInterval_currentInterval ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

MultilinkResponse_maximumHeaderInterval_currentInterval :: MultilinkResponse_maximumHeaderInterval_currentInterval ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

MultilinkResponse_maximumHeaderInterval_currentInterval * MultilinkResponse_maximumHeaderInterval_currentInterval :: clone ( ) const {
	return new MultilinkResponse_maximumHeaderInterval_currentInterval ( * this );
}

//
// SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers
//

SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers :: SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 65535 ) { }

SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers :: SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 65535 ) { }

SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers :: SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 65535 ) { }


Asn :: Object * SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers :: createObject ( Asn :: istream & is ) {
	return new CapabilityTableEntryNumber ( is );
}

Asn :: Object * SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers :: createObject ( ) {
	return new CapabilityTableEntryNumber ( );
}

CapabilityTableEntryNumber & SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers :: operator[] ( std :: size_t i ) {
	return dynamic_cast < CapabilityTableEntryNumber & > ( Asn :: Array :: operator[] ( i ) );
}

void SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers :: push_back ( const CapabilityTableEntryNumber & o ) {
	Asn :: Array :: push_back ( new CapabilityTableEntryNumber ( o ) );
}

const CapabilityTableEntryNumber & SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const CapabilityTableEntryNumber & > ( Asn :: Array :: operator[] ( i ) );
}

SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers * SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers :: clone ( ) const {
	return new SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers ( * this );
}

//
// SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers
//

SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers :: SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: fixedConstraint, 1, 256 ) { }

SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers :: SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers ( ) : Asn :: Array ( createObject, Asn :: fixedConstraint, 1, 256 ) { }

SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers :: SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers ( int s ) : Asn :: Array ( s, createObject, Asn :: fixedConstraint, 1, 256 ) { }


Asn :: Object * SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers :: createObject ( Asn :: istream & is ) {
	return new CapabilityDescriptorNumber ( is );
}

Asn :: Object * SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers :: createObject ( ) {
	return new CapabilityDescriptorNumber ( );
}

CapabilityDescriptorNumber & SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers :: operator[] ( std :: size_t i ) {
	return dynamic_cast < CapabilityDescriptorNumber & > ( Asn :: Array :: operator[] ( i ) );
}

void SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers :: push_back ( const CapabilityDescriptorNumber & o ) {
	Asn :: Array :: push_back ( new CapabilityDescriptorNumber ( o ) );
}

const CapabilityDescriptorNumber & SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const CapabilityDescriptorNumber & > ( Asn :: Array :: operator[] ( i ) );
}

SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers * SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers :: clone ( ) const {
	return new SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers ( * this );
}

//
// FlowControlCommand_scope_resourceID
//

FlowControlCommand_scope_resourceID :: FlowControlCommand_scope_resourceID ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

FlowControlCommand_scope_resourceID :: FlowControlCommand_scope_resourceID ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

FlowControlCommand_scope_resourceID * FlowControlCommand_scope_resourceID :: clone ( ) const {
	return new FlowControlCommand_scope_resourceID ( * this );
}

//
// FlowControlCommand_restriction_maximumBitRate
//

FlowControlCommand_restriction_maximumBitRate :: FlowControlCommand_restriction_maximumBitRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 16777215 ) { }

FlowControlCommand_restriction_maximumBitRate :: FlowControlCommand_restriction_maximumBitRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 16777215 ) { }

FlowControlCommand_restriction_maximumBitRate * FlowControlCommand_restriction_maximumBitRate :: clone ( ) const {
	return new FlowControlCommand_restriction_maximumBitRate ( * this );
}

//
// MiscellaneousCommand_type_videoTemporalSpatialTradeOff
//

MiscellaneousCommand_type_videoTemporalSpatialTradeOff :: MiscellaneousCommand_type_videoTemporalSpatialTradeOff ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 31 ) { }

MiscellaneousCommand_type_videoTemporalSpatialTradeOff :: MiscellaneousCommand_type_videoTemporalSpatialTradeOff ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 31 ) { }

MiscellaneousCommand_type_videoTemporalSpatialTradeOff * MiscellaneousCommand_type_videoTemporalSpatialTradeOff :: clone ( ) const {
	return new MiscellaneousCommand_type_videoTemporalSpatialTradeOff ( * this );
}

//
// MiscellaneousCommand_type_maxH223MUXPDUsize
//

MiscellaneousCommand_type_maxH223MUXPDUsize :: MiscellaneousCommand_type_maxH223MUXPDUsize ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 65535 ) { }

MiscellaneousCommand_type_maxH223MUXPDUsize :: MiscellaneousCommand_type_maxH223MUXPDUsize ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 65535 ) { }

MiscellaneousCommand_type_maxH223MUXPDUsize * MiscellaneousCommand_type_maxH223MUXPDUsize :: clone ( ) const {
	return new MiscellaneousCommand_type_maxH223MUXPDUsize ( * this );
}

//
// ArrayOf_PictureReference
//

ArrayOf_PictureReference :: ArrayOf_PictureReference ( Asn :: istream & is ) : Asn :: Array ( is, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_PictureReference :: ArrayOf_PictureReference ( ) : Asn :: Array ( createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }

ArrayOf_PictureReference :: ArrayOf_PictureReference ( int s ) : Asn :: Array ( s, createObject, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) { }


Asn :: Object * ArrayOf_PictureReference :: createObjectVirt ( ) const {
	return createObject ( );
}

Asn :: Object * ArrayOf_PictureReference :: createObject ( Asn :: istream & is ) {
	return new PictureReference ( is );
}

Asn :: Object * ArrayOf_PictureReference :: createObject ( ) {
	return new PictureReference ( );
}

PictureReference & ArrayOf_PictureReference :: operator[] ( std :: size_t i ) {
	return dynamic_cast < PictureReference & > ( Asn :: Array :: operator[] ( i ) );
}

void ArrayOf_PictureReference :: push_back ( const PictureReference & o ) {
	Asn :: Array :: push_back ( new PictureReference ( o ) );
}

const PictureReference & ArrayOf_PictureReference :: operator[] ( std :: size_t i ) const {
	return dynamic_cast < const PictureReference & > ( Asn :: Array :: operator[] ( i ) );
}

ArrayOf_PictureReference * ArrayOf_PictureReference :: clone ( ) const {
	return new ArrayOf_PictureReference ( * this );
}

//
// NewATMVCCommand_reverseParameters_bitRate
//

NewATMVCCommand_reverseParameters_bitRate :: NewATMVCCommand_reverseParameters_bitRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 65535 ) { }

NewATMVCCommand_reverseParameters_bitRate :: NewATMVCCommand_reverseParameters_bitRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 65535 ) { }

NewATMVCCommand_reverseParameters_bitRate * NewATMVCCommand_reverseParameters_bitRate :: clone ( ) const {
	return new NewATMVCCommand_reverseParameters_bitRate ( * this );
}

//
// NewATMVCCommand_reverseParameters_multiplex
//

NewATMVCCommand_reverseParameters_multiplex :: NewATMVCCommand_reverseParameters_multiplex ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_noMultiplex:
		case e_transportStream:
		case e_programStream:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

NewATMVCCommand_reverseParameters_multiplex :: NewATMVCCommand_reverseParameters_multiplex ( ) : Asn :: Choice ( 3, true ) { }

void NewATMVCCommand_reverseParameters_multiplex :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_noMultiplex:
		case e_transportStream:
		case e_programStream:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & NewATMVCCommand_reverseParameters_multiplex :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_noMultiplex, "noMultiplex" },
		{ e_transportStream, "transportStream" },
		{ e_programStream, "programStream" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

NewATMVCCommand_reverseParameters_multiplex * NewATMVCCommand_reverseParameters_multiplex :: clone ( ) const {
	return new NewATMVCCommand_reverseParameters_multiplex ( * this );
}

//
// MiscellaneousIndication_type_videoTemporalSpatialTradeOff
//

MiscellaneousIndication_type_videoTemporalSpatialTradeOff :: MiscellaneousIndication_type_videoTemporalSpatialTradeOff ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 31 ) { }

MiscellaneousIndication_type_videoTemporalSpatialTradeOff :: MiscellaneousIndication_type_videoTemporalSpatialTradeOff ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 31 ) { }

MiscellaneousIndication_type_videoTemporalSpatialTradeOff * MiscellaneousIndication_type_videoTemporalSpatialTradeOff :: clone ( ) const {
	return new MiscellaneousIndication_type_videoTemporalSpatialTradeOff ( * this );
}

//
// JitterIndication_scope_resourceID
//

JitterIndication_scope_resourceID :: JitterIndication_scope_resourceID ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

JitterIndication_scope_resourceID :: JitterIndication_scope_resourceID ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

JitterIndication_scope_resourceID * JitterIndication_scope_resourceID :: clone ( ) const {
	return new JitterIndication_scope_resourceID ( * this );
}

//
// NewATMVCIndication_reverseParameters_bitRate
//

NewATMVCIndication_reverseParameters_bitRate :: NewATMVCIndication_reverseParameters_bitRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 65535 ) { }

NewATMVCIndication_reverseParameters_bitRate :: NewATMVCIndication_reverseParameters_bitRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 65535 ) { }

NewATMVCIndication_reverseParameters_bitRate * NewATMVCIndication_reverseParameters_bitRate :: clone ( ) const {
	return new NewATMVCIndication_reverseParameters_bitRate ( * this );
}

//
// NewATMVCIndication_reverseParameters_multiplex
//

NewATMVCIndication_reverseParameters_multiplex :: NewATMVCIndication_reverseParameters_multiplex ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_noMultiplex:
		case e_transportStream:
		case e_programStream:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

NewATMVCIndication_reverseParameters_multiplex :: NewATMVCIndication_reverseParameters_multiplex ( ) : Asn :: Choice ( 3, true ) { }

void NewATMVCIndication_reverseParameters_multiplex :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_noMultiplex:
		case e_transportStream:
		case e_programStream:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & NewATMVCIndication_reverseParameters_multiplex :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_noMultiplex, "noMultiplex" },
		{ e_transportStream, "transportStream" },
		{ e_programStream, "programStream" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

NewATMVCIndication_reverseParameters_multiplex * NewATMVCIndication_reverseParameters_multiplex :: clone ( ) const {
	return new NewATMVCIndication_reverseParameters_multiplex ( * this );
}

//
// UserInputIndication_signal_signalType
//

UserInputIndication_signal_signalType :: UserInputIndication_signal_signalType ( Asn :: istream & is ) : Asn :: IA5String ( is, Asn :: fixedConstraint, 1, 1, "!#*0123456789ABCD", sizeof ( "0123456789#*ABCD!" ) > 17 ? 8 : 4 ) { }

UserInputIndication_signal_signalType :: UserInputIndication_signal_signalType ( const Asn :: string & v ) : Asn :: IA5String ( v, Asn :: fixedConstraint, 1, 1, "!#*0123456789ABCD", sizeof ( "0123456789#*ABCD!" ) > 17 ? 8 : 4 ) { }

UserInputIndication_signal_signalType * UserInputIndication_signal_signalType :: clone ( ) const {
	return new UserInputIndication_signal_signalType ( * this );
}

//
// UserInputIndication_signal_duration
//

UserInputIndication_signal_duration :: UserInputIndication_signal_duration ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 65535 ) { }

UserInputIndication_signal_duration :: UserInputIndication_signal_duration ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 65535 ) { }

UserInputIndication_signal_duration * UserInputIndication_signal_duration :: clone ( ) const {
	return new UserInputIndication_signal_duration ( * this );
}

//
// UserInputIndication_signal_rtp
//

UserInputIndication_signal_rtp :: UserInputIndication_signal_rtp ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 0 ), m_timestamp ( hasOptionalField ( e_timestamp ) ? pushTemporaryMember ( new UserInputIndication_signal_rtp_timestamp ( is ) ) : 0 ), m_expirationTime ( hasOptionalField ( e_expirationTime ) ? pushTemporaryMember ( new UserInputIndication_signal_rtp_expirationTime ( is ) ) : 0 ), m_logicalChannelNumber ( is ) {
	clearTemporaryMembers ( );
	try {
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_timestamp;
		delete m_expirationTime;
		throw;
	}
}

UserInputIndication_signal_rtp :: UserInputIndication_signal_rtp ( ) : Asn :: Sequence ( 2, true, 0 ), m_timestamp ( 0 ), m_expirationTime ( 0 ) { }

UserInputIndication_signal_rtp & UserInputIndication_signal_rtp :: operator= ( const UserInputIndication_signal_rtp & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_timestamp, s.m_timestamp );
	assignCopy ( m_expirationTime, s.m_expirationTime );
	m_logicalChannelNumber = s.m_logicalChannelNumber;
	return * this;
}

UserInputIndication_signal_rtp :: UserInputIndication_signal_rtp ( const UserInputIndication_signal_rtp & s ) : Asn :: Sequence ( s ), m_timestamp ( 0 ), m_expirationTime ( 0 ), m_logicalChannelNumber ( s.m_logicalChannelNumber ) {
	try {
		if ( s.m_timestamp )
			m_timestamp = new UserInputIndication_signal_rtp_timestamp ( * s.m_timestamp );
		if ( s.m_expirationTime )
			m_expirationTime = new UserInputIndication_signal_rtp_expirationTime ( * s.m_expirationTime );
	} catch ( ... ) {
		delete m_timestamp;
		delete m_expirationTime;
		throw;
	}
}


void UserInputIndication_signal_rtp :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_timestamp:
			assignNew ( m_timestamp, new UserInputIndication_signal_rtp_timestamp );
			break;
		case e_expirationTime:
			assignNew ( m_expirationTime, new UserInputIndication_signal_rtp_expirationTime );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void UserInputIndication_signal_rtp :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_timestamp:
			delete m_timestamp;
			m_timestamp = 0;
			break;
		case e_expirationTime:
			delete m_expirationTime;
			m_expirationTime = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void UserInputIndication_signal_rtp :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_timestamp ) )
		m_timestamp -> UserInputIndication_signal_rtp_timestamp :: encode ( os );
	if ( hasOptionalField ( e_expirationTime ) )
		m_expirationTime -> UserInputIndication_signal_rtp_expirationTime :: encode ( os );
	m_logicalChannelNumber.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

UserInputIndication_signal_rtp :: ~UserInputIndication_signal_rtp ( ) {
	delete m_timestamp;
	delete m_expirationTime;
}

void UserInputIndication_signal_rtp :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_timestamp ) ) {
		os << std :: setw ( indent + 12 ) << "timestamp = " << std :: setprecision ( indent );
		m_timestamp -> UserInputIndication_signal_rtp_timestamp :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_expirationTime ) ) {
		os << std :: setw ( indent + 17 ) << "expirationTime = " << std :: setprecision ( indent );
		m_expirationTime -> UserInputIndication_signal_rtp_expirationTime :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 23 ) << "logicalChannelNumber = " << std :: setprecision ( indent ) << m_logicalChannelNumber << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

UserInputIndication_signal_rtp * UserInputIndication_signal_rtp :: clone ( ) const {
	return new UserInputIndication_signal_rtp ( * this );
}

//
// UserInputIndication_signal_encryptedSignalType
//

UserInputIndication_signal_encryptedSignalType :: UserInputIndication_signal_encryptedSignalType ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 1, 1 ) { }

UserInputIndication_signal_encryptedSignalType :: UserInputIndication_signal_encryptedSignalType ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 1, 1 ) { }

UserInputIndication_signal_encryptedSignalType * UserInputIndication_signal_encryptedSignalType :: clone ( ) const {
	return new UserInputIndication_signal_encryptedSignalType ( * this );
}

//
// UserInputIndication_signalUpdate_duration
//

UserInputIndication_signalUpdate_duration :: UserInputIndication_signalUpdate_duration ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 65535 ) { }

UserInputIndication_signalUpdate_duration :: UserInputIndication_signalUpdate_duration ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 65535 ) { }

UserInputIndication_signalUpdate_duration * UserInputIndication_signalUpdate_duration :: clone ( ) const {
	return new UserInputIndication_signalUpdate_duration ( * this );
}

//
// UserInputIndication_signalUpdate_rtp
//

UserInputIndication_signalUpdate_rtp :: UserInputIndication_signalUpdate_rtp ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_logicalChannelNumber ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

UserInputIndication_signalUpdate_rtp :: UserInputIndication_signalUpdate_rtp ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void UserInputIndication_signalUpdate_rtp :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_logicalChannelNumber.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void UserInputIndication_signalUpdate_rtp :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 23 ) << "logicalChannelNumber = " << std :: setprecision ( indent ) << m_logicalChannelNumber << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

UserInputIndication_signalUpdate_rtp * UserInputIndication_signalUpdate_rtp :: clone ( ) const {
	return new UserInputIndication_signalUpdate_rtp ( * this );
}

//
// UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric
//

UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric :: UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_algorithmOID ( is ), m_paramS ( hasOptionalField ( e_paramS ) ? pushTemporaryMember ( new Params ( is ) ) : 0 ), m_encrypted ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) {
	clearTemporaryMembers ( );
	try {
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_paramS;
		throw;
	}
}

UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric :: UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric ( ) : Asn :: Sequence ( 1, true, 0 ), m_paramS ( 0 ) { }

UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric & UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric :: operator= ( const UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric & s ) {
	Asn :: Sequence :: operator= ( s );
	m_algorithmOID = s.m_algorithmOID;
	assignCopy ( m_paramS, s.m_paramS );
	m_encrypted = s.m_encrypted;
	return * this;
}

UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric :: UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric ( const UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric & s ) : Asn :: Sequence ( s ), m_algorithmOID ( s.m_algorithmOID ), m_paramS ( 0 ), m_encrypted ( s.m_encrypted ) {
	try {
		if ( s.m_paramS )
			m_paramS = new Params ( * s.m_paramS );
	} catch ( ... ) {
		delete m_paramS;
		throw;
	}
}


void UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_paramS:
			assignNew ( m_paramS, new Params );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_paramS:
			delete m_paramS;
			m_paramS = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_algorithmOID.encode ( os );
	if ( hasOptionalField ( e_paramS ) )
		m_paramS -> Params :: encode ( os );
	m_encrypted.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric :: ~UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric ( ) {
	delete m_paramS;
}

void UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 15 ) << "algorithmOID = " << std :: setprecision ( indent ) << m_algorithmOID << '\n';
	if ( hasOptionalField ( e_paramS ) ) {
		os << std :: setw ( indent + 9 ) << "paramS = " << std :: setprecision ( indent );
		m_paramS -> Params :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 12 ) << "encrypted = " << std :: setprecision ( indent ) << m_encrypted << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric * UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric :: clone ( ) const {
	return new UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric ( * this );
}

//
// FlowControlIndication_scope_resourceID
//

FlowControlIndication_scope_resourceID :: FlowControlIndication_scope_resourceID ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

FlowControlIndication_scope_resourceID :: FlowControlIndication_scope_resourceID ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

FlowControlIndication_scope_resourceID * FlowControlIndication_scope_resourceID :: clone ( ) const {
	return new FlowControlIndication_scope_resourceID ( * this );
}

//
// FlowControlIndication_restriction_maximumBitRate
//

FlowControlIndication_restriction_maximumBitRate :: FlowControlIndication_restriction_maximumBitRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 16777215 ) { }

FlowControlIndication_restriction_maximumBitRate :: FlowControlIndication_restriction_maximumBitRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 16777215 ) { }

FlowControlIndication_restriction_maximumBitRate * FlowControlIndication_restriction_maximumBitRate :: clone ( ) const {
	return new FlowControlIndication_restriction_maximumBitRate ( * this );
}

//
// VCCapability_availableBitRates_type_singleBitRate
//

VCCapability_availableBitRates_type_singleBitRate :: VCCapability_availableBitRates_type_singleBitRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 65535 ) { }

VCCapability_availableBitRates_type_singleBitRate :: VCCapability_availableBitRates_type_singleBitRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 65535 ) { }

VCCapability_availableBitRates_type_singleBitRate * VCCapability_availableBitRates_type_singleBitRate :: clone ( ) const {
	return new VCCapability_availableBitRates_type_singleBitRate ( * this );
}

//
// H223Capability_h223MultiplexTableCapability_enhanced_maximumNestingDepth
//

H223Capability_h223MultiplexTableCapability_enhanced_maximumNestingDepth :: H223Capability_h223MultiplexTableCapability_enhanced_maximumNestingDepth ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 15 ) { }

H223Capability_h223MultiplexTableCapability_enhanced_maximumNestingDepth :: H223Capability_h223MultiplexTableCapability_enhanced_maximumNestingDepth ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 15 ) { }

H223Capability_h223MultiplexTableCapability_enhanced_maximumNestingDepth * H223Capability_h223MultiplexTableCapability_enhanced_maximumNestingDepth :: clone ( ) const {
	return new H223Capability_h223MultiplexTableCapability_enhanced_maximumNestingDepth ( * this );
}

//
// H223Capability_h223MultiplexTableCapability_enhanced_maximumElementListSize
//

H223Capability_h223MultiplexTableCapability_enhanced_maximumElementListSize :: H223Capability_h223MultiplexTableCapability_enhanced_maximumElementListSize ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 2, 255 ) { }

H223Capability_h223MultiplexTableCapability_enhanced_maximumElementListSize :: H223Capability_h223MultiplexTableCapability_enhanced_maximumElementListSize ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 2, 255 ) { }

H223Capability_h223MultiplexTableCapability_enhanced_maximumElementListSize * H223Capability_h223MultiplexTableCapability_enhanced_maximumElementListSize :: clone ( ) const {
	return new H223Capability_h223MultiplexTableCapability_enhanced_maximumElementListSize ( * this );
}

//
// H223Capability_h223MultiplexTableCapability_enhanced_maximumSubElementListSize
//

H223Capability_h223MultiplexTableCapability_enhanced_maximumSubElementListSize :: H223Capability_h223MultiplexTableCapability_enhanced_maximumSubElementListSize ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 2, 255 ) { }

H223Capability_h223MultiplexTableCapability_enhanced_maximumSubElementListSize :: H223Capability_h223MultiplexTableCapability_enhanced_maximumSubElementListSize ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 2, 255 ) { }

H223Capability_h223MultiplexTableCapability_enhanced_maximumSubElementListSize * H223Capability_h223MultiplexTableCapability_enhanced_maximumSubElementListSize :: clone ( ) const {
	return new H223Capability_h223MultiplexTableCapability_enhanced_maximumSubElementListSize ( * this );
}

//
// RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuHorizMBs
//

RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuHorizMBs :: RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuHorizMBs ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 128 ) { }

RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuHorizMBs :: RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuHorizMBs ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 128 ) { }

RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuHorizMBs * RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuHorizMBs :: clone ( ) const {
	return new RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuHorizMBs ( * this );
}

//
// RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuVertMBs
//

RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuVertMBs :: RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuVertMBs ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 72 ) { }

RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuVertMBs :: RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuVertMBs ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 72 ) { }

RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuVertMBs * RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuVertMBs :: clone ( ) const {
	return new RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuVertMBs ( * this );
}

//
// RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuTotalNumber
//

RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuTotalNumber :: RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuTotalNumber ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 65536 ) { }

RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuTotalNumber :: RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuTotalNumber ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 65536 ) { }

RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuTotalNumber * RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuTotalNumber :: clone ( ) const {
	return new RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters_mpuTotalNumber ( * this );
}

//
// CustomPictureFormat_pixelAspectInformation_pixelAspectCode_subtype
//

CustomPictureFormat_pixelAspectInformation_pixelAspectCode_subtype :: CustomPictureFormat_pixelAspectInformation_pixelAspectCode_subtype ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 14 ) { }

CustomPictureFormat_pixelAspectInformation_pixelAspectCode_subtype :: CustomPictureFormat_pixelAspectInformation_pixelAspectCode_subtype ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 14 ) { }

CustomPictureFormat_pixelAspectInformation_pixelAspectCode_subtype * CustomPictureFormat_pixelAspectInformation_pixelAspectCode_subtype :: clone ( ) const {
	return new CustomPictureFormat_pixelAspectInformation_pixelAspectCode_subtype ( * this );
}

//
// H223LogicalChannelParameters_adaptationLayerType_al3_controlFieldOctets
//

H223LogicalChannelParameters_adaptationLayerType_al3_controlFieldOctets :: H223LogicalChannelParameters_adaptationLayerType_al3_controlFieldOctets ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 2 ) { }

H223LogicalChannelParameters_adaptationLayerType_al3_controlFieldOctets :: H223LogicalChannelParameters_adaptationLayerType_al3_controlFieldOctets ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 2 ) { }

H223LogicalChannelParameters_adaptationLayerType_al3_controlFieldOctets * H223LogicalChannelParameters_adaptationLayerType_al3_controlFieldOctets :: clone ( ) const {
	return new H223LogicalChannelParameters_adaptationLayerType_al3_controlFieldOctets ( * this );
}

//
// H223LogicalChannelParameters_adaptationLayerType_al3_sendBufferSize
//

H223LogicalChannelParameters_adaptationLayerType_al3_sendBufferSize :: H223LogicalChannelParameters_adaptationLayerType_al3_sendBufferSize ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 16777215 ) { }

H223LogicalChannelParameters_adaptationLayerType_al3_sendBufferSize :: H223LogicalChannelParameters_adaptationLayerType_al3_sendBufferSize ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 16777215 ) { }

H223LogicalChannelParameters_adaptationLayerType_al3_sendBufferSize * H223LogicalChannelParameters_adaptationLayerType_al3_sendBufferSize :: clone ( ) const {
	return new H223LogicalChannelParameters_adaptationLayerType_al3_sendBufferSize ( * this );
}

//
// V76LogicalChannelParameters_mode_eRM_windowSize
//

V76LogicalChannelParameters_mode_eRM_windowSize :: V76LogicalChannelParameters_mode_eRM_windowSize ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 127 ) { }

V76LogicalChannelParameters_mode_eRM_windowSize :: V76LogicalChannelParameters_mode_eRM_windowSize ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 127 ) { }

V76LogicalChannelParameters_mode_eRM_windowSize * V76LogicalChannelParameters_mode_eRM_windowSize :: clone ( ) const {
	return new V76LogicalChannelParameters_mode_eRM_windowSize ( * this );
}

//
// V76LogicalChannelParameters_mode_eRM_recovery
//

V76LogicalChannelParameters_mode_eRM_recovery :: V76LogicalChannelParameters_mode_eRM_recovery ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_rej:
		case e_sREJ:
		case e_mSREJ:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

V76LogicalChannelParameters_mode_eRM_recovery :: V76LogicalChannelParameters_mode_eRM_recovery ( ) : Asn :: Choice ( 3, true ) { }

void V76LogicalChannelParameters_mode_eRM_recovery :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_rej:
		case e_sREJ:
		case e_mSREJ:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & V76LogicalChannelParameters_mode_eRM_recovery :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_rej, "rej" },
		{ e_sREJ, "sREJ" },
		{ e_mSREJ, "mSREJ" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

V76LogicalChannelParameters_mode_eRM_recovery * V76LogicalChannelParameters_mode_eRM_recovery :: clone ( ) const {
	return new V76LogicalChannelParameters_mode_eRM_recovery ( * this );
}

//
// FECData_rfc2733_pktMode_rfc2733sameport
//

FECData_rfc2733_pktMode_rfc2733sameport :: FECData_rfc2733_pktMode_rfc2733sameport ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

FECData_rfc2733_pktMode_rfc2733sameport :: FECData_rfc2733_pktMode_rfc2733sameport ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void FECData_rfc2733_pktMode_rfc2733sameport :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void FECData_rfc2733_pktMode_rfc2733sameport :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

FECData_rfc2733_pktMode_rfc2733sameport * FECData_rfc2733_pktMode_rfc2733sameport :: clone ( ) const {
	return new FECData_rfc2733_pktMode_rfc2733sameport ( * this );
}

//
// FECData_rfc2733_pktMode_rfc2733diffport
//

FECData_rfc2733_pktMode_rfc2733diffport :: FECData_rfc2733_pktMode_rfc2733diffport ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_protectedChannel ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

FECData_rfc2733_pktMode_rfc2733diffport :: FECData_rfc2733_pktMode_rfc2733diffport ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void FECData_rfc2733_pktMode_rfc2733diffport :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_protectedChannel.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void FECData_rfc2733_pktMode_rfc2733diffport :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 19 ) << "protectedChannel = " << std :: setprecision ( indent ) << m_protectedChannel << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

FECData_rfc2733_pktMode_rfc2733diffport * FECData_rfc2733_pktMode_rfc2733diffport :: clone ( ) const {
	return new FECData_rfc2733_pktMode_rfc2733diffport ( * this );
}

//
// UnicastAddress_iPSourceRouteAddress_route_subtype
//

UnicastAddress_iPSourceRouteAddress_route_subtype :: UnicastAddress_iPSourceRouteAddress_route_subtype ( Asn :: istream & is ) : Asn :: OctetString ( is, Asn :: fixedConstraint, 4, 4 ) { }

UnicastAddress_iPSourceRouteAddress_route_subtype :: UnicastAddress_iPSourceRouteAddress_route_subtype ( const Asn :: string & v ) : Asn :: OctetString ( v, Asn :: fixedConstraint, 4, 4 ) { }

UnicastAddress_iPSourceRouteAddress_route_subtype * UnicastAddress_iPSourceRouteAddress_route_subtype :: clone ( ) const {
	return new UnicastAddress_iPSourceRouteAddress_route_subtype ( * this );
}

//
// H223ModeParameters_adaptationLayerType_al3_controlFieldOctets
//

H223ModeParameters_adaptationLayerType_al3_controlFieldOctets :: H223ModeParameters_adaptationLayerType_al3_controlFieldOctets ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 2 ) { }

H223ModeParameters_adaptationLayerType_al3_controlFieldOctets :: H223ModeParameters_adaptationLayerType_al3_controlFieldOctets ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 2 ) { }

H223ModeParameters_adaptationLayerType_al3_controlFieldOctets * H223ModeParameters_adaptationLayerType_al3_controlFieldOctets :: clone ( ) const {
	return new H223ModeParameters_adaptationLayerType_al3_controlFieldOctets ( * this );
}

//
// H223ModeParameters_adaptationLayerType_al3_sendBufferSize
//

H223ModeParameters_adaptationLayerType_al3_sendBufferSize :: H223ModeParameters_adaptationLayerType_al3_sendBufferSize ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 16777215 ) { }

H223ModeParameters_adaptationLayerType_al3_sendBufferSize :: H223ModeParameters_adaptationLayerType_al3_sendBufferSize ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 16777215 ) { }

H223ModeParameters_adaptationLayerType_al3_sendBufferSize * H223ModeParameters_adaptationLayerType_al3_sendBufferSize :: clone ( ) const {
	return new H223ModeParameters_adaptationLayerType_al3_sendBufferSize ( * this );
}

//
// MultilinkRequest_maximumHeaderInterval_requestType_requestedInterval
//

MultilinkRequest_maximumHeaderInterval_requestType_requestedInterval :: MultilinkRequest_maximumHeaderInterval_requestType_requestedInterval ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

MultilinkRequest_maximumHeaderInterval_requestType_requestedInterval :: MultilinkRequest_maximumHeaderInterval_requestType_requestedInterval ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

MultilinkRequest_maximumHeaderInterval_requestType_requestedInterval * MultilinkRequest_maximumHeaderInterval_requestType_requestedInterval :: clone ( ) const {
	return new MultilinkRequest_maximumHeaderInterval_requestType_requestedInterval ( * this );
}

//
// MultilinkResponse_addConnection_responseCode_rejected
//

MultilinkResponse_addConnection_responseCode_rejected :: MultilinkResponse_addConnection_responseCode_rejected ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_connectionsNotAvailable:
		case e_userRejected:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

MultilinkResponse_addConnection_responseCode_rejected :: MultilinkResponse_addConnection_responseCode_rejected ( ) : Asn :: Choice ( 2, true ) { }

void MultilinkResponse_addConnection_responseCode_rejected :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_connectionsNotAvailable:
		case e_userRejected:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & MultilinkResponse_addConnection_responseCode_rejected :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_connectionsNotAvailable, "connectionsNotAvailable" },
		{ e_userRejected, "userRejected" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

MultilinkResponse_addConnection_responseCode_rejected * MultilinkResponse_addConnection_responseCode_rejected :: clone ( ) const {
	return new MultilinkResponse_addConnection_responseCode_rejected ( * this );
}

//
// MiscellaneousCommand_type_videoFastUpdateGOB_firstGOB
//

MiscellaneousCommand_type_videoFastUpdateGOB_firstGOB :: MiscellaneousCommand_type_videoFastUpdateGOB_firstGOB ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 17 ) { }

MiscellaneousCommand_type_videoFastUpdateGOB_firstGOB :: MiscellaneousCommand_type_videoFastUpdateGOB_firstGOB ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 17 ) { }

MiscellaneousCommand_type_videoFastUpdateGOB_firstGOB * MiscellaneousCommand_type_videoFastUpdateGOB_firstGOB :: clone ( ) const {
	return new MiscellaneousCommand_type_videoFastUpdateGOB_firstGOB ( * this );
}

//
// MiscellaneousCommand_type_videoFastUpdateGOB_numberOfGOBs
//

MiscellaneousCommand_type_videoFastUpdateGOB_numberOfGOBs :: MiscellaneousCommand_type_videoFastUpdateGOB_numberOfGOBs ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 18 ) { }

MiscellaneousCommand_type_videoFastUpdateGOB_numberOfGOBs :: MiscellaneousCommand_type_videoFastUpdateGOB_numberOfGOBs ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 18 ) { }

MiscellaneousCommand_type_videoFastUpdateGOB_numberOfGOBs * MiscellaneousCommand_type_videoFastUpdateGOB_numberOfGOBs :: clone ( ) const {
	return new MiscellaneousCommand_type_videoFastUpdateGOB_numberOfGOBs ( * this );
}

//
// MiscellaneousCommand_type_videoFastUpdateMB_firstGOB
//

MiscellaneousCommand_type_videoFastUpdateMB_firstGOB :: MiscellaneousCommand_type_videoFastUpdateMB_firstGOB ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 255 ) { }

MiscellaneousCommand_type_videoFastUpdateMB_firstGOB :: MiscellaneousCommand_type_videoFastUpdateMB_firstGOB ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 255 ) { }

MiscellaneousCommand_type_videoFastUpdateMB_firstGOB * MiscellaneousCommand_type_videoFastUpdateMB_firstGOB :: clone ( ) const {
	return new MiscellaneousCommand_type_videoFastUpdateMB_firstGOB ( * this );
}

//
// MiscellaneousCommand_type_videoFastUpdateMB_firstMB
//

MiscellaneousCommand_type_videoFastUpdateMB_firstMB :: MiscellaneousCommand_type_videoFastUpdateMB_firstMB ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 8192 ) { }

MiscellaneousCommand_type_videoFastUpdateMB_firstMB :: MiscellaneousCommand_type_videoFastUpdateMB_firstMB ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 8192 ) { }

MiscellaneousCommand_type_videoFastUpdateMB_firstMB * MiscellaneousCommand_type_videoFastUpdateMB_firstMB :: clone ( ) const {
	return new MiscellaneousCommand_type_videoFastUpdateMB_firstMB ( * this );
}

//
// MiscellaneousCommand_type_videoFastUpdateMB_numberOfMBs
//

MiscellaneousCommand_type_videoFastUpdateMB_numberOfMBs :: MiscellaneousCommand_type_videoFastUpdateMB_numberOfMBs ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 8192 ) { }

MiscellaneousCommand_type_videoFastUpdateMB_numberOfMBs :: MiscellaneousCommand_type_videoFastUpdateMB_numberOfMBs ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 8192 ) { }

MiscellaneousCommand_type_videoFastUpdateMB_numberOfMBs * MiscellaneousCommand_type_videoFastUpdateMB_numberOfMBs :: clone ( ) const {
	return new MiscellaneousCommand_type_videoFastUpdateMB_numberOfMBs ( * this );
}

//
// MiscellaneousCommand_type_progressiveRefinementStart_repeatCount
//

MiscellaneousCommand_type_progressiveRefinementStart_repeatCount :: MiscellaneousCommand_type_progressiveRefinementStart_repeatCount ( Asn :: istream & is ) : Asn :: Choice ( is, 4, true ) {
	switch ( tag ) {
		case e_doOneProgression:
		case e_doContinuousProgressions:
		case e_doOneIndependentProgression:
		case e_doContinuousIndependentProgressions:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

MiscellaneousCommand_type_progressiveRefinementStart_repeatCount :: MiscellaneousCommand_type_progressiveRefinementStart_repeatCount ( ) : Asn :: Choice ( 4, true ) { }

void MiscellaneousCommand_type_progressiveRefinementStart_repeatCount :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_doOneProgression:
		case e_doContinuousProgressions:
		case e_doOneIndependentProgression:
		case e_doContinuousIndependentProgressions:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & MiscellaneousCommand_type_progressiveRefinementStart_repeatCount :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_doOneProgression, "doOneProgression" },
		{ e_doContinuousProgressions, "doContinuousProgressions" },
		{ e_doOneIndependentProgression, "doOneIndependentProgression" },
		{ e_doContinuousIndependentProgressions, "doContinuousIndependentProgressions" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

MiscellaneousCommand_type_progressiveRefinementStart_repeatCount * MiscellaneousCommand_type_progressiveRefinementStart_repeatCount :: clone ( ) const {
	return new MiscellaneousCommand_type_progressiveRefinementStart_repeatCount ( * this );
}

//
// MiscellaneousCommand_type_videoBadMBs_firstMB
//

MiscellaneousCommand_type_videoBadMBs_firstMB :: MiscellaneousCommand_type_videoBadMBs_firstMB ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 9216 ) { }

MiscellaneousCommand_type_videoBadMBs_firstMB :: MiscellaneousCommand_type_videoBadMBs_firstMB ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 9216 ) { }

MiscellaneousCommand_type_videoBadMBs_firstMB * MiscellaneousCommand_type_videoBadMBs_firstMB :: clone ( ) const {
	return new MiscellaneousCommand_type_videoBadMBs_firstMB ( * this );
}

//
// MiscellaneousCommand_type_videoBadMBs_numberOfMBs
//

MiscellaneousCommand_type_videoBadMBs_numberOfMBs :: MiscellaneousCommand_type_videoBadMBs_numberOfMBs ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 9216 ) { }

MiscellaneousCommand_type_videoBadMBs_numberOfMBs :: MiscellaneousCommand_type_videoBadMBs_numberOfMBs ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 9216 ) { }

MiscellaneousCommand_type_videoBadMBs_numberOfMBs * MiscellaneousCommand_type_videoBadMBs_numberOfMBs :: clone ( ) const {
	return new MiscellaneousCommand_type_videoBadMBs_numberOfMBs ( * this );
}

//
// MiscellaneousCommand_type_videoBadMBs_temporalReference
//

MiscellaneousCommand_type_videoBadMBs_temporalReference :: MiscellaneousCommand_type_videoBadMBs_temporalReference ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 1023 ) { }

MiscellaneousCommand_type_videoBadMBs_temporalReference :: MiscellaneousCommand_type_videoBadMBs_temporalReference ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 1023 ) { }

MiscellaneousCommand_type_videoBadMBs_temporalReference * MiscellaneousCommand_type_videoBadMBs_temporalReference :: clone ( ) const {
	return new MiscellaneousCommand_type_videoBadMBs_temporalReference ( * this );
}

//
// MiscellaneousCommand_type_lostPartialPicture_firstMB
//

MiscellaneousCommand_type_lostPartialPicture_firstMB :: MiscellaneousCommand_type_lostPartialPicture_firstMB ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 9216 ) { }

MiscellaneousCommand_type_lostPartialPicture_firstMB :: MiscellaneousCommand_type_lostPartialPicture_firstMB ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 9216 ) { }

MiscellaneousCommand_type_lostPartialPicture_firstMB * MiscellaneousCommand_type_lostPartialPicture_firstMB :: clone ( ) const {
	return new MiscellaneousCommand_type_lostPartialPicture_firstMB ( * this );
}

//
// MiscellaneousCommand_type_lostPartialPicture_numberOfMBs
//

MiscellaneousCommand_type_lostPartialPicture_numberOfMBs :: MiscellaneousCommand_type_lostPartialPicture_numberOfMBs ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 9216 ) { }

MiscellaneousCommand_type_lostPartialPicture_numberOfMBs :: MiscellaneousCommand_type_lostPartialPicture_numberOfMBs ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 9216 ) { }

MiscellaneousCommand_type_lostPartialPicture_numberOfMBs * MiscellaneousCommand_type_lostPartialPicture_numberOfMBs :: clone ( ) const {
	return new MiscellaneousCommand_type_lostPartialPicture_numberOfMBs ( * this );
}

//
// MiscellaneousCommand_type_encryptionUpdateAck_synchFlag
//

MiscellaneousCommand_type_encryptionUpdateAck_synchFlag :: MiscellaneousCommand_type_encryptionUpdateAck_synchFlag ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 255 ) { }

MiscellaneousCommand_type_encryptionUpdateAck_synchFlag :: MiscellaneousCommand_type_encryptionUpdateAck_synchFlag ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 255 ) { }

MiscellaneousCommand_type_encryptionUpdateAck_synchFlag * MiscellaneousCommand_type_encryptionUpdateAck_synchFlag :: clone ( ) const {
	return new MiscellaneousCommand_type_encryptionUpdateAck_synchFlag ( * this );
}

//
// NewATMVCCommand_aal_aal1_clockRecovery
//

NewATMVCCommand_aal_aal1_clockRecovery :: NewATMVCCommand_aal_aal1_clockRecovery ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_nullClockRecovery:
		case e_srtsClockRecovery:
		case e_adaptiveClockRecovery:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

NewATMVCCommand_aal_aal1_clockRecovery :: NewATMVCCommand_aal_aal1_clockRecovery ( ) : Asn :: Choice ( 3, true ) { }

void NewATMVCCommand_aal_aal1_clockRecovery :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nullClockRecovery:
		case e_srtsClockRecovery:
		case e_adaptiveClockRecovery:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & NewATMVCCommand_aal_aal1_clockRecovery :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nullClockRecovery, "nullClockRecovery" },
		{ e_srtsClockRecovery, "srtsClockRecovery" },
		{ e_adaptiveClockRecovery, "adaptiveClockRecovery" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

NewATMVCCommand_aal_aal1_clockRecovery * NewATMVCCommand_aal_aal1_clockRecovery :: clone ( ) const {
	return new NewATMVCCommand_aal_aal1_clockRecovery ( * this );
}

//
// NewATMVCCommand_aal_aal1_errorCorrection
//

NewATMVCCommand_aal_aal1_errorCorrection :: NewATMVCCommand_aal_aal1_errorCorrection ( Asn :: istream & is ) : Asn :: Choice ( is, 4, true ) {
	switch ( tag ) {
		case e_nullErrorCorrection:
		case e_longInterleaver:
		case e_shortInterleaver:
		case e_errorCorrectionOnly:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

NewATMVCCommand_aal_aal1_errorCorrection :: NewATMVCCommand_aal_aal1_errorCorrection ( ) : Asn :: Choice ( 4, true ) { }

void NewATMVCCommand_aal_aal1_errorCorrection :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nullErrorCorrection:
		case e_longInterleaver:
		case e_shortInterleaver:
		case e_errorCorrectionOnly:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & NewATMVCCommand_aal_aal1_errorCorrection :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nullErrorCorrection, "nullErrorCorrection" },
		{ e_longInterleaver, "longInterleaver" },
		{ e_shortInterleaver, "shortInterleaver" },
		{ e_errorCorrectionOnly, "errorCorrectionOnly" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

NewATMVCCommand_aal_aal1_errorCorrection * NewATMVCCommand_aal_aal1_errorCorrection :: clone ( ) const {
	return new NewATMVCCommand_aal_aal1_errorCorrection ( * this );
}

//
// NewATMVCCommand_aal_aal5_forwardMaximumSDUSize
//

NewATMVCCommand_aal_aal5_forwardMaximumSDUSize :: NewATMVCCommand_aal_aal5_forwardMaximumSDUSize ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

NewATMVCCommand_aal_aal5_forwardMaximumSDUSize :: NewATMVCCommand_aal_aal5_forwardMaximumSDUSize ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

NewATMVCCommand_aal_aal5_forwardMaximumSDUSize * NewATMVCCommand_aal_aal5_forwardMaximumSDUSize :: clone ( ) const {
	return new NewATMVCCommand_aal_aal5_forwardMaximumSDUSize ( * this );
}

//
// NewATMVCCommand_aal_aal5_backwardMaximumSDUSize
//

NewATMVCCommand_aal_aal5_backwardMaximumSDUSize :: NewATMVCCommand_aal_aal5_backwardMaximumSDUSize ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

NewATMVCCommand_aal_aal5_backwardMaximumSDUSize :: NewATMVCCommand_aal_aal5_backwardMaximumSDUSize ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

NewATMVCCommand_aal_aal5_backwardMaximumSDUSize * NewATMVCCommand_aal_aal5_backwardMaximumSDUSize :: clone ( ) const {
	return new NewATMVCCommand_aal_aal5_backwardMaximumSDUSize ( * this );
}

//
// MiscellaneousIndication_type_videoNotDecodedMBs_firstMB
//

MiscellaneousIndication_type_videoNotDecodedMBs_firstMB :: MiscellaneousIndication_type_videoNotDecodedMBs_firstMB ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 8192 ) { }

MiscellaneousIndication_type_videoNotDecodedMBs_firstMB :: MiscellaneousIndication_type_videoNotDecodedMBs_firstMB ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 8192 ) { }

MiscellaneousIndication_type_videoNotDecodedMBs_firstMB * MiscellaneousIndication_type_videoNotDecodedMBs_firstMB :: clone ( ) const {
	return new MiscellaneousIndication_type_videoNotDecodedMBs_firstMB ( * this );
}

//
// MiscellaneousIndication_type_videoNotDecodedMBs_numberOfMBs
//

MiscellaneousIndication_type_videoNotDecodedMBs_numberOfMBs :: MiscellaneousIndication_type_videoNotDecodedMBs_numberOfMBs ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 8192 ) { }

MiscellaneousIndication_type_videoNotDecodedMBs_numberOfMBs :: MiscellaneousIndication_type_videoNotDecodedMBs_numberOfMBs ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 8192 ) { }

MiscellaneousIndication_type_videoNotDecodedMBs_numberOfMBs * MiscellaneousIndication_type_videoNotDecodedMBs_numberOfMBs :: clone ( ) const {
	return new MiscellaneousIndication_type_videoNotDecodedMBs_numberOfMBs ( * this );
}

//
// MiscellaneousIndication_type_videoNotDecodedMBs_temporalReference
//

MiscellaneousIndication_type_videoNotDecodedMBs_temporalReference :: MiscellaneousIndication_type_videoNotDecodedMBs_temporalReference ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 255 ) { }

MiscellaneousIndication_type_videoNotDecodedMBs_temporalReference :: MiscellaneousIndication_type_videoNotDecodedMBs_temporalReference ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 255 ) { }

MiscellaneousIndication_type_videoNotDecodedMBs_temporalReference * MiscellaneousIndication_type_videoNotDecodedMBs_temporalReference :: clone ( ) const {
	return new MiscellaneousIndication_type_videoNotDecodedMBs_temporalReference ( * this );
}

//
// NewATMVCIndication_aal_aal1_clockRecovery
//

NewATMVCIndication_aal_aal1_clockRecovery :: NewATMVCIndication_aal_aal1_clockRecovery ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_nullClockRecovery:
		case e_srtsClockRecovery:
		case e_adaptiveClockRecovery:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

NewATMVCIndication_aal_aal1_clockRecovery :: NewATMVCIndication_aal_aal1_clockRecovery ( ) : Asn :: Choice ( 3, true ) { }

void NewATMVCIndication_aal_aal1_clockRecovery :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nullClockRecovery:
		case e_srtsClockRecovery:
		case e_adaptiveClockRecovery:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & NewATMVCIndication_aal_aal1_clockRecovery :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nullClockRecovery, "nullClockRecovery" },
		{ e_srtsClockRecovery, "srtsClockRecovery" },
		{ e_adaptiveClockRecovery, "adaptiveClockRecovery" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

NewATMVCIndication_aal_aal1_clockRecovery * NewATMVCIndication_aal_aal1_clockRecovery :: clone ( ) const {
	return new NewATMVCIndication_aal_aal1_clockRecovery ( * this );
}

//
// NewATMVCIndication_aal_aal1_errorCorrection
//

NewATMVCIndication_aal_aal1_errorCorrection :: NewATMVCIndication_aal_aal1_errorCorrection ( Asn :: istream & is ) : Asn :: Choice ( is, 4, true ) {
	switch ( tag ) {
		case e_nullErrorCorrection:
		case e_longInterleaver:
		case e_shortInterleaver:
		case e_errorCorrectionOnly:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

NewATMVCIndication_aal_aal1_errorCorrection :: NewATMVCIndication_aal_aal1_errorCorrection ( ) : Asn :: Choice ( 4, true ) { }

void NewATMVCIndication_aal_aal1_errorCorrection :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nullErrorCorrection:
		case e_longInterleaver:
		case e_shortInterleaver:
		case e_errorCorrectionOnly:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & NewATMVCIndication_aal_aal1_errorCorrection :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nullErrorCorrection, "nullErrorCorrection" },
		{ e_longInterleaver, "longInterleaver" },
		{ e_shortInterleaver, "shortInterleaver" },
		{ e_errorCorrectionOnly, "errorCorrectionOnly" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

NewATMVCIndication_aal_aal1_errorCorrection * NewATMVCIndication_aal_aal1_errorCorrection :: clone ( ) const {
	return new NewATMVCIndication_aal_aal1_errorCorrection ( * this );
}

//
// NewATMVCIndication_aal_aal5_forwardMaximumSDUSize
//

NewATMVCIndication_aal_aal5_forwardMaximumSDUSize :: NewATMVCIndication_aal_aal5_forwardMaximumSDUSize ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

NewATMVCIndication_aal_aal5_forwardMaximumSDUSize :: NewATMVCIndication_aal_aal5_forwardMaximumSDUSize ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

NewATMVCIndication_aal_aal5_forwardMaximumSDUSize * NewATMVCIndication_aal_aal5_forwardMaximumSDUSize :: clone ( ) const {
	return new NewATMVCIndication_aal_aal5_forwardMaximumSDUSize ( * this );
}

//
// NewATMVCIndication_aal_aal5_backwardMaximumSDUSize
//

NewATMVCIndication_aal_aal5_backwardMaximumSDUSize :: NewATMVCIndication_aal_aal5_backwardMaximumSDUSize ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 65535 ) { }

NewATMVCIndication_aal_aal5_backwardMaximumSDUSize :: NewATMVCIndication_aal_aal5_backwardMaximumSDUSize ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 65535 ) { }

NewATMVCIndication_aal_aal5_backwardMaximumSDUSize * NewATMVCIndication_aal_aal5_backwardMaximumSDUSize :: clone ( ) const {
	return new NewATMVCIndication_aal_aal5_backwardMaximumSDUSize ( * this );
}

//
// UserInputIndication_signal_rtp_timestamp
//

UserInputIndication_signal_rtp_timestamp :: UserInputIndication_signal_rtp_timestamp ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 4294967295U ) { }

UserInputIndication_signal_rtp_timestamp :: UserInputIndication_signal_rtp_timestamp ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 4294967295U ) { }

UserInputIndication_signal_rtp_timestamp * UserInputIndication_signal_rtp_timestamp :: clone ( ) const {
	return new UserInputIndication_signal_rtp_timestamp ( * this );
}

//
// UserInputIndication_signal_rtp_expirationTime
//

UserInputIndication_signal_rtp_expirationTime :: UserInputIndication_signal_rtp_expirationTime ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 4294967295U ) { }

UserInputIndication_signal_rtp_expirationTime :: UserInputIndication_signal_rtp_expirationTime ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 4294967295U ) { }

UserInputIndication_signal_rtp_expirationTime * UserInputIndication_signal_rtp_expirationTime :: clone ( ) const {
	return new UserInputIndication_signal_rtp_expirationTime ( * this );
}

//
// VCCapability_availableBitRates_type_rangeOfBitRates_lowerBitRate
//

VCCapability_availableBitRates_type_rangeOfBitRates_lowerBitRate :: VCCapability_availableBitRates_type_rangeOfBitRates_lowerBitRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 65535 ) { }

VCCapability_availableBitRates_type_rangeOfBitRates_lowerBitRate :: VCCapability_availableBitRates_type_rangeOfBitRates_lowerBitRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 65535 ) { }

VCCapability_availableBitRates_type_rangeOfBitRates_lowerBitRate * VCCapability_availableBitRates_type_rangeOfBitRates_lowerBitRate :: clone ( ) const {
	return new VCCapability_availableBitRates_type_rangeOfBitRates_lowerBitRate ( * this );
}

//
// VCCapability_availableBitRates_type_rangeOfBitRates_higherBitRate
//

VCCapability_availableBitRates_type_rangeOfBitRates_higherBitRate :: VCCapability_availableBitRates_type_rangeOfBitRates_higherBitRate ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 65535 ) { }

VCCapability_availableBitRates_type_rangeOfBitRates_higherBitRate :: VCCapability_availableBitRates_type_rangeOfBitRates_higherBitRate ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 65535 ) { }

VCCapability_availableBitRates_type_rangeOfBitRates_higherBitRate * VCCapability_availableBitRates_type_rangeOfBitRates_higherBitRate :: clone ( ) const {
	return new VCCapability_availableBitRates_type_rangeOfBitRates_higherBitRate ( * this );
}

//
// CustomPictureFormat_mPI_customPCF_subtype_clockConversionCode
//

CustomPictureFormat_mPI_customPCF_subtype_clockConversionCode :: CustomPictureFormat_mPI_customPCF_subtype_clockConversionCode ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1000, 1001 ) { }

CustomPictureFormat_mPI_customPCF_subtype_clockConversionCode :: CustomPictureFormat_mPI_customPCF_subtype_clockConversionCode ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1000, 1001 ) { }

CustomPictureFormat_mPI_customPCF_subtype_clockConversionCode * CustomPictureFormat_mPI_customPCF_subtype_clockConversionCode :: clone ( ) const {
	return new CustomPictureFormat_mPI_customPCF_subtype_clockConversionCode ( * this );
}

//
// CustomPictureFormat_mPI_customPCF_subtype_clockDivisor
//

CustomPictureFormat_mPI_customPCF_subtype_clockDivisor :: CustomPictureFormat_mPI_customPCF_subtype_clockDivisor ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 127 ) { }

CustomPictureFormat_mPI_customPCF_subtype_clockDivisor :: CustomPictureFormat_mPI_customPCF_subtype_clockDivisor ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 127 ) { }

CustomPictureFormat_mPI_customPCF_subtype_clockDivisor * CustomPictureFormat_mPI_customPCF_subtype_clockDivisor :: clone ( ) const {
	return new CustomPictureFormat_mPI_customPCF_subtype_clockDivisor ( * this );
}

//
// CustomPictureFormat_mPI_customPCF_subtype_customMPI
//

CustomPictureFormat_mPI_customPCF_subtype_customMPI :: CustomPictureFormat_mPI_customPCF_subtype_customMPI ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 2048 ) { }

CustomPictureFormat_mPI_customPCF_subtype_customMPI :: CustomPictureFormat_mPI_customPCF_subtype_customMPI ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 2048 ) { }

CustomPictureFormat_mPI_customPCF_subtype_customMPI * CustomPictureFormat_mPI_customPCF_subtype_customMPI :: clone ( ) const {
	return new CustomPictureFormat_mPI_customPCF_subtype_customMPI ( * this );
}

//
// CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype_width
//

CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype_width :: CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype_width ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 255 ) { }

CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype_width :: CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype_width ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 255 ) { }

CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype_width * CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype_width :: clone ( ) const {
	return new CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype_width ( * this );
}

//
// CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype_height
//

CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype_height :: CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype_height ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 255 ) { }

CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype_height :: CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype_height ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 255 ) { }

CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype_height * CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype_height :: clone ( ) const {
	return new CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype_height ( * this );
}

//
// DepFECData_rfc2733_mode_separateStream_differentPort_protectedSessionID
//

DepFECData_rfc2733_mode_separateStream_differentPort_protectedSessionID :: DepFECData_rfc2733_mode_separateStream_differentPort_protectedSessionID ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 255 ) { }

DepFECData_rfc2733_mode_separateStream_differentPort_protectedSessionID :: DepFECData_rfc2733_mode_separateStream_differentPort_protectedSessionID ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 255 ) { }

DepFECData_rfc2733_mode_separateStream_differentPort_protectedSessionID * DepFECData_rfc2733_mode_separateStream_differentPort_protectedSessionID :: clone ( ) const {
	return new DepFECData_rfc2733_mode_separateStream_differentPort_protectedSessionID ( * this );
}

//
// DepFECData_rfc2733_mode_separateStream_differentPort_protectedPayloadType
//

DepFECData_rfc2733_mode_separateStream_differentPort_protectedPayloadType :: DepFECData_rfc2733_mode_separateStream_differentPort_protectedPayloadType ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 127 ) { }

DepFECData_rfc2733_mode_separateStream_differentPort_protectedPayloadType :: DepFECData_rfc2733_mode_separateStream_differentPort_protectedPayloadType ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 127 ) { }

DepFECData_rfc2733_mode_separateStream_differentPort_protectedPayloadType * DepFECData_rfc2733_mode_separateStream_differentPort_protectedPayloadType :: clone ( ) const {
	return new DepFECData_rfc2733_mode_separateStream_differentPort_protectedPayloadType ( * this );
}

//
// DepFECData_rfc2733_mode_separateStream_samePort_protectedPayloadType
//

DepFECData_rfc2733_mode_separateStream_samePort_protectedPayloadType :: DepFECData_rfc2733_mode_separateStream_samePort_protectedPayloadType ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 127 ) { }

DepFECData_rfc2733_mode_separateStream_samePort_protectedPayloadType :: DepFECData_rfc2733_mode_separateStream_samePort_protectedPayloadType ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 127 ) { }

DepFECData_rfc2733_mode_separateStream_samePort_protectedPayloadType * DepFECData_rfc2733_mode_separateStream_samePort_protectedPayloadType :: clone ( ) const {
	return new DepFECData_rfc2733_mode_separateStream_samePort_protectedPayloadType ( * this );
}

//
// DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedSessionID
//

DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedSessionID :: DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedSessionID ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 1, 255 ) { }

DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedSessionID :: DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedSessionID ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 1, 255 ) { }

DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedSessionID * DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedSessionID :: clone ( ) const {
	return new DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedSessionID ( * this );
}

//
// DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedPayloadType
//

DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedPayloadType :: DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedPayloadType ( Asn :: istream & is ) : Asn :: Integer ( is, Asn :: fixedConstraint, 0, 127 ) { }

DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedPayloadType :: DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedPayloadType ( unsigned v ) : Asn :: Integer ( v, Asn :: fixedConstraint, 0, 127 ) { }

DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedPayloadType * DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedPayloadType :: clone ( ) const {
	return new DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedPayloadType ( * this );
}

//
// MasterSlaveDetermination
//

MasterSlaveDetermination :: MasterSlaveDetermination ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_terminalType ( is ), m_statusDeterminationNumber ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MasterSlaveDetermination :: MasterSlaveDetermination ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MasterSlaveDetermination :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_terminalType.encode ( os );
	m_statusDeterminationNumber.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MasterSlaveDetermination :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 15 ) << "terminalType = " << std :: setprecision ( indent ) << m_terminalType << '\n';
	os << std :: setw ( indent + 28 ) << "statusDeterminationNumber = " << std :: setprecision ( indent ) << m_statusDeterminationNumber << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MasterSlaveDetermination * MasterSlaveDetermination :: clone ( ) const {
	return new MasterSlaveDetermination ( * this );
}

//
// MasterSlaveDeterminationAck
//

MasterSlaveDeterminationAck :: MasterSlaveDeterminationAck ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_decision ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MasterSlaveDeterminationAck :: MasterSlaveDeterminationAck ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MasterSlaveDeterminationAck :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_decision.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MasterSlaveDeterminationAck :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 11 ) << "decision = " << std :: setprecision ( indent ) << m_decision << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MasterSlaveDeterminationAck * MasterSlaveDeterminationAck :: clone ( ) const {
	return new MasterSlaveDeterminationAck ( * this );
}

//
// MasterSlaveDeterminationReject
//

MasterSlaveDeterminationReject :: MasterSlaveDeterminationReject ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_cause ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MasterSlaveDeterminationReject :: MasterSlaveDeterminationReject ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MasterSlaveDeterminationReject :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_cause.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MasterSlaveDeterminationReject :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 8 ) << "cause = " << std :: setprecision ( indent ) << m_cause << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MasterSlaveDeterminationReject * MasterSlaveDeterminationReject :: clone ( ) const {
	return new MasterSlaveDeterminationReject ( * this );
}

//
// CapabilityTableEntry
//

CapabilityTableEntry :: CapabilityTableEntry ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, false, 0 ), m_capabilityTableEntryNumber ( is ), m_capability ( 0 ) {
	if ( hasOptionalField ( e_capability ) )
		m_capability = new Capability ( is );
}

CapabilityTableEntry :: CapabilityTableEntry ( ) : Asn :: Sequence ( 1, false, 0 ), m_capability ( 0 ) { }

CapabilityTableEntry & CapabilityTableEntry :: operator= ( const CapabilityTableEntry & s ) {
	Asn :: Sequence :: operator= ( s );
	m_capabilityTableEntryNumber = s.m_capabilityTableEntryNumber;
	assignCopy ( m_capability, s.m_capability );
	return * this;
}

CapabilityTableEntry :: CapabilityTableEntry ( const CapabilityTableEntry & s ) : Asn :: Sequence ( s ), m_capabilityTableEntryNumber ( s.m_capabilityTableEntryNumber ), m_capability ( 0 ) {
	try {
		if ( s.m_capability )
			m_capability = new Capability ( * s.m_capability );
	} catch ( ... ) {
		delete m_capability;
		throw;
	}
}


void CapabilityTableEntry :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_capability:
			assignNew ( m_capability, new Capability );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void CapabilityTableEntry :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_capability:
			delete m_capability;
			m_capability = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void CapabilityTableEntry :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_capabilityTableEntryNumber.encode ( os );
	if ( hasOptionalField ( e_capability ) )
		m_capability -> Capability :: encode ( os );
}

CapabilityTableEntry :: ~CapabilityTableEntry ( ) {
	delete m_capability;
}

void CapabilityTableEntry :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 29 ) << "capabilityTableEntryNumber = " << std :: setprecision ( indent ) << m_capabilityTableEntryNumber << '\n';
	if ( hasOptionalField ( e_capability ) ) {
		os << std :: setw ( indent + 13 ) << "capability = " << std :: setprecision ( indent );
		m_capability -> Capability :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent - 1 ) << '}';
}

CapabilityTableEntry * CapabilityTableEntry :: clone ( ) const {
	return new CapabilityTableEntry ( * this );
}

//
// CapabilityDescriptor
//

CapabilityDescriptor :: CapabilityDescriptor ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, false, 0 ), m_capabilityDescriptorNumber ( is ), m_simultaneousCapabilities ( 0 ) {
	if ( hasOptionalField ( e_simultaneousCapabilities ) )
		m_simultaneousCapabilities = new CapabilityDescriptor_simultaneousCapabilities ( is );
}

CapabilityDescriptor :: CapabilityDescriptor ( ) : Asn :: Sequence ( 1, false, 0 ), m_simultaneousCapabilities ( 0 ) { }

CapabilityDescriptor & CapabilityDescriptor :: operator= ( const CapabilityDescriptor & s ) {
	Asn :: Sequence :: operator= ( s );
	m_capabilityDescriptorNumber = s.m_capabilityDescriptorNumber;
	assignCopy ( m_simultaneousCapabilities, s.m_simultaneousCapabilities );
	return * this;
}

CapabilityDescriptor :: CapabilityDescriptor ( const CapabilityDescriptor & s ) : Asn :: Sequence ( s ), m_capabilityDescriptorNumber ( s.m_capabilityDescriptorNumber ), m_simultaneousCapabilities ( 0 ) {
	try {
		if ( s.m_simultaneousCapabilities )
			m_simultaneousCapabilities = new CapabilityDescriptor_simultaneousCapabilities ( * s.m_simultaneousCapabilities );
	} catch ( ... ) {
		delete m_simultaneousCapabilities;
		throw;
	}
}


void CapabilityDescriptor :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_simultaneousCapabilities:
			assignNew ( m_simultaneousCapabilities, new CapabilityDescriptor_simultaneousCapabilities );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void CapabilityDescriptor :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_simultaneousCapabilities:
			delete m_simultaneousCapabilities;
			m_simultaneousCapabilities = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void CapabilityDescriptor :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_capabilityDescriptorNumber.encode ( os );
	if ( hasOptionalField ( e_simultaneousCapabilities ) )
		m_simultaneousCapabilities -> CapabilityDescriptor_simultaneousCapabilities :: encode ( os );
}

CapabilityDescriptor :: ~CapabilityDescriptor ( ) {
	delete m_simultaneousCapabilities;
}

void CapabilityDescriptor :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 29 ) << "capabilityDescriptorNumber = " << std :: setprecision ( indent ) << m_capabilityDescriptorNumber << '\n';
	if ( hasOptionalField ( e_simultaneousCapabilities ) ) {
		os << std :: setw ( indent + 27 ) << "simultaneousCapabilities = " << std :: setprecision ( indent );
		m_simultaneousCapabilities -> CapabilityDescriptor_simultaneousCapabilities :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent - 1 ) << '}';
}

CapabilityDescriptor * CapabilityDescriptor :: clone ( ) const {
	return new CapabilityDescriptor ( * this );
}

//
// H235SecurityCapability
//

H235SecurityCapability :: H235SecurityCapability ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_encryptionAuthenticationAndIntegrity ( is ), m_mediaCapability ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

H235SecurityCapability :: H235SecurityCapability ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void H235SecurityCapability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_encryptionAuthenticationAndIntegrity.encode ( os );
	m_mediaCapability.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void H235SecurityCapability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 39 ) << "encryptionAuthenticationAndIntegrity = " << std :: setprecision ( indent ) << m_encryptionAuthenticationAndIntegrity << '\n';
	os << std :: setw ( indent + 18 ) << "mediaCapability = " << std :: setprecision ( indent ) << m_mediaCapability << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H235SecurityCapability * H235SecurityCapability :: clone ( ) const {
	return new H235SecurityCapability ( * this );
}

//
// H222Capability
//

H222Capability :: H222Capability ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_numberOfVCs ( is ), m_vcCapability ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

H222Capability :: H222Capability ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void H222Capability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_numberOfVCs.encode ( os );
	m_vcCapability.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void H222Capability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 14 ) << "numberOfVCs = " << std :: setprecision ( indent ) << m_numberOfVCs << '\n';
	os << std :: setw ( indent + 15 ) << "vcCapability = " << std :: setprecision ( indent ) << m_vcCapability << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H222Capability * H222Capability :: clone ( ) const {
	return new H222Capability ( * this );
}

//
// H223AnnexCCapability
//

H223AnnexCCapability :: H223AnnexCCapability ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 1 ), m_videoWithAL1M ( is ), m_videoWithAL2M ( is ), m_videoWithAL3M ( is ), m_audioWithAL1M ( is ), m_audioWithAL2M ( is ), m_audioWithAL3M ( is ), m_dataWithAL1M ( is ), m_dataWithAL2M ( is ), m_dataWithAL3M ( is ), m_alpduInterleaving ( is ), m_maximumAL1MPDUSize ( is ), m_maximumAL2MSDUSize ( is ), m_maximumAL3MSDUSize ( is ), m_rsCodeCapability ( 0 ) {
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_rsCodeCapability ) )
				m_rsCodeCapability = new Asn :: Boolean ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_rsCodeCapability;
		throw;
	}
}

H223AnnexCCapability :: H223AnnexCCapability ( ) : Asn :: Sequence ( 0, true, 1 ), m_rsCodeCapability ( 0 ) { }

H223AnnexCCapability & H223AnnexCCapability :: operator= ( const H223AnnexCCapability & s ) {
	Asn :: Sequence :: operator= ( s );
	m_videoWithAL1M = s.m_videoWithAL1M;
	m_videoWithAL2M = s.m_videoWithAL2M;
	m_videoWithAL3M = s.m_videoWithAL3M;
	m_audioWithAL1M = s.m_audioWithAL1M;
	m_audioWithAL2M = s.m_audioWithAL2M;
	m_audioWithAL3M = s.m_audioWithAL3M;
	m_dataWithAL1M = s.m_dataWithAL1M;
	m_dataWithAL2M = s.m_dataWithAL2M;
	m_dataWithAL3M = s.m_dataWithAL3M;
	m_alpduInterleaving = s.m_alpduInterleaving;
	m_maximumAL1MPDUSize = s.m_maximumAL1MPDUSize;
	m_maximumAL2MSDUSize = s.m_maximumAL2MSDUSize;
	m_maximumAL3MSDUSize = s.m_maximumAL3MSDUSize;
	assignCopy ( m_rsCodeCapability, s.m_rsCodeCapability );
	return * this;
}

H223AnnexCCapability :: H223AnnexCCapability ( const H223AnnexCCapability & s ) : Asn :: Sequence ( s ), m_videoWithAL1M ( s.m_videoWithAL1M ), m_videoWithAL2M ( s.m_videoWithAL2M ), m_videoWithAL3M ( s.m_videoWithAL3M ), m_audioWithAL1M ( s.m_audioWithAL1M ), m_audioWithAL2M ( s.m_audioWithAL2M ), m_audioWithAL3M ( s.m_audioWithAL3M ), m_dataWithAL1M ( s.m_dataWithAL1M ), m_dataWithAL2M ( s.m_dataWithAL2M ), m_dataWithAL3M ( s.m_dataWithAL3M ), m_alpduInterleaving ( s.m_alpduInterleaving ), m_maximumAL1MPDUSize ( s.m_maximumAL1MPDUSize ), m_maximumAL2MSDUSize ( s.m_maximumAL2MSDUSize ), m_maximumAL3MSDUSize ( s.m_maximumAL3MSDUSize ), m_rsCodeCapability ( 0 ) {
	try {
		if ( s.m_rsCodeCapability )
			m_rsCodeCapability = new Asn :: Boolean ( * s.m_rsCodeCapability );
	} catch ( ... ) {
		delete m_rsCodeCapability;
		throw;
	}
}


void H223AnnexCCapability :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_rsCodeCapability:
			assignNew ( m_rsCodeCapability, new Asn :: Boolean );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void H223AnnexCCapability :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_rsCodeCapability:
			delete m_rsCodeCapability;
			m_rsCodeCapability = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void H223AnnexCCapability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_videoWithAL1M.encode ( os );
	m_videoWithAL2M.encode ( os );
	m_videoWithAL3M.encode ( os );
	m_audioWithAL1M.encode ( os );
	m_audioWithAL2M.encode ( os );
	m_audioWithAL3M.encode ( os );
	m_dataWithAL1M.encode ( os );
	m_dataWithAL2M.encode ( os );
	m_dataWithAL3M.encode ( os );
	m_alpduInterleaving.encode ( os );
	m_maximumAL1MPDUSize.encode ( os );
	m_maximumAL2MSDUSize.encode ( os );
	m_maximumAL3MSDUSize.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_rsCodeCapability, m_rsCodeCapability );
		unknownExtensionsEncode ( os );
	}
}

H223AnnexCCapability :: ~H223AnnexCCapability ( ) {
	delete m_rsCodeCapability;
}

void H223AnnexCCapability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "videoWithAL1M = " << std :: setprecision ( indent ) << m_videoWithAL1M << '\n';
	os << std :: setw ( indent + 16 ) << "videoWithAL2M = " << std :: setprecision ( indent ) << m_videoWithAL2M << '\n';
	os << std :: setw ( indent + 16 ) << "videoWithAL3M = " << std :: setprecision ( indent ) << m_videoWithAL3M << '\n';
	os << std :: setw ( indent + 16 ) << "audioWithAL1M = " << std :: setprecision ( indent ) << m_audioWithAL1M << '\n';
	os << std :: setw ( indent + 16 ) << "audioWithAL2M = " << std :: setprecision ( indent ) << m_audioWithAL2M << '\n';
	os << std :: setw ( indent + 16 ) << "audioWithAL3M = " << std :: setprecision ( indent ) << m_audioWithAL3M << '\n';
	os << std :: setw ( indent + 15 ) << "dataWithAL1M = " << std :: setprecision ( indent ) << m_dataWithAL1M << '\n';
	os << std :: setw ( indent + 15 ) << "dataWithAL2M = " << std :: setprecision ( indent ) << m_dataWithAL2M << '\n';
	os << std :: setw ( indent + 15 ) << "dataWithAL3M = " << std :: setprecision ( indent ) << m_dataWithAL3M << '\n';
	os << std :: setw ( indent + 20 ) << "alpduInterleaving = " << std :: setprecision ( indent ) << m_alpduInterleaving << '\n';
	os << std :: setw ( indent + 21 ) << "maximumAL1MPDUSize = " << std :: setprecision ( indent ) << m_maximumAL1MPDUSize << '\n';
	os << std :: setw ( indent + 21 ) << "maximumAL2MSDUSize = " << std :: setprecision ( indent ) << m_maximumAL2MSDUSize << '\n';
	os << std :: setw ( indent + 21 ) << "maximumAL3MSDUSize = " << std :: setprecision ( indent ) << m_maximumAL3MSDUSize << '\n';
	if ( hasOptionalField ( e_rsCodeCapability ) ) {
		os << std :: setw ( indent + 19 ) << "rsCodeCapability = " << std :: setprecision ( indent );
		m_rsCodeCapability -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H223AnnexCCapability * H223AnnexCCapability :: clone ( ) const {
	return new H223AnnexCCapability ( * this );
}

//
// V76Capability
//

V76Capability :: V76Capability ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_suspendResumeCapabilitywAddress ( is ), m_suspendResumeCapabilitywoAddress ( is ), m_rejCapability ( is ), m_sREJCapability ( is ), m_mREJCapability ( is ), m_crc8bitCapability ( is ), m_crc16bitCapability ( is ), m_crc32bitCapability ( is ), m_uihCapability ( is ), m_numOfDLCS ( is ), m_twoOctetAddressFieldCapability ( is ), m_loopBackTestCapability ( is ), m_n401Capability ( is ), m_maxWindowSizeCapability ( is ), m_v75Capability ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

V76Capability :: V76Capability ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void V76Capability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_suspendResumeCapabilitywAddress.encode ( os );
	m_suspendResumeCapabilitywoAddress.encode ( os );
	m_rejCapability.encode ( os );
	m_sREJCapability.encode ( os );
	m_mREJCapability.encode ( os );
	m_crc8bitCapability.encode ( os );
	m_crc16bitCapability.encode ( os );
	m_crc32bitCapability.encode ( os );
	m_uihCapability.encode ( os );
	m_numOfDLCS.encode ( os );
	m_twoOctetAddressFieldCapability.encode ( os );
	m_loopBackTestCapability.encode ( os );
	m_n401Capability.encode ( os );
	m_maxWindowSizeCapability.encode ( os );
	m_v75Capability.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void V76Capability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 34 ) << "suspendResumeCapabilitywAddress = " << std :: setprecision ( indent ) << m_suspendResumeCapabilitywAddress << '\n';
	os << std :: setw ( indent + 35 ) << "suspendResumeCapabilitywoAddress = " << std :: setprecision ( indent ) << m_suspendResumeCapabilitywoAddress << '\n';
	os << std :: setw ( indent + 16 ) << "rejCapability = " << std :: setprecision ( indent ) << m_rejCapability << '\n';
	os << std :: setw ( indent + 17 ) << "sREJCapability = " << std :: setprecision ( indent ) << m_sREJCapability << '\n';
	os << std :: setw ( indent + 17 ) << "mREJCapability = " << std :: setprecision ( indent ) << m_mREJCapability << '\n';
	os << std :: setw ( indent + 20 ) << "crc8bitCapability = " << std :: setprecision ( indent ) << m_crc8bitCapability << '\n';
	os << std :: setw ( indent + 21 ) << "crc16bitCapability = " << std :: setprecision ( indent ) << m_crc16bitCapability << '\n';
	os << std :: setw ( indent + 21 ) << "crc32bitCapability = " << std :: setprecision ( indent ) << m_crc32bitCapability << '\n';
	os << std :: setw ( indent + 16 ) << "uihCapability = " << std :: setprecision ( indent ) << m_uihCapability << '\n';
	os << std :: setw ( indent + 12 ) << "numOfDLCS = " << std :: setprecision ( indent ) << m_numOfDLCS << '\n';
	os << std :: setw ( indent + 33 ) << "twoOctetAddressFieldCapability = " << std :: setprecision ( indent ) << m_twoOctetAddressFieldCapability << '\n';
	os << std :: setw ( indent + 25 ) << "loopBackTestCapability = " << std :: setprecision ( indent ) << m_loopBackTestCapability << '\n';
	os << std :: setw ( indent + 17 ) << "n401Capability = " << std :: setprecision ( indent ) << m_n401Capability << '\n';
	os << std :: setw ( indent + 26 ) << "maxWindowSizeCapability = " << std :: setprecision ( indent ) << m_maxWindowSizeCapability << '\n';
	os << std :: setw ( indent + 16 ) << "v75Capability = " << std :: setprecision ( indent ) << m_v75Capability << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

V76Capability * V76Capability :: clone ( ) const {
	return new V76Capability ( * this );
}

//
// ATMParameters
//

ATMParameters :: ATMParameters ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_maxNTUSize ( is ), m_atmUBR ( is ), m_atmrtVBR ( is ), m_atmnrtVBR ( is ), m_atmABR ( is ), m_atmCBR ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

ATMParameters :: ATMParameters ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void ATMParameters :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_maxNTUSize.encode ( os );
	m_atmUBR.encode ( os );
	m_atmrtVBR.encode ( os );
	m_atmnrtVBR.encode ( os );
	m_atmABR.encode ( os );
	m_atmCBR.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void ATMParameters :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 13 ) << "maxNTUSize = " << std :: setprecision ( indent ) << m_maxNTUSize << '\n';
	os << std :: setw ( indent + 9 ) << "atmUBR = " << std :: setprecision ( indent ) << m_atmUBR << '\n';
	os << std :: setw ( indent + 11 ) << "atmrtVBR = " << std :: setprecision ( indent ) << m_atmrtVBR << '\n';
	os << std :: setw ( indent + 12 ) << "atmnrtVBR = " << std :: setprecision ( indent ) << m_atmnrtVBR << '\n';
	os << std :: setw ( indent + 9 ) << "atmABR = " << std :: setprecision ( indent ) << m_atmABR << '\n';
	os << std :: setw ( indent + 9 ) << "atmCBR = " << std :: setprecision ( indent ) << m_atmCBR << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

ATMParameters * ATMParameters :: clone ( ) const {
	return new ATMParameters ( * this );
}

//
// MediaTransportType
//

MediaTransportType :: MediaTransportType ( Asn :: istream & is ) : Asn :: Choice ( is, 4, true ) {
	switch ( tag ) {
		case e_ip_UDP:
		case e_ip_TCP:
		case e_atm_AAL5_UNIDIR:
		case e_atm_AAL5_BIDIR:
			choice = new Asn :: Null ( is );
			break;
		case e_atm_AAL5_compressed:
			choice = new MediaTransportType_atm_AAL5_compressed ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

MediaTransportType :: MediaTransportType ( ) : Asn :: Choice ( 4, true ) { }

void MediaTransportType :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_ip_UDP:
		case e_ip_TCP:
		case e_atm_AAL5_UNIDIR:
		case e_atm_AAL5_BIDIR:
			o = new Asn :: Null;
			break;
		case e_atm_AAL5_compressed:
			o = new MediaTransportType_atm_AAL5_compressed;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & MediaTransportType :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_ip_UDP, "ip_UDP" },
		{ e_ip_TCP, "ip_TCP" },
		{ e_atm_AAL5_UNIDIR, "atm_AAL5_UNIDIR" },
		{ e_atm_AAL5_BIDIR, "atm_AAL5_BIDIR" },
		{ e_atm_AAL5_compressed, "atm_AAL5_compressed" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

MediaTransportType * MediaTransportType :: clone ( ) const {
	return new MediaTransportType ( * this );
}

//
// RTPH263VideoRedundancyFrameMapping
//

RTPH263VideoRedundancyFrameMapping :: RTPH263VideoRedundancyFrameMapping ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_threadNumber ( is ), m_frameSequence ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

RTPH263VideoRedundancyFrameMapping :: RTPH263VideoRedundancyFrameMapping ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void RTPH263VideoRedundancyFrameMapping :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_threadNumber.encode ( os );
	m_frameSequence.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void RTPH263VideoRedundancyFrameMapping :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 15 ) << "threadNumber = " << std :: setprecision ( indent ) << m_threadNumber << '\n';
	os << std :: setw ( indent + 16 ) << "frameSequence = " << std :: setprecision ( indent ) << m_frameSequence << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RTPH263VideoRedundancyFrameMapping * RTPH263VideoRedundancyFrameMapping :: clone ( ) const {
	return new RTPH263VideoRedundancyFrameMapping ( * this );
}

//
// MultipointCapability
//

MultipointCapability :: MultipointCapability ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_multicastCapability ( is ), m_multiUniCastConference ( is ), m_mediaDistributionCapability ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MultipointCapability :: MultipointCapability ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MultipointCapability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_multicastCapability.encode ( os );
	m_multiUniCastConference.encode ( os );
	m_mediaDistributionCapability.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MultipointCapability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 22 ) << "multicastCapability = " << std :: setprecision ( indent ) << m_multicastCapability << '\n';
	os << std :: setw ( indent + 25 ) << "multiUniCastConference = " << std :: setprecision ( indent ) << m_multiUniCastConference << '\n';
	os << std :: setw ( indent + 30 ) << "mediaDistributionCapability = " << std :: setprecision ( indent ) << m_mediaDistributionCapability << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MultipointCapability * MultipointCapability :: clone ( ) const {
	return new MultipointCapability ( * this );
}

//
// ExtendedVideoCapability
//

ExtendedVideoCapability :: ExtendedVideoCapability ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_videoCapability ( is ), m_videoCapabilityExtension ( 0 ) {
	try {
		if ( hasOptionalField ( e_videoCapabilityExtension ) )
			m_videoCapabilityExtension = new ArrayOf_GenericCapability ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_videoCapabilityExtension;
		throw;
	}
}

ExtendedVideoCapability :: ExtendedVideoCapability ( ) : Asn :: Sequence ( 1, true, 0 ), m_videoCapabilityExtension ( 0 ) { }

ExtendedVideoCapability & ExtendedVideoCapability :: operator= ( const ExtendedVideoCapability & s ) {
	Asn :: Sequence :: operator= ( s );
	m_videoCapability = s.m_videoCapability;
	assignCopy ( m_videoCapabilityExtension, s.m_videoCapabilityExtension );
	return * this;
}

ExtendedVideoCapability :: ExtendedVideoCapability ( const ExtendedVideoCapability & s ) : Asn :: Sequence ( s ), m_videoCapability ( s.m_videoCapability ), m_videoCapabilityExtension ( 0 ) {
	try {
		if ( s.m_videoCapabilityExtension )
			m_videoCapabilityExtension = new ArrayOf_GenericCapability ( * s.m_videoCapabilityExtension );
	} catch ( ... ) {
		delete m_videoCapabilityExtension;
		throw;
	}
}


void ExtendedVideoCapability :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_videoCapabilityExtension:
			assignNew ( m_videoCapabilityExtension, new ArrayOf_GenericCapability );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void ExtendedVideoCapability :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_videoCapabilityExtension:
			delete m_videoCapabilityExtension;
			m_videoCapabilityExtension = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void ExtendedVideoCapability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_videoCapability.encode ( os );
	if ( hasOptionalField ( e_videoCapabilityExtension ) )
		m_videoCapabilityExtension -> ArrayOf_GenericCapability :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

ExtendedVideoCapability :: ~ExtendedVideoCapability ( ) {
	delete m_videoCapabilityExtension;
}

void ExtendedVideoCapability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 18 ) << "videoCapability = " << std :: setprecision ( indent ) << m_videoCapability << '\n';
	if ( hasOptionalField ( e_videoCapabilityExtension ) ) {
		os << std :: setw ( indent + 27 ) << "videoCapabilityExtension = " << std :: setprecision ( indent );
		m_videoCapabilityExtension -> ArrayOf_GenericCapability :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

ExtendedVideoCapability * ExtendedVideoCapability :: clone ( ) const {
	return new ExtendedVideoCapability ( * this );
}

//
// H261VideoCapability
//

H261VideoCapability :: H261VideoCapability ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 1 ), m_qcifMPI ( hasOptionalField ( e_qcifMPI ) ? pushTemporaryMember ( new H261VideoCapability_qcifMPI ( is ) ) : 0 ), m_cifMPI ( hasOptionalField ( e_cifMPI ) ? pushTemporaryMember ( new H261VideoCapability_cifMPI ( is ) ) : 0 ), m_temporalSpatialTradeOffCapability ( is ), m_maxBitRate ( is ), m_stillImageTransmission ( is ), m_videoBadMBsCap ( 0 ) {
	clearTemporaryMembers ( );
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_videoBadMBsCap ) )
				m_videoBadMBsCap = new Asn :: Boolean ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_qcifMPI;
		delete m_cifMPI;
		delete m_videoBadMBsCap;
		throw;
	}
}

H261VideoCapability :: H261VideoCapability ( ) : Asn :: Sequence ( 2, true, 1 ), m_qcifMPI ( 0 ), m_cifMPI ( 0 ), m_videoBadMBsCap ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_videoBadMBsCap );
		m_videoBadMBsCap = new Asn :: Boolean;
	} catch ( ... ) {
		delete m_videoBadMBsCap;
		throw;
	}
}

H261VideoCapability & H261VideoCapability :: operator= ( const H261VideoCapability & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_qcifMPI, s.m_qcifMPI );
	assignCopy ( m_cifMPI, s.m_cifMPI );
	m_temporalSpatialTradeOffCapability = s.m_temporalSpatialTradeOffCapability;
	m_maxBitRate = s.m_maxBitRate;
	m_stillImageTransmission = s.m_stillImageTransmission;
	assignCopy ( m_videoBadMBsCap, s.m_videoBadMBsCap );
	return * this;
}

H261VideoCapability :: H261VideoCapability ( const H261VideoCapability & s ) : Asn :: Sequence ( s ), m_qcifMPI ( 0 ), m_cifMPI ( 0 ), m_temporalSpatialTradeOffCapability ( s.m_temporalSpatialTradeOffCapability ), m_maxBitRate ( s.m_maxBitRate ), m_stillImageTransmission ( s.m_stillImageTransmission ), m_videoBadMBsCap ( 0 ) {
	try {
		if ( s.m_qcifMPI )
			m_qcifMPI = new H261VideoCapability_qcifMPI ( * s.m_qcifMPI );
		if ( s.m_cifMPI )
			m_cifMPI = new H261VideoCapability_cifMPI ( * s.m_cifMPI );
		if ( s.m_videoBadMBsCap )
			m_videoBadMBsCap = new Asn :: Boolean ( * s.m_videoBadMBsCap );
	} catch ( ... ) {
		delete m_qcifMPI;
		delete m_cifMPI;
		delete m_videoBadMBsCap;
		throw;
	}
}


void H261VideoCapability :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_qcifMPI:
			assignNew ( m_qcifMPI, new H261VideoCapability_qcifMPI );
			break;
		case e_cifMPI:
			assignNew ( m_cifMPI, new H261VideoCapability_cifMPI );
			break;
		case e_videoBadMBsCap:
			assignNew ( m_videoBadMBsCap, new Asn :: Boolean );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void H261VideoCapability :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_qcifMPI:
			delete m_qcifMPI;
			m_qcifMPI = 0;
			break;
		case e_cifMPI:
			delete m_cifMPI;
			m_cifMPI = 0;
			break;
		case e_videoBadMBsCap:
			delete m_videoBadMBsCap;
			m_videoBadMBsCap = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void H261VideoCapability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_qcifMPI ) )
		m_qcifMPI -> H261VideoCapability_qcifMPI :: encode ( os );
	if ( hasOptionalField ( e_cifMPI ) )
		m_cifMPI -> H261VideoCapability_cifMPI :: encode ( os );
	m_temporalSpatialTradeOffCapability.encode ( os );
	m_maxBitRate.encode ( os );
	m_stillImageTransmission.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_videoBadMBsCap, m_videoBadMBsCap );
		unknownExtensionsEncode ( os );
	}
}

H261VideoCapability :: ~H261VideoCapability ( ) {
	delete m_qcifMPI;
	delete m_cifMPI;
	delete m_videoBadMBsCap;
}

void H261VideoCapability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_qcifMPI ) ) {
		os << std :: setw ( indent + 10 ) << "qcifMPI = " << std :: setprecision ( indent );
		m_qcifMPI -> H261VideoCapability_qcifMPI :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cifMPI ) ) {
		os << std :: setw ( indent + 9 ) << "cifMPI = " << std :: setprecision ( indent );
		m_cifMPI -> H261VideoCapability_cifMPI :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 36 ) << "temporalSpatialTradeOffCapability = " << std :: setprecision ( indent ) << m_temporalSpatialTradeOffCapability << '\n';
	os << std :: setw ( indent + 13 ) << "maxBitRate = " << std :: setprecision ( indent ) << m_maxBitRate << '\n';
	os << std :: setw ( indent + 25 ) << "stillImageTransmission = " << std :: setprecision ( indent ) << m_stillImageTransmission << '\n';
	if ( hasOptionalField ( e_videoBadMBsCap ) ) {
		os << std :: setw ( indent + 17 ) << "videoBadMBsCap = " << std :: setprecision ( indent );
		m_videoBadMBsCap -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H261VideoCapability * H261VideoCapability :: clone ( ) const {
	return new H261VideoCapability ( * this );
}

//
// H263VideoCapability
//

H263VideoCapability :: H263VideoCapability ( Asn :: istream & is ) : Asn :: Sequence ( is, 7, true, 8 ), m_sqcifMPI ( hasOptionalField ( e_sqcifMPI ) ? pushTemporaryMember ( new H263VideoCapability_sqcifMPI ( is ) ) : 0 ), m_qcifMPI ( hasOptionalField ( e_qcifMPI ) ? pushTemporaryMember ( new H263VideoCapability_qcifMPI ( is ) ) : 0 ), m_cifMPI ( hasOptionalField ( e_cifMPI ) ? pushTemporaryMember ( new H263VideoCapability_cifMPI ( is ) ) : 0 ), m_cif4MPI ( hasOptionalField ( e_cif4MPI ) ? pushTemporaryMember ( new H263VideoCapability_cif4MPI ( is ) ) : 0 ), m_cif16MPI ( hasOptionalField ( e_cif16MPI ) ? pushTemporaryMember ( new H263VideoCapability_cif16MPI ( is ) ) : 0 ), m_maxBitRate ( is ), m_unrestrictedVector ( is ), m_arithmeticCoding ( is ), m_advancedPrediction ( is ), m_pbFrames ( is ), m_temporalSpatialTradeOffCapability ( is ), m_hrd_B ( 0 ), m_bppMaxKb ( 0 ), m_slowSqcifMPI ( 0 ), m_slowQcifMPI ( 0 ), m_slowCifMPI ( 0 ), m_slowCif4MPI ( 0 ), m_slowCif16MPI ( 0 ), m_errorCompensation ( 0 ), m_enhancementLayerInfo ( 0 ), m_h263Options ( 0 ) {
	clearTemporaryMembers ( );
	try {
		if ( hasOptionalField ( e_hrd_B ) )
			m_hrd_B = new H263VideoCapability_hrd_B ( is );
		if ( hasOptionalField ( e_bppMaxKb ) )
			m_bppMaxKb = new H263VideoCapability_bppMaxKb ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_slowSqcifMPI ) )
				m_slowSqcifMPI = new H263VideoCapability_slowSqcifMPI ( is );
			if ( hasKnownExtensionToDecode ( is, e_slowQcifMPI ) )
				m_slowQcifMPI = new H263VideoCapability_slowQcifMPI ( is );
			if ( hasKnownExtensionToDecode ( is, e_slowCifMPI ) )
				m_slowCifMPI = new H263VideoCapability_slowCifMPI ( is );
			if ( hasKnownExtensionToDecode ( is, e_slowCif4MPI ) )
				m_slowCif4MPI = new H263VideoCapability_slowCif4MPI ( is );
			if ( hasKnownExtensionToDecode ( is, e_slowCif16MPI ) )
				m_slowCif16MPI = new H263VideoCapability_slowCif16MPI ( is );
			if ( hasKnownExtensionToDecode ( is, e_errorCompensation ) )
				m_errorCompensation = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_enhancementLayerInfo ) )
				m_enhancementLayerInfo = new EnhancementLayerInfo ( is );
			if ( hasKnownExtensionToDecode ( is, e_h263Options ) )
				m_h263Options = new H263Options ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_sqcifMPI;
		delete m_qcifMPI;
		delete m_cifMPI;
		delete m_cif4MPI;
		delete m_cif16MPI;
		delete m_hrd_B;
		delete m_bppMaxKb;
		delete m_slowSqcifMPI;
		delete m_slowQcifMPI;
		delete m_slowCifMPI;
		delete m_slowCif4MPI;
		delete m_slowCif16MPI;
		delete m_errorCompensation;
		delete m_enhancementLayerInfo;
		delete m_h263Options;
		throw;
	}
}

H263VideoCapability :: H263VideoCapability ( ) : Asn :: Sequence ( 7, true, 8 ), m_sqcifMPI ( 0 ), m_qcifMPI ( 0 ), m_cifMPI ( 0 ), m_cif4MPI ( 0 ), m_cif16MPI ( 0 ), m_hrd_B ( 0 ), m_bppMaxKb ( 0 ), m_slowSqcifMPI ( 0 ), m_slowQcifMPI ( 0 ), m_slowCifMPI ( 0 ), m_slowCif4MPI ( 0 ), m_slowCif16MPI ( 0 ), m_errorCompensation ( 0 ), m_enhancementLayerInfo ( 0 ), m_h263Options ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_errorCompensation );
		m_errorCompensation = new Asn :: Boolean;
	} catch ( ... ) {
		delete m_errorCompensation;
		throw;
	}
}

H263VideoCapability & H263VideoCapability :: operator= ( const H263VideoCapability & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_sqcifMPI, s.m_sqcifMPI );
	assignCopy ( m_qcifMPI, s.m_qcifMPI );
	assignCopy ( m_cifMPI, s.m_cifMPI );
	assignCopy ( m_cif4MPI, s.m_cif4MPI );
	assignCopy ( m_cif16MPI, s.m_cif16MPI );
	m_maxBitRate = s.m_maxBitRate;
	m_unrestrictedVector = s.m_unrestrictedVector;
	m_arithmeticCoding = s.m_arithmeticCoding;
	m_advancedPrediction = s.m_advancedPrediction;
	m_pbFrames = s.m_pbFrames;
	m_temporalSpatialTradeOffCapability = s.m_temporalSpatialTradeOffCapability;
	assignCopy ( m_hrd_B, s.m_hrd_B );
	assignCopy ( m_bppMaxKb, s.m_bppMaxKb );
	assignCopy ( m_slowSqcifMPI, s.m_slowSqcifMPI );
	assignCopy ( m_slowQcifMPI, s.m_slowQcifMPI );
	assignCopy ( m_slowCifMPI, s.m_slowCifMPI );
	assignCopy ( m_slowCif4MPI, s.m_slowCif4MPI );
	assignCopy ( m_slowCif16MPI, s.m_slowCif16MPI );
	assignCopy ( m_errorCompensation, s.m_errorCompensation );
	assignCopy ( m_enhancementLayerInfo, s.m_enhancementLayerInfo );
	assignCopy ( m_h263Options, s.m_h263Options );
	return * this;
}

H263VideoCapability :: H263VideoCapability ( const H263VideoCapability & s ) : Asn :: Sequence ( s ), m_sqcifMPI ( 0 ), m_qcifMPI ( 0 ), m_cifMPI ( 0 ), m_cif4MPI ( 0 ), m_cif16MPI ( 0 ), m_maxBitRate ( s.m_maxBitRate ), m_unrestrictedVector ( s.m_unrestrictedVector ), m_arithmeticCoding ( s.m_arithmeticCoding ), m_advancedPrediction ( s.m_advancedPrediction ), m_pbFrames ( s.m_pbFrames ), m_temporalSpatialTradeOffCapability ( s.m_temporalSpatialTradeOffCapability ), m_hrd_B ( 0 ), m_bppMaxKb ( 0 ), m_slowSqcifMPI ( 0 ), m_slowQcifMPI ( 0 ), m_slowCifMPI ( 0 ), m_slowCif4MPI ( 0 ), m_slowCif16MPI ( 0 ), m_errorCompensation ( 0 ), m_enhancementLayerInfo ( 0 ), m_h263Options ( 0 ) {
	try {
		if ( s.m_sqcifMPI )
			m_sqcifMPI = new H263VideoCapability_sqcifMPI ( * s.m_sqcifMPI );
		if ( s.m_qcifMPI )
			m_qcifMPI = new H263VideoCapability_qcifMPI ( * s.m_qcifMPI );
		if ( s.m_cifMPI )
			m_cifMPI = new H263VideoCapability_cifMPI ( * s.m_cifMPI );
		if ( s.m_cif4MPI )
			m_cif4MPI = new H263VideoCapability_cif4MPI ( * s.m_cif4MPI );
		if ( s.m_cif16MPI )
			m_cif16MPI = new H263VideoCapability_cif16MPI ( * s.m_cif16MPI );
		if ( s.m_hrd_B )
			m_hrd_B = new H263VideoCapability_hrd_B ( * s.m_hrd_B );
		if ( s.m_bppMaxKb )
			m_bppMaxKb = new H263VideoCapability_bppMaxKb ( * s.m_bppMaxKb );
		if ( s.m_slowSqcifMPI )
			m_slowSqcifMPI = new H263VideoCapability_slowSqcifMPI ( * s.m_slowSqcifMPI );
		if ( s.m_slowQcifMPI )
			m_slowQcifMPI = new H263VideoCapability_slowQcifMPI ( * s.m_slowQcifMPI );
		if ( s.m_slowCifMPI )
			m_slowCifMPI = new H263VideoCapability_slowCifMPI ( * s.m_slowCifMPI );
		if ( s.m_slowCif4MPI )
			m_slowCif4MPI = new H263VideoCapability_slowCif4MPI ( * s.m_slowCif4MPI );
		if ( s.m_slowCif16MPI )
			m_slowCif16MPI = new H263VideoCapability_slowCif16MPI ( * s.m_slowCif16MPI );
		if ( s.m_errorCompensation )
			m_errorCompensation = new Asn :: Boolean ( * s.m_errorCompensation );
		if ( s.m_enhancementLayerInfo )
			m_enhancementLayerInfo = new EnhancementLayerInfo ( * s.m_enhancementLayerInfo );
		if ( s.m_h263Options )
			m_h263Options = new H263Options ( * s.m_h263Options );
	} catch ( ... ) {
		delete m_sqcifMPI;
		delete m_qcifMPI;
		delete m_cifMPI;
		delete m_cif4MPI;
		delete m_cif16MPI;
		delete m_hrd_B;
		delete m_bppMaxKb;
		delete m_slowSqcifMPI;
		delete m_slowQcifMPI;
		delete m_slowCifMPI;
		delete m_slowCif4MPI;
		delete m_slowCif16MPI;
		delete m_errorCompensation;
		delete m_enhancementLayerInfo;
		delete m_h263Options;
		throw;
	}
}


void H263VideoCapability :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_sqcifMPI:
			assignNew ( m_sqcifMPI, new H263VideoCapability_sqcifMPI );
			break;
		case e_qcifMPI:
			assignNew ( m_qcifMPI, new H263VideoCapability_qcifMPI );
			break;
		case e_cifMPI:
			assignNew ( m_cifMPI, new H263VideoCapability_cifMPI );
			break;
		case e_cif4MPI:
			assignNew ( m_cif4MPI, new H263VideoCapability_cif4MPI );
			break;
		case e_cif16MPI:
			assignNew ( m_cif16MPI, new H263VideoCapability_cif16MPI );
			break;
		case e_hrd_B:
			assignNew ( m_hrd_B, new H263VideoCapability_hrd_B );
			break;
		case e_bppMaxKb:
			assignNew ( m_bppMaxKb, new H263VideoCapability_bppMaxKb );
			break;
		case e_slowSqcifMPI:
			assignNew ( m_slowSqcifMPI, new H263VideoCapability_slowSqcifMPI );
			break;
		case e_slowQcifMPI:
			assignNew ( m_slowQcifMPI, new H263VideoCapability_slowQcifMPI );
			break;
		case e_slowCifMPI:
			assignNew ( m_slowCifMPI, new H263VideoCapability_slowCifMPI );
			break;
		case e_slowCif4MPI:
			assignNew ( m_slowCif4MPI, new H263VideoCapability_slowCif4MPI );
			break;
		case e_slowCif16MPI:
			assignNew ( m_slowCif16MPI, new H263VideoCapability_slowCif16MPI );
			break;
		case e_errorCompensation:
			assignNew ( m_errorCompensation, new Asn :: Boolean );
			break;
		case e_enhancementLayerInfo:
			assignNew ( m_enhancementLayerInfo, new EnhancementLayerInfo );
			break;
		case e_h263Options:
			assignNew ( m_h263Options, new H263Options );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void H263VideoCapability :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_sqcifMPI:
			delete m_sqcifMPI;
			m_sqcifMPI = 0;
			break;
		case e_qcifMPI:
			delete m_qcifMPI;
			m_qcifMPI = 0;
			break;
		case e_cifMPI:
			delete m_cifMPI;
			m_cifMPI = 0;
			break;
		case e_cif4MPI:
			delete m_cif4MPI;
			m_cif4MPI = 0;
			break;
		case e_cif16MPI:
			delete m_cif16MPI;
			m_cif16MPI = 0;
			break;
		case e_hrd_B:
			delete m_hrd_B;
			m_hrd_B = 0;
			break;
		case e_bppMaxKb:
			delete m_bppMaxKb;
			m_bppMaxKb = 0;
			break;
		case e_slowSqcifMPI:
			delete m_slowSqcifMPI;
			m_slowSqcifMPI = 0;
			break;
		case e_slowQcifMPI:
			delete m_slowQcifMPI;
			m_slowQcifMPI = 0;
			break;
		case e_slowCifMPI:
			delete m_slowCifMPI;
			m_slowCifMPI = 0;
			break;
		case e_slowCif4MPI:
			delete m_slowCif4MPI;
			m_slowCif4MPI = 0;
			break;
		case e_slowCif16MPI:
			delete m_slowCif16MPI;
			m_slowCif16MPI = 0;
			break;
		case e_errorCompensation:
			delete m_errorCompensation;
			m_errorCompensation = 0;
			break;
		case e_enhancementLayerInfo:
			delete m_enhancementLayerInfo;
			m_enhancementLayerInfo = 0;
			break;
		case e_h263Options:
			delete m_h263Options;
			m_h263Options = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void H263VideoCapability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_sqcifMPI ) )
		m_sqcifMPI -> H263VideoCapability_sqcifMPI :: encode ( os );
	if ( hasOptionalField ( e_qcifMPI ) )
		m_qcifMPI -> H263VideoCapability_qcifMPI :: encode ( os );
	if ( hasOptionalField ( e_cifMPI ) )
		m_cifMPI -> H263VideoCapability_cifMPI :: encode ( os );
	if ( hasOptionalField ( e_cif4MPI ) )
		m_cif4MPI -> H263VideoCapability_cif4MPI :: encode ( os );
	if ( hasOptionalField ( e_cif16MPI ) )
		m_cif16MPI -> H263VideoCapability_cif16MPI :: encode ( os );
	m_maxBitRate.encode ( os );
	m_unrestrictedVector.encode ( os );
	m_arithmeticCoding.encode ( os );
	m_advancedPrediction.encode ( os );
	m_pbFrames.encode ( os );
	m_temporalSpatialTradeOffCapability.encode ( os );
	if ( hasOptionalField ( e_hrd_B ) )
		m_hrd_B -> H263VideoCapability_hrd_B :: encode ( os );
	if ( hasOptionalField ( e_bppMaxKb ) )
		m_bppMaxKb -> H263VideoCapability_bppMaxKb :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_slowSqcifMPI, m_slowSqcifMPI );
		knownExtensionEncode ( os, e_slowQcifMPI, m_slowQcifMPI );
		knownExtensionEncode ( os, e_slowCifMPI, m_slowCifMPI );
		knownExtensionEncode ( os, e_slowCif4MPI, m_slowCif4MPI );
		knownExtensionEncode ( os, e_slowCif16MPI, m_slowCif16MPI );
		knownExtensionEncode ( os, e_errorCompensation, m_errorCompensation );
		knownExtensionEncode ( os, e_enhancementLayerInfo, m_enhancementLayerInfo );
		knownExtensionEncode ( os, e_h263Options, m_h263Options );
		unknownExtensionsEncode ( os );
	}
}

H263VideoCapability :: ~H263VideoCapability ( ) {
	delete m_sqcifMPI;
	delete m_qcifMPI;
	delete m_cifMPI;
	delete m_cif4MPI;
	delete m_cif16MPI;
	delete m_hrd_B;
	delete m_bppMaxKb;
	delete m_slowSqcifMPI;
	delete m_slowQcifMPI;
	delete m_slowCifMPI;
	delete m_slowCif4MPI;
	delete m_slowCif16MPI;
	delete m_errorCompensation;
	delete m_enhancementLayerInfo;
	delete m_h263Options;
}

void H263VideoCapability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_sqcifMPI ) ) {
		os << std :: setw ( indent + 11 ) << "sqcifMPI = " << std :: setprecision ( indent );
		m_sqcifMPI -> H263VideoCapability_sqcifMPI :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_qcifMPI ) ) {
		os << std :: setw ( indent + 10 ) << "qcifMPI = " << std :: setprecision ( indent );
		m_qcifMPI -> H263VideoCapability_qcifMPI :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cifMPI ) ) {
		os << std :: setw ( indent + 9 ) << "cifMPI = " << std :: setprecision ( indent );
		m_cifMPI -> H263VideoCapability_cifMPI :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cif4MPI ) ) {
		os << std :: setw ( indent + 10 ) << "cif4MPI = " << std :: setprecision ( indent );
		m_cif4MPI -> H263VideoCapability_cif4MPI :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cif16MPI ) ) {
		os << std :: setw ( indent + 11 ) << "cif16MPI = " << std :: setprecision ( indent );
		m_cif16MPI -> H263VideoCapability_cif16MPI :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 13 ) << "maxBitRate = " << std :: setprecision ( indent ) << m_maxBitRate << '\n';
	os << std :: setw ( indent + 21 ) << "unrestrictedVector = " << std :: setprecision ( indent ) << m_unrestrictedVector << '\n';
	os << std :: setw ( indent + 19 ) << "arithmeticCoding = " << std :: setprecision ( indent ) << m_arithmeticCoding << '\n';
	os << std :: setw ( indent + 21 ) << "advancedPrediction = " << std :: setprecision ( indent ) << m_advancedPrediction << '\n';
	os << std :: setw ( indent + 11 ) << "pbFrames = " << std :: setprecision ( indent ) << m_pbFrames << '\n';
	os << std :: setw ( indent + 36 ) << "temporalSpatialTradeOffCapability = " << std :: setprecision ( indent ) << m_temporalSpatialTradeOffCapability << '\n';
	if ( hasOptionalField ( e_hrd_B ) ) {
		os << std :: setw ( indent + 8 ) << "hrd_B = " << std :: setprecision ( indent );
		m_hrd_B -> H263VideoCapability_hrd_B :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_bppMaxKb ) ) {
		os << std :: setw ( indent + 11 ) << "bppMaxKb = " << std :: setprecision ( indent );
		m_bppMaxKb -> H263VideoCapability_bppMaxKb :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_slowSqcifMPI ) ) {
		os << std :: setw ( indent + 15 ) << "slowSqcifMPI = " << std :: setprecision ( indent );
		m_slowSqcifMPI -> H263VideoCapability_slowSqcifMPI :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_slowQcifMPI ) ) {
		os << std :: setw ( indent + 14 ) << "slowQcifMPI = " << std :: setprecision ( indent );
		m_slowQcifMPI -> H263VideoCapability_slowQcifMPI :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_slowCifMPI ) ) {
		os << std :: setw ( indent + 13 ) << "slowCifMPI = " << std :: setprecision ( indent );
		m_slowCifMPI -> H263VideoCapability_slowCifMPI :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_slowCif4MPI ) ) {
		os << std :: setw ( indent + 14 ) << "slowCif4MPI = " << std :: setprecision ( indent );
		m_slowCif4MPI -> H263VideoCapability_slowCif4MPI :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_slowCif16MPI ) ) {
		os << std :: setw ( indent + 15 ) << "slowCif16MPI = " << std :: setprecision ( indent );
		m_slowCif16MPI -> H263VideoCapability_slowCif16MPI :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_errorCompensation ) ) {
		os << std :: setw ( indent + 20 ) << "errorCompensation = " << std :: setprecision ( indent );
		m_errorCompensation -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_enhancementLayerInfo ) ) {
		os << std :: setw ( indent + 23 ) << "enhancementLayerInfo = " << std :: setprecision ( indent );
		m_enhancementLayerInfo -> EnhancementLayerInfo :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_h263Options ) ) {
		os << std :: setw ( indent + 14 ) << "h263Options = " << std :: setprecision ( indent );
		m_h263Options -> H263Options :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H263VideoCapability * H263VideoCapability :: clone ( ) const {
	return new H263VideoCapability ( * this );
}

//
// EnhancementOptions
//

EnhancementOptions :: EnhancementOptions ( Asn :: istream & is ) : Asn :: Sequence ( is, 11, true, 0 ), m_sqcifMPI ( hasOptionalField ( e_sqcifMPI ) ? pushTemporaryMember ( new EnhancementOptions_sqcifMPI ( is ) ) : 0 ), m_qcifMPI ( hasOptionalField ( e_qcifMPI ) ? pushTemporaryMember ( new EnhancementOptions_qcifMPI ( is ) ) : 0 ), m_cifMPI ( hasOptionalField ( e_cifMPI ) ? pushTemporaryMember ( new EnhancementOptions_cifMPI ( is ) ) : 0 ), m_cif4MPI ( hasOptionalField ( e_cif4MPI ) ? pushTemporaryMember ( new EnhancementOptions_cif4MPI ( is ) ) : 0 ), m_cif16MPI ( hasOptionalField ( e_cif16MPI ) ? pushTemporaryMember ( new EnhancementOptions_cif16MPI ( is ) ) : 0 ), m_maxBitRate ( is ), m_unrestrictedVector ( is ), m_arithmeticCoding ( is ), m_temporalSpatialTradeOffCapability ( is ), m_slowSqcifMPI ( hasOptionalField ( e_slowSqcifMPI ) ? pushTemporaryMember ( new EnhancementOptions_slowSqcifMPI ( is ) ) : 0 ), m_slowQcifMPI ( hasOptionalField ( e_slowQcifMPI ) ? pushTemporaryMember ( new EnhancementOptions_slowQcifMPI ( is ) ) : 0 ), m_slowCifMPI ( hasOptionalField ( e_slowCifMPI ) ? pushTemporaryMember ( new EnhancementOptions_slowCifMPI ( is ) ) : 0 ), m_slowCif4MPI ( hasOptionalField ( e_slowCif4MPI ) ? pushTemporaryMember ( new EnhancementOptions_slowCif4MPI ( is ) ) : 0 ), m_slowCif16MPI ( hasOptionalField ( e_slowCif16MPI ) ? pushTemporaryMember ( new EnhancementOptions_slowCif16MPI ( is ) ) : 0 ), m_errorCompensation ( is ), m_h263Options ( 0 ) {
	clearTemporaryMembers ( );
	try {
		if ( hasOptionalField ( e_h263Options ) )
			m_h263Options = new H263Options ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_sqcifMPI;
		delete m_qcifMPI;
		delete m_cifMPI;
		delete m_cif4MPI;
		delete m_cif16MPI;
		delete m_slowSqcifMPI;
		delete m_slowQcifMPI;
		delete m_slowCifMPI;
		delete m_slowCif4MPI;
		delete m_slowCif16MPI;
		delete m_h263Options;
		throw;
	}
}

EnhancementOptions :: EnhancementOptions ( ) : Asn :: Sequence ( 11, true, 0 ), m_sqcifMPI ( 0 ), m_qcifMPI ( 0 ), m_cifMPI ( 0 ), m_cif4MPI ( 0 ), m_cif16MPI ( 0 ), m_slowSqcifMPI ( 0 ), m_slowQcifMPI ( 0 ), m_slowCifMPI ( 0 ), m_slowCif4MPI ( 0 ), m_slowCif16MPI ( 0 ), m_h263Options ( 0 ) { }

EnhancementOptions & EnhancementOptions :: operator= ( const EnhancementOptions & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_sqcifMPI, s.m_sqcifMPI );
	assignCopy ( m_qcifMPI, s.m_qcifMPI );
	assignCopy ( m_cifMPI, s.m_cifMPI );
	assignCopy ( m_cif4MPI, s.m_cif4MPI );
	assignCopy ( m_cif16MPI, s.m_cif16MPI );
	m_maxBitRate = s.m_maxBitRate;
	m_unrestrictedVector = s.m_unrestrictedVector;
	m_arithmeticCoding = s.m_arithmeticCoding;
	m_temporalSpatialTradeOffCapability = s.m_temporalSpatialTradeOffCapability;
	assignCopy ( m_slowSqcifMPI, s.m_slowSqcifMPI );
	assignCopy ( m_slowQcifMPI, s.m_slowQcifMPI );
	assignCopy ( m_slowCifMPI, s.m_slowCifMPI );
	assignCopy ( m_slowCif4MPI, s.m_slowCif4MPI );
	assignCopy ( m_slowCif16MPI, s.m_slowCif16MPI );
	m_errorCompensation = s.m_errorCompensation;
	assignCopy ( m_h263Options, s.m_h263Options );
	return * this;
}

EnhancementOptions :: EnhancementOptions ( const EnhancementOptions & s ) : Asn :: Sequence ( s ), m_sqcifMPI ( 0 ), m_qcifMPI ( 0 ), m_cifMPI ( 0 ), m_cif4MPI ( 0 ), m_cif16MPI ( 0 ), m_maxBitRate ( s.m_maxBitRate ), m_unrestrictedVector ( s.m_unrestrictedVector ), m_arithmeticCoding ( s.m_arithmeticCoding ), m_temporalSpatialTradeOffCapability ( s.m_temporalSpatialTradeOffCapability ), m_slowSqcifMPI ( 0 ), m_slowQcifMPI ( 0 ), m_slowCifMPI ( 0 ), m_slowCif4MPI ( 0 ), m_slowCif16MPI ( 0 ), m_errorCompensation ( s.m_errorCompensation ), m_h263Options ( 0 ) {
	try {
		if ( s.m_sqcifMPI )
			m_sqcifMPI = new EnhancementOptions_sqcifMPI ( * s.m_sqcifMPI );
		if ( s.m_qcifMPI )
			m_qcifMPI = new EnhancementOptions_qcifMPI ( * s.m_qcifMPI );
		if ( s.m_cifMPI )
			m_cifMPI = new EnhancementOptions_cifMPI ( * s.m_cifMPI );
		if ( s.m_cif4MPI )
			m_cif4MPI = new EnhancementOptions_cif4MPI ( * s.m_cif4MPI );
		if ( s.m_cif16MPI )
			m_cif16MPI = new EnhancementOptions_cif16MPI ( * s.m_cif16MPI );
		if ( s.m_slowSqcifMPI )
			m_slowSqcifMPI = new EnhancementOptions_slowSqcifMPI ( * s.m_slowSqcifMPI );
		if ( s.m_slowQcifMPI )
			m_slowQcifMPI = new EnhancementOptions_slowQcifMPI ( * s.m_slowQcifMPI );
		if ( s.m_slowCifMPI )
			m_slowCifMPI = new EnhancementOptions_slowCifMPI ( * s.m_slowCifMPI );
		if ( s.m_slowCif4MPI )
			m_slowCif4MPI = new EnhancementOptions_slowCif4MPI ( * s.m_slowCif4MPI );
		if ( s.m_slowCif16MPI )
			m_slowCif16MPI = new EnhancementOptions_slowCif16MPI ( * s.m_slowCif16MPI );
		if ( s.m_h263Options )
			m_h263Options = new H263Options ( * s.m_h263Options );
	} catch ( ... ) {
		delete m_sqcifMPI;
		delete m_qcifMPI;
		delete m_cifMPI;
		delete m_cif4MPI;
		delete m_cif16MPI;
		delete m_slowSqcifMPI;
		delete m_slowQcifMPI;
		delete m_slowCifMPI;
		delete m_slowCif4MPI;
		delete m_slowCif16MPI;
		delete m_h263Options;
		throw;
	}
}


void EnhancementOptions :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_sqcifMPI:
			assignNew ( m_sqcifMPI, new EnhancementOptions_sqcifMPI );
			break;
		case e_qcifMPI:
			assignNew ( m_qcifMPI, new EnhancementOptions_qcifMPI );
			break;
		case e_cifMPI:
			assignNew ( m_cifMPI, new EnhancementOptions_cifMPI );
			break;
		case e_cif4MPI:
			assignNew ( m_cif4MPI, new EnhancementOptions_cif4MPI );
			break;
		case e_cif16MPI:
			assignNew ( m_cif16MPI, new EnhancementOptions_cif16MPI );
			break;
		case e_slowSqcifMPI:
			assignNew ( m_slowSqcifMPI, new EnhancementOptions_slowSqcifMPI );
			break;
		case e_slowQcifMPI:
			assignNew ( m_slowQcifMPI, new EnhancementOptions_slowQcifMPI );
			break;
		case e_slowCifMPI:
			assignNew ( m_slowCifMPI, new EnhancementOptions_slowCifMPI );
			break;
		case e_slowCif4MPI:
			assignNew ( m_slowCif4MPI, new EnhancementOptions_slowCif4MPI );
			break;
		case e_slowCif16MPI:
			assignNew ( m_slowCif16MPI, new EnhancementOptions_slowCif16MPI );
			break;
		case e_h263Options:
			assignNew ( m_h263Options, new H263Options );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void EnhancementOptions :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_sqcifMPI:
			delete m_sqcifMPI;
			m_sqcifMPI = 0;
			break;
		case e_qcifMPI:
			delete m_qcifMPI;
			m_qcifMPI = 0;
			break;
		case e_cifMPI:
			delete m_cifMPI;
			m_cifMPI = 0;
			break;
		case e_cif4MPI:
			delete m_cif4MPI;
			m_cif4MPI = 0;
			break;
		case e_cif16MPI:
			delete m_cif16MPI;
			m_cif16MPI = 0;
			break;
		case e_slowSqcifMPI:
			delete m_slowSqcifMPI;
			m_slowSqcifMPI = 0;
			break;
		case e_slowQcifMPI:
			delete m_slowQcifMPI;
			m_slowQcifMPI = 0;
			break;
		case e_slowCifMPI:
			delete m_slowCifMPI;
			m_slowCifMPI = 0;
			break;
		case e_slowCif4MPI:
			delete m_slowCif4MPI;
			m_slowCif4MPI = 0;
			break;
		case e_slowCif16MPI:
			delete m_slowCif16MPI;
			m_slowCif16MPI = 0;
			break;
		case e_h263Options:
			delete m_h263Options;
			m_h263Options = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void EnhancementOptions :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_sqcifMPI ) )
		m_sqcifMPI -> EnhancementOptions_sqcifMPI :: encode ( os );
	if ( hasOptionalField ( e_qcifMPI ) )
		m_qcifMPI -> EnhancementOptions_qcifMPI :: encode ( os );
	if ( hasOptionalField ( e_cifMPI ) )
		m_cifMPI -> EnhancementOptions_cifMPI :: encode ( os );
	if ( hasOptionalField ( e_cif4MPI ) )
		m_cif4MPI -> EnhancementOptions_cif4MPI :: encode ( os );
	if ( hasOptionalField ( e_cif16MPI ) )
		m_cif16MPI -> EnhancementOptions_cif16MPI :: encode ( os );
	m_maxBitRate.encode ( os );
	m_unrestrictedVector.encode ( os );
	m_arithmeticCoding.encode ( os );
	m_temporalSpatialTradeOffCapability.encode ( os );
	if ( hasOptionalField ( e_slowSqcifMPI ) )
		m_slowSqcifMPI -> EnhancementOptions_slowSqcifMPI :: encode ( os );
	if ( hasOptionalField ( e_slowQcifMPI ) )
		m_slowQcifMPI -> EnhancementOptions_slowQcifMPI :: encode ( os );
	if ( hasOptionalField ( e_slowCifMPI ) )
		m_slowCifMPI -> EnhancementOptions_slowCifMPI :: encode ( os );
	if ( hasOptionalField ( e_slowCif4MPI ) )
		m_slowCif4MPI -> EnhancementOptions_slowCif4MPI :: encode ( os );
	if ( hasOptionalField ( e_slowCif16MPI ) )
		m_slowCif16MPI -> EnhancementOptions_slowCif16MPI :: encode ( os );
	m_errorCompensation.encode ( os );
	if ( hasOptionalField ( e_h263Options ) )
		m_h263Options -> H263Options :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

EnhancementOptions :: ~EnhancementOptions ( ) {
	delete m_sqcifMPI;
	delete m_qcifMPI;
	delete m_cifMPI;
	delete m_cif4MPI;
	delete m_cif16MPI;
	delete m_slowSqcifMPI;
	delete m_slowQcifMPI;
	delete m_slowCifMPI;
	delete m_slowCif4MPI;
	delete m_slowCif16MPI;
	delete m_h263Options;
}

void EnhancementOptions :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_sqcifMPI ) ) {
		os << std :: setw ( indent + 11 ) << "sqcifMPI = " << std :: setprecision ( indent );
		m_sqcifMPI -> EnhancementOptions_sqcifMPI :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_qcifMPI ) ) {
		os << std :: setw ( indent + 10 ) << "qcifMPI = " << std :: setprecision ( indent );
		m_qcifMPI -> EnhancementOptions_qcifMPI :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cifMPI ) ) {
		os << std :: setw ( indent + 9 ) << "cifMPI = " << std :: setprecision ( indent );
		m_cifMPI -> EnhancementOptions_cifMPI :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cif4MPI ) ) {
		os << std :: setw ( indent + 10 ) << "cif4MPI = " << std :: setprecision ( indent );
		m_cif4MPI -> EnhancementOptions_cif4MPI :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cif16MPI ) ) {
		os << std :: setw ( indent + 11 ) << "cif16MPI = " << std :: setprecision ( indent );
		m_cif16MPI -> EnhancementOptions_cif16MPI :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 13 ) << "maxBitRate = " << std :: setprecision ( indent ) << m_maxBitRate << '\n';
	os << std :: setw ( indent + 21 ) << "unrestrictedVector = " << std :: setprecision ( indent ) << m_unrestrictedVector << '\n';
	os << std :: setw ( indent + 19 ) << "arithmeticCoding = " << std :: setprecision ( indent ) << m_arithmeticCoding << '\n';
	os << std :: setw ( indent + 36 ) << "temporalSpatialTradeOffCapability = " << std :: setprecision ( indent ) << m_temporalSpatialTradeOffCapability << '\n';
	if ( hasOptionalField ( e_slowSqcifMPI ) ) {
		os << std :: setw ( indent + 15 ) << "slowSqcifMPI = " << std :: setprecision ( indent );
		m_slowSqcifMPI -> EnhancementOptions_slowSqcifMPI :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_slowQcifMPI ) ) {
		os << std :: setw ( indent + 14 ) << "slowQcifMPI = " << std :: setprecision ( indent );
		m_slowQcifMPI -> EnhancementOptions_slowQcifMPI :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_slowCifMPI ) ) {
		os << std :: setw ( indent + 13 ) << "slowCifMPI = " << std :: setprecision ( indent );
		m_slowCifMPI -> EnhancementOptions_slowCifMPI :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_slowCif4MPI ) ) {
		os << std :: setw ( indent + 14 ) << "slowCif4MPI = " << std :: setprecision ( indent );
		m_slowCif4MPI -> EnhancementOptions_slowCif4MPI :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_slowCif16MPI ) ) {
		os << std :: setw ( indent + 15 ) << "slowCif16MPI = " << std :: setprecision ( indent );
		m_slowCif16MPI -> EnhancementOptions_slowCif16MPI :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 20 ) << "errorCompensation = " << std :: setprecision ( indent ) << m_errorCompensation << '\n';
	if ( hasOptionalField ( e_h263Options ) ) {
		os << std :: setw ( indent + 14 ) << "h263Options = " << std :: setprecision ( indent );
		m_h263Options -> H263Options :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

EnhancementOptions * EnhancementOptions :: clone ( ) const {
	return new EnhancementOptions ( * this );
}

//
// TransparencyParameters
//

TransparencyParameters :: TransparencyParameters ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_presentationOrder ( is ), m_offset_x ( is ), m_offset_y ( is ), m_scale_x ( is ), m_scale_y ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

TransparencyParameters :: TransparencyParameters ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void TransparencyParameters :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_presentationOrder.encode ( os );
	m_offset_x.encode ( os );
	m_offset_y.encode ( os );
	m_scale_x.encode ( os );
	m_scale_y.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void TransparencyParameters :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 20 ) << "presentationOrder = " << std :: setprecision ( indent ) << m_presentationOrder << '\n';
	os << std :: setw ( indent + 11 ) << "offset_x = " << std :: setprecision ( indent ) << m_offset_x << '\n';
	os << std :: setw ( indent + 11 ) << "offset_y = " << std :: setprecision ( indent ) << m_offset_y << '\n';
	os << std :: setw ( indent + 10 ) << "scale_x = " << std :: setprecision ( indent ) << m_scale_x << '\n';
	os << std :: setw ( indent + 10 ) << "scale_y = " << std :: setprecision ( indent ) << m_scale_y << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

TransparencyParameters * TransparencyParameters :: clone ( ) const {
	return new TransparencyParameters ( * this );
}

//
// RefPictureSelection
//

RefPictureSelection :: RefPictureSelection ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 1 ), m_additionalPictureMemory ( hasOptionalField ( e_additionalPictureMemory ) ? pushTemporaryMember ( new RefPictureSelection_additionalPictureMemory ( is ) ) : 0 ), m_videoMux ( is ), m_videoBackChannelSend ( is ), m_enhancedReferencePicSelect ( 0 ) {
	clearTemporaryMembers ( );
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_enhancedReferencePicSelect ) )
				m_enhancedReferencePicSelect = new RefPictureSelection_enhancedReferencePicSelect ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_additionalPictureMemory;
		delete m_enhancedReferencePicSelect;
		throw;
	}
}

RefPictureSelection :: RefPictureSelection ( ) : Asn :: Sequence ( 1, true, 1 ), m_additionalPictureMemory ( 0 ), m_enhancedReferencePicSelect ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_enhancedReferencePicSelect );
		m_enhancedReferencePicSelect = new RefPictureSelection_enhancedReferencePicSelect;
	} catch ( ... ) {
		delete m_enhancedReferencePicSelect;
		throw;
	}
}

RefPictureSelection & RefPictureSelection :: operator= ( const RefPictureSelection & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_additionalPictureMemory, s.m_additionalPictureMemory );
	m_videoMux = s.m_videoMux;
	m_videoBackChannelSend = s.m_videoBackChannelSend;
	assignCopy ( m_enhancedReferencePicSelect, s.m_enhancedReferencePicSelect );
	return * this;
}

RefPictureSelection :: RefPictureSelection ( const RefPictureSelection & s ) : Asn :: Sequence ( s ), m_additionalPictureMemory ( 0 ), m_videoMux ( s.m_videoMux ), m_videoBackChannelSend ( s.m_videoBackChannelSend ), m_enhancedReferencePicSelect ( 0 ) {
	try {
		if ( s.m_additionalPictureMemory )
			m_additionalPictureMemory = new RefPictureSelection_additionalPictureMemory ( * s.m_additionalPictureMemory );
		if ( s.m_enhancedReferencePicSelect )
			m_enhancedReferencePicSelect = new RefPictureSelection_enhancedReferencePicSelect ( * s.m_enhancedReferencePicSelect );
	} catch ( ... ) {
		delete m_additionalPictureMemory;
		delete m_enhancedReferencePicSelect;
		throw;
	}
}


void RefPictureSelection :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_additionalPictureMemory:
			assignNew ( m_additionalPictureMemory, new RefPictureSelection_additionalPictureMemory );
			break;
		case e_enhancedReferencePicSelect:
			assignNew ( m_enhancedReferencePicSelect, new RefPictureSelection_enhancedReferencePicSelect );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void RefPictureSelection :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_additionalPictureMemory:
			delete m_additionalPictureMemory;
			m_additionalPictureMemory = 0;
			break;
		case e_enhancedReferencePicSelect:
			delete m_enhancedReferencePicSelect;
			m_enhancedReferencePicSelect = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void RefPictureSelection :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_additionalPictureMemory ) )
		m_additionalPictureMemory -> RefPictureSelection_additionalPictureMemory :: encode ( os );
	m_videoMux.encode ( os );
	m_videoBackChannelSend.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_enhancedReferencePicSelect, m_enhancedReferencePicSelect );
		unknownExtensionsEncode ( os );
	}
}

RefPictureSelection :: ~RefPictureSelection ( ) {
	delete m_additionalPictureMemory;
	delete m_enhancedReferencePicSelect;
}

void RefPictureSelection :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_additionalPictureMemory ) ) {
		os << std :: setw ( indent + 26 ) << "additionalPictureMemory = " << std :: setprecision ( indent );
		m_additionalPictureMemory -> RefPictureSelection_additionalPictureMemory :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 11 ) << "videoMux = " << std :: setprecision ( indent ) << m_videoMux << '\n';
	os << std :: setw ( indent + 23 ) << "videoBackChannelSend = " << std :: setprecision ( indent ) << m_videoBackChannelSend << '\n';
	if ( hasOptionalField ( e_enhancedReferencePicSelect ) ) {
		os << std :: setw ( indent + 29 ) << "enhancedReferencePicSelect = " << std :: setprecision ( indent );
		m_enhancedReferencePicSelect -> RefPictureSelection_enhancedReferencePicSelect :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RefPictureSelection * RefPictureSelection :: clone ( ) const {
	return new RefPictureSelection ( * this );
}

//
// CustomPictureClockFrequency
//

CustomPictureClockFrequency :: CustomPictureClockFrequency ( Asn :: istream & is ) : Asn :: Sequence ( is, 5, true, 0 ), m_clockConversionCode ( is ), m_clockDivisor ( is ), m_sqcifMPI ( 0 ), m_qcifMPI ( 0 ), m_cifMPI ( 0 ), m_cif4MPI ( 0 ), m_cif16MPI ( 0 ) {
	try {
		if ( hasOptionalField ( e_sqcifMPI ) )
			m_sqcifMPI = new CustomPictureClockFrequency_sqcifMPI ( is );
		if ( hasOptionalField ( e_qcifMPI ) )
			m_qcifMPI = new CustomPictureClockFrequency_qcifMPI ( is );
		if ( hasOptionalField ( e_cifMPI ) )
			m_cifMPI = new CustomPictureClockFrequency_cifMPI ( is );
		if ( hasOptionalField ( e_cif4MPI ) )
			m_cif4MPI = new CustomPictureClockFrequency_cif4MPI ( is );
		if ( hasOptionalField ( e_cif16MPI ) )
			m_cif16MPI = new CustomPictureClockFrequency_cif16MPI ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_sqcifMPI;
		delete m_qcifMPI;
		delete m_cifMPI;
		delete m_cif4MPI;
		delete m_cif16MPI;
		throw;
	}
}

CustomPictureClockFrequency :: CustomPictureClockFrequency ( ) : Asn :: Sequence ( 5, true, 0 ), m_sqcifMPI ( 0 ), m_qcifMPI ( 0 ), m_cifMPI ( 0 ), m_cif4MPI ( 0 ), m_cif16MPI ( 0 ) { }

CustomPictureClockFrequency & CustomPictureClockFrequency :: operator= ( const CustomPictureClockFrequency & s ) {
	Asn :: Sequence :: operator= ( s );
	m_clockConversionCode = s.m_clockConversionCode;
	m_clockDivisor = s.m_clockDivisor;
	assignCopy ( m_sqcifMPI, s.m_sqcifMPI );
	assignCopy ( m_qcifMPI, s.m_qcifMPI );
	assignCopy ( m_cifMPI, s.m_cifMPI );
	assignCopy ( m_cif4MPI, s.m_cif4MPI );
	assignCopy ( m_cif16MPI, s.m_cif16MPI );
	return * this;
}

CustomPictureClockFrequency :: CustomPictureClockFrequency ( const CustomPictureClockFrequency & s ) : Asn :: Sequence ( s ), m_clockConversionCode ( s.m_clockConversionCode ), m_clockDivisor ( s.m_clockDivisor ), m_sqcifMPI ( 0 ), m_qcifMPI ( 0 ), m_cifMPI ( 0 ), m_cif4MPI ( 0 ), m_cif16MPI ( 0 ) {
	try {
		if ( s.m_sqcifMPI )
			m_sqcifMPI = new CustomPictureClockFrequency_sqcifMPI ( * s.m_sqcifMPI );
		if ( s.m_qcifMPI )
			m_qcifMPI = new CustomPictureClockFrequency_qcifMPI ( * s.m_qcifMPI );
		if ( s.m_cifMPI )
			m_cifMPI = new CustomPictureClockFrequency_cifMPI ( * s.m_cifMPI );
		if ( s.m_cif4MPI )
			m_cif4MPI = new CustomPictureClockFrequency_cif4MPI ( * s.m_cif4MPI );
		if ( s.m_cif16MPI )
			m_cif16MPI = new CustomPictureClockFrequency_cif16MPI ( * s.m_cif16MPI );
	} catch ( ... ) {
		delete m_sqcifMPI;
		delete m_qcifMPI;
		delete m_cifMPI;
		delete m_cif4MPI;
		delete m_cif16MPI;
		throw;
	}
}


void CustomPictureClockFrequency :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_sqcifMPI:
			assignNew ( m_sqcifMPI, new CustomPictureClockFrequency_sqcifMPI );
			break;
		case e_qcifMPI:
			assignNew ( m_qcifMPI, new CustomPictureClockFrequency_qcifMPI );
			break;
		case e_cifMPI:
			assignNew ( m_cifMPI, new CustomPictureClockFrequency_cifMPI );
			break;
		case e_cif4MPI:
			assignNew ( m_cif4MPI, new CustomPictureClockFrequency_cif4MPI );
			break;
		case e_cif16MPI:
			assignNew ( m_cif16MPI, new CustomPictureClockFrequency_cif16MPI );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void CustomPictureClockFrequency :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_sqcifMPI:
			delete m_sqcifMPI;
			m_sqcifMPI = 0;
			break;
		case e_qcifMPI:
			delete m_qcifMPI;
			m_qcifMPI = 0;
			break;
		case e_cifMPI:
			delete m_cifMPI;
			m_cifMPI = 0;
			break;
		case e_cif4MPI:
			delete m_cif4MPI;
			m_cif4MPI = 0;
			break;
		case e_cif16MPI:
			delete m_cif16MPI;
			m_cif16MPI = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void CustomPictureClockFrequency :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_clockConversionCode.encode ( os );
	m_clockDivisor.encode ( os );
	if ( hasOptionalField ( e_sqcifMPI ) )
		m_sqcifMPI -> CustomPictureClockFrequency_sqcifMPI :: encode ( os );
	if ( hasOptionalField ( e_qcifMPI ) )
		m_qcifMPI -> CustomPictureClockFrequency_qcifMPI :: encode ( os );
	if ( hasOptionalField ( e_cifMPI ) )
		m_cifMPI -> CustomPictureClockFrequency_cifMPI :: encode ( os );
	if ( hasOptionalField ( e_cif4MPI ) )
		m_cif4MPI -> CustomPictureClockFrequency_cif4MPI :: encode ( os );
	if ( hasOptionalField ( e_cif16MPI ) )
		m_cif16MPI -> CustomPictureClockFrequency_cif16MPI :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

CustomPictureClockFrequency :: ~CustomPictureClockFrequency ( ) {
	delete m_sqcifMPI;
	delete m_qcifMPI;
	delete m_cifMPI;
	delete m_cif4MPI;
	delete m_cif16MPI;
}

void CustomPictureClockFrequency :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 22 ) << "clockConversionCode = " << std :: setprecision ( indent ) << m_clockConversionCode << '\n';
	os << std :: setw ( indent + 15 ) << "clockDivisor = " << std :: setprecision ( indent ) << m_clockDivisor << '\n';
	if ( hasOptionalField ( e_sqcifMPI ) ) {
		os << std :: setw ( indent + 11 ) << "sqcifMPI = " << std :: setprecision ( indent );
		m_sqcifMPI -> CustomPictureClockFrequency_sqcifMPI :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_qcifMPI ) ) {
		os << std :: setw ( indent + 10 ) << "qcifMPI = " << std :: setprecision ( indent );
		m_qcifMPI -> CustomPictureClockFrequency_qcifMPI :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cifMPI ) ) {
		os << std :: setw ( indent + 9 ) << "cifMPI = " << std :: setprecision ( indent );
		m_cifMPI -> CustomPictureClockFrequency_cifMPI :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cif4MPI ) ) {
		os << std :: setw ( indent + 10 ) << "cif4MPI = " << std :: setprecision ( indent );
		m_cif4MPI -> CustomPictureClockFrequency_cif4MPI :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_cif16MPI ) ) {
		os << std :: setw ( indent + 11 ) << "cif16MPI = " << std :: setprecision ( indent );
		m_cif16MPI -> CustomPictureClockFrequency_cif16MPI :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

CustomPictureClockFrequency * CustomPictureClockFrequency :: clone ( ) const {
	return new CustomPictureClockFrequency ( * this );
}

//
// H263VideoModeCombos
//

H263VideoModeCombos :: H263VideoModeCombos ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_h263VideoUncoupledModes ( is ), m_h263VideoCoupledModes ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

H263VideoModeCombos :: H263VideoModeCombos ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void H263VideoModeCombos :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_h263VideoUncoupledModes.encode ( os );
	m_h263VideoCoupledModes.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void H263VideoModeCombos :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 26 ) << "h263VideoUncoupledModes = " << std :: setprecision ( indent ) << m_h263VideoUncoupledModes << '\n';
	os << std :: setw ( indent + 24 ) << "h263VideoCoupledModes = " << std :: setprecision ( indent ) << m_h263VideoCoupledModes << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H263VideoModeCombos * H263VideoModeCombos :: clone ( ) const {
	return new H263VideoModeCombos ( * this );
}

//
// G7231AnnexCCapability
//

G7231AnnexCCapability :: G7231AnnexCCapability ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_maxAl_sduAudioFrames ( is ), m_silenceSuppression ( is ), m_g723AnnexCAudioMode ( 0 ) {
	try {
		if ( hasOptionalField ( e_g723AnnexCAudioMode ) )
			m_g723AnnexCAudioMode = new G7231AnnexCCapability_g723AnnexCAudioMode ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_g723AnnexCAudioMode;
		throw;
	}
}

G7231AnnexCCapability :: G7231AnnexCCapability ( ) : Asn :: Sequence ( 1, true, 0 ), m_g723AnnexCAudioMode ( 0 ) { }

G7231AnnexCCapability & G7231AnnexCCapability :: operator= ( const G7231AnnexCCapability & s ) {
	Asn :: Sequence :: operator= ( s );
	m_maxAl_sduAudioFrames = s.m_maxAl_sduAudioFrames;
	m_silenceSuppression = s.m_silenceSuppression;
	assignCopy ( m_g723AnnexCAudioMode, s.m_g723AnnexCAudioMode );
	return * this;
}

G7231AnnexCCapability :: G7231AnnexCCapability ( const G7231AnnexCCapability & s ) : Asn :: Sequence ( s ), m_maxAl_sduAudioFrames ( s.m_maxAl_sduAudioFrames ), m_silenceSuppression ( s.m_silenceSuppression ), m_g723AnnexCAudioMode ( 0 ) {
	try {
		if ( s.m_g723AnnexCAudioMode )
			m_g723AnnexCAudioMode = new G7231AnnexCCapability_g723AnnexCAudioMode ( * s.m_g723AnnexCAudioMode );
	} catch ( ... ) {
		delete m_g723AnnexCAudioMode;
		throw;
	}
}


void G7231AnnexCCapability :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_g723AnnexCAudioMode:
			assignNew ( m_g723AnnexCAudioMode, new G7231AnnexCCapability_g723AnnexCAudioMode );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void G7231AnnexCCapability :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_g723AnnexCAudioMode:
			delete m_g723AnnexCAudioMode;
			m_g723AnnexCAudioMode = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void G7231AnnexCCapability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_maxAl_sduAudioFrames.encode ( os );
	m_silenceSuppression.encode ( os );
	if ( hasOptionalField ( e_g723AnnexCAudioMode ) )
		m_g723AnnexCAudioMode -> G7231AnnexCCapability_g723AnnexCAudioMode :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

G7231AnnexCCapability :: ~G7231AnnexCCapability ( ) {
	delete m_g723AnnexCAudioMode;
}

void G7231AnnexCCapability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 23 ) << "maxAl_sduAudioFrames = " << std :: setprecision ( indent ) << m_maxAl_sduAudioFrames << '\n';
	os << std :: setw ( indent + 21 ) << "silenceSuppression = " << std :: setprecision ( indent ) << m_silenceSuppression << '\n';
	if ( hasOptionalField ( e_g723AnnexCAudioMode ) ) {
		os << std :: setw ( indent + 22 ) << "g723AnnexCAudioMode = " << std :: setprecision ( indent );
		m_g723AnnexCAudioMode -> G7231AnnexCCapability_g723AnnexCAudioMode :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

G7231AnnexCCapability * G7231AnnexCCapability :: clone ( ) const {
	return new G7231AnnexCCapability ( * this );
}

//
// IS11172AudioCapability
//

IS11172AudioCapability :: IS11172AudioCapability ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_audioLayer1 ( is ), m_audioLayer2 ( is ), m_audioLayer3 ( is ), m_audioSampling32k ( is ), m_audioSampling44k1 ( is ), m_audioSampling48k ( is ), m_singleChannel ( is ), m_twoChannels ( is ), m_bitRate ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

IS11172AudioCapability :: IS11172AudioCapability ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void IS11172AudioCapability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_audioLayer1.encode ( os );
	m_audioLayer2.encode ( os );
	m_audioLayer3.encode ( os );
	m_audioSampling32k.encode ( os );
	m_audioSampling44k1.encode ( os );
	m_audioSampling48k.encode ( os );
	m_singleChannel.encode ( os );
	m_twoChannels.encode ( os );
	m_bitRate.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void IS11172AudioCapability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 14 ) << "audioLayer1 = " << std :: setprecision ( indent ) << m_audioLayer1 << '\n';
	os << std :: setw ( indent + 14 ) << "audioLayer2 = " << std :: setprecision ( indent ) << m_audioLayer2 << '\n';
	os << std :: setw ( indent + 14 ) << "audioLayer3 = " << std :: setprecision ( indent ) << m_audioLayer3 << '\n';
	os << std :: setw ( indent + 19 ) << "audioSampling32k = " << std :: setprecision ( indent ) << m_audioSampling32k << '\n';
	os << std :: setw ( indent + 20 ) << "audioSampling44k1 = " << std :: setprecision ( indent ) << m_audioSampling44k1 << '\n';
	os << std :: setw ( indent + 19 ) << "audioSampling48k = " << std :: setprecision ( indent ) << m_audioSampling48k << '\n';
	os << std :: setw ( indent + 16 ) << "singleChannel = " << std :: setprecision ( indent ) << m_singleChannel << '\n';
	os << std :: setw ( indent + 14 ) << "twoChannels = " << std :: setprecision ( indent ) << m_twoChannels << '\n';
	os << std :: setw ( indent + 10 ) << "bitRate = " << std :: setprecision ( indent ) << m_bitRate << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

IS11172AudioCapability * IS11172AudioCapability :: clone ( ) const {
	return new IS11172AudioCapability ( * this );
}

//
// IS13818AudioCapability
//

IS13818AudioCapability :: IS13818AudioCapability ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_audioLayer1 ( is ), m_audioLayer2 ( is ), m_audioLayer3 ( is ), m_audioSampling16k ( is ), m_audioSampling22k05 ( is ), m_audioSampling24k ( is ), m_audioSampling32k ( is ), m_audioSampling44k1 ( is ), m_audioSampling48k ( is ), m_singleChannel ( is ), m_twoChannels ( is ), m_threeChannels2_1 ( is ), m_threeChannels3_0 ( is ), m_fourChannels2_0_2_0 ( is ), m_fourChannels2_2 ( is ), m_fourChannels3_1 ( is ), m_fiveChannels3_0_2_0 ( is ), m_fiveChannels3_2 ( is ), m_lowFrequencyEnhancement ( is ), m_multilingual ( is ), m_bitRate ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

IS13818AudioCapability :: IS13818AudioCapability ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void IS13818AudioCapability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_audioLayer1.encode ( os );
	m_audioLayer2.encode ( os );
	m_audioLayer3.encode ( os );
	m_audioSampling16k.encode ( os );
	m_audioSampling22k05.encode ( os );
	m_audioSampling24k.encode ( os );
	m_audioSampling32k.encode ( os );
	m_audioSampling44k1.encode ( os );
	m_audioSampling48k.encode ( os );
	m_singleChannel.encode ( os );
	m_twoChannels.encode ( os );
	m_threeChannels2_1.encode ( os );
	m_threeChannels3_0.encode ( os );
	m_fourChannels2_0_2_0.encode ( os );
	m_fourChannels2_2.encode ( os );
	m_fourChannels3_1.encode ( os );
	m_fiveChannels3_0_2_0.encode ( os );
	m_fiveChannels3_2.encode ( os );
	m_lowFrequencyEnhancement.encode ( os );
	m_multilingual.encode ( os );
	m_bitRate.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void IS13818AudioCapability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 14 ) << "audioLayer1 = " << std :: setprecision ( indent ) << m_audioLayer1 << '\n';
	os << std :: setw ( indent + 14 ) << "audioLayer2 = " << std :: setprecision ( indent ) << m_audioLayer2 << '\n';
	os << std :: setw ( indent + 14 ) << "audioLayer3 = " << std :: setprecision ( indent ) << m_audioLayer3 << '\n';
	os << std :: setw ( indent + 19 ) << "audioSampling16k = " << std :: setprecision ( indent ) << m_audioSampling16k << '\n';
	os << std :: setw ( indent + 21 ) << "audioSampling22k05 = " << std :: setprecision ( indent ) << m_audioSampling22k05 << '\n';
	os << std :: setw ( indent + 19 ) << "audioSampling24k = " << std :: setprecision ( indent ) << m_audioSampling24k << '\n';
	os << std :: setw ( indent + 19 ) << "audioSampling32k = " << std :: setprecision ( indent ) << m_audioSampling32k << '\n';
	os << std :: setw ( indent + 20 ) << "audioSampling44k1 = " << std :: setprecision ( indent ) << m_audioSampling44k1 << '\n';
	os << std :: setw ( indent + 19 ) << "audioSampling48k = " << std :: setprecision ( indent ) << m_audioSampling48k << '\n';
	os << std :: setw ( indent + 16 ) << "singleChannel = " << std :: setprecision ( indent ) << m_singleChannel << '\n';
	os << std :: setw ( indent + 14 ) << "twoChannels = " << std :: setprecision ( indent ) << m_twoChannels << '\n';
	os << std :: setw ( indent + 19 ) << "threeChannels2_1 = " << std :: setprecision ( indent ) << m_threeChannels2_1 << '\n';
	os << std :: setw ( indent + 19 ) << "threeChannels3_0 = " << std :: setprecision ( indent ) << m_threeChannels3_0 << '\n';
	os << std :: setw ( indent + 22 ) << "fourChannels2_0_2_0 = " << std :: setprecision ( indent ) << m_fourChannels2_0_2_0 << '\n';
	os << std :: setw ( indent + 18 ) << "fourChannels2_2 = " << std :: setprecision ( indent ) << m_fourChannels2_2 << '\n';
	os << std :: setw ( indent + 18 ) << "fourChannels3_1 = " << std :: setprecision ( indent ) << m_fourChannels3_1 << '\n';
	os << std :: setw ( indent + 22 ) << "fiveChannels3_0_2_0 = " << std :: setprecision ( indent ) << m_fiveChannels3_0_2_0 << '\n';
	os << std :: setw ( indent + 18 ) << "fiveChannels3_2 = " << std :: setprecision ( indent ) << m_fiveChannels3_2 << '\n';
	os << std :: setw ( indent + 26 ) << "lowFrequencyEnhancement = " << std :: setprecision ( indent ) << m_lowFrequencyEnhancement << '\n';
	os << std :: setw ( indent + 15 ) << "multilingual = " << std :: setprecision ( indent ) << m_multilingual << '\n';
	os << std :: setw ( indent + 10 ) << "bitRate = " << std :: setprecision ( indent ) << m_bitRate << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

IS13818AudioCapability * IS13818AudioCapability :: clone ( ) const {
	return new IS13818AudioCapability ( * this );
}

//
// GSMAudioCapability
//

GSMAudioCapability :: GSMAudioCapability ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_audioUnitSize ( is ), m_comfortNoise ( is ), m_scrambled ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

GSMAudioCapability :: GSMAudioCapability ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void GSMAudioCapability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_audioUnitSize.encode ( os );
	m_comfortNoise.encode ( os );
	m_scrambled.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void GSMAudioCapability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "audioUnitSize = " << std :: setprecision ( indent ) << m_audioUnitSize << '\n';
	os << std :: setw ( indent + 15 ) << "comfortNoise = " << std :: setprecision ( indent ) << m_comfortNoise << '\n';
	os << std :: setw ( indent + 12 ) << "scrambled = " << std :: setprecision ( indent ) << m_scrambled << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

GSMAudioCapability * GSMAudioCapability :: clone ( ) const {
	return new GSMAudioCapability ( * this );
}

//
// V42bis
//

V42bis :: V42bis ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_numberOfCodewords ( is ), m_maximumStringLength ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

V42bis :: V42bis ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void V42bis :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_numberOfCodewords.encode ( os );
	m_maximumStringLength.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void V42bis :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 20 ) << "numberOfCodewords = " << std :: setprecision ( indent ) << m_numberOfCodewords << '\n';
	os << std :: setw ( indent + 22 ) << "maximumStringLength = " << std :: setprecision ( indent ) << m_maximumStringLength << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

V42bis * V42bis :: clone ( ) const {
	return new V42bis ( * this );
}

//
// T84Profile
//

T84Profile :: T84Profile ( Asn :: istream & is ) : Asn :: Choice ( is, 2, false ) {
	switch ( tag ) {
		case e_t84Unrestricted:
			choice = new Asn :: Null ( is );
			break;
		case e_t84Restricted:
			choice = new T84Profile_t84Restricted ( is );
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
}

T84Profile :: T84Profile ( ) : Asn :: Choice ( 2, false ) { }

void T84Profile :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_t84Unrestricted:
			o = new Asn :: Null;
			break;
		case e_t84Restricted:
			o = new T84Profile_t84Restricted;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & T84Profile :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_t84Unrestricted, "t84Unrestricted" },
		{ e_t84Restricted, "t84Restricted" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

T84Profile * T84Profile :: clone ( ) const {
	return new T84Profile ( * this );
}

//
// T38FaxUdpOptions
//

T38FaxUdpOptions :: T38FaxUdpOptions ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, false, 0 ), m_t38FaxMaxBuffer ( hasOptionalField ( e_t38FaxMaxBuffer ) ? pushTemporaryMember ( new Asn :: Integer ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) ) : 0 ), m_t38FaxMaxDatagram ( hasOptionalField ( e_t38FaxMaxDatagram ) ? pushTemporaryMember ( new Asn :: Integer ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) ) : 0 ), m_t38FaxUdpEC ( is ) {
	clearTemporaryMembers ( );
}

T38FaxUdpOptions :: T38FaxUdpOptions ( ) : Asn :: Sequence ( 2, false, 0 ), m_t38FaxMaxBuffer ( 0 ), m_t38FaxMaxDatagram ( 0 ) { }

T38FaxUdpOptions & T38FaxUdpOptions :: operator= ( const T38FaxUdpOptions & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_t38FaxMaxBuffer, s.m_t38FaxMaxBuffer );
	assignCopy ( m_t38FaxMaxDatagram, s.m_t38FaxMaxDatagram );
	m_t38FaxUdpEC = s.m_t38FaxUdpEC;
	return * this;
}

T38FaxUdpOptions :: T38FaxUdpOptions ( const T38FaxUdpOptions & s ) : Asn :: Sequence ( s ), m_t38FaxMaxBuffer ( 0 ), m_t38FaxMaxDatagram ( 0 ), m_t38FaxUdpEC ( s.m_t38FaxUdpEC ) {
	try {
		if ( s.m_t38FaxMaxBuffer )
			m_t38FaxMaxBuffer = new Asn :: Integer ( * s.m_t38FaxMaxBuffer );
		if ( s.m_t38FaxMaxDatagram )
			m_t38FaxMaxDatagram = new Asn :: Integer ( * s.m_t38FaxMaxDatagram );
	} catch ( ... ) {
		delete m_t38FaxMaxBuffer;
		delete m_t38FaxMaxDatagram;
		throw;
	}
}


void T38FaxUdpOptions :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_t38FaxMaxBuffer:
			assignNew ( m_t38FaxMaxBuffer, new Asn :: Integer );
			break;
		case e_t38FaxMaxDatagram:
			assignNew ( m_t38FaxMaxDatagram, new Asn :: Integer );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void T38FaxUdpOptions :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_t38FaxMaxBuffer:
			delete m_t38FaxMaxBuffer;
			m_t38FaxMaxBuffer = 0;
			break;
		case e_t38FaxMaxDatagram:
			delete m_t38FaxMaxDatagram;
			m_t38FaxMaxDatagram = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void T38FaxUdpOptions :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_t38FaxMaxBuffer ) )
		m_t38FaxMaxBuffer -> Asn :: Integer :: encode ( os );
	if ( hasOptionalField ( e_t38FaxMaxDatagram ) )
		m_t38FaxMaxDatagram -> Asn :: Integer :: encode ( os );
	m_t38FaxUdpEC.encode ( os );
}

T38FaxUdpOptions :: ~T38FaxUdpOptions ( ) {
	delete m_t38FaxMaxBuffer;
	delete m_t38FaxMaxDatagram;
}

void T38FaxUdpOptions :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_t38FaxMaxBuffer ) ) {
		os << std :: setw ( indent + 18 ) << "t38FaxMaxBuffer = " << std :: setprecision ( indent );
		m_t38FaxMaxBuffer -> Asn :: Integer :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_t38FaxMaxDatagram ) ) {
		os << std :: setw ( indent + 20 ) << "t38FaxMaxDatagram = " << std :: setprecision ( indent );
		m_t38FaxMaxDatagram -> Asn :: Integer :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 14 ) << "t38FaxUdpEC = " << std :: setprecision ( indent ) << m_t38FaxUdpEC << '\n';
	os << std :: setw ( indent - 1 ) << '}';
}

T38FaxUdpOptions * T38FaxUdpOptions :: clone ( ) const {
	return new T38FaxUdpOptions ( * this );
}

//
// ParameterValue
//

ParameterValue :: ParameterValue ( Asn :: istream & is ) : Asn :: Choice ( is, 8, true ) {
	switch ( tag ) {
		case e_logical:
			choice = new Asn :: Null ( is );
			break;
		case e_booleanArray:
			choice = new ParameterValue_booleanArray ( is );
			break;
		case e_unsignedMin:
			choice = new ParameterValue_unsignedMin ( is );
			break;
		case e_unsignedMax:
			choice = new ParameterValue_unsignedMax ( is );
			break;
		case e_unsigned32Min:
			choice = new ParameterValue_unsigned32Min ( is );
			break;
		case e_unsigned32Max:
			choice = new ParameterValue_unsigned32Max ( is );
			break;
		case e_octetString:
			choice = new Asn :: OctetString ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) );
			break;
		case e_genericParameter:
			choice = new ArrayOf_GenericParameter ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

ParameterValue :: ParameterValue ( ) : Asn :: Choice ( 8, true ) { }

void ParameterValue :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_logical:
			o = new Asn :: Null;
			break;
		case e_booleanArray:
			o = new ParameterValue_booleanArray;
			break;
		case e_unsignedMin:
			o = new ParameterValue_unsignedMin;
			break;
		case e_unsignedMax:
			o = new ParameterValue_unsignedMax;
			break;
		case e_unsigned32Min:
			o = new ParameterValue_unsigned32Min;
			break;
		case e_unsigned32Max:
			o = new ParameterValue_unsigned32Max;
			break;
		case e_octetString:
			o = new Asn :: OctetString;
			break;
		case e_genericParameter:
			o = new ArrayOf_GenericParameter;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & ParameterValue :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_logical, "logical" },
		{ e_booleanArray, "booleanArray" },
		{ e_unsignedMin, "unsignedMin" },
		{ e_unsignedMax, "unsignedMax" },
		{ e_unsigned32Min, "unsigned32Min" },
		{ e_unsigned32Max, "unsigned32Max" },
		{ e_octetString, "octetString" },
		{ e_genericParameter, "genericParameter" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

ParameterValue * ParameterValue :: clone ( ) const {
	return new ParameterValue ( * this );
}

//
// AudioTelephonyEventCapability
//

AudioTelephonyEventCapability :: AudioTelephonyEventCapability ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_dynamicRTPPayloadType ( is ), m_audioTelephoneEvent ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

AudioTelephonyEventCapability :: AudioTelephonyEventCapability ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void AudioTelephonyEventCapability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_dynamicRTPPayloadType.encode ( os );
	m_audioTelephoneEvent.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void AudioTelephonyEventCapability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 24 ) << "dynamicRTPPayloadType = " << std :: setprecision ( indent ) << m_dynamicRTPPayloadType << '\n';
	os << std :: setw ( indent + 22 ) << "audioTelephoneEvent = " << std :: setprecision ( indent ) << m_audioTelephoneEvent << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

AudioTelephonyEventCapability * AudioTelephonyEventCapability :: clone ( ) const {
	return new AudioTelephonyEventCapability ( * this );
}

//
// AudioToneCapability
//

AudioToneCapability :: AudioToneCapability ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_dynamicRTPPayloadType ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

AudioToneCapability :: AudioToneCapability ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void AudioToneCapability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_dynamicRTPPayloadType.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void AudioToneCapability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 24 ) << "dynamicRTPPayloadType = " << std :: setprecision ( indent ) << m_dynamicRTPPayloadType << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

AudioToneCapability * AudioToneCapability :: clone ( ) const {
	return new AudioToneCapability ( * this );
}

//
// MultiplePayloadStreamCapability
//

MultiplePayloadStreamCapability :: MultiplePayloadStreamCapability ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_capabilities ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MultiplePayloadStreamCapability :: MultiplePayloadStreamCapability ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MultiplePayloadStreamCapability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_capabilities.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MultiplePayloadStreamCapability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 15 ) << "capabilities = " << std :: setprecision ( indent ) << m_capabilities << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MultiplePayloadStreamCapability * MultiplePayloadStreamCapability :: clone ( ) const {
	return new MultiplePayloadStreamCapability ( * this );
}

//
// H222LogicalChannelParameters
//

H222LogicalChannelParameters :: H222LogicalChannelParameters ( Asn :: istream & is ) : Asn :: Sequence ( is, 3, true, 0 ), m_resourceID ( is ), m_subChannelID ( is ), m_pcr_pid ( 0 ), m_programDescriptors ( 0 ), m_streamDescriptors ( 0 ) {
	try {
		if ( hasOptionalField ( e_pcr_pid ) )
			m_pcr_pid = new H222LogicalChannelParameters_pcr_pid ( is );
		if ( hasOptionalField ( e_programDescriptors ) )
			m_programDescriptors = new Asn :: OctetString ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) );
		if ( hasOptionalField ( e_streamDescriptors ) )
			m_streamDescriptors = new Asn :: OctetString ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_pcr_pid;
		delete m_programDescriptors;
		delete m_streamDescriptors;
		throw;
	}
}

H222LogicalChannelParameters :: H222LogicalChannelParameters ( ) : Asn :: Sequence ( 3, true, 0 ), m_pcr_pid ( 0 ), m_programDescriptors ( 0 ), m_streamDescriptors ( 0 ) { }

H222LogicalChannelParameters & H222LogicalChannelParameters :: operator= ( const H222LogicalChannelParameters & s ) {
	Asn :: Sequence :: operator= ( s );
	m_resourceID = s.m_resourceID;
	m_subChannelID = s.m_subChannelID;
	assignCopy ( m_pcr_pid, s.m_pcr_pid );
	assignCopy ( m_programDescriptors, s.m_programDescriptors );
	assignCopy ( m_streamDescriptors, s.m_streamDescriptors );
	return * this;
}

H222LogicalChannelParameters :: H222LogicalChannelParameters ( const H222LogicalChannelParameters & s ) : Asn :: Sequence ( s ), m_resourceID ( s.m_resourceID ), m_subChannelID ( s.m_subChannelID ), m_pcr_pid ( 0 ), m_programDescriptors ( 0 ), m_streamDescriptors ( 0 ) {
	try {
		if ( s.m_pcr_pid )
			m_pcr_pid = new H222LogicalChannelParameters_pcr_pid ( * s.m_pcr_pid );
		if ( s.m_programDescriptors )
			m_programDescriptors = new Asn :: OctetString ( * s.m_programDescriptors );
		if ( s.m_streamDescriptors )
			m_streamDescriptors = new Asn :: OctetString ( * s.m_streamDescriptors );
	} catch ( ... ) {
		delete m_pcr_pid;
		delete m_programDescriptors;
		delete m_streamDescriptors;
		throw;
	}
}


void H222LogicalChannelParameters :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_pcr_pid:
			assignNew ( m_pcr_pid, new H222LogicalChannelParameters_pcr_pid );
			break;
		case e_programDescriptors:
			assignNew ( m_programDescriptors, new Asn :: OctetString );
			break;
		case e_streamDescriptors:
			assignNew ( m_streamDescriptors, new Asn :: OctetString );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void H222LogicalChannelParameters :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_pcr_pid:
			delete m_pcr_pid;
			m_pcr_pid = 0;
			break;
		case e_programDescriptors:
			delete m_programDescriptors;
			m_programDescriptors = 0;
			break;
		case e_streamDescriptors:
			delete m_streamDescriptors;
			m_streamDescriptors = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void H222LogicalChannelParameters :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_resourceID.encode ( os );
	m_subChannelID.encode ( os );
	if ( hasOptionalField ( e_pcr_pid ) )
		m_pcr_pid -> H222LogicalChannelParameters_pcr_pid :: encode ( os );
	if ( hasOptionalField ( e_programDescriptors ) )
		m_programDescriptors -> Asn :: OctetString :: encode ( os );
	if ( hasOptionalField ( e_streamDescriptors ) )
		m_streamDescriptors -> Asn :: OctetString :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

H222LogicalChannelParameters :: ~H222LogicalChannelParameters ( ) {
	delete m_pcr_pid;
	delete m_programDescriptors;
	delete m_streamDescriptors;
}

void H222LogicalChannelParameters :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 13 ) << "resourceID = " << std :: setprecision ( indent ) << m_resourceID << '\n';
	os << std :: setw ( indent + 15 ) << "subChannelID = " << std :: setprecision ( indent ) << m_subChannelID << '\n';
	if ( hasOptionalField ( e_pcr_pid ) ) {
		os << std :: setw ( indent + 10 ) << "pcr_pid = " << std :: setprecision ( indent );
		m_pcr_pid -> H222LogicalChannelParameters_pcr_pid :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_programDescriptors ) ) {
		os << std :: setw ( indent + 21 ) << "programDescriptors = " << std :: setprecision ( indent );
		m_programDescriptors -> Asn :: OctetString :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_streamDescriptors ) ) {
		os << std :: setw ( indent + 20 ) << "streamDescriptors = " << std :: setprecision ( indent );
		m_streamDescriptors -> Asn :: OctetString :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H222LogicalChannelParameters * H222LogicalChannelParameters :: clone ( ) const {
	return new H222LogicalChannelParameters ( * this );
}

//
// H223AL2MParameters
//

H223AL2MParameters :: H223AL2MParameters ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_headerFEC ( is ), m_alpduInterleaving ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

H223AL2MParameters :: H223AL2MParameters ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void H223AL2MParameters :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_headerFEC.encode ( os );
	m_alpduInterleaving.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void H223AL2MParameters :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 12 ) << "headerFEC = " << std :: setprecision ( indent ) << m_headerFEC << '\n';
	os << std :: setw ( indent + 20 ) << "alpduInterleaving = " << std :: setprecision ( indent ) << m_alpduInterleaving << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H223AL2MParameters * H223AL2MParameters :: clone ( ) const {
	return new H223AL2MParameters ( * this );
}

//
// V76HDLCParameters
//

V76HDLCParameters :: V76HDLCParameters ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_crcLength ( is ), m_n401 ( is ), m_loopbackTestProcedure ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

V76HDLCParameters :: V76HDLCParameters ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void V76HDLCParameters :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_crcLength.encode ( os );
	m_n401.encode ( os );
	m_loopbackTestProcedure.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void V76HDLCParameters :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 12 ) << "crcLength = " << std :: setprecision ( indent ) << m_crcLength << '\n';
	os << std :: setw ( indent + 7 ) << "n401 = " << std :: setprecision ( indent ) << m_n401 << '\n';
	os << std :: setw ( indent + 24 ) << "loopbackTestProcedure = " << std :: setprecision ( indent ) << m_loopbackTestProcedure << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

V76HDLCParameters * V76HDLCParameters :: clone ( ) const {
	return new V76HDLCParameters ( * this );
}

//
// H2250LogicalChannelParameters
//

H2250LogicalChannelParameters :: H2250LogicalChannelParameters ( Asn :: istream & is ) : Asn :: Sequence ( is, 10, true, 3 ), m_nonStandard ( hasOptionalField ( e_nonStandard ) ? pushTemporaryMember ( new ArrayOf_NonStandardParameter ( is ) ) : 0 ), m_sessionID ( is ), m_associatedSessionID ( 0 ), m_mediaChannel ( 0 ), m_mediaGuaranteedDelivery ( 0 ), m_mediaControlChannel ( 0 ), m_mediaControlGuaranteedDelivery ( 0 ), m_silenceSuppression ( 0 ), m_destination ( 0 ), m_dynamicRTPPayloadType ( 0 ), m_mediaPacketization ( 0 ), m_transportCapability ( 0 ), m_redundancyEncoding ( 0 ), m_source ( 0 ) {
	clearTemporaryMembers ( );
	try {
		if ( hasOptionalField ( e_associatedSessionID ) )
			m_associatedSessionID = new H2250LogicalChannelParameters_associatedSessionID ( is );
		if ( hasOptionalField ( e_mediaChannel ) )
			m_mediaChannel = new TransportAddress ( is );
		if ( hasOptionalField ( e_mediaGuaranteedDelivery ) )
			m_mediaGuaranteedDelivery = new Asn :: Boolean ( is );
		if ( hasOptionalField ( e_mediaControlChannel ) )
			m_mediaControlChannel = new TransportAddress ( is );
		if ( hasOptionalField ( e_mediaControlGuaranteedDelivery ) )
			m_mediaControlGuaranteedDelivery = new Asn :: Boolean ( is );
		if ( hasOptionalField ( e_silenceSuppression ) )
			m_silenceSuppression = new Asn :: Boolean ( is );
		if ( hasOptionalField ( e_destination ) )
			m_destination = new TerminalLabel ( is );
		if ( hasOptionalField ( e_dynamicRTPPayloadType ) )
			m_dynamicRTPPayloadType = new H2250LogicalChannelParameters_dynamicRTPPayloadType ( is );
		if ( hasOptionalField ( e_mediaPacketization ) )
			m_mediaPacketization = new H2250LogicalChannelParameters_mediaPacketization ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_transportCapability ) )
				m_transportCapability = new TransportCapability ( is );
			if ( hasKnownExtensionToDecode ( is, e_redundancyEncoding ) )
				m_redundancyEncoding = new RedundancyEncoding ( is );
			if ( hasKnownExtensionToDecode ( is, e_source ) )
				m_source = new TerminalLabel ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandard;
		delete m_associatedSessionID;
		delete m_mediaChannel;
		delete m_mediaGuaranteedDelivery;
		delete m_mediaControlChannel;
		delete m_mediaControlGuaranteedDelivery;
		delete m_silenceSuppression;
		delete m_destination;
		delete m_dynamicRTPPayloadType;
		delete m_mediaPacketization;
		delete m_transportCapability;
		delete m_redundancyEncoding;
		delete m_source;
		throw;
	}
}

H2250LogicalChannelParameters :: H2250LogicalChannelParameters ( ) : Asn :: Sequence ( 10, true, 3 ), m_nonStandard ( 0 ), m_associatedSessionID ( 0 ), m_mediaChannel ( 0 ), m_mediaGuaranteedDelivery ( 0 ), m_mediaControlChannel ( 0 ), m_mediaControlGuaranteedDelivery ( 0 ), m_silenceSuppression ( 0 ), m_destination ( 0 ), m_dynamicRTPPayloadType ( 0 ), m_mediaPacketization ( 0 ), m_transportCapability ( 0 ), m_redundancyEncoding ( 0 ), m_source ( 0 ) { }

H2250LogicalChannelParameters & H2250LogicalChannelParameters :: operator= ( const H2250LogicalChannelParameters & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_nonStandard, s.m_nonStandard );
	m_sessionID = s.m_sessionID;
	assignCopy ( m_associatedSessionID, s.m_associatedSessionID );
	assignCopy ( m_mediaChannel, s.m_mediaChannel );
	assignCopy ( m_mediaGuaranteedDelivery, s.m_mediaGuaranteedDelivery );
	assignCopy ( m_mediaControlChannel, s.m_mediaControlChannel );
	assignCopy ( m_mediaControlGuaranteedDelivery, s.m_mediaControlGuaranteedDelivery );
	assignCopy ( m_silenceSuppression, s.m_silenceSuppression );
	assignCopy ( m_destination, s.m_destination );
	assignCopy ( m_dynamicRTPPayloadType, s.m_dynamicRTPPayloadType );
	assignCopy ( m_mediaPacketization, s.m_mediaPacketization );
	assignCopy ( m_transportCapability, s.m_transportCapability );
	assignCopy ( m_redundancyEncoding, s.m_redundancyEncoding );
	assignCopy ( m_source, s.m_source );
	return * this;
}

H2250LogicalChannelParameters :: H2250LogicalChannelParameters ( const H2250LogicalChannelParameters & s ) : Asn :: Sequence ( s ), m_nonStandard ( 0 ), m_sessionID ( s.m_sessionID ), m_associatedSessionID ( 0 ), m_mediaChannel ( 0 ), m_mediaGuaranteedDelivery ( 0 ), m_mediaControlChannel ( 0 ), m_mediaControlGuaranteedDelivery ( 0 ), m_silenceSuppression ( 0 ), m_destination ( 0 ), m_dynamicRTPPayloadType ( 0 ), m_mediaPacketization ( 0 ), m_transportCapability ( 0 ), m_redundancyEncoding ( 0 ), m_source ( 0 ) {
	try {
		if ( s.m_nonStandard )
			m_nonStandard = new ArrayOf_NonStandardParameter ( * s.m_nonStandard );
		if ( s.m_associatedSessionID )
			m_associatedSessionID = new H2250LogicalChannelParameters_associatedSessionID ( * s.m_associatedSessionID );
		if ( s.m_mediaChannel )
			m_mediaChannel = new TransportAddress ( * s.m_mediaChannel );
		if ( s.m_mediaGuaranteedDelivery )
			m_mediaGuaranteedDelivery = new Asn :: Boolean ( * s.m_mediaGuaranteedDelivery );
		if ( s.m_mediaControlChannel )
			m_mediaControlChannel = new TransportAddress ( * s.m_mediaControlChannel );
		if ( s.m_mediaControlGuaranteedDelivery )
			m_mediaControlGuaranteedDelivery = new Asn :: Boolean ( * s.m_mediaControlGuaranteedDelivery );
		if ( s.m_silenceSuppression )
			m_silenceSuppression = new Asn :: Boolean ( * s.m_silenceSuppression );
		if ( s.m_destination )
			m_destination = new TerminalLabel ( * s.m_destination );
		if ( s.m_dynamicRTPPayloadType )
			m_dynamicRTPPayloadType = new H2250LogicalChannelParameters_dynamicRTPPayloadType ( * s.m_dynamicRTPPayloadType );
		if ( s.m_mediaPacketization )
			m_mediaPacketization = new H2250LogicalChannelParameters_mediaPacketization ( * s.m_mediaPacketization );
		if ( s.m_transportCapability )
			m_transportCapability = new TransportCapability ( * s.m_transportCapability );
		if ( s.m_redundancyEncoding )
			m_redundancyEncoding = new RedundancyEncoding ( * s.m_redundancyEncoding );
		if ( s.m_source )
			m_source = new TerminalLabel ( * s.m_source );
	} catch ( ... ) {
		delete m_nonStandard;
		delete m_associatedSessionID;
		delete m_mediaChannel;
		delete m_mediaGuaranteedDelivery;
		delete m_mediaControlChannel;
		delete m_mediaControlGuaranteedDelivery;
		delete m_silenceSuppression;
		delete m_destination;
		delete m_dynamicRTPPayloadType;
		delete m_mediaPacketization;
		delete m_transportCapability;
		delete m_redundancyEncoding;
		delete m_source;
		throw;
	}
}


void H2250LogicalChannelParameters :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandard:
			assignNew ( m_nonStandard, new ArrayOf_NonStandardParameter );
			break;
		case e_associatedSessionID:
			assignNew ( m_associatedSessionID, new H2250LogicalChannelParameters_associatedSessionID );
			break;
		case e_mediaChannel:
			assignNew ( m_mediaChannel, new TransportAddress );
			break;
		case e_mediaGuaranteedDelivery:
			assignNew ( m_mediaGuaranteedDelivery, new Asn :: Boolean );
			break;
		case e_mediaControlChannel:
			assignNew ( m_mediaControlChannel, new TransportAddress );
			break;
		case e_mediaControlGuaranteedDelivery:
			assignNew ( m_mediaControlGuaranteedDelivery, new Asn :: Boolean );
			break;
		case e_silenceSuppression:
			assignNew ( m_silenceSuppression, new Asn :: Boolean );
			break;
		case e_destination:
			assignNew ( m_destination, new TerminalLabel );
			break;
		case e_dynamicRTPPayloadType:
			assignNew ( m_dynamicRTPPayloadType, new H2250LogicalChannelParameters_dynamicRTPPayloadType );
			break;
		case e_mediaPacketization:
			assignNew ( m_mediaPacketization, new H2250LogicalChannelParameters_mediaPacketization );
			break;
		case e_transportCapability:
			assignNew ( m_transportCapability, new TransportCapability );
			break;
		case e_redundancyEncoding:
			assignNew ( m_redundancyEncoding, new RedundancyEncoding );
			break;
		case e_source:
			assignNew ( m_source, new TerminalLabel );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void H2250LogicalChannelParameters :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandard:
			delete m_nonStandard;
			m_nonStandard = 0;
			break;
		case e_associatedSessionID:
			delete m_associatedSessionID;
			m_associatedSessionID = 0;
			break;
		case e_mediaChannel:
			delete m_mediaChannel;
			m_mediaChannel = 0;
			break;
		case e_mediaGuaranteedDelivery:
			delete m_mediaGuaranteedDelivery;
			m_mediaGuaranteedDelivery = 0;
			break;
		case e_mediaControlChannel:
			delete m_mediaControlChannel;
			m_mediaControlChannel = 0;
			break;
		case e_mediaControlGuaranteedDelivery:
			delete m_mediaControlGuaranteedDelivery;
			m_mediaControlGuaranteedDelivery = 0;
			break;
		case e_silenceSuppression:
			delete m_silenceSuppression;
			m_silenceSuppression = 0;
			break;
		case e_destination:
			delete m_destination;
			m_destination = 0;
			break;
		case e_dynamicRTPPayloadType:
			delete m_dynamicRTPPayloadType;
			m_dynamicRTPPayloadType = 0;
			break;
		case e_mediaPacketization:
			delete m_mediaPacketization;
			m_mediaPacketization = 0;
			break;
		case e_transportCapability:
			delete m_transportCapability;
			m_transportCapability = 0;
			break;
		case e_redundancyEncoding:
			delete m_redundancyEncoding;
			m_redundancyEncoding = 0;
			break;
		case e_source:
			delete m_source;
			m_source = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void H2250LogicalChannelParameters :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_nonStandard ) )
		m_nonStandard -> ArrayOf_NonStandardParameter :: encode ( os );
	m_sessionID.encode ( os );
	if ( hasOptionalField ( e_associatedSessionID ) )
		m_associatedSessionID -> H2250LogicalChannelParameters_associatedSessionID :: encode ( os );
	if ( hasOptionalField ( e_mediaChannel ) )
		m_mediaChannel -> TransportAddress :: encode ( os );
	if ( hasOptionalField ( e_mediaGuaranteedDelivery ) )
		m_mediaGuaranteedDelivery -> Asn :: Boolean :: encode ( os );
	if ( hasOptionalField ( e_mediaControlChannel ) )
		m_mediaControlChannel -> TransportAddress :: encode ( os );
	if ( hasOptionalField ( e_mediaControlGuaranteedDelivery ) )
		m_mediaControlGuaranteedDelivery -> Asn :: Boolean :: encode ( os );
	if ( hasOptionalField ( e_silenceSuppression ) )
		m_silenceSuppression -> Asn :: Boolean :: encode ( os );
	if ( hasOptionalField ( e_destination ) )
		m_destination -> TerminalLabel :: encode ( os );
	if ( hasOptionalField ( e_dynamicRTPPayloadType ) )
		m_dynamicRTPPayloadType -> H2250LogicalChannelParameters_dynamicRTPPayloadType :: encode ( os );
	if ( hasOptionalField ( e_mediaPacketization ) )
		m_mediaPacketization -> H2250LogicalChannelParameters_mediaPacketization :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_transportCapability, m_transportCapability );
		knownExtensionEncode ( os, e_redundancyEncoding, m_redundancyEncoding );
		knownExtensionEncode ( os, e_source, m_source );
		unknownExtensionsEncode ( os );
	}
}

H2250LogicalChannelParameters :: ~H2250LogicalChannelParameters ( ) {
	delete m_nonStandard;
	delete m_associatedSessionID;
	delete m_mediaChannel;
	delete m_mediaGuaranteedDelivery;
	delete m_mediaControlChannel;
	delete m_mediaControlGuaranteedDelivery;
	delete m_silenceSuppression;
	delete m_destination;
	delete m_dynamicRTPPayloadType;
	delete m_mediaPacketization;
	delete m_transportCapability;
	delete m_redundancyEncoding;
	delete m_source;
}

void H2250LogicalChannelParameters :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_nonStandard ) ) {
		os << std :: setw ( indent + 14 ) << "nonStandard = " << std :: setprecision ( indent );
		m_nonStandard -> ArrayOf_NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 12 ) << "sessionID = " << std :: setprecision ( indent ) << m_sessionID << '\n';
	if ( hasOptionalField ( e_associatedSessionID ) ) {
		os << std :: setw ( indent + 22 ) << "associatedSessionID = " << std :: setprecision ( indent );
		m_associatedSessionID -> H2250LogicalChannelParameters_associatedSessionID :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_mediaChannel ) ) {
		os << std :: setw ( indent + 15 ) << "mediaChannel = " << std :: setprecision ( indent );
		m_mediaChannel -> TransportAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_mediaGuaranteedDelivery ) ) {
		os << std :: setw ( indent + 26 ) << "mediaGuaranteedDelivery = " << std :: setprecision ( indent );
		m_mediaGuaranteedDelivery -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_mediaControlChannel ) ) {
		os << std :: setw ( indent + 22 ) << "mediaControlChannel = " << std :: setprecision ( indent );
		m_mediaControlChannel -> TransportAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_mediaControlGuaranteedDelivery ) ) {
		os << std :: setw ( indent + 33 ) << "mediaControlGuaranteedDelivery = " << std :: setprecision ( indent );
		m_mediaControlGuaranteedDelivery -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_silenceSuppression ) ) {
		os << std :: setw ( indent + 21 ) << "silenceSuppression = " << std :: setprecision ( indent );
		m_silenceSuppression -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_destination ) ) {
		os << std :: setw ( indent + 14 ) << "destination = " << std :: setprecision ( indent );
		m_destination -> TerminalLabel :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_dynamicRTPPayloadType ) ) {
		os << std :: setw ( indent + 24 ) << "dynamicRTPPayloadType = " << std :: setprecision ( indent );
		m_dynamicRTPPayloadType -> H2250LogicalChannelParameters_dynamicRTPPayloadType :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_mediaPacketization ) ) {
		os << std :: setw ( indent + 21 ) << "mediaPacketization = " << std :: setprecision ( indent );
		m_mediaPacketization -> H2250LogicalChannelParameters_mediaPacketization :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_transportCapability ) ) {
		os << std :: setw ( indent + 22 ) << "transportCapability = " << std :: setprecision ( indent );
		m_transportCapability -> TransportCapability :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_redundancyEncoding ) ) {
		os << std :: setw ( indent + 21 ) << "redundancyEncoding = " << std :: setprecision ( indent );
		m_redundancyEncoding -> RedundancyEncoding :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_source ) ) {
		os << std :: setw ( indent + 9 ) << "source = " << std :: setprecision ( indent );
		m_source -> TerminalLabel :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H2250LogicalChannelParameters * H2250LogicalChannelParameters :: clone ( ) const {
	return new H2250LogicalChannelParameters ( * this );
}

//
// MultiplePayloadStream
//

MultiplePayloadStream :: MultiplePayloadStream ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_elements ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MultiplePayloadStream :: MultiplePayloadStream ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MultiplePayloadStream :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_elements.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MultiplePayloadStream :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 11 ) << "elements = " << std :: setprecision ( indent ) << m_elements << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MultiplePayloadStream * MultiplePayloadStream :: clone ( ) const {
	return new MultiplePayloadStream ( * this );
}

//
// EncryptionSync
//

EncryptionSync :: EncryptionSync ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 1 ), m_nonStandard ( hasOptionalField ( e_nonStandard ) ? pushTemporaryMember ( new NonStandardParameter ( is ) ) : 0 ), m_synchFlag ( is ), m_h235Key ( is ), m_escrowentry ( 0 ), m_genericParameter ( 0 ) {
	clearTemporaryMembers ( );
	try {
		if ( hasOptionalField ( e_escrowentry ) )
			m_escrowentry = new EncryptionSync_escrowentry ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_genericParameter ) )
				m_genericParameter = new GenericParameter ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandard;
		delete m_escrowentry;
		delete m_genericParameter;
		throw;
	}
}

EncryptionSync :: EncryptionSync ( ) : Asn :: Sequence ( 2, true, 1 ), m_nonStandard ( 0 ), m_escrowentry ( 0 ), m_genericParameter ( 0 ) { }

EncryptionSync & EncryptionSync :: operator= ( const EncryptionSync & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_nonStandard, s.m_nonStandard );
	m_synchFlag = s.m_synchFlag;
	m_h235Key = s.m_h235Key;
	assignCopy ( m_escrowentry, s.m_escrowentry );
	assignCopy ( m_genericParameter, s.m_genericParameter );
	return * this;
}

EncryptionSync :: EncryptionSync ( const EncryptionSync & s ) : Asn :: Sequence ( s ), m_nonStandard ( 0 ), m_synchFlag ( s.m_synchFlag ), m_h235Key ( s.m_h235Key ), m_escrowentry ( 0 ), m_genericParameter ( 0 ) {
	try {
		if ( s.m_nonStandard )
			m_nonStandard = new NonStandardParameter ( * s.m_nonStandard );
		if ( s.m_escrowentry )
			m_escrowentry = new EncryptionSync_escrowentry ( * s.m_escrowentry );
		if ( s.m_genericParameter )
			m_genericParameter = new GenericParameter ( * s.m_genericParameter );
	} catch ( ... ) {
		delete m_nonStandard;
		delete m_escrowentry;
		delete m_genericParameter;
		throw;
	}
}


void EncryptionSync :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandard:
			assignNew ( m_nonStandard, new NonStandardParameter );
			break;
		case e_escrowentry:
			assignNew ( m_escrowentry, new EncryptionSync_escrowentry );
			break;
		case e_genericParameter:
			assignNew ( m_genericParameter, new GenericParameter );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void EncryptionSync :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandard:
			delete m_nonStandard;
			m_nonStandard = 0;
			break;
		case e_escrowentry:
			delete m_escrowentry;
			m_escrowentry = 0;
			break;
		case e_genericParameter:
			delete m_genericParameter;
			m_genericParameter = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void EncryptionSync :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_nonStandard ) )
		m_nonStandard -> NonStandardParameter :: encode ( os );
	m_synchFlag.encode ( os );
	m_h235Key.encode ( os );
	if ( hasOptionalField ( e_escrowentry ) )
		m_escrowentry -> EncryptionSync_escrowentry :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_genericParameter, m_genericParameter );
		unknownExtensionsEncode ( os );
	}
}

EncryptionSync :: ~EncryptionSync ( ) {
	delete m_nonStandard;
	delete m_escrowentry;
	delete m_genericParameter;
}

void EncryptionSync :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_nonStandard ) ) {
		os << std :: setw ( indent + 14 ) << "nonStandard = " << std :: setprecision ( indent );
		m_nonStandard -> NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 12 ) << "synchFlag = " << std :: setprecision ( indent ) << m_synchFlag << '\n';
	os << std :: setw ( indent + 10 ) << "h235Key = " << std :: setprecision ( indent ) << m_h235Key << '\n';
	if ( hasOptionalField ( e_escrowentry ) ) {
		os << std :: setw ( indent + 14 ) << "escrowentry = " << std :: setprecision ( indent );
		m_escrowentry -> EncryptionSync_escrowentry :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_genericParameter ) ) {
		os << std :: setw ( indent + 19 ) << "genericParameter = " << std :: setprecision ( indent );
		m_genericParameter -> GenericParameter :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

EncryptionSync * EncryptionSync :: clone ( ) const {
	return new EncryptionSync ( * this );
}

//
// EscrowData
//

EscrowData :: EscrowData ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_escrowID ( is ), m_escrowValue ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

EscrowData :: EscrowData ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void EscrowData :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_escrowID.encode ( os );
	m_escrowValue.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void EscrowData :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 11 ) << "escrowID = " << std :: setprecision ( indent ) << m_escrowID << '\n';
	os << std :: setw ( indent + 14 ) << "escrowValue = " << std :: setprecision ( indent ) << m_escrowValue << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

EscrowData * EscrowData :: clone ( ) const {
	return new EscrowData ( * this );
}

//
// OpenLogicalChannelReject
//

OpenLogicalChannelReject :: OpenLogicalChannelReject ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 1 ), m_forwardLogicalChannelNumber ( is ), m_cause ( is ), m_genericInformation ( 0 ) {
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_genericInformation ) )
				m_genericInformation = new ArrayOf_GenericInformation ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_genericInformation;
		throw;
	}
}

OpenLogicalChannelReject :: OpenLogicalChannelReject ( ) : Asn :: Sequence ( 0, true, 1 ), m_genericInformation ( 0 ) { }

OpenLogicalChannelReject & OpenLogicalChannelReject :: operator= ( const OpenLogicalChannelReject & s ) {
	Asn :: Sequence :: operator= ( s );
	m_forwardLogicalChannelNumber = s.m_forwardLogicalChannelNumber;
	m_cause = s.m_cause;
	assignCopy ( m_genericInformation, s.m_genericInformation );
	return * this;
}

OpenLogicalChannelReject :: OpenLogicalChannelReject ( const OpenLogicalChannelReject & s ) : Asn :: Sequence ( s ), m_forwardLogicalChannelNumber ( s.m_forwardLogicalChannelNumber ), m_cause ( s.m_cause ), m_genericInformation ( 0 ) {
	try {
		if ( s.m_genericInformation )
			m_genericInformation = new ArrayOf_GenericInformation ( * s.m_genericInformation );
	} catch ( ... ) {
		delete m_genericInformation;
		throw;
	}
}


void OpenLogicalChannelReject :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_genericInformation:
			assignNew ( m_genericInformation, new ArrayOf_GenericInformation );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void OpenLogicalChannelReject :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_genericInformation:
			delete m_genericInformation;
			m_genericInformation = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void OpenLogicalChannelReject :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_forwardLogicalChannelNumber.encode ( os );
	m_cause.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_genericInformation, m_genericInformation );
		unknownExtensionsEncode ( os );
	}
}

OpenLogicalChannelReject :: ~OpenLogicalChannelReject ( ) {
	delete m_genericInformation;
}

void OpenLogicalChannelReject :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 30 ) << "forwardLogicalChannelNumber = " << std :: setprecision ( indent ) << m_forwardLogicalChannelNumber << '\n';
	os << std :: setw ( indent + 8 ) << "cause = " << std :: setprecision ( indent ) << m_cause << '\n';
	if ( hasOptionalField ( e_genericInformation ) ) {
		os << std :: setw ( indent + 21 ) << "genericInformation = " << std :: setprecision ( indent );
		m_genericInformation -> ArrayOf_GenericInformation :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

OpenLogicalChannelReject * OpenLogicalChannelReject :: clone ( ) const {
	return new OpenLogicalChannelReject ( * this );
}

//
// CloseLogicalChannel
//

CloseLogicalChannel :: CloseLogicalChannel ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 1 ), m_forwardLogicalChannelNumber ( is ), m_source ( is ), m_reason ( 0 ) {
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_reason ) )
				m_reason = new CloseLogicalChannel_reason ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_reason;
		throw;
	}
}

CloseLogicalChannel :: CloseLogicalChannel ( ) : Asn :: Sequence ( 0, true, 1 ), m_reason ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_reason );
		m_reason = new CloseLogicalChannel_reason;
	} catch ( ... ) {
		delete m_reason;
		throw;
	}
}

CloseLogicalChannel & CloseLogicalChannel :: operator= ( const CloseLogicalChannel & s ) {
	Asn :: Sequence :: operator= ( s );
	m_forwardLogicalChannelNumber = s.m_forwardLogicalChannelNumber;
	m_source = s.m_source;
	assignCopy ( m_reason, s.m_reason );
	return * this;
}

CloseLogicalChannel :: CloseLogicalChannel ( const CloseLogicalChannel & s ) : Asn :: Sequence ( s ), m_forwardLogicalChannelNumber ( s.m_forwardLogicalChannelNumber ), m_source ( s.m_source ), m_reason ( 0 ) {
	try {
		if ( s.m_reason )
			m_reason = new CloseLogicalChannel_reason ( * s.m_reason );
	} catch ( ... ) {
		delete m_reason;
		throw;
	}
}


void CloseLogicalChannel :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_reason:
			assignNew ( m_reason, new CloseLogicalChannel_reason );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void CloseLogicalChannel :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_reason:
			delete m_reason;
			m_reason = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void CloseLogicalChannel :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_forwardLogicalChannelNumber.encode ( os );
	m_source.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_reason, m_reason );
		unknownExtensionsEncode ( os );
	}
}

CloseLogicalChannel :: ~CloseLogicalChannel ( ) {
	delete m_reason;
}

void CloseLogicalChannel :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 30 ) << "forwardLogicalChannelNumber = " << std :: setprecision ( indent ) << m_forwardLogicalChannelNumber << '\n';
	os << std :: setw ( indent + 9 ) << "source = " << std :: setprecision ( indent ) << m_source << '\n';
	if ( hasOptionalField ( e_reason ) ) {
		os << std :: setw ( indent + 9 ) << "reason = " << std :: setprecision ( indent );
		m_reason -> CloseLogicalChannel_reason :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

CloseLogicalChannel * CloseLogicalChannel :: clone ( ) const {
	return new CloseLogicalChannel ( * this );
}

//
// RequestChannelCloseReject
//

RequestChannelCloseReject :: RequestChannelCloseReject ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_forwardLogicalChannelNumber ( is ), m_cause ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

RequestChannelCloseReject :: RequestChannelCloseReject ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void RequestChannelCloseReject :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_forwardLogicalChannelNumber.encode ( os );
	m_cause.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void RequestChannelCloseReject :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 30 ) << "forwardLogicalChannelNumber = " << std :: setprecision ( indent ) << m_forwardLogicalChannelNumber << '\n';
	os << std :: setw ( indent + 8 ) << "cause = " << std :: setprecision ( indent ) << m_cause << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RequestChannelCloseReject * RequestChannelCloseReject :: clone ( ) const {
	return new RequestChannelCloseReject ( * this );
}

//
// MultiplexEntrySend
//

MultiplexEntrySend :: MultiplexEntrySend ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_sequenceNumber ( is ), m_multiplexEntryDescriptors ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MultiplexEntrySend :: MultiplexEntrySend ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MultiplexEntrySend :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_sequenceNumber.encode ( os );
	m_multiplexEntryDescriptors.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MultiplexEntrySend :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 17 ) << "sequenceNumber = " << std :: setprecision ( indent ) << m_sequenceNumber << '\n';
	os << std :: setw ( indent + 28 ) << "multiplexEntryDescriptors = " << std :: setprecision ( indent ) << m_multiplexEntryDescriptors << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MultiplexEntrySend * MultiplexEntrySend :: clone ( ) const {
	return new MultiplexEntrySend ( * this );
}

//
// MultiplexEntryDescriptor
//

MultiplexEntryDescriptor :: MultiplexEntryDescriptor ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, false, 0 ), m_multiplexTableEntryNumber ( is ), m_elementList ( 0 ) {
	if ( hasOptionalField ( e_elementList ) )
		m_elementList = new MultiplexEntryDescriptor_elementList ( is );
}

MultiplexEntryDescriptor :: MultiplexEntryDescriptor ( ) : Asn :: Sequence ( 1, false, 0 ), m_elementList ( 0 ) { }

MultiplexEntryDescriptor & MultiplexEntryDescriptor :: operator= ( const MultiplexEntryDescriptor & s ) {
	Asn :: Sequence :: operator= ( s );
	m_multiplexTableEntryNumber = s.m_multiplexTableEntryNumber;
	assignCopy ( m_elementList, s.m_elementList );
	return * this;
}

MultiplexEntryDescriptor :: MultiplexEntryDescriptor ( const MultiplexEntryDescriptor & s ) : Asn :: Sequence ( s ), m_multiplexTableEntryNumber ( s.m_multiplexTableEntryNumber ), m_elementList ( 0 ) {
	try {
		if ( s.m_elementList )
			m_elementList = new MultiplexEntryDescriptor_elementList ( * s.m_elementList );
	} catch ( ... ) {
		delete m_elementList;
		throw;
	}
}


void MultiplexEntryDescriptor :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_elementList:
			assignNew ( m_elementList, new MultiplexEntryDescriptor_elementList );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void MultiplexEntryDescriptor :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_elementList:
			delete m_elementList;
			m_elementList = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void MultiplexEntryDescriptor :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_multiplexTableEntryNumber.encode ( os );
	if ( hasOptionalField ( e_elementList ) )
		m_elementList -> MultiplexEntryDescriptor_elementList :: encode ( os );
}

MultiplexEntryDescriptor :: ~MultiplexEntryDescriptor ( ) {
	delete m_elementList;
}

void MultiplexEntryDescriptor :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 28 ) << "multiplexTableEntryNumber = " << std :: setprecision ( indent ) << m_multiplexTableEntryNumber << '\n';
	if ( hasOptionalField ( e_elementList ) ) {
		os << std :: setw ( indent + 14 ) << "elementList = " << std :: setprecision ( indent );
		m_elementList -> MultiplexEntryDescriptor_elementList :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent - 1 ) << '}';
}

MultiplexEntryDescriptor * MultiplexEntryDescriptor :: clone ( ) const {
	return new MultiplexEntryDescriptor ( * this );
}

//
// MultiplexEntrySendAck
//

MultiplexEntrySendAck :: MultiplexEntrySendAck ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_sequenceNumber ( is ), m_multiplexTableEntryNumber ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MultiplexEntrySendAck :: MultiplexEntrySendAck ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MultiplexEntrySendAck :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_sequenceNumber.encode ( os );
	m_multiplexTableEntryNumber.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MultiplexEntrySendAck :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 17 ) << "sequenceNumber = " << std :: setprecision ( indent ) << m_sequenceNumber << '\n';
	os << std :: setw ( indent + 28 ) << "multiplexTableEntryNumber = " << std :: setprecision ( indent ) << m_multiplexTableEntryNumber << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MultiplexEntrySendAck * MultiplexEntrySendAck :: clone ( ) const {
	return new MultiplexEntrySendAck ( * this );
}

//
// MultiplexEntrySendReject
//

MultiplexEntrySendReject :: MultiplexEntrySendReject ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_sequenceNumber ( is ), m_rejectionDescriptions ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MultiplexEntrySendReject :: MultiplexEntrySendReject ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MultiplexEntrySendReject :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_sequenceNumber.encode ( os );
	m_rejectionDescriptions.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MultiplexEntrySendReject :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 17 ) << "sequenceNumber = " << std :: setprecision ( indent ) << m_sequenceNumber << '\n';
	os << std :: setw ( indent + 24 ) << "rejectionDescriptions = " << std :: setprecision ( indent ) << m_rejectionDescriptions << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MultiplexEntrySendReject * MultiplexEntrySendReject :: clone ( ) const {
	return new MultiplexEntrySendReject ( * this );
}

//
// MultiplexEntryRejectionDescriptions
//

MultiplexEntryRejectionDescriptions :: MultiplexEntryRejectionDescriptions ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_multiplexTableEntryNumber ( is ), m_cause ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MultiplexEntryRejectionDescriptions :: MultiplexEntryRejectionDescriptions ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MultiplexEntryRejectionDescriptions :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_multiplexTableEntryNumber.encode ( os );
	m_cause.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MultiplexEntryRejectionDescriptions :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 28 ) << "multiplexTableEntryNumber = " << std :: setprecision ( indent ) << m_multiplexTableEntryNumber << '\n';
	os << std :: setw ( indent + 8 ) << "cause = " << std :: setprecision ( indent ) << m_cause << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MultiplexEntryRejectionDescriptions * MultiplexEntryRejectionDescriptions :: clone ( ) const {
	return new MultiplexEntryRejectionDescriptions ( * this );
}

//
// MultiplexEntrySendRelease
//

MultiplexEntrySendRelease :: MultiplexEntrySendRelease ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_multiplexTableEntryNumber ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MultiplexEntrySendRelease :: MultiplexEntrySendRelease ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MultiplexEntrySendRelease :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_multiplexTableEntryNumber.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MultiplexEntrySendRelease :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 28 ) << "multiplexTableEntryNumber = " << std :: setprecision ( indent ) << m_multiplexTableEntryNumber << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MultiplexEntrySendRelease * MultiplexEntrySendRelease :: clone ( ) const {
	return new MultiplexEntrySendRelease ( * this );
}

//
// RequestMultiplexEntry
//

RequestMultiplexEntry :: RequestMultiplexEntry ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_entryNumbers ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

RequestMultiplexEntry :: RequestMultiplexEntry ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void RequestMultiplexEntry :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_entryNumbers.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void RequestMultiplexEntry :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 15 ) << "entryNumbers = " << std :: setprecision ( indent ) << m_entryNumbers << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RequestMultiplexEntry * RequestMultiplexEntry :: clone ( ) const {
	return new RequestMultiplexEntry ( * this );
}

//
// RequestMultiplexEntryAck
//

RequestMultiplexEntryAck :: RequestMultiplexEntryAck ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_entryNumbers ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

RequestMultiplexEntryAck :: RequestMultiplexEntryAck ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void RequestMultiplexEntryAck :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_entryNumbers.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void RequestMultiplexEntryAck :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 15 ) << "entryNumbers = " << std :: setprecision ( indent ) << m_entryNumbers << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RequestMultiplexEntryAck * RequestMultiplexEntryAck :: clone ( ) const {
	return new RequestMultiplexEntryAck ( * this );
}

//
// RequestMultiplexEntryReject
//

RequestMultiplexEntryReject :: RequestMultiplexEntryReject ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_entryNumbers ( is ), m_rejectionDescriptions ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

RequestMultiplexEntryReject :: RequestMultiplexEntryReject ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void RequestMultiplexEntryReject :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_entryNumbers.encode ( os );
	m_rejectionDescriptions.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void RequestMultiplexEntryReject :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 15 ) << "entryNumbers = " << std :: setprecision ( indent ) << m_entryNumbers << '\n';
	os << std :: setw ( indent + 24 ) << "rejectionDescriptions = " << std :: setprecision ( indent ) << m_rejectionDescriptions << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RequestMultiplexEntryReject * RequestMultiplexEntryReject :: clone ( ) const {
	return new RequestMultiplexEntryReject ( * this );
}

//
// RequestMultiplexEntryRejectionDescriptions
//

RequestMultiplexEntryRejectionDescriptions :: RequestMultiplexEntryRejectionDescriptions ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_multiplexTableEntryNumber ( is ), m_cause ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

RequestMultiplexEntryRejectionDescriptions :: RequestMultiplexEntryRejectionDescriptions ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void RequestMultiplexEntryRejectionDescriptions :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_multiplexTableEntryNumber.encode ( os );
	m_cause.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void RequestMultiplexEntryRejectionDescriptions :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 28 ) << "multiplexTableEntryNumber = " << std :: setprecision ( indent ) << m_multiplexTableEntryNumber << '\n';
	os << std :: setw ( indent + 8 ) << "cause = " << std :: setprecision ( indent ) << m_cause << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RequestMultiplexEntryRejectionDescriptions * RequestMultiplexEntryRejectionDescriptions :: clone ( ) const {
	return new RequestMultiplexEntryRejectionDescriptions ( * this );
}

//
// RequestMultiplexEntryRelease
//

RequestMultiplexEntryRelease :: RequestMultiplexEntryRelease ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_entryNumbers ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

RequestMultiplexEntryRelease :: RequestMultiplexEntryRelease ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void RequestMultiplexEntryRelease :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_entryNumbers.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void RequestMultiplexEntryRelease :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 15 ) << "entryNumbers = " << std :: setprecision ( indent ) << m_entryNumbers << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RequestMultiplexEntryRelease * RequestMultiplexEntryRelease :: clone ( ) const {
	return new RequestMultiplexEntryRelease ( * this );
}

//
// RequestMode
//

RequestMode :: RequestMode ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_sequenceNumber ( is ), m_requestedModes ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

RequestMode :: RequestMode ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void RequestMode :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_sequenceNumber.encode ( os );
	m_requestedModes.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void RequestMode :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 17 ) << "sequenceNumber = " << std :: setprecision ( indent ) << m_sequenceNumber << '\n';
	os << std :: setw ( indent + 17 ) << "requestedModes = " << std :: setprecision ( indent ) << m_requestedModes << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RequestMode * RequestMode :: clone ( ) const {
	return new RequestMode ( * this );
}

//
// RequestModeAck
//

RequestModeAck :: RequestModeAck ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_sequenceNumber ( is ), m_response ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

RequestModeAck :: RequestModeAck ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void RequestModeAck :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_sequenceNumber.encode ( os );
	m_response.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void RequestModeAck :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 17 ) << "sequenceNumber = " << std :: setprecision ( indent ) << m_sequenceNumber << '\n';
	os << std :: setw ( indent + 11 ) << "response = " << std :: setprecision ( indent ) << m_response << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RequestModeAck * RequestModeAck :: clone ( ) const {
	return new RequestModeAck ( * this );
}

//
// RequestModeReject
//

RequestModeReject :: RequestModeReject ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_sequenceNumber ( is ), m_cause ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

RequestModeReject :: RequestModeReject ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void RequestModeReject :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_sequenceNumber.encode ( os );
	m_cause.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void RequestModeReject :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 17 ) << "sequenceNumber = " << std :: setprecision ( indent ) << m_sequenceNumber << '\n';
	os << std :: setw ( indent + 8 ) << "cause = " << std :: setprecision ( indent ) << m_cause << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RequestModeReject * RequestModeReject :: clone ( ) const {
	return new RequestModeReject ( * this );
}

//
// MultiplePayloadStreamMode
//

MultiplePayloadStreamMode :: MultiplePayloadStreamMode ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_elements ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MultiplePayloadStreamMode :: MultiplePayloadStreamMode ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MultiplePayloadStreamMode :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_elements.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MultiplePayloadStreamMode :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 11 ) << "elements = " << std :: setprecision ( indent ) << m_elements << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MultiplePayloadStreamMode * MultiplePayloadStreamMode :: clone ( ) const {
	return new MultiplePayloadStreamMode ( * this );
}

//
// H261VideoMode
//

H261VideoMode :: H261VideoMode ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_resolution ( is ), m_bitRate ( is ), m_stillImageTransmission ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

H261VideoMode :: H261VideoMode ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void H261VideoMode :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_resolution.encode ( os );
	m_bitRate.encode ( os );
	m_stillImageTransmission.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void H261VideoMode :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 13 ) << "resolution = " << std :: setprecision ( indent ) << m_resolution << '\n';
	os << std :: setw ( indent + 10 ) << "bitRate = " << std :: setprecision ( indent ) << m_bitRate << '\n';
	os << std :: setw ( indent + 25 ) << "stillImageTransmission = " << std :: setprecision ( indent ) << m_stillImageTransmission << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H261VideoMode * H261VideoMode :: clone ( ) const {
	return new H261VideoMode ( * this );
}

//
// H262VideoMode
//

H262VideoMode :: H262VideoMode ( Asn :: istream & is ) : Asn :: Sequence ( is, 6, true, 0 ), m_profileAndLevel ( is ), m_videoBitRate ( 0 ), m_vbvBufferSize ( 0 ), m_samplesPerLine ( 0 ), m_linesPerFrame ( 0 ), m_framesPerSecond ( 0 ), m_luminanceSampleRate ( 0 ) {
	try {
		if ( hasOptionalField ( e_videoBitRate ) )
			m_videoBitRate = new H262VideoMode_videoBitRate ( is );
		if ( hasOptionalField ( e_vbvBufferSize ) )
			m_vbvBufferSize = new H262VideoMode_vbvBufferSize ( is );
		if ( hasOptionalField ( e_samplesPerLine ) )
			m_samplesPerLine = new H262VideoMode_samplesPerLine ( is );
		if ( hasOptionalField ( e_linesPerFrame ) )
			m_linesPerFrame = new H262VideoMode_linesPerFrame ( is );
		if ( hasOptionalField ( e_framesPerSecond ) )
			m_framesPerSecond = new H262VideoMode_framesPerSecond ( is );
		if ( hasOptionalField ( e_luminanceSampleRate ) )
			m_luminanceSampleRate = new H262VideoMode_luminanceSampleRate ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_videoBitRate;
		delete m_vbvBufferSize;
		delete m_samplesPerLine;
		delete m_linesPerFrame;
		delete m_framesPerSecond;
		delete m_luminanceSampleRate;
		throw;
	}
}

H262VideoMode :: H262VideoMode ( ) : Asn :: Sequence ( 6, true, 0 ), m_videoBitRate ( 0 ), m_vbvBufferSize ( 0 ), m_samplesPerLine ( 0 ), m_linesPerFrame ( 0 ), m_framesPerSecond ( 0 ), m_luminanceSampleRate ( 0 ) { }

H262VideoMode & H262VideoMode :: operator= ( const H262VideoMode & s ) {
	Asn :: Sequence :: operator= ( s );
	m_profileAndLevel = s.m_profileAndLevel;
	assignCopy ( m_videoBitRate, s.m_videoBitRate );
	assignCopy ( m_vbvBufferSize, s.m_vbvBufferSize );
	assignCopy ( m_samplesPerLine, s.m_samplesPerLine );
	assignCopy ( m_linesPerFrame, s.m_linesPerFrame );
	assignCopy ( m_framesPerSecond, s.m_framesPerSecond );
	assignCopy ( m_luminanceSampleRate, s.m_luminanceSampleRate );
	return * this;
}

H262VideoMode :: H262VideoMode ( const H262VideoMode & s ) : Asn :: Sequence ( s ), m_profileAndLevel ( s.m_profileAndLevel ), m_videoBitRate ( 0 ), m_vbvBufferSize ( 0 ), m_samplesPerLine ( 0 ), m_linesPerFrame ( 0 ), m_framesPerSecond ( 0 ), m_luminanceSampleRate ( 0 ) {
	try {
		if ( s.m_videoBitRate )
			m_videoBitRate = new H262VideoMode_videoBitRate ( * s.m_videoBitRate );
		if ( s.m_vbvBufferSize )
			m_vbvBufferSize = new H262VideoMode_vbvBufferSize ( * s.m_vbvBufferSize );
		if ( s.m_samplesPerLine )
			m_samplesPerLine = new H262VideoMode_samplesPerLine ( * s.m_samplesPerLine );
		if ( s.m_linesPerFrame )
			m_linesPerFrame = new H262VideoMode_linesPerFrame ( * s.m_linesPerFrame );
		if ( s.m_framesPerSecond )
			m_framesPerSecond = new H262VideoMode_framesPerSecond ( * s.m_framesPerSecond );
		if ( s.m_luminanceSampleRate )
			m_luminanceSampleRate = new H262VideoMode_luminanceSampleRate ( * s.m_luminanceSampleRate );
	} catch ( ... ) {
		delete m_videoBitRate;
		delete m_vbvBufferSize;
		delete m_samplesPerLine;
		delete m_linesPerFrame;
		delete m_framesPerSecond;
		delete m_luminanceSampleRate;
		throw;
	}
}


void H262VideoMode :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_videoBitRate:
			assignNew ( m_videoBitRate, new H262VideoMode_videoBitRate );
			break;
		case e_vbvBufferSize:
			assignNew ( m_vbvBufferSize, new H262VideoMode_vbvBufferSize );
			break;
		case e_samplesPerLine:
			assignNew ( m_samplesPerLine, new H262VideoMode_samplesPerLine );
			break;
		case e_linesPerFrame:
			assignNew ( m_linesPerFrame, new H262VideoMode_linesPerFrame );
			break;
		case e_framesPerSecond:
			assignNew ( m_framesPerSecond, new H262VideoMode_framesPerSecond );
			break;
		case e_luminanceSampleRate:
			assignNew ( m_luminanceSampleRate, new H262VideoMode_luminanceSampleRate );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void H262VideoMode :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_videoBitRate:
			delete m_videoBitRate;
			m_videoBitRate = 0;
			break;
		case e_vbvBufferSize:
			delete m_vbvBufferSize;
			m_vbvBufferSize = 0;
			break;
		case e_samplesPerLine:
			delete m_samplesPerLine;
			m_samplesPerLine = 0;
			break;
		case e_linesPerFrame:
			delete m_linesPerFrame;
			m_linesPerFrame = 0;
			break;
		case e_framesPerSecond:
			delete m_framesPerSecond;
			m_framesPerSecond = 0;
			break;
		case e_luminanceSampleRate:
			delete m_luminanceSampleRate;
			m_luminanceSampleRate = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void H262VideoMode :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_profileAndLevel.encode ( os );
	if ( hasOptionalField ( e_videoBitRate ) )
		m_videoBitRate -> H262VideoMode_videoBitRate :: encode ( os );
	if ( hasOptionalField ( e_vbvBufferSize ) )
		m_vbvBufferSize -> H262VideoMode_vbvBufferSize :: encode ( os );
	if ( hasOptionalField ( e_samplesPerLine ) )
		m_samplesPerLine -> H262VideoMode_samplesPerLine :: encode ( os );
	if ( hasOptionalField ( e_linesPerFrame ) )
		m_linesPerFrame -> H262VideoMode_linesPerFrame :: encode ( os );
	if ( hasOptionalField ( e_framesPerSecond ) )
		m_framesPerSecond -> H262VideoMode_framesPerSecond :: encode ( os );
	if ( hasOptionalField ( e_luminanceSampleRate ) )
		m_luminanceSampleRate -> H262VideoMode_luminanceSampleRate :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

H262VideoMode :: ~H262VideoMode ( ) {
	delete m_videoBitRate;
	delete m_vbvBufferSize;
	delete m_samplesPerLine;
	delete m_linesPerFrame;
	delete m_framesPerSecond;
	delete m_luminanceSampleRate;
}

void H262VideoMode :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 18 ) << "profileAndLevel = " << std :: setprecision ( indent ) << m_profileAndLevel << '\n';
	if ( hasOptionalField ( e_videoBitRate ) ) {
		os << std :: setw ( indent + 15 ) << "videoBitRate = " << std :: setprecision ( indent );
		m_videoBitRate -> H262VideoMode_videoBitRate :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_vbvBufferSize ) ) {
		os << std :: setw ( indent + 16 ) << "vbvBufferSize = " << std :: setprecision ( indent );
		m_vbvBufferSize -> H262VideoMode_vbvBufferSize :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_samplesPerLine ) ) {
		os << std :: setw ( indent + 17 ) << "samplesPerLine = " << std :: setprecision ( indent );
		m_samplesPerLine -> H262VideoMode_samplesPerLine :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_linesPerFrame ) ) {
		os << std :: setw ( indent + 16 ) << "linesPerFrame = " << std :: setprecision ( indent );
		m_linesPerFrame -> H262VideoMode_linesPerFrame :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_framesPerSecond ) ) {
		os << std :: setw ( indent + 18 ) << "framesPerSecond = " << std :: setprecision ( indent );
		m_framesPerSecond -> H262VideoMode_framesPerSecond :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_luminanceSampleRate ) ) {
		os << std :: setw ( indent + 22 ) << "luminanceSampleRate = " << std :: setprecision ( indent );
		m_luminanceSampleRate -> H262VideoMode_luminanceSampleRate :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H262VideoMode * H262VideoMode :: clone ( ) const {
	return new H262VideoMode ( * this );
}

//
// H263VideoMode
//

H263VideoMode :: H263VideoMode ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 3 ), m_resolution ( is ), m_bitRate ( is ), m_unrestrictedVector ( is ), m_arithmeticCoding ( is ), m_advancedPrediction ( is ), m_pbFrames ( is ), m_errorCompensation ( 0 ), m_enhancementLayerInfo ( 0 ), m_h263Options ( 0 ) {
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_errorCompensation ) )
				m_errorCompensation = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_enhancementLayerInfo ) )
				m_enhancementLayerInfo = new EnhancementLayerInfo ( is );
			if ( hasKnownExtensionToDecode ( is, e_h263Options ) )
				m_h263Options = new H263Options ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_errorCompensation;
		delete m_enhancementLayerInfo;
		delete m_h263Options;
		throw;
	}
}

H263VideoMode :: H263VideoMode ( ) : Asn :: Sequence ( 0, true, 3 ), m_errorCompensation ( 0 ), m_enhancementLayerInfo ( 0 ), m_h263Options ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_errorCompensation );
		m_errorCompensation = new Asn :: Boolean;
	} catch ( ... ) {
		delete m_errorCompensation;
		throw;
	}
}

H263VideoMode & H263VideoMode :: operator= ( const H263VideoMode & s ) {
	Asn :: Sequence :: operator= ( s );
	m_resolution = s.m_resolution;
	m_bitRate = s.m_bitRate;
	m_unrestrictedVector = s.m_unrestrictedVector;
	m_arithmeticCoding = s.m_arithmeticCoding;
	m_advancedPrediction = s.m_advancedPrediction;
	m_pbFrames = s.m_pbFrames;
	assignCopy ( m_errorCompensation, s.m_errorCompensation );
	assignCopy ( m_enhancementLayerInfo, s.m_enhancementLayerInfo );
	assignCopy ( m_h263Options, s.m_h263Options );
	return * this;
}

H263VideoMode :: H263VideoMode ( const H263VideoMode & s ) : Asn :: Sequence ( s ), m_resolution ( s.m_resolution ), m_bitRate ( s.m_bitRate ), m_unrestrictedVector ( s.m_unrestrictedVector ), m_arithmeticCoding ( s.m_arithmeticCoding ), m_advancedPrediction ( s.m_advancedPrediction ), m_pbFrames ( s.m_pbFrames ), m_errorCompensation ( 0 ), m_enhancementLayerInfo ( 0 ), m_h263Options ( 0 ) {
	try {
		if ( s.m_errorCompensation )
			m_errorCompensation = new Asn :: Boolean ( * s.m_errorCompensation );
		if ( s.m_enhancementLayerInfo )
			m_enhancementLayerInfo = new EnhancementLayerInfo ( * s.m_enhancementLayerInfo );
		if ( s.m_h263Options )
			m_h263Options = new H263Options ( * s.m_h263Options );
	} catch ( ... ) {
		delete m_errorCompensation;
		delete m_enhancementLayerInfo;
		delete m_h263Options;
		throw;
	}
}


void H263VideoMode :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_errorCompensation:
			assignNew ( m_errorCompensation, new Asn :: Boolean );
			break;
		case e_enhancementLayerInfo:
			assignNew ( m_enhancementLayerInfo, new EnhancementLayerInfo );
			break;
		case e_h263Options:
			assignNew ( m_h263Options, new H263Options );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void H263VideoMode :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_errorCompensation:
			delete m_errorCompensation;
			m_errorCompensation = 0;
			break;
		case e_enhancementLayerInfo:
			delete m_enhancementLayerInfo;
			m_enhancementLayerInfo = 0;
			break;
		case e_h263Options:
			delete m_h263Options;
			m_h263Options = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void H263VideoMode :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_resolution.encode ( os );
	m_bitRate.encode ( os );
	m_unrestrictedVector.encode ( os );
	m_arithmeticCoding.encode ( os );
	m_advancedPrediction.encode ( os );
	m_pbFrames.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_errorCompensation, m_errorCompensation );
		knownExtensionEncode ( os, e_enhancementLayerInfo, m_enhancementLayerInfo );
		knownExtensionEncode ( os, e_h263Options, m_h263Options );
		unknownExtensionsEncode ( os );
	}
}

H263VideoMode :: ~H263VideoMode ( ) {
	delete m_errorCompensation;
	delete m_enhancementLayerInfo;
	delete m_h263Options;
}

void H263VideoMode :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 13 ) << "resolution = " << std :: setprecision ( indent ) << m_resolution << '\n';
	os << std :: setw ( indent + 10 ) << "bitRate = " << std :: setprecision ( indent ) << m_bitRate << '\n';
	os << std :: setw ( indent + 21 ) << "unrestrictedVector = " << std :: setprecision ( indent ) << m_unrestrictedVector << '\n';
	os << std :: setw ( indent + 19 ) << "arithmeticCoding = " << std :: setprecision ( indent ) << m_arithmeticCoding << '\n';
	os << std :: setw ( indent + 21 ) << "advancedPrediction = " << std :: setprecision ( indent ) << m_advancedPrediction << '\n';
	os << std :: setw ( indent + 11 ) << "pbFrames = " << std :: setprecision ( indent ) << m_pbFrames << '\n';
	if ( hasOptionalField ( e_errorCompensation ) ) {
		os << std :: setw ( indent + 20 ) << "errorCompensation = " << std :: setprecision ( indent );
		m_errorCompensation -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_enhancementLayerInfo ) ) {
		os << std :: setw ( indent + 23 ) << "enhancementLayerInfo = " << std :: setprecision ( indent );
		m_enhancementLayerInfo -> EnhancementLayerInfo :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_h263Options ) ) {
		os << std :: setw ( indent + 14 ) << "h263Options = " << std :: setprecision ( indent );
		m_h263Options -> H263Options :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H263VideoMode * H263VideoMode :: clone ( ) const {
	return new H263VideoMode ( * this );
}

//
// IS11172AudioMode
//

IS11172AudioMode :: IS11172AudioMode ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_audioLayer ( is ), m_audioSampling ( is ), m_multichannelType ( is ), m_bitRate ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

IS11172AudioMode :: IS11172AudioMode ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void IS11172AudioMode :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_audioLayer.encode ( os );
	m_audioSampling.encode ( os );
	m_multichannelType.encode ( os );
	m_bitRate.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void IS11172AudioMode :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 13 ) << "audioLayer = " << std :: setprecision ( indent ) << m_audioLayer << '\n';
	os << std :: setw ( indent + 16 ) << "audioSampling = " << std :: setprecision ( indent ) << m_audioSampling << '\n';
	os << std :: setw ( indent + 19 ) << "multichannelType = " << std :: setprecision ( indent ) << m_multichannelType << '\n';
	os << std :: setw ( indent + 10 ) << "bitRate = " << std :: setprecision ( indent ) << m_bitRate << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

IS11172AudioMode * IS11172AudioMode :: clone ( ) const {
	return new IS11172AudioMode ( * this );
}

//
// IS13818AudioMode
//

IS13818AudioMode :: IS13818AudioMode ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_audioLayer ( is ), m_audioSampling ( is ), m_multichannelType ( is ), m_lowFrequencyEnhancement ( is ), m_multilingual ( is ), m_bitRate ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

IS13818AudioMode :: IS13818AudioMode ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void IS13818AudioMode :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_audioLayer.encode ( os );
	m_audioSampling.encode ( os );
	m_multichannelType.encode ( os );
	m_lowFrequencyEnhancement.encode ( os );
	m_multilingual.encode ( os );
	m_bitRate.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void IS13818AudioMode :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 13 ) << "audioLayer = " << std :: setprecision ( indent ) << m_audioLayer << '\n';
	os << std :: setw ( indent + 16 ) << "audioSampling = " << std :: setprecision ( indent ) << m_audioSampling << '\n';
	os << std :: setw ( indent + 19 ) << "multichannelType = " << std :: setprecision ( indent ) << m_multichannelType << '\n';
	os << std :: setw ( indent + 26 ) << "lowFrequencyEnhancement = " << std :: setprecision ( indent ) << m_lowFrequencyEnhancement << '\n';
	os << std :: setw ( indent + 15 ) << "multilingual = " << std :: setprecision ( indent ) << m_multilingual << '\n';
	os << std :: setw ( indent + 10 ) << "bitRate = " << std :: setprecision ( indent ) << m_bitRate << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

IS13818AudioMode * IS13818AudioMode :: clone ( ) const {
	return new IS13818AudioMode ( * this );
}

//
// MaintenanceLoopRequest
//

MaintenanceLoopRequest :: MaintenanceLoopRequest ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_type ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MaintenanceLoopRequest :: MaintenanceLoopRequest ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MaintenanceLoopRequest :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_type.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MaintenanceLoopRequest :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 7 ) << "type = " << std :: setprecision ( indent ) << m_type << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MaintenanceLoopRequest * MaintenanceLoopRequest :: clone ( ) const {
	return new MaintenanceLoopRequest ( * this );
}

//
// MaintenanceLoopAck
//

MaintenanceLoopAck :: MaintenanceLoopAck ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_type ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MaintenanceLoopAck :: MaintenanceLoopAck ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MaintenanceLoopAck :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_type.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MaintenanceLoopAck :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 7 ) << "type = " << std :: setprecision ( indent ) << m_type << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MaintenanceLoopAck * MaintenanceLoopAck :: clone ( ) const {
	return new MaintenanceLoopAck ( * this );
}

//
// MaintenanceLoopReject
//

MaintenanceLoopReject :: MaintenanceLoopReject ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_type ( is ), m_cause ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MaintenanceLoopReject :: MaintenanceLoopReject ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MaintenanceLoopReject :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_type.encode ( os );
	m_cause.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MaintenanceLoopReject :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 7 ) << "type = " << std :: setprecision ( indent ) << m_type << '\n';
	os << std :: setw ( indent + 8 ) << "cause = " << std :: setprecision ( indent ) << m_cause << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MaintenanceLoopReject * MaintenanceLoopReject :: clone ( ) const {
	return new MaintenanceLoopReject ( * this );
}

//
// CommunicationModeCommand
//

CommunicationModeCommand :: CommunicationModeCommand ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_communicationModeTable ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

CommunicationModeCommand :: CommunicationModeCommand ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void CommunicationModeCommand :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_communicationModeTable.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void CommunicationModeCommand :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 25 ) << "communicationModeTable = " << std :: setprecision ( indent ) << m_communicationModeTable << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

CommunicationModeCommand * CommunicationModeCommand :: clone ( ) const {
	return new CommunicationModeCommand ( * this );
}

//
// CommunicationModeResponse
//

CommunicationModeResponse :: CommunicationModeResponse ( Asn :: istream & is ) : Asn :: Choice ( is, 1, true ) {
	switch ( tag ) {
		case e_communicationModeTable:
			choice = new CommunicationModeResponse_communicationModeTable ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

CommunicationModeResponse :: CommunicationModeResponse ( ) : Asn :: Choice ( 1, true ) { }

void CommunicationModeResponse :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_communicationModeTable:
			o = new CommunicationModeResponse_communicationModeTable;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & CommunicationModeResponse :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_communicationModeTable, "communicationModeTable" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

CommunicationModeResponse * CommunicationModeResponse :: clone ( ) const {
	return new CommunicationModeResponse ( * this );
}

//
// Criteria
//

Criteria :: Criteria ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_field ( is ), m_value ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

Criteria :: Criteria ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void Criteria :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_field.encode ( os );
	m_value.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void Criteria :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 8 ) << "field = " << std :: setprecision ( indent ) << m_field << '\n';
	os << std :: setw ( indent + 8 ) << "value = " << std :: setprecision ( indent ) << m_value << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

Criteria * Criteria :: clone ( ) const {
	return new Criteria ( * this );
}

//
// TerminalLabel
//

TerminalLabel :: TerminalLabel ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_mcuNumber ( is ), m_terminalNumber ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

TerminalLabel :: TerminalLabel ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void TerminalLabel :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_mcuNumber.encode ( os );
	m_terminalNumber.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void TerminalLabel :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 12 ) << "mcuNumber = " << std :: setprecision ( indent ) << m_mcuNumber << '\n';
	os << std :: setw ( indent + 17 ) << "terminalNumber = " << std :: setprecision ( indent ) << m_terminalNumber << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

TerminalLabel * TerminalLabel :: clone ( ) const {
	return new TerminalLabel ( * this );
}

//
// RequestAllTerminalIDsResponse
//

RequestAllTerminalIDsResponse :: RequestAllTerminalIDsResponse ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_terminalInformation ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

RequestAllTerminalIDsResponse :: RequestAllTerminalIDsResponse ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void RequestAllTerminalIDsResponse :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_terminalInformation.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void RequestAllTerminalIDsResponse :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 22 ) << "terminalInformation = " << std :: setprecision ( indent ) << m_terminalInformation << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RequestAllTerminalIDsResponse * RequestAllTerminalIDsResponse :: clone ( ) const {
	return new RequestAllTerminalIDsResponse ( * this );
}

//
// TerminalInformation
//

TerminalInformation :: TerminalInformation ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_terminalLabel ( is ), m_terminalID ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

TerminalInformation :: TerminalInformation ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void TerminalInformation :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_terminalLabel.encode ( os );
	m_terminalID.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void TerminalInformation :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "terminalLabel = " << std :: setprecision ( indent ) << m_terminalLabel << '\n';
	os << std :: setw ( indent + 13 ) << "terminalID = " << std :: setprecision ( indent ) << m_terminalID << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

TerminalInformation * TerminalInformation :: clone ( ) const {
	return new TerminalInformation ( * this );
}

//
// RemoteMCResponse
//

RemoteMCResponse :: RemoteMCResponse ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_accept:
			choice = new Asn :: Null ( is );
			break;
		case e_reject:
			choice = new RemoteMCResponse_reject ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

RemoteMCResponse :: RemoteMCResponse ( ) : Asn :: Choice ( 2, true ) { }

void RemoteMCResponse :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_accept:
			o = new Asn :: Null;
			break;
		case e_reject:
			o = new RemoteMCResponse_reject;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & RemoteMCResponse :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_accept, "accept" },
		{ e_reject, "reject" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

RemoteMCResponse * RemoteMCResponse :: clone ( ) const {
	return new RemoteMCResponse ( * this );
}

//
// DialingInformationNumber
//

DialingInformationNumber :: DialingInformationNumber ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_networkAddress ( is ), m_subAddress ( hasOptionalField ( e_subAddress ) ? pushTemporaryMember ( new DialingInformationNumber_subAddress ( is ) ) : 0 ), m_networkType ( is ) {
	clearTemporaryMembers ( );
	try {
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_subAddress;
		throw;
	}
}

DialingInformationNumber :: DialingInformationNumber ( ) : Asn :: Sequence ( 1, true, 0 ), m_subAddress ( 0 ) { }

DialingInformationNumber & DialingInformationNumber :: operator= ( const DialingInformationNumber & s ) {
	Asn :: Sequence :: operator= ( s );
	m_networkAddress = s.m_networkAddress;
	assignCopy ( m_subAddress, s.m_subAddress );
	m_networkType = s.m_networkType;
	return * this;
}

DialingInformationNumber :: DialingInformationNumber ( const DialingInformationNumber & s ) : Asn :: Sequence ( s ), m_networkAddress ( s.m_networkAddress ), m_subAddress ( 0 ), m_networkType ( s.m_networkType ) {
	try {
		if ( s.m_subAddress )
			m_subAddress = new DialingInformationNumber_subAddress ( * s.m_subAddress );
	} catch ( ... ) {
		delete m_subAddress;
		throw;
	}
}


void DialingInformationNumber :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_subAddress:
			assignNew ( m_subAddress, new DialingInformationNumber_subAddress );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void DialingInformationNumber :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_subAddress:
			delete m_subAddress;
			m_subAddress = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void DialingInformationNumber :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_networkAddress.encode ( os );
	if ( hasOptionalField ( e_subAddress ) )
		m_subAddress -> DialingInformationNumber_subAddress :: encode ( os );
	m_networkType.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

DialingInformationNumber :: ~DialingInformationNumber ( ) {
	delete m_subAddress;
}

void DialingInformationNumber :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 17 ) << "networkAddress = " << std :: setprecision ( indent ) << m_networkAddress << '\n';
	if ( hasOptionalField ( e_subAddress ) ) {
		os << std :: setw ( indent + 13 ) << "subAddress = " << std :: setprecision ( indent );
		m_subAddress -> DialingInformationNumber_subAddress :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 14 ) << "networkType = " << std :: setprecision ( indent ) << m_networkType << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

DialingInformationNumber * DialingInformationNumber :: clone ( ) const {
	return new DialingInformationNumber ( * this );
}

//
// ConnectionIdentifier
//

ConnectionIdentifier :: ConnectionIdentifier ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_channelTag ( is ), m_sequenceNumber ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

ConnectionIdentifier :: ConnectionIdentifier ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void ConnectionIdentifier :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_channelTag.encode ( os );
	m_sequenceNumber.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void ConnectionIdentifier :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 13 ) << "channelTag = " << std :: setprecision ( indent ) << m_channelTag << '\n';
	os << std :: setw ( indent + 17 ) << "sequenceNumber = " << std :: setprecision ( indent ) << m_sequenceNumber << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

ConnectionIdentifier * ConnectionIdentifier :: clone ( ) const {
	return new ConnectionIdentifier ( * this );
}

//
// LogicalChannelRateReject
//

LogicalChannelRateReject :: LogicalChannelRateReject ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_sequenceNumber ( is ), m_logicalChannelNumber ( is ), m_rejectReason ( is ), m_currentMaximumBitRate ( 0 ) {
	try {
		if ( hasOptionalField ( e_currentMaximumBitRate ) )
			m_currentMaximumBitRate = new MaximumBitRate ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_currentMaximumBitRate;
		throw;
	}
}

LogicalChannelRateReject :: LogicalChannelRateReject ( ) : Asn :: Sequence ( 1, true, 0 ), m_currentMaximumBitRate ( 0 ) { }

LogicalChannelRateReject & LogicalChannelRateReject :: operator= ( const LogicalChannelRateReject & s ) {
	Asn :: Sequence :: operator= ( s );
	m_sequenceNumber = s.m_sequenceNumber;
	m_logicalChannelNumber = s.m_logicalChannelNumber;
	m_rejectReason = s.m_rejectReason;
	assignCopy ( m_currentMaximumBitRate, s.m_currentMaximumBitRate );
	return * this;
}

LogicalChannelRateReject :: LogicalChannelRateReject ( const LogicalChannelRateReject & s ) : Asn :: Sequence ( s ), m_sequenceNumber ( s.m_sequenceNumber ), m_logicalChannelNumber ( s.m_logicalChannelNumber ), m_rejectReason ( s.m_rejectReason ), m_currentMaximumBitRate ( 0 ) {
	try {
		if ( s.m_currentMaximumBitRate )
			m_currentMaximumBitRate = new MaximumBitRate ( * s.m_currentMaximumBitRate );
	} catch ( ... ) {
		delete m_currentMaximumBitRate;
		throw;
	}
}


void LogicalChannelRateReject :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_currentMaximumBitRate:
			assignNew ( m_currentMaximumBitRate, new MaximumBitRate );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void LogicalChannelRateReject :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_currentMaximumBitRate:
			delete m_currentMaximumBitRate;
			m_currentMaximumBitRate = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void LogicalChannelRateReject :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_sequenceNumber.encode ( os );
	m_logicalChannelNumber.encode ( os );
	m_rejectReason.encode ( os );
	if ( hasOptionalField ( e_currentMaximumBitRate ) )
		m_currentMaximumBitRate -> MaximumBitRate :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

LogicalChannelRateReject :: ~LogicalChannelRateReject ( ) {
	delete m_currentMaximumBitRate;
}

void LogicalChannelRateReject :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 17 ) << "sequenceNumber = " << std :: setprecision ( indent ) << m_sequenceNumber << '\n';
	os << std :: setw ( indent + 23 ) << "logicalChannelNumber = " << std :: setprecision ( indent ) << m_logicalChannelNumber << '\n';
	os << std :: setw ( indent + 15 ) << "rejectReason = " << std :: setprecision ( indent ) << m_rejectReason << '\n';
	if ( hasOptionalField ( e_currentMaximumBitRate ) ) {
		os << std :: setw ( indent + 24 ) << "currentMaximumBitRate = " << std :: setprecision ( indent );
		m_currentMaximumBitRate -> MaximumBitRate :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

LogicalChannelRateReject * LogicalChannelRateReject :: clone ( ) const {
	return new LogicalChannelRateReject ( * this );
}

//
// SendTerminalCapabilitySet
//

SendTerminalCapabilitySet :: SendTerminalCapabilitySet ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_specificRequest:
			choice = new SendTerminalCapabilitySet_specificRequest ( is );
			break;
		case e_genericRequest:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

SendTerminalCapabilitySet :: SendTerminalCapabilitySet ( ) : Asn :: Choice ( 2, true ) { }

void SendTerminalCapabilitySet :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_specificRequest:
			o = new SendTerminalCapabilitySet_specificRequest;
			break;
		case e_genericRequest:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & SendTerminalCapabilitySet :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_specificRequest, "specificRequest" },
		{ e_genericRequest, "genericRequest" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

SendTerminalCapabilitySet * SendTerminalCapabilitySet :: clone ( ) const {
	return new SendTerminalCapabilitySet ( * this );
}

//
// SubstituteConferenceIDCommand
//

SubstituteConferenceIDCommand :: SubstituteConferenceIDCommand ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_conferenceIdentifier ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

SubstituteConferenceIDCommand :: SubstituteConferenceIDCommand ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void SubstituteConferenceIDCommand :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_conferenceIdentifier.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void SubstituteConferenceIDCommand :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 23 ) << "conferenceIdentifier = " << std :: setprecision ( indent ) << m_conferenceIdentifier << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

SubstituteConferenceIDCommand * SubstituteConferenceIDCommand :: clone ( ) const {
	return new SubstituteConferenceIDCommand ( * this );
}

//
// PictureReference
//

PictureReference :: PictureReference ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_pictureNumber:
			choice = new PictureReference_pictureNumber ( is );
			break;
		case e_longTermPictureIndex:
			choice = new PictureReference_longTermPictureIndex ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

PictureReference :: PictureReference ( ) : Asn :: Choice ( 2, true ) { }

void PictureReference :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_pictureNumber:
			o = new PictureReference_pictureNumber;
			break;
		case e_longTermPictureIndex:
			o = new PictureReference_longTermPictureIndex;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & PictureReference :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_pictureNumber, "pictureNumber" },
		{ e_longTermPictureIndex, "longTermPictureIndex" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

PictureReference * PictureReference :: clone ( ) const {
	return new PictureReference ( * this );
}

//
// H223MultiplexReconfiguration
//

H223MultiplexReconfiguration :: H223MultiplexReconfiguration ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_h223ModeChange:
			choice = new H223MultiplexReconfiguration_h223ModeChange ( is );
			break;
		case e_h223AnnexADoubleFlag:
			choice = new H223MultiplexReconfiguration_h223AnnexADoubleFlag ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

H223MultiplexReconfiguration :: H223MultiplexReconfiguration ( ) : Asn :: Choice ( 2, true ) { }

void H223MultiplexReconfiguration :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_h223ModeChange:
			o = new H223MultiplexReconfiguration_h223ModeChange;
			break;
		case e_h223AnnexADoubleFlag:
			o = new H223MultiplexReconfiguration_h223AnnexADoubleFlag;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & H223MultiplexReconfiguration :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_h223ModeChange, "h223ModeChange" },
		{ e_h223AnnexADoubleFlag, "h223AnnexADoubleFlag" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

H223MultiplexReconfiguration * H223MultiplexReconfiguration :: clone ( ) const {
	return new H223MultiplexReconfiguration ( * this );
}

//
// MobileMultilinkReconfigurationCommand
//

MobileMultilinkReconfigurationCommand :: MobileMultilinkReconfigurationCommand ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_sampleSize ( is ), m_samplesPerFrame ( is ), m_status ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MobileMultilinkReconfigurationCommand :: MobileMultilinkReconfigurationCommand ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MobileMultilinkReconfigurationCommand :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_sampleSize.encode ( os );
	m_samplesPerFrame.encode ( os );
	m_status.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MobileMultilinkReconfigurationCommand :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 13 ) << "sampleSize = " << std :: setprecision ( indent ) << m_sampleSize << '\n';
	os << std :: setw ( indent + 18 ) << "samplesPerFrame = " << std :: setprecision ( indent ) << m_samplesPerFrame << '\n';
	os << std :: setw ( indent + 9 ) << "status = " << std :: setprecision ( indent ) << m_status << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MobileMultilinkReconfigurationCommand * MobileMultilinkReconfigurationCommand :: clone ( ) const {
	return new MobileMultilinkReconfigurationCommand ( * this );
}

//
// FunctionNotSupported
//

FunctionNotSupported :: FunctionNotSupported ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_cause ( is ), m_returnedFunction ( 0 ) {
	try {
		if ( hasOptionalField ( e_returnedFunction ) )
			m_returnedFunction = new Asn :: OctetString ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_returnedFunction;
		throw;
	}
}

FunctionNotSupported :: FunctionNotSupported ( ) : Asn :: Sequence ( 1, true, 0 ), m_returnedFunction ( 0 ) { }

FunctionNotSupported & FunctionNotSupported :: operator= ( const FunctionNotSupported & s ) {
	Asn :: Sequence :: operator= ( s );
	m_cause = s.m_cause;
	assignCopy ( m_returnedFunction, s.m_returnedFunction );
	return * this;
}

FunctionNotSupported :: FunctionNotSupported ( const FunctionNotSupported & s ) : Asn :: Sequence ( s ), m_cause ( s.m_cause ), m_returnedFunction ( 0 ) {
	try {
		if ( s.m_returnedFunction )
			m_returnedFunction = new Asn :: OctetString ( * s.m_returnedFunction );
	} catch ( ... ) {
		delete m_returnedFunction;
		throw;
	}
}


void FunctionNotSupported :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_returnedFunction:
			assignNew ( m_returnedFunction, new Asn :: OctetString );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void FunctionNotSupported :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_returnedFunction:
			delete m_returnedFunction;
			m_returnedFunction = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void FunctionNotSupported :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_cause.encode ( os );
	if ( hasOptionalField ( e_returnedFunction ) )
		m_returnedFunction -> Asn :: OctetString :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

FunctionNotSupported :: ~FunctionNotSupported ( ) {
	delete m_returnedFunction;
}

void FunctionNotSupported :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 8 ) << "cause = " << std :: setprecision ( indent ) << m_cause << '\n';
	if ( hasOptionalField ( e_returnedFunction ) ) {
		os << std :: setw ( indent + 19 ) << "returnedFunction = " << std :: setprecision ( indent );
		m_returnedFunction -> Asn :: OctetString :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

FunctionNotSupported * FunctionNotSupported :: clone ( ) const {
	return new FunctionNotSupported ( * this );
}

//
// TerminalYouAreSeeingInSubPictureNumber
//

TerminalYouAreSeeingInSubPictureNumber :: TerminalYouAreSeeingInSubPictureNumber ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_terminalNumber ( is ), m_subPictureNumber ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

TerminalYouAreSeeingInSubPictureNumber :: TerminalYouAreSeeingInSubPictureNumber ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void TerminalYouAreSeeingInSubPictureNumber :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_terminalNumber.encode ( os );
	m_subPictureNumber.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void TerminalYouAreSeeingInSubPictureNumber :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 17 ) << "terminalNumber = " << std :: setprecision ( indent ) << m_terminalNumber << '\n';
	os << std :: setw ( indent + 19 ) << "subPictureNumber = " << std :: setprecision ( indent ) << m_subPictureNumber << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

TerminalYouAreSeeingInSubPictureNumber * TerminalYouAreSeeingInSubPictureNumber :: clone ( ) const {
	return new TerminalYouAreSeeingInSubPictureNumber ( * this );
}

//
// VideoIndicateCompose
//

VideoIndicateCompose :: VideoIndicateCompose ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_compositionNumber ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

VideoIndicateCompose :: VideoIndicateCompose ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void VideoIndicateCompose :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_compositionNumber.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void VideoIndicateCompose :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 20 ) << "compositionNumber = " << std :: setprecision ( indent ) << m_compositionNumber << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

VideoIndicateCompose * VideoIndicateCompose :: clone ( ) const {
	return new VideoIndicateCompose ( * this );
}

//
// H223SkewIndication
//

H223SkewIndication :: H223SkewIndication ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_logicalChannelNumber1 ( is ), m_logicalChannelNumber2 ( is ), m_skew ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

H223SkewIndication :: H223SkewIndication ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void H223SkewIndication :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_logicalChannelNumber1.encode ( os );
	m_logicalChannelNumber2.encode ( os );
	m_skew.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void H223SkewIndication :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 24 ) << "logicalChannelNumber1 = " << std :: setprecision ( indent ) << m_logicalChannelNumber1 << '\n';
	os << std :: setw ( indent + 24 ) << "logicalChannelNumber2 = " << std :: setprecision ( indent ) << m_logicalChannelNumber2 << '\n';
	os << std :: setw ( indent + 7 ) << "skew = " << std :: setprecision ( indent ) << m_skew << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H223SkewIndication * H223SkewIndication :: clone ( ) const {
	return new H223SkewIndication ( * this );
}

//
// H2250MaximumSkewIndication
//

H2250MaximumSkewIndication :: H2250MaximumSkewIndication ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_logicalChannelNumber1 ( is ), m_logicalChannelNumber2 ( is ), m_maximumSkew ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

H2250MaximumSkewIndication :: H2250MaximumSkewIndication ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void H2250MaximumSkewIndication :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_logicalChannelNumber1.encode ( os );
	m_logicalChannelNumber2.encode ( os );
	m_maximumSkew.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void H2250MaximumSkewIndication :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 24 ) << "logicalChannelNumber1 = " << std :: setprecision ( indent ) << m_logicalChannelNumber1 << '\n';
	os << std :: setw ( indent + 24 ) << "logicalChannelNumber2 = " << std :: setprecision ( indent ) << m_logicalChannelNumber2 << '\n';
	os << std :: setw ( indent + 14 ) << "maximumSkew = " << std :: setprecision ( indent ) << m_maximumSkew << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H2250MaximumSkewIndication * H2250MaximumSkewIndication :: clone ( ) const {
	return new H2250MaximumSkewIndication ( * this );
}

//
// MobileMultilinkReconfigurationIndication
//

MobileMultilinkReconfigurationIndication :: MobileMultilinkReconfigurationIndication ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_sampleSize ( is ), m_samplesPerFrame ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MobileMultilinkReconfigurationIndication :: MobileMultilinkReconfigurationIndication ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MobileMultilinkReconfigurationIndication :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_sampleSize.encode ( os );
	m_samplesPerFrame.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MobileMultilinkReconfigurationIndication :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 13 ) << "sampleSize = " << std :: setprecision ( indent ) << m_sampleSize << '\n';
	os << std :: setw ( indent + 18 ) << "samplesPerFrame = " << std :: setprecision ( indent ) << m_samplesPerFrame << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MobileMultilinkReconfigurationIndication * MobileMultilinkReconfigurationIndication :: clone ( ) const {
	return new MobileMultilinkReconfigurationIndication ( * this );
}

//
// NonStandardIdentifier_h221NonStandard
//

NonStandardIdentifier_h221NonStandard :: NonStandardIdentifier_h221NonStandard ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, false, 0 ), m_t35CountryCode ( is ), m_t35Extension ( is ), m_manufacturerCode ( is ) {
}

NonStandardIdentifier_h221NonStandard :: NonStandardIdentifier_h221NonStandard ( ) : Asn :: Sequence ( 0, false, 0 ) { }

void NonStandardIdentifier_h221NonStandard :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_t35CountryCode.encode ( os );
	m_t35Extension.encode ( os );
	m_manufacturerCode.encode ( os );
}

void NonStandardIdentifier_h221NonStandard :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 17 ) << "t35CountryCode = " << std :: setprecision ( indent ) << m_t35CountryCode << '\n';
	os << std :: setw ( indent + 15 ) << "t35Extension = " << std :: setprecision ( indent ) << m_t35Extension << '\n';
	os << std :: setw ( indent + 19 ) << "manufacturerCode = " << std :: setprecision ( indent ) << m_manufacturerCode << '\n';
	os << std :: setw ( indent - 1 ) << '}';
}

NonStandardIdentifier_h221NonStandard * NonStandardIdentifier_h221NonStandard :: clone ( ) const {
	return new NonStandardIdentifier_h221NonStandard ( * this );
}

//
// TerminalCapabilitySetReject_cause
//

TerminalCapabilitySetReject_cause :: TerminalCapabilitySetReject_cause ( Asn :: istream & is ) : Asn :: Choice ( is, 4, true ) {
	switch ( tag ) {
		case e_unspecified:
		case e_undefinedTableEntryUsed:
		case e_descriptorCapacityExceeded:
			choice = new Asn :: Null ( is );
			break;
		case e_tableEntryCapacityExceeded:
			choice = new TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

TerminalCapabilitySetReject_cause :: TerminalCapabilitySetReject_cause ( ) : Asn :: Choice ( 4, true ) { }

void TerminalCapabilitySetReject_cause :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_unspecified:
		case e_undefinedTableEntryUsed:
		case e_descriptorCapacityExceeded:
			o = new Asn :: Null;
			break;
		case e_tableEntryCapacityExceeded:
			o = new TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & TerminalCapabilitySetReject_cause :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_unspecified, "unspecified" },
		{ e_undefinedTableEntryUsed, "undefinedTableEntryUsed" },
		{ e_descriptorCapacityExceeded, "descriptorCapacityExceeded" },
		{ e_tableEntryCapacityExceeded, "tableEntryCapacityExceeded" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

TerminalCapabilitySetReject_cause * TerminalCapabilitySetReject_cause :: clone ( ) const {
	return new TerminalCapabilitySetReject_cause ( * this );
}

//
// Capability_h233EncryptionReceiveCapability
//

Capability_h233EncryptionReceiveCapability :: Capability_h233EncryptionReceiveCapability ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_h233IVResponseTime ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

Capability_h233EncryptionReceiveCapability :: Capability_h233EncryptionReceiveCapability ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void Capability_h233EncryptionReceiveCapability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_h233IVResponseTime.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void Capability_h233EncryptionReceiveCapability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 21 ) << "h233IVResponseTime = " << std :: setprecision ( indent ) << m_h233IVResponseTime << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

Capability_h233EncryptionReceiveCapability * Capability_h233EncryptionReceiveCapability :: clone ( ) const {
	return new Capability_h233EncryptionReceiveCapability ( * this );
}

//
// VCCapability_aal5
//

VCCapability_aal5 :: VCCapability_aal5 ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_forwardMaximumSDUSize ( is ), m_backwardMaximumSDUSize ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

VCCapability_aal5 :: VCCapability_aal5 ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void VCCapability_aal5 :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_forwardMaximumSDUSize.encode ( os );
	m_backwardMaximumSDUSize.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void VCCapability_aal5 :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 24 ) << "forwardMaximumSDUSize = " << std :: setprecision ( indent ) << m_forwardMaximumSDUSize << '\n';
	os << std :: setw ( indent + 25 ) << "backwardMaximumSDUSize = " << std :: setprecision ( indent ) << m_backwardMaximumSDUSize << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

VCCapability_aal5 * VCCapability_aal5 :: clone ( ) const {
	return new VCCapability_aal5 ( * this );
}

//
// VCCapability_aal1ViaGateway
//

VCCapability_aal1ViaGateway :: VCCapability_aal1ViaGateway ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_gatewayAddress ( is ), m_nullClockRecovery ( is ), m_srtsClockRecovery ( is ), m_adaptiveClockRecovery ( is ), m_nullErrorCorrection ( is ), m_longInterleaver ( is ), m_shortInterleaver ( is ), m_errorCorrectionOnly ( is ), m_structuredDataTransfer ( is ), m_partiallyFilledCells ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

VCCapability_aal1ViaGateway :: VCCapability_aal1ViaGateway ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void VCCapability_aal1ViaGateway :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_gatewayAddress.encode ( os );
	m_nullClockRecovery.encode ( os );
	m_srtsClockRecovery.encode ( os );
	m_adaptiveClockRecovery.encode ( os );
	m_nullErrorCorrection.encode ( os );
	m_longInterleaver.encode ( os );
	m_shortInterleaver.encode ( os );
	m_errorCorrectionOnly.encode ( os );
	m_structuredDataTransfer.encode ( os );
	m_partiallyFilledCells.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void VCCapability_aal1ViaGateway :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 17 ) << "gatewayAddress = " << std :: setprecision ( indent ) << m_gatewayAddress << '\n';
	os << std :: setw ( indent + 20 ) << "nullClockRecovery = " << std :: setprecision ( indent ) << m_nullClockRecovery << '\n';
	os << std :: setw ( indent + 20 ) << "srtsClockRecovery = " << std :: setprecision ( indent ) << m_srtsClockRecovery << '\n';
	os << std :: setw ( indent + 24 ) << "adaptiveClockRecovery = " << std :: setprecision ( indent ) << m_adaptiveClockRecovery << '\n';
	os << std :: setw ( indent + 22 ) << "nullErrorCorrection = " << std :: setprecision ( indent ) << m_nullErrorCorrection << '\n';
	os << std :: setw ( indent + 18 ) << "longInterleaver = " << std :: setprecision ( indent ) << m_longInterleaver << '\n';
	os << std :: setw ( indent + 19 ) << "shortInterleaver = " << std :: setprecision ( indent ) << m_shortInterleaver << '\n';
	os << std :: setw ( indent + 22 ) << "errorCorrectionOnly = " << std :: setprecision ( indent ) << m_errorCorrectionOnly << '\n';
	os << std :: setw ( indent + 25 ) << "structuredDataTransfer = " << std :: setprecision ( indent ) << m_structuredDataTransfer << '\n';
	os << std :: setw ( indent + 23 ) << "partiallyFilledCells = " << std :: setprecision ( indent ) << m_partiallyFilledCells << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

VCCapability_aal1ViaGateway * VCCapability_aal1ViaGateway :: clone ( ) const {
	return new VCCapability_aal1ViaGateway ( * this );
}

//
// H223Capability_mobileMultilinkFrameCapability
//

H223Capability_mobileMultilinkFrameCapability :: H223Capability_mobileMultilinkFrameCapability ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_maximumSampleSize ( is ), m_maximumPayloadLength ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

H223Capability_mobileMultilinkFrameCapability :: H223Capability_mobileMultilinkFrameCapability ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void H223Capability_mobileMultilinkFrameCapability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_maximumSampleSize.encode ( os );
	m_maximumPayloadLength.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void H223Capability_mobileMultilinkFrameCapability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 20 ) << "maximumSampleSize = " << std :: setprecision ( indent ) << m_maximumSampleSize << '\n';
	os << std :: setw ( indent + 23 ) << "maximumPayloadLength = " << std :: setprecision ( indent ) << m_maximumPayloadLength << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H223Capability_mobileMultilinkFrameCapability * H223Capability_mobileMultilinkFrameCapability :: clone ( ) const {
	return new H223Capability_mobileMultilinkFrameCapability ( * this );
}

//
// RTPH263VideoRedundancyEncoding_frameToThreadMapping
//

RTPH263VideoRedundancyEncoding_frameToThreadMapping :: RTPH263VideoRedundancyEncoding_frameToThreadMapping ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_roundrobin:
			choice = new Asn :: Null ( is );
			break;
		case e_custom:
			choice = new RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

RTPH263VideoRedundancyEncoding_frameToThreadMapping :: RTPH263VideoRedundancyEncoding_frameToThreadMapping ( ) : Asn :: Choice ( 2, true ) { }

void RTPH263VideoRedundancyEncoding_frameToThreadMapping :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_roundrobin:
			o = new Asn :: Null;
			break;
		case e_custom:
			o = new RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & RTPH263VideoRedundancyEncoding_frameToThreadMapping :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_roundrobin, "roundrobin" },
		{ e_custom, "custom" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

RTPH263VideoRedundancyEncoding_frameToThreadMapping * RTPH263VideoRedundancyEncoding_frameToThreadMapping :: clone ( ) const {
	return new RTPH263VideoRedundancyEncoding_frameToThreadMapping ( * this );
}

//
// CustomPictureFormat_pixelAspectInformation
//

CustomPictureFormat_pixelAspectInformation :: CustomPictureFormat_pixelAspectInformation ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_anyPixelAspectRatio:
			choice = new Asn :: Boolean ( is );
			break;
		case e_pixelAspectCode:
			choice = new CustomPictureFormat_pixelAspectInformation_pixelAspectCode ( is );
			break;
		case e_extendedPAR:
			choice = new CustomPictureFormat_pixelAspectInformation_extendedPAR ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

CustomPictureFormat_pixelAspectInformation :: CustomPictureFormat_pixelAspectInformation ( ) : Asn :: Choice ( 3, true ) { }

void CustomPictureFormat_pixelAspectInformation :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_anyPixelAspectRatio:
			o = new Asn :: Boolean;
			break;
		case e_pixelAspectCode:
			o = new CustomPictureFormat_pixelAspectInformation_pixelAspectCode;
			break;
		case e_extendedPAR:
			o = new CustomPictureFormat_pixelAspectInformation_extendedPAR;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & CustomPictureFormat_pixelAspectInformation :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_anyPixelAspectRatio, "anyPixelAspectRatio" },
		{ e_pixelAspectCode, "pixelAspectCode" },
		{ e_extendedPAR, "extendedPAR" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

CustomPictureFormat_pixelAspectInformation * CustomPictureFormat_pixelAspectInformation :: clone ( ) const {
	return new CustomPictureFormat_pixelAspectInformation ( * this );
}

//
// AudioCapability_g7231
//

AudioCapability_g7231 :: AudioCapability_g7231 ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, false, 0 ), m_maxAl_sduAudioFrames ( is ), m_silenceSuppression ( is ) {
}

AudioCapability_g7231 :: AudioCapability_g7231 ( ) : Asn :: Sequence ( 0, false, 0 ) { }

void AudioCapability_g7231 :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_maxAl_sduAudioFrames.encode ( os );
	m_silenceSuppression.encode ( os );
}

void AudioCapability_g7231 :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 23 ) << "maxAl_sduAudioFrames = " << std :: setprecision ( indent ) << m_maxAl_sduAudioFrames << '\n';
	os << std :: setw ( indent + 21 ) << "silenceSuppression = " << std :: setprecision ( indent ) << m_silenceSuppression << '\n';
	os << std :: setw ( indent - 1 ) << '}';
}

AudioCapability_g7231 * AudioCapability_g7231 :: clone ( ) const {
	return new AudioCapability_g7231 ( * this );
}

//
// G7231AnnexCCapability_g723AnnexCAudioMode
//

G7231AnnexCCapability_g723AnnexCAudioMode :: G7231AnnexCCapability_g723AnnexCAudioMode ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_highRateMode0 ( is ), m_highRateMode1 ( is ), m_lowRateMode0 ( is ), m_lowRateMode1 ( is ), m_sidMode0 ( is ), m_sidMode1 ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

G7231AnnexCCapability_g723AnnexCAudioMode :: G7231AnnexCCapability_g723AnnexCAudioMode ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void G7231AnnexCCapability_g723AnnexCAudioMode :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_highRateMode0.encode ( os );
	m_highRateMode1.encode ( os );
	m_lowRateMode0.encode ( os );
	m_lowRateMode1.encode ( os );
	m_sidMode0.encode ( os );
	m_sidMode1.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void G7231AnnexCCapability_g723AnnexCAudioMode :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "highRateMode0 = " << std :: setprecision ( indent ) << m_highRateMode0 << '\n';
	os << std :: setw ( indent + 16 ) << "highRateMode1 = " << std :: setprecision ( indent ) << m_highRateMode1 << '\n';
	os << std :: setw ( indent + 15 ) << "lowRateMode0 = " << std :: setprecision ( indent ) << m_lowRateMode0 << '\n';
	os << std :: setw ( indent + 15 ) << "lowRateMode1 = " << std :: setprecision ( indent ) << m_lowRateMode1 << '\n';
	os << std :: setw ( indent + 11 ) << "sidMode0 = " << std :: setprecision ( indent ) << m_sidMode0 << '\n';
	os << std :: setw ( indent + 11 ) << "sidMode1 = " << std :: setprecision ( indent ) << m_sidMode1 << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

G7231AnnexCCapability_g723AnnexCAudioMode * G7231AnnexCCapability_g723AnnexCAudioMode :: clone ( ) const {
	return new G7231AnnexCCapability_g723AnnexCAudioMode ( * this );
}

//
// DepFECCapability_rfc2733
//

DepFECCapability_rfc2733 :: DepFECCapability_rfc2733 ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_redundancyEncoding ( is ), m_separateStream ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

DepFECCapability_rfc2733 :: DepFECCapability_rfc2733 ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void DepFECCapability_rfc2733 :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_redundancyEncoding.encode ( os );
	m_separateStream.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void DepFECCapability_rfc2733 :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 21 ) << "redundancyEncoding = " << std :: setprecision ( indent ) << m_redundancyEncoding << '\n';
	os << std :: setw ( indent + 17 ) << "separateStream = " << std :: setprecision ( indent ) << m_separateStream << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

DepFECCapability_rfc2733 * DepFECCapability_rfc2733 :: clone ( ) const {
	return new DepFECCapability_rfc2733 ( * this );
}

//
// Q2931Address_address
//

Q2931Address_address :: Q2931Address_address ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_internationalNumber:
			choice = new Q2931Address_address_internationalNumber ( is );
			break;
		case e_nsapAddress:
			choice = new Q2931Address_address_nsapAddress ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

Q2931Address_address :: Q2931Address_address ( ) : Asn :: Choice ( 2, true ) { }

void Q2931Address_address :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_internationalNumber:
			o = new Q2931Address_address_internationalNumber;
			break;
		case e_nsapAddress:
			o = new Q2931Address_address_nsapAddress;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & Q2931Address_address :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_internationalNumber, "internationalNumber" },
		{ e_nsapAddress, "nsapAddress" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

Q2931Address_address * Q2931Address_address :: clone ( ) const {
	return new Q2931Address_address ( * this );
}

//
// H223AnnexCArqParameters_numberOfRetransmissions
//

H223AnnexCArqParameters_numberOfRetransmissions :: H223AnnexCArqParameters_numberOfRetransmissions ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_finite:
			choice = new H223AnnexCArqParameters_numberOfRetransmissions_finite ( is );
			break;
		case e_infinite:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

H223AnnexCArqParameters_numberOfRetransmissions :: H223AnnexCArqParameters_numberOfRetransmissions ( ) : Asn :: Choice ( 2, true ) { }

void H223AnnexCArqParameters_numberOfRetransmissions :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_finite:
			o = new H223AnnexCArqParameters_numberOfRetransmissions_finite;
			break;
		case e_infinite:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & H223AnnexCArqParameters_numberOfRetransmissions :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_finite, "finite" },
		{ e_infinite, "infinite" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

H223AnnexCArqParameters_numberOfRetransmissions * H223AnnexCArqParameters_numberOfRetransmissions :: clone ( ) const {
	return new H223AnnexCArqParameters_numberOfRetransmissions ( * this );
}

//
// UnicastAddress_iPAddress
//

UnicastAddress_iPAddress :: UnicastAddress_iPAddress ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_network ( is ), m_tsapIdentifier ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

UnicastAddress_iPAddress :: UnicastAddress_iPAddress ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void UnicastAddress_iPAddress :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_network.encode ( os );
	m_tsapIdentifier.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void UnicastAddress_iPAddress :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 10 ) << "network = " << std :: setprecision ( indent ) << m_network << '\n';
	os << std :: setw ( indent + 17 ) << "tsapIdentifier = " << std :: setprecision ( indent ) << m_tsapIdentifier << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

UnicastAddress_iPAddress * UnicastAddress_iPAddress :: clone ( ) const {
	return new UnicastAddress_iPAddress ( * this );
}

//
// UnicastAddress_iPXAddress
//

UnicastAddress_iPXAddress :: UnicastAddress_iPXAddress ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_node ( is ), m_netnum ( is ), m_tsapIdentifier ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

UnicastAddress_iPXAddress :: UnicastAddress_iPXAddress ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void UnicastAddress_iPXAddress :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_node.encode ( os );
	m_netnum.encode ( os );
	m_tsapIdentifier.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void UnicastAddress_iPXAddress :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 7 ) << "node = " << std :: setprecision ( indent ) << m_node << '\n';
	os << std :: setw ( indent + 9 ) << "netnum = " << std :: setprecision ( indent ) << m_netnum << '\n';
	os << std :: setw ( indent + 17 ) << "tsapIdentifier = " << std :: setprecision ( indent ) << m_tsapIdentifier << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

UnicastAddress_iPXAddress * UnicastAddress_iPXAddress :: clone ( ) const {
	return new UnicastAddress_iPXAddress ( * this );
}

//
// UnicastAddress_iP6Address
//

UnicastAddress_iP6Address :: UnicastAddress_iP6Address ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_network ( is ), m_tsapIdentifier ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

UnicastAddress_iP6Address :: UnicastAddress_iP6Address ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void UnicastAddress_iP6Address :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_network.encode ( os );
	m_tsapIdentifier.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void UnicastAddress_iP6Address :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 10 ) << "network = " << std :: setprecision ( indent ) << m_network << '\n';
	os << std :: setw ( indent + 17 ) << "tsapIdentifier = " << std :: setprecision ( indent ) << m_tsapIdentifier << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

UnicastAddress_iP6Address * UnicastAddress_iP6Address :: clone ( ) const {
	return new UnicastAddress_iP6Address ( * this );
}

//
// UnicastAddress_iPSourceRouteAddress
//

UnicastAddress_iPSourceRouteAddress :: UnicastAddress_iPSourceRouteAddress ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_routing ( is ), m_network ( is ), m_tsapIdentifier ( is ), m_route ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

UnicastAddress_iPSourceRouteAddress :: UnicastAddress_iPSourceRouteAddress ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void UnicastAddress_iPSourceRouteAddress :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_routing.encode ( os );
	m_network.encode ( os );
	m_tsapIdentifier.encode ( os );
	m_route.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void UnicastAddress_iPSourceRouteAddress :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 10 ) << "routing = " << std :: setprecision ( indent ) << m_routing << '\n';
	os << std :: setw ( indent + 10 ) << "network = " << std :: setprecision ( indent ) << m_network << '\n';
	os << std :: setw ( indent + 17 ) << "tsapIdentifier = " << std :: setprecision ( indent ) << m_tsapIdentifier << '\n';
	os << std :: setw ( indent + 8 ) << "route = " << std :: setprecision ( indent ) << m_route << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

UnicastAddress_iPSourceRouteAddress * UnicastAddress_iPSourceRouteAddress :: clone ( ) const {
	return new UnicastAddress_iPSourceRouteAddress ( * this );
}

//
// MulticastAddress_iPAddress
//

MulticastAddress_iPAddress :: MulticastAddress_iPAddress ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_network ( is ), m_tsapIdentifier ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MulticastAddress_iPAddress :: MulticastAddress_iPAddress ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MulticastAddress_iPAddress :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_network.encode ( os );
	m_tsapIdentifier.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MulticastAddress_iPAddress :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 10 ) << "network = " << std :: setprecision ( indent ) << m_network << '\n';
	os << std :: setw ( indent + 17 ) << "tsapIdentifier = " << std :: setprecision ( indent ) << m_tsapIdentifier << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MulticastAddress_iPAddress * MulticastAddress_iPAddress :: clone ( ) const {
	return new MulticastAddress_iPAddress ( * this );
}

//
// MulticastAddress_iP6Address
//

MulticastAddress_iP6Address :: MulticastAddress_iP6Address ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_network ( is ), m_tsapIdentifier ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MulticastAddress_iP6Address :: MulticastAddress_iP6Address ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MulticastAddress_iP6Address :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_network.encode ( os );
	m_tsapIdentifier.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MulticastAddress_iP6Address :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 10 ) << "network = " << std :: setprecision ( indent ) << m_network << '\n';
	os << std :: setw ( indent + 17 ) << "tsapIdentifier = " << std :: setprecision ( indent ) << m_tsapIdentifier << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MulticastAddress_iP6Address * MulticastAddress_iP6Address :: clone ( ) const {
	return new MulticastAddress_iP6Address ( * this );
}

//
// MultiplexElement_type
//

MultiplexElement_type :: MultiplexElement_type ( Asn :: istream & is ) : Asn :: Choice ( is, 2, false ) {
	switch ( tag ) {
		case e_logicalChannelNumber:
			choice = new MultiplexElement_type_logicalChannelNumber ( is );
			break;
		case e_subElementList:
			choice = new MultiplexElement_type_subElementList ( is );
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
}

MultiplexElement_type :: MultiplexElement_type ( ) : Asn :: Choice ( 2, false ) { }

void MultiplexElement_type :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_logicalChannelNumber:
			o = new MultiplexElement_type_logicalChannelNumber;
			break;
		case e_subElementList:
			o = new MultiplexElement_type_subElementList;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & MultiplexElement_type :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_logicalChannelNumber, "logicalChannelNumber" },
		{ e_subElementList, "subElementList" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

MultiplexElement_type * MultiplexElement_type :: clone ( ) const {
	return new MultiplexElement_type ( * this );
}

//
// MultiplexElement_repeatCount
//

MultiplexElement_repeatCount :: MultiplexElement_repeatCount ( Asn :: istream & is ) : Asn :: Choice ( is, 2, false ) {
	switch ( tag ) {
		case e_finite:
			choice = new MultiplexElement_repeatCount_finite ( is );
			break;
		case e_untilClosingFlag:
			choice = new Asn :: Null ( is );
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
}

MultiplexElement_repeatCount :: MultiplexElement_repeatCount ( ) : Asn :: Choice ( 2, false ) { }

void MultiplexElement_repeatCount :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_finite:
			o = new MultiplexElement_repeatCount_finite;
			break;
		case e_untilClosingFlag:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & MultiplexElement_repeatCount :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_finite, "finite" },
		{ e_untilClosingFlag, "untilClosingFlag" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

MultiplexElement_repeatCount * MultiplexElement_repeatCount :: clone ( ) const {
	return new MultiplexElement_repeatCount ( * this );
}

//
// G7231AnnexCMode_g723AnnexCAudioMode
//

G7231AnnexCMode_g723AnnexCAudioMode :: G7231AnnexCMode_g723AnnexCAudioMode ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_highRateMode0 ( is ), m_highRateMode1 ( is ), m_lowRateMode0 ( is ), m_lowRateMode1 ( is ), m_sidMode0 ( is ), m_sidMode1 ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

G7231AnnexCMode_g723AnnexCAudioMode :: G7231AnnexCMode_g723AnnexCAudioMode ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void G7231AnnexCMode_g723AnnexCAudioMode :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_highRateMode0.encode ( os );
	m_highRateMode1.encode ( os );
	m_lowRateMode0.encode ( os );
	m_lowRateMode1.encode ( os );
	m_sidMode0.encode ( os );
	m_sidMode1.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void G7231AnnexCMode_g723AnnexCAudioMode :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "highRateMode0 = " << std :: setprecision ( indent ) << m_highRateMode0 << '\n';
	os << std :: setw ( indent + 16 ) << "highRateMode1 = " << std :: setprecision ( indent ) << m_highRateMode1 << '\n';
	os << std :: setw ( indent + 15 ) << "lowRateMode0 = " << std :: setprecision ( indent ) << m_lowRateMode0 << '\n';
	os << std :: setw ( indent + 15 ) << "lowRateMode1 = " << std :: setprecision ( indent ) << m_lowRateMode1 << '\n';
	os << std :: setw ( indent + 11 ) << "sidMode0 = " << std :: setprecision ( indent ) << m_sidMode0 << '\n';
	os << std :: setw ( indent + 11 ) << "sidMode1 = " << std :: setprecision ( indent ) << m_sidMode1 << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

G7231AnnexCMode_g723AnnexCAudioMode * G7231AnnexCMode_g723AnnexCAudioMode :: clone ( ) const {
	return new G7231AnnexCMode_g723AnnexCAudioMode ( * this );
}

//
// ConferenceResponse_mCTerminalIDResponse
//

ConferenceResponse_mCTerminalIDResponse :: ConferenceResponse_mCTerminalIDResponse ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_terminalLabel ( is ), m_terminalID ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

ConferenceResponse_mCTerminalIDResponse :: ConferenceResponse_mCTerminalIDResponse ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void ConferenceResponse_mCTerminalIDResponse :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_terminalLabel.encode ( os );
	m_terminalID.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void ConferenceResponse_mCTerminalIDResponse :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "terminalLabel = " << std :: setprecision ( indent ) << m_terminalLabel << '\n';
	os << std :: setw ( indent + 13 ) << "terminalID = " << std :: setprecision ( indent ) << m_terminalID << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

ConferenceResponse_mCTerminalIDResponse * ConferenceResponse_mCTerminalIDResponse :: clone ( ) const {
	return new ConferenceResponse_mCTerminalIDResponse ( * this );
}

//
// ConferenceResponse_terminalIDResponse
//

ConferenceResponse_terminalIDResponse :: ConferenceResponse_terminalIDResponse ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_terminalLabel ( is ), m_terminalID ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

ConferenceResponse_terminalIDResponse :: ConferenceResponse_terminalIDResponse ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void ConferenceResponse_terminalIDResponse :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_terminalLabel.encode ( os );
	m_terminalID.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void ConferenceResponse_terminalIDResponse :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "terminalLabel = " << std :: setprecision ( indent ) << m_terminalLabel << '\n';
	os << std :: setw ( indent + 13 ) << "terminalID = " << std :: setprecision ( indent ) << m_terminalID << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

ConferenceResponse_terminalIDResponse * ConferenceResponse_terminalIDResponse :: clone ( ) const {
	return new ConferenceResponse_terminalIDResponse ( * this );
}

//
// ConferenceResponse_conferenceIDResponse
//

ConferenceResponse_conferenceIDResponse :: ConferenceResponse_conferenceIDResponse ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_terminalLabel ( is ), m_conferenceID ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

ConferenceResponse_conferenceIDResponse :: ConferenceResponse_conferenceIDResponse ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void ConferenceResponse_conferenceIDResponse :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_terminalLabel.encode ( os );
	m_conferenceID.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void ConferenceResponse_conferenceIDResponse :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "terminalLabel = " << std :: setprecision ( indent ) << m_terminalLabel << '\n';
	os << std :: setw ( indent + 15 ) << "conferenceID = " << std :: setprecision ( indent ) << m_conferenceID << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

ConferenceResponse_conferenceIDResponse * ConferenceResponse_conferenceIDResponse :: clone ( ) const {
	return new ConferenceResponse_conferenceIDResponse ( * this );
}

//
// ConferenceResponse_passwordResponse
//

ConferenceResponse_passwordResponse :: ConferenceResponse_passwordResponse ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_terminalLabel ( is ), m_password ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

ConferenceResponse_passwordResponse :: ConferenceResponse_passwordResponse ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void ConferenceResponse_passwordResponse :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_terminalLabel.encode ( os );
	m_password.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void ConferenceResponse_passwordResponse :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "terminalLabel = " << std :: setprecision ( indent ) << m_terminalLabel << '\n';
	os << std :: setw ( indent + 11 ) << "password = " << std :: setprecision ( indent ) << m_password << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

ConferenceResponse_passwordResponse * ConferenceResponse_passwordResponse :: clone ( ) const {
	return new ConferenceResponse_passwordResponse ( * this );
}

//
// ConferenceResponse_chairTokenOwnerResponse
//

ConferenceResponse_chairTokenOwnerResponse :: ConferenceResponse_chairTokenOwnerResponse ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_terminalLabel ( is ), m_terminalID ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

ConferenceResponse_chairTokenOwnerResponse :: ConferenceResponse_chairTokenOwnerResponse ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void ConferenceResponse_chairTokenOwnerResponse :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_terminalLabel.encode ( os );
	m_terminalID.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void ConferenceResponse_chairTokenOwnerResponse :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "terminalLabel = " << std :: setprecision ( indent ) << m_terminalLabel << '\n';
	os << std :: setw ( indent + 13 ) << "terminalID = " << std :: setprecision ( indent ) << m_terminalID << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

ConferenceResponse_chairTokenOwnerResponse * ConferenceResponse_chairTokenOwnerResponse :: clone ( ) const {
	return new ConferenceResponse_chairTokenOwnerResponse ( * this );
}

//
// MultilinkRequest_callInformation
//

MultilinkRequest_callInformation :: MultilinkRequest_callInformation ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_maxNumberOfAdditionalConnections ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MultilinkRequest_callInformation :: MultilinkRequest_callInformation ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MultilinkRequest_callInformation :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_maxNumberOfAdditionalConnections.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MultilinkRequest_callInformation :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 35 ) << "maxNumberOfAdditionalConnections = " << std :: setprecision ( indent ) << m_maxNumberOfAdditionalConnections << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MultilinkRequest_callInformation * MultilinkRequest_callInformation :: clone ( ) const {
	return new MultilinkRequest_callInformation ( * this );
}

//
// MultilinkRequest_removeConnection
//

MultilinkRequest_removeConnection :: MultilinkRequest_removeConnection ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_connectionIdentifier ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MultilinkRequest_removeConnection :: MultilinkRequest_removeConnection ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MultilinkRequest_removeConnection :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_connectionIdentifier.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MultilinkRequest_removeConnection :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 23 ) << "connectionIdentifier = " << std :: setprecision ( indent ) << m_connectionIdentifier << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MultilinkRequest_removeConnection * MultilinkRequest_removeConnection :: clone ( ) const {
	return new MultilinkRequest_removeConnection ( * this );
}

//
// MultilinkResponse_removeConnection
//

MultilinkResponse_removeConnection :: MultilinkResponse_removeConnection ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_connectionIdentifier ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MultilinkResponse_removeConnection :: MultilinkResponse_removeConnection ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MultilinkResponse_removeConnection :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_connectionIdentifier.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MultilinkResponse_removeConnection :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 23 ) << "connectionIdentifier = " << std :: setprecision ( indent ) << m_connectionIdentifier << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MultilinkResponse_removeConnection * MultilinkResponse_removeConnection :: clone ( ) const {
	return new MultilinkResponse_removeConnection ( * this );
}

//
// MultilinkResponse_maximumHeaderInterval
//

MultilinkResponse_maximumHeaderInterval :: MultilinkResponse_maximumHeaderInterval ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_currentInterval ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MultilinkResponse_maximumHeaderInterval :: MultilinkResponse_maximumHeaderInterval ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MultilinkResponse_maximumHeaderInterval :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_currentInterval.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MultilinkResponse_maximumHeaderInterval :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 18 ) << "currentInterval = " << std :: setprecision ( indent ) << m_currentInterval << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MultilinkResponse_maximumHeaderInterval * MultilinkResponse_maximumHeaderInterval :: clone ( ) const {
	return new MultilinkResponse_maximumHeaderInterval ( * this );
}

//
// MultilinkIndication_excessiveError
//

MultilinkIndication_excessiveError :: MultilinkIndication_excessiveError ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_connectionIdentifier ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MultilinkIndication_excessiveError :: MultilinkIndication_excessiveError ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MultilinkIndication_excessiveError :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_connectionIdentifier.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MultilinkIndication_excessiveError :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 23 ) << "connectionIdentifier = " << std :: setprecision ( indent ) << m_connectionIdentifier << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MultilinkIndication_excessiveError * MultilinkIndication_excessiveError :: clone ( ) const {
	return new MultilinkIndication_excessiveError ( * this );
}

//
// FlowControlCommand_scope
//

FlowControlCommand_scope :: FlowControlCommand_scope ( Asn :: istream & is ) : Asn :: Choice ( is, 3, false ) {
	switch ( tag ) {
		case e_logicalChannelNumber:
			choice = new LogicalChannelNumber ( is );
			break;
		case e_resourceID:
			choice = new FlowControlCommand_scope_resourceID ( is );
			break;
		case e_wholeMultiplex:
			choice = new Asn :: Null ( is );
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
}

FlowControlCommand_scope :: FlowControlCommand_scope ( ) : Asn :: Choice ( 3, false ) { }

void FlowControlCommand_scope :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_logicalChannelNumber:
			o = new LogicalChannelNumber;
			break;
		case e_resourceID:
			o = new FlowControlCommand_scope_resourceID;
			break;
		case e_wholeMultiplex:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & FlowControlCommand_scope :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_logicalChannelNumber, "logicalChannelNumber" },
		{ e_resourceID, "resourceID" },
		{ e_wholeMultiplex, "wholeMultiplex" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

FlowControlCommand_scope * FlowControlCommand_scope :: clone ( ) const {
	return new FlowControlCommand_scope ( * this );
}

//
// FlowControlCommand_restriction
//

FlowControlCommand_restriction :: FlowControlCommand_restriction ( Asn :: istream & is ) : Asn :: Choice ( is, 2, false ) {
	switch ( tag ) {
		case e_maximumBitRate:
			choice = new FlowControlCommand_restriction_maximumBitRate ( is );
			break;
		case e_noRestriction:
			choice = new Asn :: Null ( is );
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
}

FlowControlCommand_restriction :: FlowControlCommand_restriction ( ) : Asn :: Choice ( 2, false ) { }

void FlowControlCommand_restriction :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_maximumBitRate:
			o = new FlowControlCommand_restriction_maximumBitRate;
			break;
		case e_noRestriction:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & FlowControlCommand_restriction :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_maximumBitRate, "maximumBitRate" },
		{ e_noRestriction, "noRestriction" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

FlowControlCommand_restriction * FlowControlCommand_restriction :: clone ( ) const {
	return new FlowControlCommand_restriction ( * this );
}

//
// NewATMVCCommand_reverseParameters
//

NewATMVCCommand_reverseParameters :: NewATMVCCommand_reverseParameters ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_bitRate ( is ), m_bitRateLockedToPCRClock ( is ), m_bitRateLockedToNetworkClock ( is ), m_multiplex ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

NewATMVCCommand_reverseParameters :: NewATMVCCommand_reverseParameters ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void NewATMVCCommand_reverseParameters :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_bitRate.encode ( os );
	m_bitRateLockedToPCRClock.encode ( os );
	m_bitRateLockedToNetworkClock.encode ( os );
	m_multiplex.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void NewATMVCCommand_reverseParameters :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 10 ) << "bitRate = " << std :: setprecision ( indent ) << m_bitRate << '\n';
	os << std :: setw ( indent + 26 ) << "bitRateLockedToPCRClock = " << std :: setprecision ( indent ) << m_bitRateLockedToPCRClock << '\n';
	os << std :: setw ( indent + 30 ) << "bitRateLockedToNetworkClock = " << std :: setprecision ( indent ) << m_bitRateLockedToNetworkClock << '\n';
	os << std :: setw ( indent + 12 ) << "multiplex = " << std :: setprecision ( indent ) << m_multiplex << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

NewATMVCCommand_reverseParameters * NewATMVCCommand_reverseParameters :: clone ( ) const {
	return new NewATMVCCommand_reverseParameters ( * this );
}

//
// JitterIndication_scope
//

JitterIndication_scope :: JitterIndication_scope ( Asn :: istream & is ) : Asn :: Choice ( is, 3, false ) {
	switch ( tag ) {
		case e_logicalChannelNumber:
			choice = new LogicalChannelNumber ( is );
			break;
		case e_resourceID:
			choice = new JitterIndication_scope_resourceID ( is );
			break;
		case e_wholeMultiplex:
			choice = new Asn :: Null ( is );
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
}

JitterIndication_scope :: JitterIndication_scope ( ) : Asn :: Choice ( 3, false ) { }

void JitterIndication_scope :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_logicalChannelNumber:
			o = new LogicalChannelNumber;
			break;
		case e_resourceID:
			o = new JitterIndication_scope_resourceID;
			break;
		case e_wholeMultiplex:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & JitterIndication_scope :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_logicalChannelNumber, "logicalChannelNumber" },
		{ e_resourceID, "resourceID" },
		{ e_wholeMultiplex, "wholeMultiplex" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

JitterIndication_scope * JitterIndication_scope :: clone ( ) const {
	return new JitterIndication_scope ( * this );
}

//
// NewATMVCIndication_reverseParameters
//

NewATMVCIndication_reverseParameters :: NewATMVCIndication_reverseParameters ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_bitRate ( is ), m_bitRateLockedToPCRClock ( is ), m_bitRateLockedToNetworkClock ( is ), m_multiplex ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

NewATMVCIndication_reverseParameters :: NewATMVCIndication_reverseParameters ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void NewATMVCIndication_reverseParameters :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_bitRate.encode ( os );
	m_bitRateLockedToPCRClock.encode ( os );
	m_bitRateLockedToNetworkClock.encode ( os );
	m_multiplex.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void NewATMVCIndication_reverseParameters :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 10 ) << "bitRate = " << std :: setprecision ( indent ) << m_bitRate << '\n';
	os << std :: setw ( indent + 26 ) << "bitRateLockedToPCRClock = " << std :: setprecision ( indent ) << m_bitRateLockedToPCRClock << '\n';
	os << std :: setw ( indent + 30 ) << "bitRateLockedToNetworkClock = " << std :: setprecision ( indent ) << m_bitRateLockedToNetworkClock << '\n';
	os << std :: setw ( indent + 12 ) << "multiplex = " << std :: setprecision ( indent ) << m_multiplex << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

NewATMVCIndication_reverseParameters * NewATMVCIndication_reverseParameters :: clone ( ) const {
	return new NewATMVCIndication_reverseParameters ( * this );
}

//
// UserInputIndication_signal
//

UserInputIndication_signal :: UserInputIndication_signal ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 4 ), m_signalType ( is ), m_duration ( 0 ), m_rtp ( 0 ), m_rtpPayloadIndication ( 0 ), m_paramS ( 0 ), m_encryptedSignalType ( 0 ), m_algorithmOID ( 0 ) {
	try {
		if ( hasOptionalField ( e_duration ) )
			m_duration = new UserInputIndication_signal_duration ( is );
		if ( hasOptionalField ( e_rtp ) )
			m_rtp = new UserInputIndication_signal_rtp ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_rtpPayloadIndication ) )
				m_rtpPayloadIndication = new Asn :: Null ( is );
			if ( hasKnownExtensionToDecode ( is, e_paramS ) )
				m_paramS = new Params ( is );
			if ( hasKnownExtensionToDecode ( is, e_encryptedSignalType ) )
				m_encryptedSignalType = new UserInputIndication_signal_encryptedSignalType ( is );
			if ( hasKnownExtensionToDecode ( is, e_algorithmOID ) )
				m_algorithmOID = new Asn :: ObjectId ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_duration;
		delete m_rtp;
		delete m_rtpPayloadIndication;
		delete m_paramS;
		delete m_encryptedSignalType;
		delete m_algorithmOID;
		throw;
	}
}

UserInputIndication_signal :: UserInputIndication_signal ( ) : Asn :: Sequence ( 2, true, 4 ), m_duration ( 0 ), m_rtp ( 0 ), m_rtpPayloadIndication ( 0 ), m_paramS ( 0 ), m_encryptedSignalType ( 0 ), m_algorithmOID ( 0 ) { }

UserInputIndication_signal & UserInputIndication_signal :: operator= ( const UserInputIndication_signal & s ) {
	Asn :: Sequence :: operator= ( s );
	m_signalType = s.m_signalType;
	assignCopy ( m_duration, s.m_duration );
	assignCopy ( m_rtp, s.m_rtp );
	assignCopy ( m_rtpPayloadIndication, s.m_rtpPayloadIndication );
	assignCopy ( m_paramS, s.m_paramS );
	assignCopy ( m_encryptedSignalType, s.m_encryptedSignalType );
	assignCopy ( m_algorithmOID, s.m_algorithmOID );
	return * this;
}

UserInputIndication_signal :: UserInputIndication_signal ( const UserInputIndication_signal & s ) : Asn :: Sequence ( s ), m_signalType ( s.m_signalType ), m_duration ( 0 ), m_rtp ( 0 ), m_rtpPayloadIndication ( 0 ), m_paramS ( 0 ), m_encryptedSignalType ( 0 ), m_algorithmOID ( 0 ) {
	try {
		if ( s.m_duration )
			m_duration = new UserInputIndication_signal_duration ( * s.m_duration );
		if ( s.m_rtp )
			m_rtp = new UserInputIndication_signal_rtp ( * s.m_rtp );
		if ( s.m_rtpPayloadIndication )
			m_rtpPayloadIndication = new Asn :: Null ( * s.m_rtpPayloadIndication );
		if ( s.m_paramS )
			m_paramS = new Params ( * s.m_paramS );
		if ( s.m_encryptedSignalType )
			m_encryptedSignalType = new UserInputIndication_signal_encryptedSignalType ( * s.m_encryptedSignalType );
		if ( s.m_algorithmOID )
			m_algorithmOID = new Asn :: ObjectId ( * s.m_algorithmOID );
	} catch ( ... ) {
		delete m_duration;
		delete m_rtp;
		delete m_rtpPayloadIndication;
		delete m_paramS;
		delete m_encryptedSignalType;
		delete m_algorithmOID;
		throw;
	}
}


void UserInputIndication_signal :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_duration:
			assignNew ( m_duration, new UserInputIndication_signal_duration );
			break;
		case e_rtp:
			assignNew ( m_rtp, new UserInputIndication_signal_rtp );
			break;
		case e_rtpPayloadIndication:
			assignNew ( m_rtpPayloadIndication, new Asn :: Null );
			break;
		case e_paramS:
			assignNew ( m_paramS, new Params );
			break;
		case e_encryptedSignalType:
			assignNew ( m_encryptedSignalType, new UserInputIndication_signal_encryptedSignalType );
			break;
		case e_algorithmOID:
			assignNew ( m_algorithmOID, new Asn :: ObjectId );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void UserInputIndication_signal :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_duration:
			delete m_duration;
			m_duration = 0;
			break;
		case e_rtp:
			delete m_rtp;
			m_rtp = 0;
			break;
		case e_rtpPayloadIndication:
			delete m_rtpPayloadIndication;
			m_rtpPayloadIndication = 0;
			break;
		case e_paramS:
			delete m_paramS;
			m_paramS = 0;
			break;
		case e_encryptedSignalType:
			delete m_encryptedSignalType;
			m_encryptedSignalType = 0;
			break;
		case e_algorithmOID:
			delete m_algorithmOID;
			m_algorithmOID = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void UserInputIndication_signal :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_signalType.encode ( os );
	if ( hasOptionalField ( e_duration ) )
		m_duration -> UserInputIndication_signal_duration :: encode ( os );
	if ( hasOptionalField ( e_rtp ) )
		m_rtp -> UserInputIndication_signal_rtp :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_rtpPayloadIndication, m_rtpPayloadIndication );
		knownExtensionEncode ( os, e_paramS, m_paramS );
		knownExtensionEncode ( os, e_encryptedSignalType, m_encryptedSignalType );
		knownExtensionEncode ( os, e_algorithmOID, m_algorithmOID );
		unknownExtensionsEncode ( os );
	}
}

UserInputIndication_signal :: ~UserInputIndication_signal ( ) {
	delete m_duration;
	delete m_rtp;
	delete m_rtpPayloadIndication;
	delete m_paramS;
	delete m_encryptedSignalType;
	delete m_algorithmOID;
}

void UserInputIndication_signal :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 13 ) << "signalType = " << std :: setprecision ( indent ) << m_signalType << '\n';
	if ( hasOptionalField ( e_duration ) ) {
		os << std :: setw ( indent + 11 ) << "duration = " << std :: setprecision ( indent );
		m_duration -> UserInputIndication_signal_duration :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_rtp ) ) {
		os << std :: setw ( indent + 6 ) << "rtp = " << std :: setprecision ( indent );
		m_rtp -> UserInputIndication_signal_rtp :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_rtpPayloadIndication ) ) {
		os << std :: setw ( indent + 23 ) << "rtpPayloadIndication = " << std :: setprecision ( indent );
		m_rtpPayloadIndication -> Asn :: Null :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_paramS ) ) {
		os << std :: setw ( indent + 9 ) << "paramS = " << std :: setprecision ( indent );
		m_paramS -> Params :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_encryptedSignalType ) ) {
		os << std :: setw ( indent + 22 ) << "encryptedSignalType = " << std :: setprecision ( indent );
		m_encryptedSignalType -> UserInputIndication_signal_encryptedSignalType :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_algorithmOID ) ) {
		os << std :: setw ( indent + 15 ) << "algorithmOID = " << std :: setprecision ( indent );
		m_algorithmOID -> Asn :: ObjectId :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

UserInputIndication_signal * UserInputIndication_signal :: clone ( ) const {
	return new UserInputIndication_signal ( * this );
}

//
// UserInputIndication_signalUpdate
//

UserInputIndication_signalUpdate :: UserInputIndication_signalUpdate ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_duration ( is ), m_rtp ( 0 ) {
	try {
		if ( hasOptionalField ( e_rtp ) )
			m_rtp = new UserInputIndication_signalUpdate_rtp ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_rtp;
		throw;
	}
}

UserInputIndication_signalUpdate :: UserInputIndication_signalUpdate ( ) : Asn :: Sequence ( 1, true, 0 ), m_rtp ( 0 ) { }

UserInputIndication_signalUpdate & UserInputIndication_signalUpdate :: operator= ( const UserInputIndication_signalUpdate & s ) {
	Asn :: Sequence :: operator= ( s );
	m_duration = s.m_duration;
	assignCopy ( m_rtp, s.m_rtp );
	return * this;
}

UserInputIndication_signalUpdate :: UserInputIndication_signalUpdate ( const UserInputIndication_signalUpdate & s ) : Asn :: Sequence ( s ), m_duration ( s.m_duration ), m_rtp ( 0 ) {
	try {
		if ( s.m_rtp )
			m_rtp = new UserInputIndication_signalUpdate_rtp ( * s.m_rtp );
	} catch ( ... ) {
		delete m_rtp;
		throw;
	}
}


void UserInputIndication_signalUpdate :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_rtp:
			assignNew ( m_rtp, new UserInputIndication_signalUpdate_rtp );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void UserInputIndication_signalUpdate :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_rtp:
			delete m_rtp;
			m_rtp = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void UserInputIndication_signalUpdate :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_duration.encode ( os );
	if ( hasOptionalField ( e_rtp ) )
		m_rtp -> UserInputIndication_signalUpdate_rtp :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

UserInputIndication_signalUpdate :: ~UserInputIndication_signalUpdate ( ) {
	delete m_rtp;
}

void UserInputIndication_signalUpdate :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 11 ) << "duration = " << std :: setprecision ( indent ) << m_duration << '\n';
	if ( hasOptionalField ( e_rtp ) ) {
		os << std :: setw ( indent + 6 ) << "rtp = " << std :: setprecision ( indent );
		m_rtp -> UserInputIndication_signalUpdate_rtp :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

UserInputIndication_signalUpdate * UserInputIndication_signalUpdate :: clone ( ) const {
	return new UserInputIndication_signalUpdate ( * this );
}

//
// FlowControlIndication_scope
//

FlowControlIndication_scope :: FlowControlIndication_scope ( Asn :: istream & is ) : Asn :: Choice ( is, 3, false ) {
	switch ( tag ) {
		case e_logicalChannelNumber:
			choice = new LogicalChannelNumber ( is );
			break;
		case e_resourceID:
			choice = new FlowControlIndication_scope_resourceID ( is );
			break;
		case e_wholeMultiplex:
			choice = new Asn :: Null ( is );
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
}

FlowControlIndication_scope :: FlowControlIndication_scope ( ) : Asn :: Choice ( 3, false ) { }

void FlowControlIndication_scope :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_logicalChannelNumber:
			o = new LogicalChannelNumber;
			break;
		case e_resourceID:
			o = new FlowControlIndication_scope_resourceID;
			break;
		case e_wholeMultiplex:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & FlowControlIndication_scope :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_logicalChannelNumber, "logicalChannelNumber" },
		{ e_resourceID, "resourceID" },
		{ e_wholeMultiplex, "wholeMultiplex" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

FlowControlIndication_scope * FlowControlIndication_scope :: clone ( ) const {
	return new FlowControlIndication_scope ( * this );
}

//
// FlowControlIndication_restriction
//

FlowControlIndication_restriction :: FlowControlIndication_restriction ( Asn :: istream & is ) : Asn :: Choice ( is, 2, false ) {
	switch ( tag ) {
		case e_maximumBitRate:
			choice = new FlowControlIndication_restriction_maximumBitRate ( is );
			break;
		case e_noRestriction:
			choice = new Asn :: Null ( is );
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
}

FlowControlIndication_restriction :: FlowControlIndication_restriction ( ) : Asn :: Choice ( 2, false ) { }

void FlowControlIndication_restriction :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_maximumBitRate:
			o = new FlowControlIndication_restriction_maximumBitRate;
			break;
		case e_noRestriction:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & FlowControlIndication_restriction :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_maximumBitRate, "maximumBitRate" },
		{ e_noRestriction, "noRestriction" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

FlowControlIndication_restriction * FlowControlIndication_restriction :: clone ( ) const {
	return new FlowControlIndication_restriction ( * this );
}

//
// H223Capability_h223MultiplexTableCapability_enhanced
//

H223Capability_h223MultiplexTableCapability_enhanced :: H223Capability_h223MultiplexTableCapability_enhanced ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_maximumNestingDepth ( is ), m_maximumElementListSize ( is ), m_maximumSubElementListSize ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

H223Capability_h223MultiplexTableCapability_enhanced :: H223Capability_h223MultiplexTableCapability_enhanced ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void H223Capability_h223MultiplexTableCapability_enhanced :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_maximumNestingDepth.encode ( os );
	m_maximumElementListSize.encode ( os );
	m_maximumSubElementListSize.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void H223Capability_h223MultiplexTableCapability_enhanced :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 22 ) << "maximumNestingDepth = " << std :: setprecision ( indent ) << m_maximumNestingDepth << '\n';
	os << std :: setw ( indent + 25 ) << "maximumElementListSize = " << std :: setprecision ( indent ) << m_maximumElementListSize << '\n';
	os << std :: setw ( indent + 28 ) << "maximumSubElementListSize = " << std :: setprecision ( indent ) << m_maximumSubElementListSize << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H223Capability_h223MultiplexTableCapability_enhanced * H223Capability_h223MultiplexTableCapability_enhanced :: clone ( ) const {
	return new H223Capability_h223MultiplexTableCapability_enhanced ( * this );
}

//
// RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters
//

RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters :: RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_mpuHorizMBs ( is ), m_mpuVertMBs ( is ), m_mpuTotalNumber ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters :: RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_mpuHorizMBs.encode ( os );
	m_mpuVertMBs.encode ( os );
	m_mpuTotalNumber.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 14 ) << "mpuHorizMBs = " << std :: setprecision ( indent ) << m_mpuHorizMBs << '\n';
	os << std :: setw ( indent + 13 ) << "mpuVertMBs = " << std :: setprecision ( indent ) << m_mpuVertMBs << '\n';
	os << std :: setw ( indent + 17 ) << "mpuTotalNumber = " << std :: setprecision ( indent ) << m_mpuTotalNumber << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters * RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters :: clone ( ) const {
	return new RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters ( * this );
}

//
// H223LogicalChannelParameters_adaptationLayerType_al3
//

H223LogicalChannelParameters_adaptationLayerType_al3 :: H223LogicalChannelParameters_adaptationLayerType_al3 ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, false, 0 ), m_controlFieldOctets ( is ), m_sendBufferSize ( is ) {
}

H223LogicalChannelParameters_adaptationLayerType_al3 :: H223LogicalChannelParameters_adaptationLayerType_al3 ( ) : Asn :: Sequence ( 0, false, 0 ) { }

void H223LogicalChannelParameters_adaptationLayerType_al3 :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_controlFieldOctets.encode ( os );
	m_sendBufferSize.encode ( os );
}

void H223LogicalChannelParameters_adaptationLayerType_al3 :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 21 ) << "controlFieldOctets = " << std :: setprecision ( indent ) << m_controlFieldOctets << '\n';
	os << std :: setw ( indent + 17 ) << "sendBufferSize = " << std :: setprecision ( indent ) << m_sendBufferSize << '\n';
	os << std :: setw ( indent - 1 ) << '}';
}

H223LogicalChannelParameters_adaptationLayerType_al3 * H223LogicalChannelParameters_adaptationLayerType_al3 :: clone ( ) const {
	return new H223LogicalChannelParameters_adaptationLayerType_al3 ( * this );
}

//
// V76LogicalChannelParameters_mode_eRM
//

V76LogicalChannelParameters_mode_eRM :: V76LogicalChannelParameters_mode_eRM ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_windowSize ( is ), m_recovery ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

V76LogicalChannelParameters_mode_eRM :: V76LogicalChannelParameters_mode_eRM ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void V76LogicalChannelParameters_mode_eRM :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_windowSize.encode ( os );
	m_recovery.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void V76LogicalChannelParameters_mode_eRM :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 13 ) << "windowSize = " << std :: setprecision ( indent ) << m_windowSize << '\n';
	os << std :: setw ( indent + 11 ) << "recovery = " << std :: setprecision ( indent ) << m_recovery << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

V76LogicalChannelParameters_mode_eRM * V76LogicalChannelParameters_mode_eRM :: clone ( ) const {
	return new V76LogicalChannelParameters_mode_eRM ( * this );
}

//
// FECData_rfc2733_pktMode
//

FECData_rfc2733_pktMode :: FECData_rfc2733_pktMode ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_rfc2198coding:
			choice = new Asn :: Null ( is );
			break;
		case e_rfc2733sameport:
			choice = new FECData_rfc2733_pktMode_rfc2733sameport ( is );
			break;
		case e_rfc2733diffport:
			choice = new FECData_rfc2733_pktMode_rfc2733diffport ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

FECData_rfc2733_pktMode :: FECData_rfc2733_pktMode ( ) : Asn :: Choice ( 3, true ) { }

void FECData_rfc2733_pktMode :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_rfc2198coding:
			o = new Asn :: Null;
			break;
		case e_rfc2733sameport:
			o = new FECData_rfc2733_pktMode_rfc2733sameport;
			break;
		case e_rfc2733diffport:
			o = new FECData_rfc2733_pktMode_rfc2733diffport;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & FECData_rfc2733_pktMode :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_rfc2198coding, "rfc2198coding" },
		{ e_rfc2733sameport, "rfc2733sameport" },
		{ e_rfc2733diffport, "rfc2733diffport" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

FECData_rfc2733_pktMode * FECData_rfc2733_pktMode :: clone ( ) const {
	return new FECData_rfc2733_pktMode ( * this );
}

//
// OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters
//

OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters :: OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters ( Asn :: istream & is ) : Asn :: Choice ( is, 1, true ) {
	switch ( tag ) {
		case e_h222LogicalChannelParameters:
			choice = new H222LogicalChannelParameters ( is );
			break;
		case e_h2250LogicalChannelParameters:
			choice = new H2250LogicalChannelParameters ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters :: OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters ( ) : Asn :: Choice ( 1, true ) { }

void OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_h222LogicalChannelParameters:
			o = new H222LogicalChannelParameters;
			break;
		case e_h2250LogicalChannelParameters:
			o = new H2250LogicalChannelParameters;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_h222LogicalChannelParameters, "h222LogicalChannelParameters" },
		{ e_h2250LogicalChannelParameters, "h2250LogicalChannelParameters" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters * OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters :: clone ( ) const {
	return new OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters ( * this );
}

//
// H223ModeParameters_adaptationLayerType_al3
//

H223ModeParameters_adaptationLayerType_al3 :: H223ModeParameters_adaptationLayerType_al3 ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, false, 0 ), m_controlFieldOctets ( is ), m_sendBufferSize ( is ) {
}

H223ModeParameters_adaptationLayerType_al3 :: H223ModeParameters_adaptationLayerType_al3 ( ) : Asn :: Sequence ( 0, false, 0 ) { }

void H223ModeParameters_adaptationLayerType_al3 :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_controlFieldOctets.encode ( os );
	m_sendBufferSize.encode ( os );
}

void H223ModeParameters_adaptationLayerType_al3 :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 21 ) << "controlFieldOctets = " << std :: setprecision ( indent ) << m_controlFieldOctets << '\n';
	os << std :: setw ( indent + 17 ) << "sendBufferSize = " << std :: setprecision ( indent ) << m_sendBufferSize << '\n';
	os << std :: setw ( indent - 1 ) << '}';
}

H223ModeParameters_adaptationLayerType_al3 * H223ModeParameters_adaptationLayerType_al3 :: clone ( ) const {
	return new H223ModeParameters_adaptationLayerType_al3 ( * this );
}

//
// MultilinkRequest_maximumHeaderInterval_requestType
//

MultilinkRequest_maximumHeaderInterval_requestType :: MultilinkRequest_maximumHeaderInterval_requestType ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_currentIntervalInformation:
			choice = new Asn :: Null ( is );
			break;
		case e_requestedInterval:
			choice = new MultilinkRequest_maximumHeaderInterval_requestType_requestedInterval ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

MultilinkRequest_maximumHeaderInterval_requestType :: MultilinkRequest_maximumHeaderInterval_requestType ( ) : Asn :: Choice ( 2, true ) { }

void MultilinkRequest_maximumHeaderInterval_requestType :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_currentIntervalInformation:
			o = new Asn :: Null;
			break;
		case e_requestedInterval:
			o = new MultilinkRequest_maximumHeaderInterval_requestType_requestedInterval;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & MultilinkRequest_maximumHeaderInterval_requestType :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_currentIntervalInformation, "currentIntervalInformation" },
		{ e_requestedInterval, "requestedInterval" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

MultilinkRequest_maximumHeaderInterval_requestType * MultilinkRequest_maximumHeaderInterval_requestType :: clone ( ) const {
	return new MultilinkRequest_maximumHeaderInterval_requestType ( * this );
}

//
// MultilinkResponse_addConnection_responseCode
//

MultilinkResponse_addConnection_responseCode :: MultilinkResponse_addConnection_responseCode ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_accepted:
			choice = new Asn :: Null ( is );
			break;
		case e_rejected:
			choice = new MultilinkResponse_addConnection_responseCode_rejected ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

MultilinkResponse_addConnection_responseCode :: MultilinkResponse_addConnection_responseCode ( ) : Asn :: Choice ( 2, true ) { }

void MultilinkResponse_addConnection_responseCode :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_accepted:
			o = new Asn :: Null;
			break;
		case e_rejected:
			o = new MultilinkResponse_addConnection_responseCode_rejected;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & MultilinkResponse_addConnection_responseCode :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_accepted, "accepted" },
		{ e_rejected, "rejected" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

MultilinkResponse_addConnection_responseCode * MultilinkResponse_addConnection_responseCode :: clone ( ) const {
	return new MultilinkResponse_addConnection_responseCode ( * this );
}

//
// MiscellaneousCommand_type_videoFastUpdateGOB
//

MiscellaneousCommand_type_videoFastUpdateGOB :: MiscellaneousCommand_type_videoFastUpdateGOB ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, false, 0 ), m_firstGOB ( is ), m_numberOfGOBs ( is ) {
}

MiscellaneousCommand_type_videoFastUpdateGOB :: MiscellaneousCommand_type_videoFastUpdateGOB ( ) : Asn :: Sequence ( 0, false, 0 ) { }

void MiscellaneousCommand_type_videoFastUpdateGOB :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_firstGOB.encode ( os );
	m_numberOfGOBs.encode ( os );
}

void MiscellaneousCommand_type_videoFastUpdateGOB :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 11 ) << "firstGOB = " << std :: setprecision ( indent ) << m_firstGOB << '\n';
	os << std :: setw ( indent + 15 ) << "numberOfGOBs = " << std :: setprecision ( indent ) << m_numberOfGOBs << '\n';
	os << std :: setw ( indent - 1 ) << '}';
}

MiscellaneousCommand_type_videoFastUpdateGOB * MiscellaneousCommand_type_videoFastUpdateGOB :: clone ( ) const {
	return new MiscellaneousCommand_type_videoFastUpdateGOB ( * this );
}

//
// MiscellaneousCommand_type_videoFastUpdateMB
//

MiscellaneousCommand_type_videoFastUpdateMB :: MiscellaneousCommand_type_videoFastUpdateMB ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 0 ), m_firstGOB ( hasOptionalField ( e_firstGOB ) ? pushTemporaryMember ( new MiscellaneousCommand_type_videoFastUpdateMB_firstGOB ( is ) ) : 0 ), m_firstMB ( hasOptionalField ( e_firstMB ) ? pushTemporaryMember ( new MiscellaneousCommand_type_videoFastUpdateMB_firstMB ( is ) ) : 0 ), m_numberOfMBs ( is ) {
	clearTemporaryMembers ( );
	try {
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_firstGOB;
		delete m_firstMB;
		throw;
	}
}

MiscellaneousCommand_type_videoFastUpdateMB :: MiscellaneousCommand_type_videoFastUpdateMB ( ) : Asn :: Sequence ( 2, true, 0 ), m_firstGOB ( 0 ), m_firstMB ( 0 ) { }

MiscellaneousCommand_type_videoFastUpdateMB & MiscellaneousCommand_type_videoFastUpdateMB :: operator= ( const MiscellaneousCommand_type_videoFastUpdateMB & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_firstGOB, s.m_firstGOB );
	assignCopy ( m_firstMB, s.m_firstMB );
	m_numberOfMBs = s.m_numberOfMBs;
	return * this;
}

MiscellaneousCommand_type_videoFastUpdateMB :: MiscellaneousCommand_type_videoFastUpdateMB ( const MiscellaneousCommand_type_videoFastUpdateMB & s ) : Asn :: Sequence ( s ), m_firstGOB ( 0 ), m_firstMB ( 0 ), m_numberOfMBs ( s.m_numberOfMBs ) {
	try {
		if ( s.m_firstGOB )
			m_firstGOB = new MiscellaneousCommand_type_videoFastUpdateMB_firstGOB ( * s.m_firstGOB );
		if ( s.m_firstMB )
			m_firstMB = new MiscellaneousCommand_type_videoFastUpdateMB_firstMB ( * s.m_firstMB );
	} catch ( ... ) {
		delete m_firstGOB;
		delete m_firstMB;
		throw;
	}
}


void MiscellaneousCommand_type_videoFastUpdateMB :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_firstGOB:
			assignNew ( m_firstGOB, new MiscellaneousCommand_type_videoFastUpdateMB_firstGOB );
			break;
		case e_firstMB:
			assignNew ( m_firstMB, new MiscellaneousCommand_type_videoFastUpdateMB_firstMB );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void MiscellaneousCommand_type_videoFastUpdateMB :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_firstGOB:
			delete m_firstGOB;
			m_firstGOB = 0;
			break;
		case e_firstMB:
			delete m_firstMB;
			m_firstMB = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void MiscellaneousCommand_type_videoFastUpdateMB :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_firstGOB ) )
		m_firstGOB -> MiscellaneousCommand_type_videoFastUpdateMB_firstGOB :: encode ( os );
	if ( hasOptionalField ( e_firstMB ) )
		m_firstMB -> MiscellaneousCommand_type_videoFastUpdateMB_firstMB :: encode ( os );
	m_numberOfMBs.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

MiscellaneousCommand_type_videoFastUpdateMB :: ~MiscellaneousCommand_type_videoFastUpdateMB ( ) {
	delete m_firstGOB;
	delete m_firstMB;
}

void MiscellaneousCommand_type_videoFastUpdateMB :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_firstGOB ) ) {
		os << std :: setw ( indent + 11 ) << "firstGOB = " << std :: setprecision ( indent );
		m_firstGOB -> MiscellaneousCommand_type_videoFastUpdateMB_firstGOB :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_firstMB ) ) {
		os << std :: setw ( indent + 10 ) << "firstMB = " << std :: setprecision ( indent );
		m_firstMB -> MiscellaneousCommand_type_videoFastUpdateMB_firstMB :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 14 ) << "numberOfMBs = " << std :: setprecision ( indent ) << m_numberOfMBs << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MiscellaneousCommand_type_videoFastUpdateMB * MiscellaneousCommand_type_videoFastUpdateMB :: clone ( ) const {
	return new MiscellaneousCommand_type_videoFastUpdateMB ( * this );
}

//
// MiscellaneousCommand_type_progressiveRefinementStart
//

MiscellaneousCommand_type_progressiveRefinementStart :: MiscellaneousCommand_type_progressiveRefinementStart ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_repeatCount ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MiscellaneousCommand_type_progressiveRefinementStart :: MiscellaneousCommand_type_progressiveRefinementStart ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MiscellaneousCommand_type_progressiveRefinementStart :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_repeatCount.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MiscellaneousCommand_type_progressiveRefinementStart :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 14 ) << "repeatCount = " << std :: setprecision ( indent ) << m_repeatCount << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MiscellaneousCommand_type_progressiveRefinementStart * MiscellaneousCommand_type_progressiveRefinementStart :: clone ( ) const {
	return new MiscellaneousCommand_type_progressiveRefinementStart ( * this );
}

//
// MiscellaneousCommand_type_videoBadMBs
//

MiscellaneousCommand_type_videoBadMBs :: MiscellaneousCommand_type_videoBadMBs ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_firstMB ( is ), m_numberOfMBs ( is ), m_temporalReference ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MiscellaneousCommand_type_videoBadMBs :: MiscellaneousCommand_type_videoBadMBs ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MiscellaneousCommand_type_videoBadMBs :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_firstMB.encode ( os );
	m_numberOfMBs.encode ( os );
	m_temporalReference.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MiscellaneousCommand_type_videoBadMBs :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 10 ) << "firstMB = " << std :: setprecision ( indent ) << m_firstMB << '\n';
	os << std :: setw ( indent + 14 ) << "numberOfMBs = " << std :: setprecision ( indent ) << m_numberOfMBs << '\n';
	os << std :: setw ( indent + 20 ) << "temporalReference = " << std :: setprecision ( indent ) << m_temporalReference << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MiscellaneousCommand_type_videoBadMBs * MiscellaneousCommand_type_videoBadMBs :: clone ( ) const {
	return new MiscellaneousCommand_type_videoBadMBs ( * this );
}

//
// MiscellaneousCommand_type_lostPartialPicture
//

MiscellaneousCommand_type_lostPartialPicture :: MiscellaneousCommand_type_lostPartialPicture ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_pictureReference ( is ), m_firstMB ( is ), m_numberOfMBs ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MiscellaneousCommand_type_lostPartialPicture :: MiscellaneousCommand_type_lostPartialPicture ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MiscellaneousCommand_type_lostPartialPicture :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_pictureReference.encode ( os );
	m_firstMB.encode ( os );
	m_numberOfMBs.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MiscellaneousCommand_type_lostPartialPicture :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 19 ) << "pictureReference = " << std :: setprecision ( indent ) << m_pictureReference << '\n';
	os << std :: setw ( indent + 10 ) << "firstMB = " << std :: setprecision ( indent ) << m_firstMB << '\n';
	os << std :: setw ( indent + 14 ) << "numberOfMBs = " << std :: setprecision ( indent ) << m_numberOfMBs << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MiscellaneousCommand_type_lostPartialPicture * MiscellaneousCommand_type_lostPartialPicture :: clone ( ) const {
	return new MiscellaneousCommand_type_lostPartialPicture ( * this );
}

//
// MiscellaneousCommand_type_encryptionUpdateCommand
//

MiscellaneousCommand_type_encryptionUpdateCommand :: MiscellaneousCommand_type_encryptionUpdateCommand ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_encryptionSync ( is ), m_multiplePayloadStream ( 0 ) {
	try {
		if ( hasOptionalField ( e_multiplePayloadStream ) )
			m_multiplePayloadStream = new MultiplePayloadStream ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_multiplePayloadStream;
		throw;
	}
}

MiscellaneousCommand_type_encryptionUpdateCommand :: MiscellaneousCommand_type_encryptionUpdateCommand ( ) : Asn :: Sequence ( 1, true, 0 ), m_multiplePayloadStream ( 0 ) { }

MiscellaneousCommand_type_encryptionUpdateCommand & MiscellaneousCommand_type_encryptionUpdateCommand :: operator= ( const MiscellaneousCommand_type_encryptionUpdateCommand & s ) {
	Asn :: Sequence :: operator= ( s );
	m_encryptionSync = s.m_encryptionSync;
	assignCopy ( m_multiplePayloadStream, s.m_multiplePayloadStream );
	return * this;
}

MiscellaneousCommand_type_encryptionUpdateCommand :: MiscellaneousCommand_type_encryptionUpdateCommand ( const MiscellaneousCommand_type_encryptionUpdateCommand & s ) : Asn :: Sequence ( s ), m_encryptionSync ( s.m_encryptionSync ), m_multiplePayloadStream ( 0 ) {
	try {
		if ( s.m_multiplePayloadStream )
			m_multiplePayloadStream = new MultiplePayloadStream ( * s.m_multiplePayloadStream );
	} catch ( ... ) {
		delete m_multiplePayloadStream;
		throw;
	}
}


void MiscellaneousCommand_type_encryptionUpdateCommand :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_multiplePayloadStream:
			assignNew ( m_multiplePayloadStream, new MultiplePayloadStream );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void MiscellaneousCommand_type_encryptionUpdateCommand :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_multiplePayloadStream:
			delete m_multiplePayloadStream;
			m_multiplePayloadStream = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void MiscellaneousCommand_type_encryptionUpdateCommand :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_encryptionSync.encode ( os );
	if ( hasOptionalField ( e_multiplePayloadStream ) )
		m_multiplePayloadStream -> MultiplePayloadStream :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

MiscellaneousCommand_type_encryptionUpdateCommand :: ~MiscellaneousCommand_type_encryptionUpdateCommand ( ) {
	delete m_multiplePayloadStream;
}

void MiscellaneousCommand_type_encryptionUpdateCommand :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 17 ) << "encryptionSync = " << std :: setprecision ( indent ) << m_encryptionSync << '\n';
	if ( hasOptionalField ( e_multiplePayloadStream ) ) {
		os << std :: setw ( indent + 24 ) << "multiplePayloadStream = " << std :: setprecision ( indent );
		m_multiplePayloadStream -> MultiplePayloadStream :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MiscellaneousCommand_type_encryptionUpdateCommand * MiscellaneousCommand_type_encryptionUpdateCommand :: clone ( ) const {
	return new MiscellaneousCommand_type_encryptionUpdateCommand ( * this );
}

//
// MiscellaneousCommand_type_encryptionUpdateAck
//

MiscellaneousCommand_type_encryptionUpdateAck :: MiscellaneousCommand_type_encryptionUpdateAck ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_synchFlag ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MiscellaneousCommand_type_encryptionUpdateAck :: MiscellaneousCommand_type_encryptionUpdateAck ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MiscellaneousCommand_type_encryptionUpdateAck :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_synchFlag.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MiscellaneousCommand_type_encryptionUpdateAck :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 12 ) << "synchFlag = " << std :: setprecision ( indent ) << m_synchFlag << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MiscellaneousCommand_type_encryptionUpdateAck * MiscellaneousCommand_type_encryptionUpdateAck :: clone ( ) const {
	return new MiscellaneousCommand_type_encryptionUpdateAck ( * this );
}

//
// NewATMVCCommand_aal_aal1
//

NewATMVCCommand_aal_aal1 :: NewATMVCCommand_aal_aal1 ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_clockRecovery ( is ), m_errorCorrection ( is ), m_structuredDataTransfer ( is ), m_partiallyFilledCells ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

NewATMVCCommand_aal_aal1 :: NewATMVCCommand_aal_aal1 ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void NewATMVCCommand_aal_aal1 :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_clockRecovery.encode ( os );
	m_errorCorrection.encode ( os );
	m_structuredDataTransfer.encode ( os );
	m_partiallyFilledCells.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void NewATMVCCommand_aal_aal1 :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "clockRecovery = " << std :: setprecision ( indent ) << m_clockRecovery << '\n';
	os << std :: setw ( indent + 18 ) << "errorCorrection = " << std :: setprecision ( indent ) << m_errorCorrection << '\n';
	os << std :: setw ( indent + 25 ) << "structuredDataTransfer = " << std :: setprecision ( indent ) << m_structuredDataTransfer << '\n';
	os << std :: setw ( indent + 23 ) << "partiallyFilledCells = " << std :: setprecision ( indent ) << m_partiallyFilledCells << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

NewATMVCCommand_aal_aal1 * NewATMVCCommand_aal_aal1 :: clone ( ) const {
	return new NewATMVCCommand_aal_aal1 ( * this );
}

//
// NewATMVCCommand_aal_aal5
//

NewATMVCCommand_aal_aal5 :: NewATMVCCommand_aal_aal5 ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_forwardMaximumSDUSize ( is ), m_backwardMaximumSDUSize ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

NewATMVCCommand_aal_aal5 :: NewATMVCCommand_aal_aal5 ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void NewATMVCCommand_aal_aal5 :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_forwardMaximumSDUSize.encode ( os );
	m_backwardMaximumSDUSize.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void NewATMVCCommand_aal_aal5 :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 24 ) << "forwardMaximumSDUSize = " << std :: setprecision ( indent ) << m_forwardMaximumSDUSize << '\n';
	os << std :: setw ( indent + 25 ) << "backwardMaximumSDUSize = " << std :: setprecision ( indent ) << m_backwardMaximumSDUSize << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

NewATMVCCommand_aal_aal5 * NewATMVCCommand_aal_aal5 :: clone ( ) const {
	return new NewATMVCCommand_aal_aal5 ( * this );
}

//
// MiscellaneousIndication_type_videoNotDecodedMBs
//

MiscellaneousIndication_type_videoNotDecodedMBs :: MiscellaneousIndication_type_videoNotDecodedMBs ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_firstMB ( is ), m_numberOfMBs ( is ), m_temporalReference ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MiscellaneousIndication_type_videoNotDecodedMBs :: MiscellaneousIndication_type_videoNotDecodedMBs ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MiscellaneousIndication_type_videoNotDecodedMBs :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_firstMB.encode ( os );
	m_numberOfMBs.encode ( os );
	m_temporalReference.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MiscellaneousIndication_type_videoNotDecodedMBs :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 10 ) << "firstMB = " << std :: setprecision ( indent ) << m_firstMB << '\n';
	os << std :: setw ( indent + 14 ) << "numberOfMBs = " << std :: setprecision ( indent ) << m_numberOfMBs << '\n';
	os << std :: setw ( indent + 20 ) << "temporalReference = " << std :: setprecision ( indent ) << m_temporalReference << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MiscellaneousIndication_type_videoNotDecodedMBs * MiscellaneousIndication_type_videoNotDecodedMBs :: clone ( ) const {
	return new MiscellaneousIndication_type_videoNotDecodedMBs ( * this );
}

//
// NewATMVCIndication_aal_aal1
//

NewATMVCIndication_aal_aal1 :: NewATMVCIndication_aal_aal1 ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_clockRecovery ( is ), m_errorCorrection ( is ), m_structuredDataTransfer ( is ), m_partiallyFilledCells ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

NewATMVCIndication_aal_aal1 :: NewATMVCIndication_aal_aal1 ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void NewATMVCIndication_aal_aal1 :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_clockRecovery.encode ( os );
	m_errorCorrection.encode ( os );
	m_structuredDataTransfer.encode ( os );
	m_partiallyFilledCells.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void NewATMVCIndication_aal_aal1 :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "clockRecovery = " << std :: setprecision ( indent ) << m_clockRecovery << '\n';
	os << std :: setw ( indent + 18 ) << "errorCorrection = " << std :: setprecision ( indent ) << m_errorCorrection << '\n';
	os << std :: setw ( indent + 25 ) << "structuredDataTransfer = " << std :: setprecision ( indent ) << m_structuredDataTransfer << '\n';
	os << std :: setw ( indent + 23 ) << "partiallyFilledCells = " << std :: setprecision ( indent ) << m_partiallyFilledCells << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

NewATMVCIndication_aal_aal1 * NewATMVCIndication_aal_aal1 :: clone ( ) const {
	return new NewATMVCIndication_aal_aal1 ( * this );
}

//
// NewATMVCIndication_aal_aal5
//

NewATMVCIndication_aal_aal5 :: NewATMVCIndication_aal_aal5 ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_forwardMaximumSDUSize ( is ), m_backwardMaximumSDUSize ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

NewATMVCIndication_aal_aal5 :: NewATMVCIndication_aal_aal5 ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void NewATMVCIndication_aal_aal5 :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_forwardMaximumSDUSize.encode ( os );
	m_backwardMaximumSDUSize.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void NewATMVCIndication_aal_aal5 :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 24 ) << "forwardMaximumSDUSize = " << std :: setprecision ( indent ) << m_forwardMaximumSDUSize << '\n';
	os << std :: setw ( indent + 25 ) << "backwardMaximumSDUSize = " << std :: setprecision ( indent ) << m_backwardMaximumSDUSize << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

NewATMVCIndication_aal_aal5 * NewATMVCIndication_aal_aal5 :: clone ( ) const {
	return new NewATMVCIndication_aal_aal5 ( * this );
}

//
// VCCapability_availableBitRates_type_rangeOfBitRates
//

VCCapability_availableBitRates_type_rangeOfBitRates :: VCCapability_availableBitRates_type_rangeOfBitRates ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, false, 0 ), m_lowerBitRate ( is ), m_higherBitRate ( is ) {
}

VCCapability_availableBitRates_type_rangeOfBitRates :: VCCapability_availableBitRates_type_rangeOfBitRates ( ) : Asn :: Sequence ( 0, false, 0 ) { }

void VCCapability_availableBitRates_type_rangeOfBitRates :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_lowerBitRate.encode ( os );
	m_higherBitRate.encode ( os );
}

void VCCapability_availableBitRates_type_rangeOfBitRates :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 15 ) << "lowerBitRate = " << std :: setprecision ( indent ) << m_lowerBitRate << '\n';
	os << std :: setw ( indent + 16 ) << "higherBitRate = " << std :: setprecision ( indent ) << m_higherBitRate << '\n';
	os << std :: setw ( indent - 1 ) << '}';
}

VCCapability_availableBitRates_type_rangeOfBitRates * VCCapability_availableBitRates_type_rangeOfBitRates :: clone ( ) const {
	return new VCCapability_availableBitRates_type_rangeOfBitRates ( * this );
}

//
// CustomPictureFormat_mPI_customPCF_subtype
//

CustomPictureFormat_mPI_customPCF_subtype :: CustomPictureFormat_mPI_customPCF_subtype ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_clockConversionCode ( is ), m_clockDivisor ( is ), m_customMPI ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

CustomPictureFormat_mPI_customPCF_subtype :: CustomPictureFormat_mPI_customPCF_subtype ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void CustomPictureFormat_mPI_customPCF_subtype :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_clockConversionCode.encode ( os );
	m_clockDivisor.encode ( os );
	m_customMPI.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void CustomPictureFormat_mPI_customPCF_subtype :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 22 ) << "clockConversionCode = " << std :: setprecision ( indent ) << m_clockConversionCode << '\n';
	os << std :: setw ( indent + 15 ) << "clockDivisor = " << std :: setprecision ( indent ) << m_clockDivisor << '\n';
	os << std :: setw ( indent + 12 ) << "customMPI = " << std :: setprecision ( indent ) << m_customMPI << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

CustomPictureFormat_mPI_customPCF_subtype * CustomPictureFormat_mPI_customPCF_subtype :: clone ( ) const {
	return new CustomPictureFormat_mPI_customPCF_subtype ( * this );
}

//
// CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype
//

CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype :: CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_width ( is ), m_height ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype :: CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_width.encode ( os );
	m_height.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 8 ) << "width = " << std :: setprecision ( indent ) << m_width << '\n';
	os << std :: setw ( indent + 9 ) << "height = " << std :: setprecision ( indent ) << m_height << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype * CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype :: clone ( ) const {
	return new CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype ( * this );
}

//
// DepFECData_rfc2733_mode_separateStream_differentPort
//

DepFECData_rfc2733_mode_separateStream_differentPort :: DepFECData_rfc2733_mode_separateStream_differentPort ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_protectedSessionID ( is ), m_protectedPayloadType ( 0 ) {
	try {
		if ( hasOptionalField ( e_protectedPayloadType ) )
			m_protectedPayloadType = new DepFECData_rfc2733_mode_separateStream_differentPort_protectedPayloadType ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_protectedPayloadType;
		throw;
	}
}

DepFECData_rfc2733_mode_separateStream_differentPort :: DepFECData_rfc2733_mode_separateStream_differentPort ( ) : Asn :: Sequence ( 1, true, 0 ), m_protectedPayloadType ( 0 ) { }

DepFECData_rfc2733_mode_separateStream_differentPort & DepFECData_rfc2733_mode_separateStream_differentPort :: operator= ( const DepFECData_rfc2733_mode_separateStream_differentPort & s ) {
	Asn :: Sequence :: operator= ( s );
	m_protectedSessionID = s.m_protectedSessionID;
	assignCopy ( m_protectedPayloadType, s.m_protectedPayloadType );
	return * this;
}

DepFECData_rfc2733_mode_separateStream_differentPort :: DepFECData_rfc2733_mode_separateStream_differentPort ( const DepFECData_rfc2733_mode_separateStream_differentPort & s ) : Asn :: Sequence ( s ), m_protectedSessionID ( s.m_protectedSessionID ), m_protectedPayloadType ( 0 ) {
	try {
		if ( s.m_protectedPayloadType )
			m_protectedPayloadType = new DepFECData_rfc2733_mode_separateStream_differentPort_protectedPayloadType ( * s.m_protectedPayloadType );
	} catch ( ... ) {
		delete m_protectedPayloadType;
		throw;
	}
}


void DepFECData_rfc2733_mode_separateStream_differentPort :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_protectedPayloadType:
			assignNew ( m_protectedPayloadType, new DepFECData_rfc2733_mode_separateStream_differentPort_protectedPayloadType );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void DepFECData_rfc2733_mode_separateStream_differentPort :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_protectedPayloadType:
			delete m_protectedPayloadType;
			m_protectedPayloadType = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void DepFECData_rfc2733_mode_separateStream_differentPort :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_protectedSessionID.encode ( os );
	if ( hasOptionalField ( e_protectedPayloadType ) )
		m_protectedPayloadType -> DepFECData_rfc2733_mode_separateStream_differentPort_protectedPayloadType :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

DepFECData_rfc2733_mode_separateStream_differentPort :: ~DepFECData_rfc2733_mode_separateStream_differentPort ( ) {
	delete m_protectedPayloadType;
}

void DepFECData_rfc2733_mode_separateStream_differentPort :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 21 ) << "protectedSessionID = " << std :: setprecision ( indent ) << m_protectedSessionID << '\n';
	if ( hasOptionalField ( e_protectedPayloadType ) ) {
		os << std :: setw ( indent + 23 ) << "protectedPayloadType = " << std :: setprecision ( indent );
		m_protectedPayloadType -> DepFECData_rfc2733_mode_separateStream_differentPort_protectedPayloadType :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

DepFECData_rfc2733_mode_separateStream_differentPort * DepFECData_rfc2733_mode_separateStream_differentPort :: clone ( ) const {
	return new DepFECData_rfc2733_mode_separateStream_differentPort ( * this );
}

//
// DepFECData_rfc2733_mode_separateStream_samePort
//

DepFECData_rfc2733_mode_separateStream_samePort :: DepFECData_rfc2733_mode_separateStream_samePort ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_protectedPayloadType ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

DepFECData_rfc2733_mode_separateStream_samePort :: DepFECData_rfc2733_mode_separateStream_samePort ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void DepFECData_rfc2733_mode_separateStream_samePort :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_protectedPayloadType.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void DepFECData_rfc2733_mode_separateStream_samePort :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 23 ) << "protectedPayloadType = " << std :: setprecision ( indent ) << m_protectedPayloadType << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

DepFECData_rfc2733_mode_separateStream_samePort * DepFECData_rfc2733_mode_separateStream_samePort :: clone ( ) const {
	return new DepFECData_rfc2733_mode_separateStream_samePort ( * this );
}

//
// DepFECMode_rfc2733Mode_mode_separateStream_differentPort
//

DepFECMode_rfc2733Mode_mode_separateStream_differentPort :: DepFECMode_rfc2733Mode_mode_separateStream_differentPort ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_protectedSessionID ( is ), m_protectedPayloadType ( 0 ) {
	try {
		if ( hasOptionalField ( e_protectedPayloadType ) )
			m_protectedPayloadType = new DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedPayloadType ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_protectedPayloadType;
		throw;
	}
}

DepFECMode_rfc2733Mode_mode_separateStream_differentPort :: DepFECMode_rfc2733Mode_mode_separateStream_differentPort ( ) : Asn :: Sequence ( 1, true, 0 ), m_protectedPayloadType ( 0 ) { }

DepFECMode_rfc2733Mode_mode_separateStream_differentPort & DepFECMode_rfc2733Mode_mode_separateStream_differentPort :: operator= ( const DepFECMode_rfc2733Mode_mode_separateStream_differentPort & s ) {
	Asn :: Sequence :: operator= ( s );
	m_protectedSessionID = s.m_protectedSessionID;
	assignCopy ( m_protectedPayloadType, s.m_protectedPayloadType );
	return * this;
}

DepFECMode_rfc2733Mode_mode_separateStream_differentPort :: DepFECMode_rfc2733Mode_mode_separateStream_differentPort ( const DepFECMode_rfc2733Mode_mode_separateStream_differentPort & s ) : Asn :: Sequence ( s ), m_protectedSessionID ( s.m_protectedSessionID ), m_protectedPayloadType ( 0 ) {
	try {
		if ( s.m_protectedPayloadType )
			m_protectedPayloadType = new DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedPayloadType ( * s.m_protectedPayloadType );
	} catch ( ... ) {
		delete m_protectedPayloadType;
		throw;
	}
}


void DepFECMode_rfc2733Mode_mode_separateStream_differentPort :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_protectedPayloadType:
			assignNew ( m_protectedPayloadType, new DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedPayloadType );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void DepFECMode_rfc2733Mode_mode_separateStream_differentPort :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_protectedPayloadType:
			delete m_protectedPayloadType;
			m_protectedPayloadType = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void DepFECMode_rfc2733Mode_mode_separateStream_differentPort :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_protectedSessionID.encode ( os );
	if ( hasOptionalField ( e_protectedPayloadType ) )
		m_protectedPayloadType -> DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedPayloadType :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

DepFECMode_rfc2733Mode_mode_separateStream_differentPort :: ~DepFECMode_rfc2733Mode_mode_separateStream_differentPort ( ) {
	delete m_protectedPayloadType;
}

void DepFECMode_rfc2733Mode_mode_separateStream_differentPort :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 21 ) << "protectedSessionID = " << std :: setprecision ( indent ) << m_protectedSessionID << '\n';
	if ( hasOptionalField ( e_protectedPayloadType ) ) {
		os << std :: setw ( indent + 23 ) << "protectedPayloadType = " << std :: setprecision ( indent );
		m_protectedPayloadType -> DepFECMode_rfc2733Mode_mode_separateStream_differentPort_protectedPayloadType :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

DepFECMode_rfc2733Mode_mode_separateStream_differentPort * DepFECMode_rfc2733Mode_mode_separateStream_differentPort :: clone ( ) const {
	return new DepFECMode_rfc2733Mode_mode_separateStream_differentPort ( * this );
}

//
// NonStandardIdentifier
//

NonStandardIdentifier :: NonStandardIdentifier ( Asn :: istream & is ) : Asn :: Choice ( is, 2, false ) {
	switch ( tag ) {
		case e_object:
			choice = new Asn :: ObjectId ( is );
			break;
		case e_h221NonStandard:
			choice = new NonStandardIdentifier_h221NonStandard ( is );
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
}

NonStandardIdentifier :: NonStandardIdentifier ( ) : Asn :: Choice ( 2, false ) { }

void NonStandardIdentifier :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_object:
			o = new Asn :: ObjectId;
			break;
		case e_h221NonStandard:
			o = new NonStandardIdentifier_h221NonStandard;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & NonStandardIdentifier :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_object, "object" },
		{ e_h221NonStandard, "h221NonStandard" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

NonStandardIdentifier * NonStandardIdentifier :: clone ( ) const {
	return new NonStandardIdentifier ( * this );
}

//
// TerminalCapabilitySetReject
//

TerminalCapabilitySetReject :: TerminalCapabilitySetReject ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 1 ), m_sequenceNumber ( is ), m_cause ( is ), m_genericInformation ( 0 ) {
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_genericInformation ) )
				m_genericInformation = new ArrayOf_GenericInformation ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_genericInformation;
		throw;
	}
}

TerminalCapabilitySetReject :: TerminalCapabilitySetReject ( ) : Asn :: Sequence ( 0, true, 1 ), m_genericInformation ( 0 ) { }

TerminalCapabilitySetReject & TerminalCapabilitySetReject :: operator= ( const TerminalCapabilitySetReject & s ) {
	Asn :: Sequence :: operator= ( s );
	m_sequenceNumber = s.m_sequenceNumber;
	m_cause = s.m_cause;
	assignCopy ( m_genericInformation, s.m_genericInformation );
	return * this;
}

TerminalCapabilitySetReject :: TerminalCapabilitySetReject ( const TerminalCapabilitySetReject & s ) : Asn :: Sequence ( s ), m_sequenceNumber ( s.m_sequenceNumber ), m_cause ( s.m_cause ), m_genericInformation ( 0 ) {
	try {
		if ( s.m_genericInformation )
			m_genericInformation = new ArrayOf_GenericInformation ( * s.m_genericInformation );
	} catch ( ... ) {
		delete m_genericInformation;
		throw;
	}
}


void TerminalCapabilitySetReject :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_genericInformation:
			assignNew ( m_genericInformation, new ArrayOf_GenericInformation );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void TerminalCapabilitySetReject :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_genericInformation:
			delete m_genericInformation;
			m_genericInformation = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void TerminalCapabilitySetReject :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_sequenceNumber.encode ( os );
	m_cause.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_genericInformation, m_genericInformation );
		unknownExtensionsEncode ( os );
	}
}

TerminalCapabilitySetReject :: ~TerminalCapabilitySetReject ( ) {
	delete m_genericInformation;
}

void TerminalCapabilitySetReject :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 17 ) << "sequenceNumber = " << std :: setprecision ( indent ) << m_sequenceNumber << '\n';
	os << std :: setw ( indent + 8 ) << "cause = " << std :: setprecision ( indent ) << m_cause << '\n';
	if ( hasOptionalField ( e_genericInformation ) ) {
		os << std :: setw ( indent + 21 ) << "genericInformation = " << std :: setprecision ( indent );
		m_genericInformation -> ArrayOf_GenericInformation :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

TerminalCapabilitySetReject * TerminalCapabilitySetReject :: clone ( ) const {
	return new TerminalCapabilitySetReject ( * this );
}

//
// H2250Capability
//

H2250Capability :: H2250Capability ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 4 ), m_maximumAudioDelayJitter ( is ), m_receiveMultipointCapability ( is ), m_transmitMultipointCapability ( is ), m_receiveAndTransmitMultipointCapability ( is ), m_mcCapability ( is ), m_rtcpVideoControlCapability ( is ), m_mediaPacketizationCapability ( is ), m_transportCapability ( 0 ), m_redundancyEncodingCapability ( 0 ), m_logicalChannelSwitchingCapability ( 0 ), m_t120DynamicPortCapability ( 0 ) {
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_transportCapability ) )
				m_transportCapability = new TransportCapability ( is );
			if ( hasKnownExtensionToDecode ( is, e_redundancyEncodingCapability ) )
				m_redundancyEncodingCapability = new H2250Capability_redundancyEncodingCapability ( is );
			if ( hasKnownExtensionToDecode ( is, e_logicalChannelSwitchingCapability ) )
				m_logicalChannelSwitchingCapability = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_t120DynamicPortCapability ) )
				m_t120DynamicPortCapability = new Asn :: Boolean ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_transportCapability;
		delete m_redundancyEncodingCapability;
		delete m_logicalChannelSwitchingCapability;
		delete m_t120DynamicPortCapability;
		throw;
	}
}

H2250Capability :: H2250Capability ( ) : Asn :: Sequence ( 0, true, 4 ), m_transportCapability ( 0 ), m_redundancyEncodingCapability ( 0 ), m_logicalChannelSwitchingCapability ( 0 ), m_t120DynamicPortCapability ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_logicalChannelSwitchingCapability );
		m_logicalChannelSwitchingCapability = new Asn :: Boolean;
		Asn :: Sequence :: includeOptionalField ( e_t120DynamicPortCapability );
		m_t120DynamicPortCapability = new Asn :: Boolean;
	} catch ( ... ) {
		delete m_logicalChannelSwitchingCapability;
		delete m_t120DynamicPortCapability;
		throw;
	}
}

H2250Capability & H2250Capability :: operator= ( const H2250Capability & s ) {
	Asn :: Sequence :: operator= ( s );
	m_maximumAudioDelayJitter = s.m_maximumAudioDelayJitter;
	m_receiveMultipointCapability = s.m_receiveMultipointCapability;
	m_transmitMultipointCapability = s.m_transmitMultipointCapability;
	m_receiveAndTransmitMultipointCapability = s.m_receiveAndTransmitMultipointCapability;
	m_mcCapability = s.m_mcCapability;
	m_rtcpVideoControlCapability = s.m_rtcpVideoControlCapability;
	m_mediaPacketizationCapability = s.m_mediaPacketizationCapability;
	assignCopy ( m_transportCapability, s.m_transportCapability );
	assignCopy ( m_redundancyEncodingCapability, s.m_redundancyEncodingCapability );
	assignCopy ( m_logicalChannelSwitchingCapability, s.m_logicalChannelSwitchingCapability );
	assignCopy ( m_t120DynamicPortCapability, s.m_t120DynamicPortCapability );
	return * this;
}

H2250Capability :: H2250Capability ( const H2250Capability & s ) : Asn :: Sequence ( s ), m_maximumAudioDelayJitter ( s.m_maximumAudioDelayJitter ), m_receiveMultipointCapability ( s.m_receiveMultipointCapability ), m_transmitMultipointCapability ( s.m_transmitMultipointCapability ), m_receiveAndTransmitMultipointCapability ( s.m_receiveAndTransmitMultipointCapability ), m_mcCapability ( s.m_mcCapability ), m_rtcpVideoControlCapability ( s.m_rtcpVideoControlCapability ), m_mediaPacketizationCapability ( s.m_mediaPacketizationCapability ), m_transportCapability ( 0 ), m_redundancyEncodingCapability ( 0 ), m_logicalChannelSwitchingCapability ( 0 ), m_t120DynamicPortCapability ( 0 ) {
	try {
		if ( s.m_transportCapability )
			m_transportCapability = new TransportCapability ( * s.m_transportCapability );
		if ( s.m_redundancyEncodingCapability )
			m_redundancyEncodingCapability = new H2250Capability_redundancyEncodingCapability ( * s.m_redundancyEncodingCapability );
		if ( s.m_logicalChannelSwitchingCapability )
			m_logicalChannelSwitchingCapability = new Asn :: Boolean ( * s.m_logicalChannelSwitchingCapability );
		if ( s.m_t120DynamicPortCapability )
			m_t120DynamicPortCapability = new Asn :: Boolean ( * s.m_t120DynamicPortCapability );
	} catch ( ... ) {
		delete m_transportCapability;
		delete m_redundancyEncodingCapability;
		delete m_logicalChannelSwitchingCapability;
		delete m_t120DynamicPortCapability;
		throw;
	}
}


void H2250Capability :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_transportCapability:
			assignNew ( m_transportCapability, new TransportCapability );
			break;
		case e_redundancyEncodingCapability:
			assignNew ( m_redundancyEncodingCapability, new H2250Capability_redundancyEncodingCapability );
			break;
		case e_logicalChannelSwitchingCapability:
			assignNew ( m_logicalChannelSwitchingCapability, new Asn :: Boolean );
			break;
		case e_t120DynamicPortCapability:
			assignNew ( m_t120DynamicPortCapability, new Asn :: Boolean );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void H2250Capability :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_transportCapability:
			delete m_transportCapability;
			m_transportCapability = 0;
			break;
		case e_redundancyEncodingCapability:
			delete m_redundancyEncodingCapability;
			m_redundancyEncodingCapability = 0;
			break;
		case e_logicalChannelSwitchingCapability:
			delete m_logicalChannelSwitchingCapability;
			m_logicalChannelSwitchingCapability = 0;
			break;
		case e_t120DynamicPortCapability:
			delete m_t120DynamicPortCapability;
			m_t120DynamicPortCapability = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void H2250Capability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_maximumAudioDelayJitter.encode ( os );
	m_receiveMultipointCapability.encode ( os );
	m_transmitMultipointCapability.encode ( os );
	m_receiveAndTransmitMultipointCapability.encode ( os );
	m_mcCapability.encode ( os );
	m_rtcpVideoControlCapability.encode ( os );
	m_mediaPacketizationCapability.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_transportCapability, m_transportCapability );
		knownExtensionEncode ( os, e_redundancyEncodingCapability, m_redundancyEncodingCapability );
		knownExtensionEncode ( os, e_logicalChannelSwitchingCapability, m_logicalChannelSwitchingCapability );
		knownExtensionEncode ( os, e_t120DynamicPortCapability, m_t120DynamicPortCapability );
		unknownExtensionsEncode ( os );
	}
}

H2250Capability :: ~H2250Capability ( ) {
	delete m_transportCapability;
	delete m_redundancyEncodingCapability;
	delete m_logicalChannelSwitchingCapability;
	delete m_t120DynamicPortCapability;
}

void H2250Capability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 26 ) << "maximumAudioDelayJitter = " << std :: setprecision ( indent ) << m_maximumAudioDelayJitter << '\n';
	os << std :: setw ( indent + 30 ) << "receiveMultipointCapability = " << std :: setprecision ( indent ) << m_receiveMultipointCapability << '\n';
	os << std :: setw ( indent + 31 ) << "transmitMultipointCapability = " << std :: setprecision ( indent ) << m_transmitMultipointCapability << '\n';
	os << std :: setw ( indent + 41 ) << "receiveAndTransmitMultipointCapability = " << std :: setprecision ( indent ) << m_receiveAndTransmitMultipointCapability << '\n';
	os << std :: setw ( indent + 15 ) << "mcCapability = " << std :: setprecision ( indent ) << m_mcCapability << '\n';
	os << std :: setw ( indent + 29 ) << "rtcpVideoControlCapability = " << std :: setprecision ( indent ) << m_rtcpVideoControlCapability << '\n';
	os << std :: setw ( indent + 31 ) << "mediaPacketizationCapability = " << std :: setprecision ( indent ) << m_mediaPacketizationCapability << '\n';
	if ( hasOptionalField ( e_transportCapability ) ) {
		os << std :: setw ( indent + 22 ) << "transportCapability = " << std :: setprecision ( indent );
		m_transportCapability -> TransportCapability :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_redundancyEncodingCapability ) ) {
		os << std :: setw ( indent + 31 ) << "redundancyEncodingCapability = " << std :: setprecision ( indent );
		m_redundancyEncodingCapability -> H2250Capability_redundancyEncodingCapability :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_logicalChannelSwitchingCapability ) ) {
		os << std :: setw ( indent + 36 ) << "logicalChannelSwitchingCapability = " << std :: setprecision ( indent );
		m_logicalChannelSwitchingCapability -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_t120DynamicPortCapability ) ) {
		os << std :: setw ( indent + 28 ) << "t120DynamicPortCapability = " << std :: setprecision ( indent );
		m_t120DynamicPortCapability -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H2250Capability * H2250Capability :: clone ( ) const {
	return new H2250Capability ( * this );
}

//
// RTPH263VideoRedundancyEncoding
//

RTPH263VideoRedundancyEncoding :: RTPH263VideoRedundancyEncoding ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_numberOfThreads ( is ), m_framesBetweenSyncPoints ( is ), m_frameToThreadMapping ( is ), m_containedThreads ( 0 ) {
	try {
		if ( hasOptionalField ( e_containedThreads ) )
			m_containedThreads = new RTPH263VideoRedundancyEncoding_containedThreads ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_containedThreads;
		throw;
	}
}

RTPH263VideoRedundancyEncoding :: RTPH263VideoRedundancyEncoding ( ) : Asn :: Sequence ( 1, true, 0 ), m_containedThreads ( 0 ) { }

RTPH263VideoRedundancyEncoding & RTPH263VideoRedundancyEncoding :: operator= ( const RTPH263VideoRedundancyEncoding & s ) {
	Asn :: Sequence :: operator= ( s );
	m_numberOfThreads = s.m_numberOfThreads;
	m_framesBetweenSyncPoints = s.m_framesBetweenSyncPoints;
	m_frameToThreadMapping = s.m_frameToThreadMapping;
	assignCopy ( m_containedThreads, s.m_containedThreads );
	return * this;
}

RTPH263VideoRedundancyEncoding :: RTPH263VideoRedundancyEncoding ( const RTPH263VideoRedundancyEncoding & s ) : Asn :: Sequence ( s ), m_numberOfThreads ( s.m_numberOfThreads ), m_framesBetweenSyncPoints ( s.m_framesBetweenSyncPoints ), m_frameToThreadMapping ( s.m_frameToThreadMapping ), m_containedThreads ( 0 ) {
	try {
		if ( s.m_containedThreads )
			m_containedThreads = new RTPH263VideoRedundancyEncoding_containedThreads ( * s.m_containedThreads );
	} catch ( ... ) {
		delete m_containedThreads;
		throw;
	}
}


void RTPH263VideoRedundancyEncoding :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_containedThreads:
			assignNew ( m_containedThreads, new RTPH263VideoRedundancyEncoding_containedThreads );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void RTPH263VideoRedundancyEncoding :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_containedThreads:
			delete m_containedThreads;
			m_containedThreads = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void RTPH263VideoRedundancyEncoding :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_numberOfThreads.encode ( os );
	m_framesBetweenSyncPoints.encode ( os );
	m_frameToThreadMapping.encode ( os );
	if ( hasOptionalField ( e_containedThreads ) )
		m_containedThreads -> RTPH263VideoRedundancyEncoding_containedThreads :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

RTPH263VideoRedundancyEncoding :: ~RTPH263VideoRedundancyEncoding ( ) {
	delete m_containedThreads;
}

void RTPH263VideoRedundancyEncoding :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 18 ) << "numberOfThreads = " << std :: setprecision ( indent ) << m_numberOfThreads << '\n';
	os << std :: setw ( indent + 26 ) << "framesBetweenSyncPoints = " << std :: setprecision ( indent ) << m_framesBetweenSyncPoints << '\n';
	os << std :: setw ( indent + 23 ) << "frameToThreadMapping = " << std :: setprecision ( indent ) << m_frameToThreadMapping << '\n';
	if ( hasOptionalField ( e_containedThreads ) ) {
		os << std :: setw ( indent + 19 ) << "containedThreads = " << std :: setprecision ( indent );
		m_containedThreads -> RTPH263VideoRedundancyEncoding_containedThreads :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RTPH263VideoRedundancyEncoding * RTPH263VideoRedundancyEncoding :: clone ( ) const {
	return new RTPH263VideoRedundancyEncoding ( * this );
}

//
// BEnhancementParameters
//

BEnhancementParameters :: BEnhancementParameters ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_enhancementOptions ( is ), m_numberOfBPictures ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

BEnhancementParameters :: BEnhancementParameters ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void BEnhancementParameters :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_enhancementOptions.encode ( os );
	m_numberOfBPictures.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void BEnhancementParameters :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 21 ) << "enhancementOptions = " << std :: setprecision ( indent ) << m_enhancementOptions << '\n';
	os << std :: setw ( indent + 20 ) << "numberOfBPictures = " << std :: setprecision ( indent ) << m_numberOfBPictures << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

BEnhancementParameters * BEnhancementParameters :: clone ( ) const {
	return new BEnhancementParameters ( * this );
}

//
// CustomPictureFormat
//

CustomPictureFormat :: CustomPictureFormat ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_maxCustomPictureWidth ( is ), m_maxCustomPictureHeight ( is ), m_minCustomPictureWidth ( is ), m_minCustomPictureHeight ( is ), m_mPI ( is ), m_pixelAspectInformation ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

CustomPictureFormat :: CustomPictureFormat ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void CustomPictureFormat :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_maxCustomPictureWidth.encode ( os );
	m_maxCustomPictureHeight.encode ( os );
	m_minCustomPictureWidth.encode ( os );
	m_minCustomPictureHeight.encode ( os );
	m_mPI.encode ( os );
	m_pixelAspectInformation.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void CustomPictureFormat :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 24 ) << "maxCustomPictureWidth = " << std :: setprecision ( indent ) << m_maxCustomPictureWidth << '\n';
	os << std :: setw ( indent + 25 ) << "maxCustomPictureHeight = " << std :: setprecision ( indent ) << m_maxCustomPictureHeight << '\n';
	os << std :: setw ( indent + 24 ) << "minCustomPictureWidth = " << std :: setprecision ( indent ) << m_minCustomPictureWidth << '\n';
	os << std :: setw ( indent + 25 ) << "minCustomPictureHeight = " << std :: setprecision ( indent ) << m_minCustomPictureHeight << '\n';
	os << std :: setw ( indent + 6 ) << "mPI = " << std :: setprecision ( indent ) << m_mPI << '\n';
	os << std :: setw ( indent + 25 ) << "pixelAspectInformation = " << std :: setprecision ( indent ) << m_pixelAspectInformation << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

CustomPictureFormat * CustomPictureFormat :: clone ( ) const {
	return new CustomPictureFormat ( * this );
}

//
// CompressionType
//

CompressionType :: CompressionType ( Asn :: istream & is ) : Asn :: Choice ( is, 1, true ) {
	switch ( tag ) {
		case e_v42bis:
			choice = new V42bis ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

CompressionType :: CompressionType ( ) : Asn :: Choice ( 1, true ) { }

void CompressionType :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_v42bis:
			o = new V42bis;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & CompressionType :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_v42bis, "v42bis" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

CompressionType * CompressionType :: clone ( ) const {
	return new CompressionType ( * this );
}

//
// DepFECCapability
//

DepFECCapability :: DepFECCapability ( Asn :: istream & is ) : Asn :: Choice ( is, 1, true ) {
	switch ( tag ) {
		case e_rfc2733:
			choice = new DepFECCapability_rfc2733 ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

DepFECCapability :: DepFECCapability ( ) : Asn :: Choice ( 1, true ) { }

void DepFECCapability :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_rfc2733:
			o = new DepFECCapability_rfc2733;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & DepFECCapability :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_rfc2733, "rfc2733" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

DepFECCapability * DepFECCapability :: clone ( ) const {
	return new DepFECCapability ( * this );
}

//
// Q2931Address
//

Q2931Address :: Q2931Address ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_address ( is ), m_subaddress ( 0 ) {
	try {
		if ( hasOptionalField ( e_subaddress ) )
			m_subaddress = new Q2931Address_subaddress ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_subaddress;
		throw;
	}
}

Q2931Address :: Q2931Address ( ) : Asn :: Sequence ( 1, true, 0 ), m_subaddress ( 0 ) { }

Q2931Address & Q2931Address :: operator= ( const Q2931Address & s ) {
	Asn :: Sequence :: operator= ( s );
	m_address = s.m_address;
	assignCopy ( m_subaddress, s.m_subaddress );
	return * this;
}

Q2931Address :: Q2931Address ( const Q2931Address & s ) : Asn :: Sequence ( s ), m_address ( s.m_address ), m_subaddress ( 0 ) {
	try {
		if ( s.m_subaddress )
			m_subaddress = new Q2931Address_subaddress ( * s.m_subaddress );
	} catch ( ... ) {
		delete m_subaddress;
		throw;
	}
}


void Q2931Address :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_subaddress:
			assignNew ( m_subaddress, new Q2931Address_subaddress );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void Q2931Address :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_subaddress:
			delete m_subaddress;
			m_subaddress = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void Q2931Address :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_address.encode ( os );
	if ( hasOptionalField ( e_subaddress ) )
		m_subaddress -> Q2931Address_subaddress :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

Q2931Address :: ~Q2931Address ( ) {
	delete m_subaddress;
}

void Q2931Address :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 10 ) << "address = " << std :: setprecision ( indent ) << m_address << '\n';
	if ( hasOptionalField ( e_subaddress ) ) {
		os << std :: setw ( indent + 13 ) << "subaddress = " << std :: setprecision ( indent );
		m_subaddress -> Q2931Address_subaddress :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

Q2931Address * Q2931Address :: clone ( ) const {
	return new Q2931Address ( * this );
}

//
// H223AnnexCArqParameters
//

H223AnnexCArqParameters :: H223AnnexCArqParameters ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_numberOfRetransmissions ( is ), m_sendBufferSize ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

H223AnnexCArqParameters :: H223AnnexCArqParameters ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void H223AnnexCArqParameters :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_numberOfRetransmissions.encode ( os );
	m_sendBufferSize.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void H223AnnexCArqParameters :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 26 ) << "numberOfRetransmissions = " << std :: setprecision ( indent ) << m_numberOfRetransmissions << '\n';
	os << std :: setw ( indent + 17 ) << "sendBufferSize = " << std :: setprecision ( indent ) << m_sendBufferSize << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H223AnnexCArqParameters * H223AnnexCArqParameters :: clone ( ) const {
	return new H223AnnexCArqParameters ( * this );
}

//
// MultiplexElement
//

MultiplexElement :: MultiplexElement ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, false, 0 ), m_type ( is ), m_repeatCount ( is ) {
}

MultiplexElement :: MultiplexElement ( ) : Asn :: Sequence ( 0, false, 0 ) { }

void MultiplexElement :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_type.encode ( os );
	m_repeatCount.encode ( os );
}

void MultiplexElement :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 7 ) << "type = " << std :: setprecision ( indent ) << m_type << '\n';
	os << std :: setw ( indent + 14 ) << "repeatCount = " << std :: setprecision ( indent ) << m_repeatCount << '\n';
	os << std :: setw ( indent - 1 ) << '}';
}

MultiplexElement * MultiplexElement :: clone ( ) const {
	return new MultiplexElement ( * this );
}

//
// G7231AnnexCMode
//

G7231AnnexCMode :: G7231AnnexCMode ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_maxAl_sduAudioFrames ( is ), m_silenceSuppression ( is ), m_g723AnnexCAudioMode ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

G7231AnnexCMode :: G7231AnnexCMode ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void G7231AnnexCMode :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_maxAl_sduAudioFrames.encode ( os );
	m_silenceSuppression.encode ( os );
	m_g723AnnexCAudioMode.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void G7231AnnexCMode :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 23 ) << "maxAl_sduAudioFrames = " << std :: setprecision ( indent ) << m_maxAl_sduAudioFrames << '\n';
	os << std :: setw ( indent + 21 ) << "silenceSuppression = " << std :: setprecision ( indent ) << m_silenceSuppression << '\n';
	os << std :: setw ( indent + 22 ) << "g723AnnexCAudioMode = " << std :: setprecision ( indent ) << m_g723AnnexCAudioMode << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

G7231AnnexCMode * G7231AnnexCMode :: clone ( ) const {
	return new G7231AnnexCMode ( * this );
}

//
// ConferenceRequest
//

ConferenceRequest :: ConferenceRequest ( Asn :: istream & is ) : Asn :: Choice ( is, 8, true ) {
	switch ( tag ) {
		case e_terminalListRequest:
		case e_makeMeChair:
		case e_cancelMakeMeChair:
		case e_enterH243Password:
		case e_enterH243TerminalID:
		case e_enterH243ConferenceID:
		case e_enterExtensionAddress:
		case e_requestChairTokenOwner:
		case e_requestAllTerminalIDs:
			choice = new Asn :: Null ( is );
			break;
		case e_dropTerminal:
		case e_requestTerminalID:
		case e_makeTerminalBroadcaster:
		case e_sendThisSource:
			choice = new TerminalLabel ( is );
			break;
		case e_requestTerminalCertificate:
			choice = new ConferenceRequest_requestTerminalCertificate ( is );
			break;
		case e_broadcastMyLogicalChannel:
			choice = new LogicalChannelNumber ( is );
			break;
		case e_remoteMCRequest:
			choice = new RemoteMCRequest ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

ConferenceRequest :: ConferenceRequest ( ) : Asn :: Choice ( 8, true ) { }

void ConferenceRequest :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_terminalListRequest:
		case e_makeMeChair:
		case e_cancelMakeMeChair:
		case e_enterH243Password:
		case e_enterH243TerminalID:
		case e_enterH243ConferenceID:
		case e_enterExtensionAddress:
		case e_requestChairTokenOwner:
		case e_requestAllTerminalIDs:
			o = new Asn :: Null;
			break;
		case e_dropTerminal:
		case e_requestTerminalID:
		case e_makeTerminalBroadcaster:
		case e_sendThisSource:
			o = new TerminalLabel;
			break;
		case e_requestTerminalCertificate:
			o = new ConferenceRequest_requestTerminalCertificate;
			break;
		case e_broadcastMyLogicalChannel:
			o = new LogicalChannelNumber;
			break;
		case e_remoteMCRequest:
			o = new RemoteMCRequest;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & ConferenceRequest :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_terminalListRequest, "terminalListRequest" },
		{ e_makeMeChair, "makeMeChair" },
		{ e_cancelMakeMeChair, "cancelMakeMeChair" },
		{ e_dropTerminal, "dropTerminal" },
		{ e_requestTerminalID, "requestTerminalID" },
		{ e_enterH243Password, "enterH243Password" },
		{ e_enterH243TerminalID, "enterH243TerminalID" },
		{ e_enterH243ConferenceID, "enterH243ConferenceID" },
		{ e_enterExtensionAddress, "enterExtensionAddress" },
		{ e_requestChairTokenOwner, "requestChairTokenOwner" },
		{ e_requestTerminalCertificate, "requestTerminalCertificate" },
		{ e_broadcastMyLogicalChannel, "broadcastMyLogicalChannel" },
		{ e_makeTerminalBroadcaster, "makeTerminalBroadcaster" },
		{ e_sendThisSource, "sendThisSource" },
		{ e_requestAllTerminalIDs, "requestAllTerminalIDs" },
		{ e_remoteMCRequest, "remoteMCRequest" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

ConferenceRequest * ConferenceRequest :: clone ( ) const {
	return new ConferenceRequest ( * this );
}

//
// ConferenceResponse
//

ConferenceResponse :: ConferenceResponse ( Asn :: istream & is ) : Asn :: Choice ( is, 8, true ) {
	switch ( tag ) {
		case e_mCTerminalIDResponse:
			choice = new ConferenceResponse_mCTerminalIDResponse ( is );
			break;
		case e_terminalIDResponse:
			choice = new ConferenceResponse_terminalIDResponse ( is );
			break;
		case e_conferenceIDResponse:
			choice = new ConferenceResponse_conferenceIDResponse ( is );
			break;
		case e_passwordResponse:
			choice = new ConferenceResponse_passwordResponse ( is );
			break;
		case e_terminalListResponse:
			choice = new ConferenceResponse_terminalListResponse ( is );
			break;
		case e_videoCommandReject:
		case e_terminalDropReject:
			choice = new Asn :: Null ( is );
			break;
		case e_makeMeChairResponse:
			choice = new ConferenceResponse_makeMeChairResponse ( is );
			break;
		case e_extensionAddressResponse:
			choice = new ConferenceResponse_extensionAddressResponse ( is );
			break;
		case e_chairTokenOwnerResponse:
			choice = new ConferenceResponse_chairTokenOwnerResponse ( is );
			break;
		case e_terminalCertificateResponse:
			choice = new ConferenceResponse_terminalCertificateResponse ( is );
			break;
		case e_broadcastMyLogicalChannelResponse:
			choice = new ConferenceResponse_broadcastMyLogicalChannelResponse ( is );
			break;
		case e_makeTerminalBroadcasterResponse:
			choice = new ConferenceResponse_makeTerminalBroadcasterResponse ( is );
			break;
		case e_sendThisSourceResponse:
			choice = new ConferenceResponse_sendThisSourceResponse ( is );
			break;
		case e_requestAllTerminalIDsResponse:
			choice = new RequestAllTerminalIDsResponse ( is );
			break;
		case e_remoteMCResponse:
			choice = new RemoteMCResponse ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

ConferenceResponse :: ConferenceResponse ( ) : Asn :: Choice ( 8, true ) { }

void ConferenceResponse :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_mCTerminalIDResponse:
			o = new ConferenceResponse_mCTerminalIDResponse;
			break;
		case e_terminalIDResponse:
			o = new ConferenceResponse_terminalIDResponse;
			break;
		case e_conferenceIDResponse:
			o = new ConferenceResponse_conferenceIDResponse;
			break;
		case e_passwordResponse:
			o = new ConferenceResponse_passwordResponse;
			break;
		case e_terminalListResponse:
			o = new ConferenceResponse_terminalListResponse;
			break;
		case e_videoCommandReject:
		case e_terminalDropReject:
			o = new Asn :: Null;
			break;
		case e_makeMeChairResponse:
			o = new ConferenceResponse_makeMeChairResponse;
			break;
		case e_extensionAddressResponse:
			o = new ConferenceResponse_extensionAddressResponse;
			break;
		case e_chairTokenOwnerResponse:
			o = new ConferenceResponse_chairTokenOwnerResponse;
			break;
		case e_terminalCertificateResponse:
			o = new ConferenceResponse_terminalCertificateResponse;
			break;
		case e_broadcastMyLogicalChannelResponse:
			o = new ConferenceResponse_broadcastMyLogicalChannelResponse;
			break;
		case e_makeTerminalBroadcasterResponse:
			o = new ConferenceResponse_makeTerminalBroadcasterResponse;
			break;
		case e_sendThisSourceResponse:
			o = new ConferenceResponse_sendThisSourceResponse;
			break;
		case e_requestAllTerminalIDsResponse:
			o = new RequestAllTerminalIDsResponse;
			break;
		case e_remoteMCResponse:
			o = new RemoteMCResponse;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & ConferenceResponse :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_mCTerminalIDResponse, "mCTerminalIDResponse" },
		{ e_terminalIDResponse, "terminalIDResponse" },
		{ e_conferenceIDResponse, "conferenceIDResponse" },
		{ e_passwordResponse, "passwordResponse" },
		{ e_terminalListResponse, "terminalListResponse" },
		{ e_videoCommandReject, "videoCommandReject" },
		{ e_terminalDropReject, "terminalDropReject" },
		{ e_makeMeChairResponse, "makeMeChairResponse" },
		{ e_extensionAddressResponse, "extensionAddressResponse" },
		{ e_chairTokenOwnerResponse, "chairTokenOwnerResponse" },
		{ e_terminalCertificateResponse, "terminalCertificateResponse" },
		{ e_broadcastMyLogicalChannelResponse, "broadcastMyLogicalChannelResponse" },
		{ e_makeTerminalBroadcasterResponse, "makeTerminalBroadcasterResponse" },
		{ e_sendThisSourceResponse, "sendThisSourceResponse" },
		{ e_requestAllTerminalIDsResponse, "requestAllTerminalIDsResponse" },
		{ e_remoteMCResponse, "remoteMCResponse" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

ConferenceResponse * ConferenceResponse :: clone ( ) const {
	return new ConferenceResponse ( * this );
}

//
// FlowControlCommand
//

FlowControlCommand :: FlowControlCommand ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_scope ( is ), m_restriction ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

FlowControlCommand :: FlowControlCommand ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void FlowControlCommand :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_scope.encode ( os );
	m_restriction.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void FlowControlCommand :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 8 ) << "scope = " << std :: setprecision ( indent ) << m_scope << '\n';
	os << std :: setw ( indent + 14 ) << "restriction = " << std :: setprecision ( indent ) << m_restriction << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

FlowControlCommand * FlowControlCommand :: clone ( ) const {
	return new FlowControlCommand ( * this );
}

//
// ConferenceCommand
//

ConferenceCommand :: ConferenceCommand ( Asn :: istream & is ) : Asn :: Choice ( is, 7, true ) {
	switch ( tag ) {
		case e_broadcastMyLogicalChannel:
		case e_cancelBroadcastMyLogicalChannel:
			choice = new LogicalChannelNumber ( is );
			break;
		case e_makeTerminalBroadcaster:
		case e_sendThisSource:
			choice = new TerminalLabel ( is );
			break;
		case e_cancelMakeTerminalBroadcaster:
		case e_cancelSendThisSource:
		case e_dropConference:
			choice = new Asn :: Null ( is );
			break;
		case e_substituteConferenceIDCommand:
			choice = new SubstituteConferenceIDCommand ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

ConferenceCommand :: ConferenceCommand ( ) : Asn :: Choice ( 7, true ) { }

void ConferenceCommand :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_broadcastMyLogicalChannel:
		case e_cancelBroadcastMyLogicalChannel:
			o = new LogicalChannelNumber;
			break;
		case e_makeTerminalBroadcaster:
		case e_sendThisSource:
			o = new TerminalLabel;
			break;
		case e_cancelMakeTerminalBroadcaster:
		case e_cancelSendThisSource:
		case e_dropConference:
			o = new Asn :: Null;
			break;
		case e_substituteConferenceIDCommand:
			o = new SubstituteConferenceIDCommand;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & ConferenceCommand :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_broadcastMyLogicalChannel, "broadcastMyLogicalChannel" },
		{ e_cancelBroadcastMyLogicalChannel, "cancelBroadcastMyLogicalChannel" },
		{ e_makeTerminalBroadcaster, "makeTerminalBroadcaster" },
		{ e_cancelMakeTerminalBroadcaster, "cancelMakeTerminalBroadcaster" },
		{ e_sendThisSource, "sendThisSource" },
		{ e_cancelSendThisSource, "cancelSendThisSource" },
		{ e_dropConference, "dropConference" },
		{ e_substituteConferenceIDCommand, "substituteConferenceIDCommand" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

ConferenceCommand * ConferenceCommand :: clone ( ) const {
	return new ConferenceCommand ( * this );
}

//
// ConferenceIndication
//

ConferenceIndication :: ConferenceIndication ( Asn :: istream & is ) : Asn :: Choice ( is, 10, true ) {
	switch ( tag ) {
		case e_sbeNumber:
			choice = new ConferenceIndication_sbeNumber ( is );
			break;
		case e_terminalNumberAssign:
		case e_terminalJoinedConference:
		case e_terminalLeftConference:
		case e_terminalYouAreSeeing:
		case e_floorRequested:
			choice = new TerminalLabel ( is );
			break;
		case e_seenByAtLeastOneOther:
		case e_cancelSeenByAtLeastOneOther:
		case e_seenByAll:
		case e_cancelSeenByAll:
		case e_requestForFloor:
		case e_withdrawChairToken:
			choice = new Asn :: Null ( is );
			break;
		case e_terminalYouAreSeeingInSubPictureNumber:
			choice = new TerminalYouAreSeeingInSubPictureNumber ( is );
			break;
		case e_videoIndicateCompose:
			choice = new VideoIndicateCompose ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

ConferenceIndication :: ConferenceIndication ( ) : Asn :: Choice ( 10, true ) { }

void ConferenceIndication :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_sbeNumber:
			o = new ConferenceIndication_sbeNumber;
			break;
		case e_terminalNumberAssign:
		case e_terminalJoinedConference:
		case e_terminalLeftConference:
		case e_terminalYouAreSeeing:
		case e_floorRequested:
			o = new TerminalLabel;
			break;
		case e_seenByAtLeastOneOther:
		case e_cancelSeenByAtLeastOneOther:
		case e_seenByAll:
		case e_cancelSeenByAll:
		case e_requestForFloor:
		case e_withdrawChairToken:
			o = new Asn :: Null;
			break;
		case e_terminalYouAreSeeingInSubPictureNumber:
			o = new TerminalYouAreSeeingInSubPictureNumber;
			break;
		case e_videoIndicateCompose:
			o = new VideoIndicateCompose;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & ConferenceIndication :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_sbeNumber, "sbeNumber" },
		{ e_terminalNumberAssign, "terminalNumberAssign" },
		{ e_terminalJoinedConference, "terminalJoinedConference" },
		{ e_terminalLeftConference, "terminalLeftConference" },
		{ e_seenByAtLeastOneOther, "seenByAtLeastOneOther" },
		{ e_cancelSeenByAtLeastOneOther, "cancelSeenByAtLeastOneOther" },
		{ e_seenByAll, "seenByAll" },
		{ e_cancelSeenByAll, "cancelSeenByAll" },
		{ e_terminalYouAreSeeing, "terminalYouAreSeeing" },
		{ e_requestForFloor, "requestForFloor" },
		{ e_withdrawChairToken, "withdrawChairToken" },
		{ e_floorRequested, "floorRequested" },
		{ e_terminalYouAreSeeingInSubPictureNumber, "terminalYouAreSeeingInSubPictureNumber" },
		{ e_videoIndicateCompose, "videoIndicateCompose" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

ConferenceIndication * ConferenceIndication :: clone ( ) const {
	return new ConferenceIndication ( * this );
}

//
// JitterIndication
//

JitterIndication :: JitterIndication ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 0 ), m_scope ( is ), m_estimatedReceivedJitterMantissa ( is ), m_estimatedReceivedJitterExponent ( is ), m_skippedFrameCount ( 0 ), m_additionalDecoderBuffer ( 0 ) {
	try {
		if ( hasOptionalField ( e_skippedFrameCount ) )
			m_skippedFrameCount = new JitterIndication_skippedFrameCount ( is );
		if ( hasOptionalField ( e_additionalDecoderBuffer ) )
			m_additionalDecoderBuffer = new JitterIndication_additionalDecoderBuffer ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_skippedFrameCount;
		delete m_additionalDecoderBuffer;
		throw;
	}
}

JitterIndication :: JitterIndication ( ) : Asn :: Sequence ( 2, true, 0 ), m_skippedFrameCount ( 0 ), m_additionalDecoderBuffer ( 0 ) { }

JitterIndication & JitterIndication :: operator= ( const JitterIndication & s ) {
	Asn :: Sequence :: operator= ( s );
	m_scope = s.m_scope;
	m_estimatedReceivedJitterMantissa = s.m_estimatedReceivedJitterMantissa;
	m_estimatedReceivedJitterExponent = s.m_estimatedReceivedJitterExponent;
	assignCopy ( m_skippedFrameCount, s.m_skippedFrameCount );
	assignCopy ( m_additionalDecoderBuffer, s.m_additionalDecoderBuffer );
	return * this;
}

JitterIndication :: JitterIndication ( const JitterIndication & s ) : Asn :: Sequence ( s ), m_scope ( s.m_scope ), m_estimatedReceivedJitterMantissa ( s.m_estimatedReceivedJitterMantissa ), m_estimatedReceivedJitterExponent ( s.m_estimatedReceivedJitterExponent ), m_skippedFrameCount ( 0 ), m_additionalDecoderBuffer ( 0 ) {
	try {
		if ( s.m_skippedFrameCount )
			m_skippedFrameCount = new JitterIndication_skippedFrameCount ( * s.m_skippedFrameCount );
		if ( s.m_additionalDecoderBuffer )
			m_additionalDecoderBuffer = new JitterIndication_additionalDecoderBuffer ( * s.m_additionalDecoderBuffer );
	} catch ( ... ) {
		delete m_skippedFrameCount;
		delete m_additionalDecoderBuffer;
		throw;
	}
}


void JitterIndication :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_skippedFrameCount:
			assignNew ( m_skippedFrameCount, new JitterIndication_skippedFrameCount );
			break;
		case e_additionalDecoderBuffer:
			assignNew ( m_additionalDecoderBuffer, new JitterIndication_additionalDecoderBuffer );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void JitterIndication :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_skippedFrameCount:
			delete m_skippedFrameCount;
			m_skippedFrameCount = 0;
			break;
		case e_additionalDecoderBuffer:
			delete m_additionalDecoderBuffer;
			m_additionalDecoderBuffer = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void JitterIndication :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_scope.encode ( os );
	m_estimatedReceivedJitterMantissa.encode ( os );
	m_estimatedReceivedJitterExponent.encode ( os );
	if ( hasOptionalField ( e_skippedFrameCount ) )
		m_skippedFrameCount -> JitterIndication_skippedFrameCount :: encode ( os );
	if ( hasOptionalField ( e_additionalDecoderBuffer ) )
		m_additionalDecoderBuffer -> JitterIndication_additionalDecoderBuffer :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

JitterIndication :: ~JitterIndication ( ) {
	delete m_skippedFrameCount;
	delete m_additionalDecoderBuffer;
}

void JitterIndication :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 8 ) << "scope = " << std :: setprecision ( indent ) << m_scope << '\n';
	os << std :: setw ( indent + 34 ) << "estimatedReceivedJitterMantissa = " << std :: setprecision ( indent ) << m_estimatedReceivedJitterMantissa << '\n';
	os << std :: setw ( indent + 34 ) << "estimatedReceivedJitterExponent = " << std :: setprecision ( indent ) << m_estimatedReceivedJitterExponent << '\n';
	if ( hasOptionalField ( e_skippedFrameCount ) ) {
		os << std :: setw ( indent + 20 ) << "skippedFrameCount = " << std :: setprecision ( indent );
		m_skippedFrameCount -> JitterIndication_skippedFrameCount :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_additionalDecoderBuffer ) ) {
		os << std :: setw ( indent + 26 ) << "additionalDecoderBuffer = " << std :: setprecision ( indent );
		m_additionalDecoderBuffer -> JitterIndication_additionalDecoderBuffer :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

JitterIndication * JitterIndication :: clone ( ) const {
	return new JitterIndication ( * this );
}

//
// VendorIdentification
//

VendorIdentification :: VendorIdentification ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 0 ), m_vendor ( is ), m_productNumber ( 0 ), m_versionNumber ( 0 ) {
	try {
		if ( hasOptionalField ( e_productNumber ) )
			m_productNumber = new VendorIdentification_productNumber ( is );
		if ( hasOptionalField ( e_versionNumber ) )
			m_versionNumber = new VendorIdentification_versionNumber ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_productNumber;
		delete m_versionNumber;
		throw;
	}
}

VendorIdentification :: VendorIdentification ( ) : Asn :: Sequence ( 2, true, 0 ), m_productNumber ( 0 ), m_versionNumber ( 0 ) { }

VendorIdentification & VendorIdentification :: operator= ( const VendorIdentification & s ) {
	Asn :: Sequence :: operator= ( s );
	m_vendor = s.m_vendor;
	assignCopy ( m_productNumber, s.m_productNumber );
	assignCopy ( m_versionNumber, s.m_versionNumber );
	return * this;
}

VendorIdentification :: VendorIdentification ( const VendorIdentification & s ) : Asn :: Sequence ( s ), m_vendor ( s.m_vendor ), m_productNumber ( 0 ), m_versionNumber ( 0 ) {
	try {
		if ( s.m_productNumber )
			m_productNumber = new VendorIdentification_productNumber ( * s.m_productNumber );
		if ( s.m_versionNumber )
			m_versionNumber = new VendorIdentification_versionNumber ( * s.m_versionNumber );
	} catch ( ... ) {
		delete m_productNumber;
		delete m_versionNumber;
		throw;
	}
}


void VendorIdentification :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_productNumber:
			assignNew ( m_productNumber, new VendorIdentification_productNumber );
			break;
		case e_versionNumber:
			assignNew ( m_versionNumber, new VendorIdentification_versionNumber );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void VendorIdentification :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_productNumber:
			delete m_productNumber;
			m_productNumber = 0;
			break;
		case e_versionNumber:
			delete m_versionNumber;
			m_versionNumber = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void VendorIdentification :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_vendor.encode ( os );
	if ( hasOptionalField ( e_productNumber ) )
		m_productNumber -> VendorIdentification_productNumber :: encode ( os );
	if ( hasOptionalField ( e_versionNumber ) )
		m_versionNumber -> VendorIdentification_versionNumber :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

VendorIdentification :: ~VendorIdentification ( ) {
	delete m_productNumber;
	delete m_versionNumber;
}

void VendorIdentification :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 9 ) << "vendor = " << std :: setprecision ( indent ) << m_vendor << '\n';
	if ( hasOptionalField ( e_productNumber ) ) {
		os << std :: setw ( indent + 16 ) << "productNumber = " << std :: setprecision ( indent );
		m_productNumber -> VendorIdentification_productNumber :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_versionNumber ) ) {
		os << std :: setw ( indent + 16 ) << "versionNumber = " << std :: setprecision ( indent );
		m_versionNumber -> VendorIdentification_versionNumber :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

VendorIdentification * VendorIdentification :: clone ( ) const {
	return new VendorIdentification ( * this );
}

//
// FlowControlIndication
//

FlowControlIndication :: FlowControlIndication ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_scope ( is ), m_restriction ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

FlowControlIndication :: FlowControlIndication ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void FlowControlIndication :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_scope.encode ( os );
	m_restriction.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void FlowControlIndication :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 8 ) << "scope = " << std :: setprecision ( indent ) << m_scope << '\n';
	os << std :: setw ( indent + 14 ) << "restriction = " << std :: setprecision ( indent ) << m_restriction << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

FlowControlIndication * FlowControlIndication :: clone ( ) const {
	return new FlowControlIndication ( * this );
}

//
// H223Capability_h223MultiplexTableCapability
//

H223Capability_h223MultiplexTableCapability :: H223Capability_h223MultiplexTableCapability ( Asn :: istream & is ) : Asn :: Choice ( is, 2, false ) {
	switch ( tag ) {
		case e_basic:
			choice = new Asn :: Null ( is );
			break;
		case e_enhanced:
			choice = new H223Capability_h223MultiplexTableCapability_enhanced ( is );
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
}

H223Capability_h223MultiplexTableCapability :: H223Capability_h223MultiplexTableCapability ( ) : Asn :: Choice ( 2, false ) { }

void H223Capability_h223MultiplexTableCapability :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_basic:
			o = new Asn :: Null;
			break;
		case e_enhanced:
			o = new H223Capability_h223MultiplexTableCapability_enhanced;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & H223Capability_h223MultiplexTableCapability :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_basic, "basic" },
		{ e_enhanced, "enhanced" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

H223Capability_h223MultiplexTableCapability * H223Capability_h223MultiplexTableCapability :: clone ( ) const {
	return new H223Capability_h223MultiplexTableCapability ( * this );
}

//
// DataProtocolCapability_v76wCompression
//

DataProtocolCapability_v76wCompression :: DataProtocolCapability_v76wCompression ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_transmitCompression:
		case e_receiveCompression:
		case e_transmitAndReceiveCompression:
			choice = new CompressionType ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

DataProtocolCapability_v76wCompression :: DataProtocolCapability_v76wCompression ( ) : Asn :: Choice ( 3, true ) { }

void DataProtocolCapability_v76wCompression :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_transmitCompression:
		case e_receiveCompression:
		case e_transmitAndReceiveCompression:
			o = new CompressionType;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & DataProtocolCapability_v76wCompression :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_transmitCompression, "transmitCompression" },
		{ e_receiveCompression, "receiveCompression" },
		{ e_transmitAndReceiveCompression, "transmitAndReceiveCompression" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

DataProtocolCapability_v76wCompression * DataProtocolCapability_v76wCompression :: clone ( ) const {
	return new DataProtocolCapability_v76wCompression ( * this );
}

//
// H223AL1MParameters_arqType
//

H223AL1MParameters_arqType :: H223AL1MParameters_arqType ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_noArq:
			choice = new Asn :: Null ( is );
			break;
		case e_typeIArq:
		case e_typeIIArq:
			choice = new H223AnnexCArqParameters ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

H223AL1MParameters_arqType :: H223AL1MParameters_arqType ( ) : Asn :: Choice ( 3, true ) { }

void H223AL1MParameters_arqType :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_noArq:
			o = new Asn :: Null;
			break;
		case e_typeIArq:
		case e_typeIIArq:
			o = new H223AnnexCArqParameters;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & H223AL1MParameters_arqType :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_noArq, "noArq" },
		{ e_typeIArq, "typeIArq" },
		{ e_typeIIArq, "typeIIArq" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

H223AL1MParameters_arqType * H223AL1MParameters_arqType :: clone ( ) const {
	return new H223AL1MParameters_arqType ( * this );
}

//
// H223AL3MParameters_arqType
//

H223AL3MParameters_arqType :: H223AL3MParameters_arqType ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_noArq:
			choice = new Asn :: Null ( is );
			break;
		case e_typeIArq:
		case e_typeIIArq:
			choice = new H223AnnexCArqParameters ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

H223AL3MParameters_arqType :: H223AL3MParameters_arqType ( ) : Asn :: Choice ( 3, true ) { }

void H223AL3MParameters_arqType :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_noArq:
			o = new Asn :: Null;
			break;
		case e_typeIArq:
		case e_typeIIArq:
			o = new H223AnnexCArqParameters;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & H223AL3MParameters_arqType :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_noArq, "noArq" },
		{ e_typeIArq, "typeIArq" },
		{ e_typeIIArq, "typeIIArq" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

H223AL3MParameters_arqType * H223AL3MParameters_arqType :: clone ( ) const {
	return new H223AL3MParameters_arqType ( * this );
}

//
// V76LogicalChannelParameters_mode
//

V76LogicalChannelParameters_mode :: V76LogicalChannelParameters_mode ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_eRM:
			choice = new V76LogicalChannelParameters_mode_eRM ( is );
			break;
		case e_uNERM:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

V76LogicalChannelParameters_mode :: V76LogicalChannelParameters_mode ( ) : Asn :: Choice ( 2, true ) { }

void V76LogicalChannelParameters_mode :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_eRM:
			o = new V76LogicalChannelParameters_mode_eRM;
			break;
		case e_uNERM:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & V76LogicalChannelParameters_mode :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_eRM, "eRM" },
		{ e_uNERM, "uNERM" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

V76LogicalChannelParameters_mode * V76LogicalChannelParameters_mode :: clone ( ) const {
	return new V76LogicalChannelParameters_mode ( * this );
}

//
// FECData_rfc2733
//

FECData_rfc2733 :: FECData_rfc2733 ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_protectedPayloadType ( is ), m_fecScheme ( hasOptionalField ( e_fecScheme ) ? pushTemporaryMember ( new Asn :: ObjectId ( is ) ) : 0 ), m_pktMode ( is ) {
	clearTemporaryMembers ( );
	try {
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_fecScheme;
		throw;
	}
}

FECData_rfc2733 :: FECData_rfc2733 ( ) : Asn :: Sequence ( 1, true, 0 ), m_fecScheme ( 0 ) { }

FECData_rfc2733 & FECData_rfc2733 :: operator= ( const FECData_rfc2733 & s ) {
	Asn :: Sequence :: operator= ( s );
	m_protectedPayloadType = s.m_protectedPayloadType;
	assignCopy ( m_fecScheme, s.m_fecScheme );
	m_pktMode = s.m_pktMode;
	return * this;
}

FECData_rfc2733 :: FECData_rfc2733 ( const FECData_rfc2733 & s ) : Asn :: Sequence ( s ), m_protectedPayloadType ( s.m_protectedPayloadType ), m_fecScheme ( 0 ), m_pktMode ( s.m_pktMode ) {
	try {
		if ( s.m_fecScheme )
			m_fecScheme = new Asn :: ObjectId ( * s.m_fecScheme );
	} catch ( ... ) {
		delete m_fecScheme;
		throw;
	}
}


void FECData_rfc2733 :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_fecScheme:
			assignNew ( m_fecScheme, new Asn :: ObjectId );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void FECData_rfc2733 :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_fecScheme:
			delete m_fecScheme;
			m_fecScheme = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void FECData_rfc2733 :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_protectedPayloadType.encode ( os );
	if ( hasOptionalField ( e_fecScheme ) )
		m_fecScheme -> Asn :: ObjectId :: encode ( os );
	m_pktMode.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

FECData_rfc2733 :: ~FECData_rfc2733 ( ) {
	delete m_fecScheme;
}

void FECData_rfc2733 :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 23 ) << "protectedPayloadType = " << std :: setprecision ( indent ) << m_protectedPayloadType << '\n';
	if ( hasOptionalField ( e_fecScheme ) ) {
		os << std :: setw ( indent + 12 ) << "fecScheme = " << std :: setprecision ( indent );
		m_fecScheme -> Asn :: ObjectId :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 10 ) << "pktMode = " << std :: setprecision ( indent ) << m_pktMode << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

FECData_rfc2733 * FECData_rfc2733 :: clone ( ) const {
	return new FECData_rfc2733 ( * this );
}

//
// MultilinkRequest_maximumHeaderInterval
//

MultilinkRequest_maximumHeaderInterval :: MultilinkRequest_maximumHeaderInterval ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_requestType ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MultilinkRequest_maximumHeaderInterval :: MultilinkRequest_maximumHeaderInterval ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MultilinkRequest_maximumHeaderInterval :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_requestType.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MultilinkRequest_maximumHeaderInterval :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 14 ) << "requestType = " << std :: setprecision ( indent ) << m_requestType << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MultilinkRequest_maximumHeaderInterval * MultilinkRequest_maximumHeaderInterval :: clone ( ) const {
	return new MultilinkRequest_maximumHeaderInterval ( * this );
}

//
// MultilinkResponse_addConnection
//

MultilinkResponse_addConnection :: MultilinkResponse_addConnection ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_sequenceNumber ( is ), m_responseCode ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MultilinkResponse_addConnection :: MultilinkResponse_addConnection ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MultilinkResponse_addConnection :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_sequenceNumber.encode ( os );
	m_responseCode.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MultilinkResponse_addConnection :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 17 ) << "sequenceNumber = " << std :: setprecision ( indent ) << m_sequenceNumber << '\n';
	os << std :: setw ( indent + 15 ) << "responseCode = " << std :: setprecision ( indent ) << m_responseCode << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MultilinkResponse_addConnection * MultilinkResponse_addConnection :: clone ( ) const {
	return new MultilinkResponse_addConnection ( * this );
}

//
// MiscellaneousCommand_type
//

MiscellaneousCommand_type :: MiscellaneousCommand_type ( Asn :: istream & is ) : Asn :: Choice ( is, 10, true ) {
	switch ( tag ) {
		case e_equaliseDelay:
		case e_zeroDelay:
		case e_multipointModeCommand:
		case e_cancelMultipointModeCommand:
		case e_videoFreezePicture:
		case e_videoFastUpdatePicture:
		case e_videoSendSyncEveryGOB:
		case e_videoSendSyncEveryGOBCancel:
		case e_switchReceiveMediaOff:
		case e_switchReceiveMediaOn:
		case e_progressiveRefinementAbortOne:
		case e_progressiveRefinementAbortContinuous:
			choice = new Asn :: Null ( is );
			break;
		case e_videoFastUpdateGOB:
			choice = new MiscellaneousCommand_type_videoFastUpdateGOB ( is );
			break;
		case e_videoTemporalSpatialTradeOff:
			choice = new MiscellaneousCommand_type_videoTemporalSpatialTradeOff ( is );
			break;
		case e_videoFastUpdateMB:
			choice = new MiscellaneousCommand_type_videoFastUpdateMB ( is );
			break;
		case e_maxH223MUXPDUsize:
			choice = new MiscellaneousCommand_type_maxH223MUXPDUsize ( is );
			break;
		case e_encryptionUpdate:
			choice = new EncryptionSync ( is );
			break;
		case e_encryptionUpdateRequest:
			choice = new EncryptionUpdateRequest ( is );
			break;
		case e_progressiveRefinementStart:
			choice = new MiscellaneousCommand_type_progressiveRefinementStart ( is );
			break;
		case e_videoBadMBs:
			choice = new MiscellaneousCommand_type_videoBadMBs ( is );
			break;
		case e_lostPicture:
		case e_recoveryReferencePicture:
			choice = new ArrayOf_PictureReference ( is );
			break;
		case e_lostPartialPicture:
			choice = new MiscellaneousCommand_type_lostPartialPicture ( is );
			break;
		case e_encryptionUpdateCommand:
			choice = new MiscellaneousCommand_type_encryptionUpdateCommand ( is );
			break;
		case e_encryptionUpdateAck:
			choice = new MiscellaneousCommand_type_encryptionUpdateAck ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

MiscellaneousCommand_type :: MiscellaneousCommand_type ( ) : Asn :: Choice ( 10, true ) { }

void MiscellaneousCommand_type :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_equaliseDelay:
		case e_zeroDelay:
		case e_multipointModeCommand:
		case e_cancelMultipointModeCommand:
		case e_videoFreezePicture:
		case e_videoFastUpdatePicture:
		case e_videoSendSyncEveryGOB:
		case e_videoSendSyncEveryGOBCancel:
		case e_switchReceiveMediaOff:
		case e_switchReceiveMediaOn:
		case e_progressiveRefinementAbortOne:
		case e_progressiveRefinementAbortContinuous:
			o = new Asn :: Null;
			break;
		case e_videoFastUpdateGOB:
			o = new MiscellaneousCommand_type_videoFastUpdateGOB;
			break;
		case e_videoTemporalSpatialTradeOff:
			o = new MiscellaneousCommand_type_videoTemporalSpatialTradeOff;
			break;
		case e_videoFastUpdateMB:
			o = new MiscellaneousCommand_type_videoFastUpdateMB;
			break;
		case e_maxH223MUXPDUsize:
			o = new MiscellaneousCommand_type_maxH223MUXPDUsize;
			break;
		case e_encryptionUpdate:
			o = new EncryptionSync;
			break;
		case e_encryptionUpdateRequest:
			o = new EncryptionUpdateRequest;
			break;
		case e_progressiveRefinementStart:
			o = new MiscellaneousCommand_type_progressiveRefinementStart;
			break;
		case e_videoBadMBs:
			o = new MiscellaneousCommand_type_videoBadMBs;
			break;
		case e_lostPicture:
		case e_recoveryReferencePicture:
			o = new ArrayOf_PictureReference;
			break;
		case e_lostPartialPicture:
			o = new MiscellaneousCommand_type_lostPartialPicture;
			break;
		case e_encryptionUpdateCommand:
			o = new MiscellaneousCommand_type_encryptionUpdateCommand;
			break;
		case e_encryptionUpdateAck:
			o = new MiscellaneousCommand_type_encryptionUpdateAck;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & MiscellaneousCommand_type :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_equaliseDelay, "equaliseDelay" },
		{ e_zeroDelay, "zeroDelay" },
		{ e_multipointModeCommand, "multipointModeCommand" },
		{ e_cancelMultipointModeCommand, "cancelMultipointModeCommand" },
		{ e_videoFreezePicture, "videoFreezePicture" },
		{ e_videoFastUpdatePicture, "videoFastUpdatePicture" },
		{ e_videoFastUpdateGOB, "videoFastUpdateGOB" },
		{ e_videoTemporalSpatialTradeOff, "videoTemporalSpatialTradeOff" },
		{ e_videoSendSyncEveryGOB, "videoSendSyncEveryGOB" },
		{ e_videoSendSyncEveryGOBCancel, "videoSendSyncEveryGOBCancel" },
		{ e_videoFastUpdateMB, "videoFastUpdateMB" },
		{ e_maxH223MUXPDUsize, "maxH223MUXPDUsize" },
		{ e_encryptionUpdate, "encryptionUpdate" },
		{ e_encryptionUpdateRequest, "encryptionUpdateRequest" },
		{ e_switchReceiveMediaOff, "switchReceiveMediaOff" },
		{ e_switchReceiveMediaOn, "switchReceiveMediaOn" },
		{ e_progressiveRefinementStart, "progressiveRefinementStart" },
		{ e_progressiveRefinementAbortOne, "progressiveRefinementAbortOne" },
		{ e_progressiveRefinementAbortContinuous, "progressiveRefinementAbortContinuous" },
		{ e_videoBadMBs, "videoBadMBs" },
		{ e_lostPicture, "lostPicture" },
		{ e_lostPartialPicture, "lostPartialPicture" },
		{ e_recoveryReferencePicture, "recoveryReferencePicture" },
		{ e_encryptionUpdateCommand, "encryptionUpdateCommand" },
		{ e_encryptionUpdateAck, "encryptionUpdateAck" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

MiscellaneousCommand_type * MiscellaneousCommand_type :: clone ( ) const {
	return new MiscellaneousCommand_type ( * this );
}

//
// NewATMVCCommand_aal
//

NewATMVCCommand_aal :: NewATMVCCommand_aal ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_aal1:
			choice = new NewATMVCCommand_aal_aal1 ( is );
			break;
		case e_aal5:
			choice = new NewATMVCCommand_aal_aal5 ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

NewATMVCCommand_aal :: NewATMVCCommand_aal ( ) : Asn :: Choice ( 2, true ) { }

void NewATMVCCommand_aal :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_aal1:
			o = new NewATMVCCommand_aal_aal1;
			break;
		case e_aal5:
			o = new NewATMVCCommand_aal_aal5;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & NewATMVCCommand_aal :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_aal1, "aal1" },
		{ e_aal5, "aal5" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

NewATMVCCommand_aal * NewATMVCCommand_aal :: clone ( ) const {
	return new NewATMVCCommand_aal ( * this );
}

//
// MiscellaneousIndication_type
//

MiscellaneousIndication_type :: MiscellaneousIndication_type ( Asn :: istream & is ) : Asn :: Choice ( is, 10, true ) {
	switch ( tag ) {
		case e_logicalChannelActive:
		case e_logicalChannelInactive:
		case e_multipointConference:
		case e_cancelMultipointConference:
		case e_multipointZeroComm:
		case e_cancelMultipointZeroComm:
		case e_multipointSecondaryStatus:
		case e_cancelMultipointSecondaryStatus:
		case e_videoIndicateReadyToActivate:
			choice = new Asn :: Null ( is );
			break;
		case e_videoTemporalSpatialTradeOff:
			choice = new MiscellaneousIndication_type_videoTemporalSpatialTradeOff ( is );
			break;
		case e_videoNotDecodedMBs:
			choice = new MiscellaneousIndication_type_videoNotDecodedMBs ( is );
			break;
		case e_transportCapability:
			choice = new TransportCapability ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

MiscellaneousIndication_type :: MiscellaneousIndication_type ( ) : Asn :: Choice ( 10, true ) { }

void MiscellaneousIndication_type :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_logicalChannelActive:
		case e_logicalChannelInactive:
		case e_multipointConference:
		case e_cancelMultipointConference:
		case e_multipointZeroComm:
		case e_cancelMultipointZeroComm:
		case e_multipointSecondaryStatus:
		case e_cancelMultipointSecondaryStatus:
		case e_videoIndicateReadyToActivate:
			o = new Asn :: Null;
			break;
		case e_videoTemporalSpatialTradeOff:
			o = new MiscellaneousIndication_type_videoTemporalSpatialTradeOff;
			break;
		case e_videoNotDecodedMBs:
			o = new MiscellaneousIndication_type_videoNotDecodedMBs;
			break;
		case e_transportCapability:
			o = new TransportCapability;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & MiscellaneousIndication_type :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_logicalChannelActive, "logicalChannelActive" },
		{ e_logicalChannelInactive, "logicalChannelInactive" },
		{ e_multipointConference, "multipointConference" },
		{ e_cancelMultipointConference, "cancelMultipointConference" },
		{ e_multipointZeroComm, "multipointZeroComm" },
		{ e_cancelMultipointZeroComm, "cancelMultipointZeroComm" },
		{ e_multipointSecondaryStatus, "multipointSecondaryStatus" },
		{ e_cancelMultipointSecondaryStatus, "cancelMultipointSecondaryStatus" },
		{ e_videoIndicateReadyToActivate, "videoIndicateReadyToActivate" },
		{ e_videoTemporalSpatialTradeOff, "videoTemporalSpatialTradeOff" },
		{ e_videoNotDecodedMBs, "videoNotDecodedMBs" },
		{ e_transportCapability, "transportCapability" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

MiscellaneousIndication_type * MiscellaneousIndication_type :: clone ( ) const {
	return new MiscellaneousIndication_type ( * this );
}

//
// NewATMVCIndication_aal
//

NewATMVCIndication_aal :: NewATMVCIndication_aal ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_aal1:
			choice = new NewATMVCIndication_aal_aal1 ( is );
			break;
		case e_aal5:
			choice = new NewATMVCIndication_aal_aal5 ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

NewATMVCIndication_aal :: NewATMVCIndication_aal ( ) : Asn :: Choice ( 2, true ) { }

void NewATMVCIndication_aal :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_aal1:
			o = new NewATMVCIndication_aal_aal1;
			break;
		case e_aal5:
			o = new NewATMVCIndication_aal_aal5;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & NewATMVCIndication_aal :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_aal1, "aal1" },
		{ e_aal5, "aal5" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

NewATMVCIndication_aal * NewATMVCIndication_aal :: clone ( ) const {
	return new NewATMVCIndication_aal ( * this );
}

//
// VCCapability_availableBitRates_type
//

VCCapability_availableBitRates_type :: VCCapability_availableBitRates_type ( Asn :: istream & is ) : Asn :: Choice ( is, 2, false ) {
	switch ( tag ) {
		case e_singleBitRate:
			choice = new VCCapability_availableBitRates_type_singleBitRate ( is );
			break;
		case e_rangeOfBitRates:
			choice = new VCCapability_availableBitRates_type_rangeOfBitRates ( is );
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
}

VCCapability_availableBitRates_type :: VCCapability_availableBitRates_type ( ) : Asn :: Choice ( 2, false ) { }

void VCCapability_availableBitRates_type :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_singleBitRate:
			o = new VCCapability_availableBitRates_type_singleBitRate;
			break;
		case e_rangeOfBitRates:
			o = new VCCapability_availableBitRates_type_rangeOfBitRates;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & VCCapability_availableBitRates_type :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_singleBitRate, "singleBitRate" },
		{ e_rangeOfBitRates, "rangeOfBitRates" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

VCCapability_availableBitRates_type * VCCapability_availableBitRates_type :: clone ( ) const {
	return new VCCapability_availableBitRates_type ( * this );
}

//
// DepFECData_rfc2733_mode_separateStream
//

DepFECData_rfc2733_mode_separateStream :: DepFECData_rfc2733_mode_separateStream ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_differentPort:
			choice = new DepFECData_rfc2733_mode_separateStream_differentPort ( is );
			break;
		case e_samePort:
			choice = new DepFECData_rfc2733_mode_separateStream_samePort ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

DepFECData_rfc2733_mode_separateStream :: DepFECData_rfc2733_mode_separateStream ( ) : Asn :: Choice ( 2, true ) { }

void DepFECData_rfc2733_mode_separateStream :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_differentPort:
			o = new DepFECData_rfc2733_mode_separateStream_differentPort;
			break;
		case e_samePort:
			o = new DepFECData_rfc2733_mode_separateStream_samePort;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & DepFECData_rfc2733_mode_separateStream :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_differentPort, "differentPort" },
		{ e_samePort, "samePort" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

DepFECData_rfc2733_mode_separateStream * DepFECData_rfc2733_mode_separateStream :: clone ( ) const {
	return new DepFECData_rfc2733_mode_separateStream ( * this );
}

//
// NonStandardParameter
//

NonStandardParameter :: NonStandardParameter ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, false, 0 ), m_nonStandardIdentifier ( is ), m_data ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) {
}

NonStandardParameter :: NonStandardParameter ( ) : Asn :: Sequence ( 0, false, 0 ) { }

void NonStandardParameter :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_nonStandardIdentifier.encode ( os );
	m_data.encode ( os );
}

void NonStandardParameter :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 24 ) << "nonStandardIdentifier = " << std :: setprecision ( indent ) << m_nonStandardIdentifier << '\n';
	os << std :: setw ( indent + 7 ) << "data = " << std :: setprecision ( indent ) << m_data << '\n';
	os << std :: setw ( indent - 1 ) << '}';
}

NonStandardParameter * NonStandardParameter :: clone ( ) const {
	return new NonStandardParameter ( * this );
}

//
// H223Capability
//

H223Capability :: H223Capability ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 6 ), m_transportWithI_frames ( is ), m_videoWithAL1 ( is ), m_videoWithAL2 ( is ), m_videoWithAL3 ( is ), m_audioWithAL1 ( is ), m_audioWithAL2 ( is ), m_audioWithAL3 ( is ), m_dataWithAL1 ( is ), m_dataWithAL2 ( is ), m_dataWithAL3 ( is ), m_maximumAl2SDUSize ( is ), m_maximumAl3SDUSize ( is ), m_maximumDelayJitter ( is ), m_h223MultiplexTableCapability ( is ), m_maxMUXPDUSizeCapability ( 0 ), m_nsrpSupport ( 0 ), m_mobileOperationTransmitCapability ( 0 ), m_h223AnnexCCapability ( 0 ), m_bitRate ( 0 ), m_mobileMultilinkFrameCapability ( 0 ) {
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_maxMUXPDUSizeCapability ) )
				m_maxMUXPDUSizeCapability = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_nsrpSupport ) )
				m_nsrpSupport = new Asn :: Boolean ( is );
			if ( hasKnownExtensionToDecode ( is, e_mobileOperationTransmitCapability ) )
				m_mobileOperationTransmitCapability = new H223Capability_mobileOperationTransmitCapability ( is );
			if ( hasKnownExtensionToDecode ( is, e_h223AnnexCCapability ) )
				m_h223AnnexCCapability = new H223AnnexCCapability ( is );
			if ( hasKnownExtensionToDecode ( is, e_bitRate ) )
				m_bitRate = new H223Capability_bitRate ( is );
			if ( hasKnownExtensionToDecode ( is, e_mobileMultilinkFrameCapability ) )
				m_mobileMultilinkFrameCapability = new H223Capability_mobileMultilinkFrameCapability ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_maxMUXPDUSizeCapability;
		delete m_nsrpSupport;
		delete m_mobileOperationTransmitCapability;
		delete m_h223AnnexCCapability;
		delete m_bitRate;
		delete m_mobileMultilinkFrameCapability;
		throw;
	}
}

H223Capability :: H223Capability ( ) : Asn :: Sequence ( 0, true, 6 ), m_maxMUXPDUSizeCapability ( 0 ), m_nsrpSupport ( 0 ), m_mobileOperationTransmitCapability ( 0 ), m_h223AnnexCCapability ( 0 ), m_bitRate ( 0 ), m_mobileMultilinkFrameCapability ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_maxMUXPDUSizeCapability );
		m_maxMUXPDUSizeCapability = new Asn :: Boolean;
		Asn :: Sequence :: includeOptionalField ( e_nsrpSupport );
		m_nsrpSupport = new Asn :: Boolean;
	} catch ( ... ) {
		delete m_maxMUXPDUSizeCapability;
		delete m_nsrpSupport;
		throw;
	}
}

H223Capability & H223Capability :: operator= ( const H223Capability & s ) {
	Asn :: Sequence :: operator= ( s );
	m_transportWithI_frames = s.m_transportWithI_frames;
	m_videoWithAL1 = s.m_videoWithAL1;
	m_videoWithAL2 = s.m_videoWithAL2;
	m_videoWithAL3 = s.m_videoWithAL3;
	m_audioWithAL1 = s.m_audioWithAL1;
	m_audioWithAL2 = s.m_audioWithAL2;
	m_audioWithAL3 = s.m_audioWithAL3;
	m_dataWithAL1 = s.m_dataWithAL1;
	m_dataWithAL2 = s.m_dataWithAL2;
	m_dataWithAL3 = s.m_dataWithAL3;
	m_maximumAl2SDUSize = s.m_maximumAl2SDUSize;
	m_maximumAl3SDUSize = s.m_maximumAl3SDUSize;
	m_maximumDelayJitter = s.m_maximumDelayJitter;
	m_h223MultiplexTableCapability = s.m_h223MultiplexTableCapability;
	assignCopy ( m_maxMUXPDUSizeCapability, s.m_maxMUXPDUSizeCapability );
	assignCopy ( m_nsrpSupport, s.m_nsrpSupport );
	assignCopy ( m_mobileOperationTransmitCapability, s.m_mobileOperationTransmitCapability );
	assignCopy ( m_h223AnnexCCapability, s.m_h223AnnexCCapability );
	assignCopy ( m_bitRate, s.m_bitRate );
	assignCopy ( m_mobileMultilinkFrameCapability, s.m_mobileMultilinkFrameCapability );
	return * this;
}

H223Capability :: H223Capability ( const H223Capability & s ) : Asn :: Sequence ( s ), m_transportWithI_frames ( s.m_transportWithI_frames ), m_videoWithAL1 ( s.m_videoWithAL1 ), m_videoWithAL2 ( s.m_videoWithAL2 ), m_videoWithAL3 ( s.m_videoWithAL3 ), m_audioWithAL1 ( s.m_audioWithAL1 ), m_audioWithAL2 ( s.m_audioWithAL2 ), m_audioWithAL3 ( s.m_audioWithAL3 ), m_dataWithAL1 ( s.m_dataWithAL1 ), m_dataWithAL2 ( s.m_dataWithAL2 ), m_dataWithAL3 ( s.m_dataWithAL3 ), m_maximumAl2SDUSize ( s.m_maximumAl2SDUSize ), m_maximumAl3SDUSize ( s.m_maximumAl3SDUSize ), m_maximumDelayJitter ( s.m_maximumDelayJitter ), m_h223MultiplexTableCapability ( s.m_h223MultiplexTableCapability ), m_maxMUXPDUSizeCapability ( 0 ), m_nsrpSupport ( 0 ), m_mobileOperationTransmitCapability ( 0 ), m_h223AnnexCCapability ( 0 ), m_bitRate ( 0 ), m_mobileMultilinkFrameCapability ( 0 ) {
	try {
		if ( s.m_maxMUXPDUSizeCapability )
			m_maxMUXPDUSizeCapability = new Asn :: Boolean ( * s.m_maxMUXPDUSizeCapability );
		if ( s.m_nsrpSupport )
			m_nsrpSupport = new Asn :: Boolean ( * s.m_nsrpSupport );
		if ( s.m_mobileOperationTransmitCapability )
			m_mobileOperationTransmitCapability = new H223Capability_mobileOperationTransmitCapability ( * s.m_mobileOperationTransmitCapability );
		if ( s.m_h223AnnexCCapability )
			m_h223AnnexCCapability = new H223AnnexCCapability ( * s.m_h223AnnexCCapability );
		if ( s.m_bitRate )
			m_bitRate = new H223Capability_bitRate ( * s.m_bitRate );
		if ( s.m_mobileMultilinkFrameCapability )
			m_mobileMultilinkFrameCapability = new H223Capability_mobileMultilinkFrameCapability ( * s.m_mobileMultilinkFrameCapability );
	} catch ( ... ) {
		delete m_maxMUXPDUSizeCapability;
		delete m_nsrpSupport;
		delete m_mobileOperationTransmitCapability;
		delete m_h223AnnexCCapability;
		delete m_bitRate;
		delete m_mobileMultilinkFrameCapability;
		throw;
	}
}


void H223Capability :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_maxMUXPDUSizeCapability:
			assignNew ( m_maxMUXPDUSizeCapability, new Asn :: Boolean );
			break;
		case e_nsrpSupport:
			assignNew ( m_nsrpSupport, new Asn :: Boolean );
			break;
		case e_mobileOperationTransmitCapability:
			assignNew ( m_mobileOperationTransmitCapability, new H223Capability_mobileOperationTransmitCapability );
			break;
		case e_h223AnnexCCapability:
			assignNew ( m_h223AnnexCCapability, new H223AnnexCCapability );
			break;
		case e_bitRate:
			assignNew ( m_bitRate, new H223Capability_bitRate );
			break;
		case e_mobileMultilinkFrameCapability:
			assignNew ( m_mobileMultilinkFrameCapability, new H223Capability_mobileMultilinkFrameCapability );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void H223Capability :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_maxMUXPDUSizeCapability:
			delete m_maxMUXPDUSizeCapability;
			m_maxMUXPDUSizeCapability = 0;
			break;
		case e_nsrpSupport:
			delete m_nsrpSupport;
			m_nsrpSupport = 0;
			break;
		case e_mobileOperationTransmitCapability:
			delete m_mobileOperationTransmitCapability;
			m_mobileOperationTransmitCapability = 0;
			break;
		case e_h223AnnexCCapability:
			delete m_h223AnnexCCapability;
			m_h223AnnexCCapability = 0;
			break;
		case e_bitRate:
			delete m_bitRate;
			m_bitRate = 0;
			break;
		case e_mobileMultilinkFrameCapability:
			delete m_mobileMultilinkFrameCapability;
			m_mobileMultilinkFrameCapability = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void H223Capability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_transportWithI_frames.encode ( os );
	m_videoWithAL1.encode ( os );
	m_videoWithAL2.encode ( os );
	m_videoWithAL3.encode ( os );
	m_audioWithAL1.encode ( os );
	m_audioWithAL2.encode ( os );
	m_audioWithAL3.encode ( os );
	m_dataWithAL1.encode ( os );
	m_dataWithAL2.encode ( os );
	m_dataWithAL3.encode ( os );
	m_maximumAl2SDUSize.encode ( os );
	m_maximumAl3SDUSize.encode ( os );
	m_maximumDelayJitter.encode ( os );
	m_h223MultiplexTableCapability.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_maxMUXPDUSizeCapability, m_maxMUXPDUSizeCapability );
		knownExtensionEncode ( os, e_nsrpSupport, m_nsrpSupport );
		knownExtensionEncode ( os, e_mobileOperationTransmitCapability, m_mobileOperationTransmitCapability );
		knownExtensionEncode ( os, e_h223AnnexCCapability, m_h223AnnexCCapability );
		knownExtensionEncode ( os, e_bitRate, m_bitRate );
		knownExtensionEncode ( os, e_mobileMultilinkFrameCapability, m_mobileMultilinkFrameCapability );
		unknownExtensionsEncode ( os );
	}
}

H223Capability :: ~H223Capability ( ) {
	delete m_maxMUXPDUSizeCapability;
	delete m_nsrpSupport;
	delete m_mobileOperationTransmitCapability;
	delete m_h223AnnexCCapability;
	delete m_bitRate;
	delete m_mobileMultilinkFrameCapability;
}

void H223Capability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 24 ) << "transportWithI_frames = " << std :: setprecision ( indent ) << m_transportWithI_frames << '\n';
	os << std :: setw ( indent + 15 ) << "videoWithAL1 = " << std :: setprecision ( indent ) << m_videoWithAL1 << '\n';
	os << std :: setw ( indent + 15 ) << "videoWithAL2 = " << std :: setprecision ( indent ) << m_videoWithAL2 << '\n';
	os << std :: setw ( indent + 15 ) << "videoWithAL3 = " << std :: setprecision ( indent ) << m_videoWithAL3 << '\n';
	os << std :: setw ( indent + 15 ) << "audioWithAL1 = " << std :: setprecision ( indent ) << m_audioWithAL1 << '\n';
	os << std :: setw ( indent + 15 ) << "audioWithAL2 = " << std :: setprecision ( indent ) << m_audioWithAL2 << '\n';
	os << std :: setw ( indent + 15 ) << "audioWithAL3 = " << std :: setprecision ( indent ) << m_audioWithAL3 << '\n';
	os << std :: setw ( indent + 14 ) << "dataWithAL1 = " << std :: setprecision ( indent ) << m_dataWithAL1 << '\n';
	os << std :: setw ( indent + 14 ) << "dataWithAL2 = " << std :: setprecision ( indent ) << m_dataWithAL2 << '\n';
	os << std :: setw ( indent + 14 ) << "dataWithAL3 = " << std :: setprecision ( indent ) << m_dataWithAL3 << '\n';
	os << std :: setw ( indent + 20 ) << "maximumAl2SDUSize = " << std :: setprecision ( indent ) << m_maximumAl2SDUSize << '\n';
	os << std :: setw ( indent + 20 ) << "maximumAl3SDUSize = " << std :: setprecision ( indent ) << m_maximumAl3SDUSize << '\n';
	os << std :: setw ( indent + 21 ) << "maximumDelayJitter = " << std :: setprecision ( indent ) << m_maximumDelayJitter << '\n';
	os << std :: setw ( indent + 31 ) << "h223MultiplexTableCapability = " << std :: setprecision ( indent ) << m_h223MultiplexTableCapability << '\n';
	if ( hasOptionalField ( e_maxMUXPDUSizeCapability ) ) {
		os << std :: setw ( indent + 26 ) << "maxMUXPDUSizeCapability = " << std :: setprecision ( indent );
		m_maxMUXPDUSizeCapability -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_nsrpSupport ) ) {
		os << std :: setw ( indent + 14 ) << "nsrpSupport = " << std :: setprecision ( indent );
		m_nsrpSupport -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_mobileOperationTransmitCapability ) ) {
		os << std :: setw ( indent + 36 ) << "mobileOperationTransmitCapability = " << std :: setprecision ( indent );
		m_mobileOperationTransmitCapability -> H223Capability_mobileOperationTransmitCapability :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_h223AnnexCCapability ) ) {
		os << std :: setw ( indent + 23 ) << "h223AnnexCCapability = " << std :: setprecision ( indent );
		m_h223AnnexCCapability -> H223AnnexCCapability :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_bitRate ) ) {
		os << std :: setw ( indent + 10 ) << "bitRate = " << std :: setprecision ( indent );
		m_bitRate -> H223Capability_bitRate :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_mobileMultilinkFrameCapability ) ) {
		os << std :: setw ( indent + 33 ) << "mobileMultilinkFrameCapability = " << std :: setprecision ( indent );
		m_mobileMultilinkFrameCapability -> H223Capability_mobileMultilinkFrameCapability :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H223Capability * H223Capability :: clone ( ) const {
	return new H223Capability ( * this );
}

//
// RedundancyEncodingMethod
//

RedundancyEncodingMethod :: RedundancyEncodingMethod ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_nonStandard:
			choice = new NonStandardParameter ( is );
			break;
		case e_rtpAudioRedundancyEncoding:
			choice = new Asn :: Null ( is );
			break;
		case e_rtpH263VideoRedundancyEncoding:
			choice = new RTPH263VideoRedundancyEncoding ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

RedundancyEncodingMethod :: RedundancyEncodingMethod ( ) : Asn :: Choice ( 2, true ) { }

void RedundancyEncodingMethod :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandard:
			o = new NonStandardParameter;
			break;
		case e_rtpAudioRedundancyEncoding:
			o = new Asn :: Null;
			break;
		case e_rtpH263VideoRedundancyEncoding:
			o = new RTPH263VideoRedundancyEncoding;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & RedundancyEncodingMethod :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandard, "nonStandard" },
		{ e_rtpAudioRedundancyEncoding, "rtpAudioRedundancyEncoding" },
		{ e_rtpH263VideoRedundancyEncoding, "rtpH263VideoRedundancyEncoding" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

RedundancyEncodingMethod * RedundancyEncodingMethod :: clone ( ) const {
	return new RedundancyEncodingMethod ( * this );
}

//
// DataProtocolCapability
//

DataProtocolCapability :: DataProtocolCapability ( Asn :: istream & is ) : Asn :: Choice ( is, 7, true ) {
	switch ( tag ) {
		case e_nonStandard:
			choice = new NonStandardParameter ( is );
			break;
		case e_v14buffered:
		case e_v42lapm:
		case e_hdlcFrameTunnelling:
		case e_h310SeparateVCStack:
		case e_h310SingleVCStack:
		case e_transparent:
		case e_segmentationAndReassembly:
		case e_hdlcFrameTunnelingwSAR:
		case e_v120:
		case e_separateLANStack:
		case e_tcp:
		case e_udp:
			choice = new Asn :: Null ( is );
			break;
		case e_v76wCompression:
			choice = new DataProtocolCapability_v76wCompression ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

DataProtocolCapability :: DataProtocolCapability ( ) : Asn :: Choice ( 7, true ) { }

void DataProtocolCapability :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandard:
			o = new NonStandardParameter;
			break;
		case e_v14buffered:
		case e_v42lapm:
		case e_hdlcFrameTunnelling:
		case e_h310SeparateVCStack:
		case e_h310SingleVCStack:
		case e_transparent:
		case e_segmentationAndReassembly:
		case e_hdlcFrameTunnelingwSAR:
		case e_v120:
		case e_separateLANStack:
		case e_tcp:
		case e_udp:
			o = new Asn :: Null;
			break;
		case e_v76wCompression:
			o = new DataProtocolCapability_v76wCompression;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & DataProtocolCapability :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandard, "nonStandard" },
		{ e_v14buffered, "v14buffered" },
		{ e_v42lapm, "v42lapm" },
		{ e_hdlcFrameTunnelling, "hdlcFrameTunnelling" },
		{ e_h310SeparateVCStack, "h310SeparateVCStack" },
		{ e_h310SingleVCStack, "h310SingleVCStack" },
		{ e_transparent, "transparent" },
		{ e_segmentationAndReassembly, "segmentationAndReassembly" },
		{ e_hdlcFrameTunnelingwSAR, "hdlcFrameTunnelingwSAR" },
		{ e_v120, "v120" },
		{ e_separateLANStack, "separateLANStack" },
		{ e_v76wCompression, "v76wCompression" },
		{ e_tcp, "tcp" },
		{ e_udp, "udp" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

DataProtocolCapability * DataProtocolCapability :: clone ( ) const {
	return new DataProtocolCapability ( * this );
}

//
// MediaEncryptionAlgorithm
//

MediaEncryptionAlgorithm :: MediaEncryptionAlgorithm ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_nonStandard:
			choice = new NonStandardParameter ( is );
			break;
		case e_algorithm:
			choice = new Asn :: ObjectId ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

MediaEncryptionAlgorithm :: MediaEncryptionAlgorithm ( ) : Asn :: Choice ( 2, true ) { }

void MediaEncryptionAlgorithm :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandard:
			o = new NonStandardParameter;
			break;
		case e_algorithm:
			o = new Asn :: ObjectId;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & MediaEncryptionAlgorithm :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandard, "nonStandard" },
		{ e_algorithm, "algorithm" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

MediaEncryptionAlgorithm * MediaEncryptionAlgorithm :: clone ( ) const {
	return new MediaEncryptionAlgorithm ( * this );
}

//
// CapabilityIdentifier
//

CapabilityIdentifier :: CapabilityIdentifier ( Asn :: istream & is ) : Asn :: Choice ( is, 4, true ) {
	switch ( tag ) {
		case e_standard:
			choice = new Asn :: ObjectId ( is );
			break;
		case e_h221NonStandard:
			choice = new NonStandardParameter ( is );
			break;
		case e_uuid:
			choice = new CapabilityIdentifier_uuid ( is );
			break;
		case e_domainBased:
			choice = new CapabilityIdentifier_domainBased ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

CapabilityIdentifier :: CapabilityIdentifier ( ) : Asn :: Choice ( 4, true ) { }

void CapabilityIdentifier :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_standard:
			o = new Asn :: ObjectId;
			break;
		case e_h221NonStandard:
			o = new NonStandardParameter;
			break;
		case e_uuid:
			o = new CapabilityIdentifier_uuid;
			break;
		case e_domainBased:
			o = new CapabilityIdentifier_domainBased;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & CapabilityIdentifier :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_standard, "standard" },
		{ e_h221NonStandard, "h221NonStandard" },
		{ e_uuid, "uuid" },
		{ e_domainBased, "domainBased" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

CapabilityIdentifier * CapabilityIdentifier :: clone ( ) const {
	return new CapabilityIdentifier ( * this );
}

//
// ParameterIdentifier
//

ParameterIdentifier :: ParameterIdentifier ( Asn :: istream & is ) : Asn :: Choice ( is, 4, true ) {
	switch ( tag ) {
		case e_standard:
			choice = new ParameterIdentifier_standard ( is );
			break;
		case e_h221NonStandard:
			choice = new NonStandardParameter ( is );
			break;
		case e_uuid:
			choice = new ParameterIdentifier_uuid ( is );
			break;
		case e_domainBased:
			choice = new ParameterIdentifier_domainBased ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

ParameterIdentifier :: ParameterIdentifier ( ) : Asn :: Choice ( 4, true ) { }

void ParameterIdentifier :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_standard:
			o = new ParameterIdentifier_standard;
			break;
		case e_h221NonStandard:
			o = new NonStandardParameter;
			break;
		case e_uuid:
			o = new ParameterIdentifier_uuid;
			break;
		case e_domainBased:
			o = new ParameterIdentifier_domainBased;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & ParameterIdentifier :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_standard, "standard" },
		{ e_h221NonStandard, "h221NonStandard" },
		{ e_uuid, "uuid" },
		{ e_domainBased, "domainBased" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

ParameterIdentifier * ParameterIdentifier :: clone ( ) const {
	return new ParameterIdentifier ( * this );
}

//
// MultiplexFormat
//

MultiplexFormat :: MultiplexFormat ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_nonStandard:
			choice = new NonStandardParameter ( is );
			break;
		case e_h222Capability:
			choice = new H222Capability ( is );
			break;
		case e_h223Capability:
			choice = new H223Capability ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

MultiplexFormat :: MultiplexFormat ( ) : Asn :: Choice ( 3, true ) { }

void MultiplexFormat :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandard:
			o = new NonStandardParameter;
			break;
		case e_h222Capability:
			o = new H222Capability;
			break;
		case e_h223Capability:
			o = new H223Capability;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & MultiplexFormat :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandard, "nonStandard" },
		{ e_h222Capability, "h222Capability" },
		{ e_h223Capability, "h223Capability" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

MultiplexFormat * MultiplexFormat :: clone ( ) const {
	return new MultiplexFormat ( * this );
}

//
// MultiplexedStreamParameter
//

MultiplexedStreamParameter :: MultiplexedStreamParameter ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_multiplexFormat ( is ), m_controlOnMuxStream ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MultiplexedStreamParameter :: MultiplexedStreamParameter ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MultiplexedStreamParameter :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_multiplexFormat.encode ( os );
	m_controlOnMuxStream.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MultiplexedStreamParameter :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 18 ) << "multiplexFormat = " << std :: setprecision ( indent ) << m_multiplexFormat << '\n';
	os << std :: setw ( indent + 21 ) << "controlOnMuxStream = " << std :: setprecision ( indent ) << m_controlOnMuxStream << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MultiplexedStreamParameter * MultiplexedStreamParameter :: clone ( ) const {
	return new MultiplexedStreamParameter ( * this );
}

//
// H223AL1MParameters
//

H223AL1MParameters :: H223AL1MParameters ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 1 ), m_transferMode ( is ), m_headerFEC ( is ), m_crcLength ( is ), m_rcpcCodeRate ( is ), m_arqType ( is ), m_alpduInterleaving ( is ), m_alsduSplitting ( is ), m_rsCodeCorrection ( 0 ) {
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_rsCodeCorrection ) )
				m_rsCodeCorrection = new H223AL1MParameters_rsCodeCorrection ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_rsCodeCorrection;
		throw;
	}
}

H223AL1MParameters :: H223AL1MParameters ( ) : Asn :: Sequence ( 0, true, 1 ), m_rsCodeCorrection ( 0 ) { }

H223AL1MParameters & H223AL1MParameters :: operator= ( const H223AL1MParameters & s ) {
	Asn :: Sequence :: operator= ( s );
	m_transferMode = s.m_transferMode;
	m_headerFEC = s.m_headerFEC;
	m_crcLength = s.m_crcLength;
	m_rcpcCodeRate = s.m_rcpcCodeRate;
	m_arqType = s.m_arqType;
	m_alpduInterleaving = s.m_alpduInterleaving;
	m_alsduSplitting = s.m_alsduSplitting;
	assignCopy ( m_rsCodeCorrection, s.m_rsCodeCorrection );
	return * this;
}

H223AL1MParameters :: H223AL1MParameters ( const H223AL1MParameters & s ) : Asn :: Sequence ( s ), m_transferMode ( s.m_transferMode ), m_headerFEC ( s.m_headerFEC ), m_crcLength ( s.m_crcLength ), m_rcpcCodeRate ( s.m_rcpcCodeRate ), m_arqType ( s.m_arqType ), m_alpduInterleaving ( s.m_alpduInterleaving ), m_alsduSplitting ( s.m_alsduSplitting ), m_rsCodeCorrection ( 0 ) {
	try {
		if ( s.m_rsCodeCorrection )
			m_rsCodeCorrection = new H223AL1MParameters_rsCodeCorrection ( * s.m_rsCodeCorrection );
	} catch ( ... ) {
		delete m_rsCodeCorrection;
		throw;
	}
}


void H223AL1MParameters :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_rsCodeCorrection:
			assignNew ( m_rsCodeCorrection, new H223AL1MParameters_rsCodeCorrection );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void H223AL1MParameters :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_rsCodeCorrection:
			delete m_rsCodeCorrection;
			m_rsCodeCorrection = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void H223AL1MParameters :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_transferMode.encode ( os );
	m_headerFEC.encode ( os );
	m_crcLength.encode ( os );
	m_rcpcCodeRate.encode ( os );
	m_arqType.encode ( os );
	m_alpduInterleaving.encode ( os );
	m_alsduSplitting.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_rsCodeCorrection, m_rsCodeCorrection );
		unknownExtensionsEncode ( os );
	}
}

H223AL1MParameters :: ~H223AL1MParameters ( ) {
	delete m_rsCodeCorrection;
}

void H223AL1MParameters :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 15 ) << "transferMode = " << std :: setprecision ( indent ) << m_transferMode << '\n';
	os << std :: setw ( indent + 12 ) << "headerFEC = " << std :: setprecision ( indent ) << m_headerFEC << '\n';
	os << std :: setw ( indent + 12 ) << "crcLength = " << std :: setprecision ( indent ) << m_crcLength << '\n';
	os << std :: setw ( indent + 15 ) << "rcpcCodeRate = " << std :: setprecision ( indent ) << m_rcpcCodeRate << '\n';
	os << std :: setw ( indent + 10 ) << "arqType = " << std :: setprecision ( indent ) << m_arqType << '\n';
	os << std :: setw ( indent + 20 ) << "alpduInterleaving = " << std :: setprecision ( indent ) << m_alpduInterleaving << '\n';
	os << std :: setw ( indent + 17 ) << "alsduSplitting = " << std :: setprecision ( indent ) << m_alsduSplitting << '\n';
	if ( hasOptionalField ( e_rsCodeCorrection ) ) {
		os << std :: setw ( indent + 19 ) << "rsCodeCorrection = " << std :: setprecision ( indent );
		m_rsCodeCorrection -> H223AL1MParameters_rsCodeCorrection :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H223AL1MParameters * H223AL1MParameters :: clone ( ) const {
	return new H223AL1MParameters ( * this );
}

//
// H223AL3MParameters
//

H223AL3MParameters :: H223AL3MParameters ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 1 ), m_headerFormat ( is ), m_crcLength ( is ), m_rcpcCodeRate ( is ), m_arqType ( is ), m_alpduInterleaving ( is ), m_rsCodeCorrection ( 0 ) {
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_rsCodeCorrection ) )
				m_rsCodeCorrection = new H223AL3MParameters_rsCodeCorrection ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_rsCodeCorrection;
		throw;
	}
}

H223AL3MParameters :: H223AL3MParameters ( ) : Asn :: Sequence ( 0, true, 1 ), m_rsCodeCorrection ( 0 ) { }

H223AL3MParameters & H223AL3MParameters :: operator= ( const H223AL3MParameters & s ) {
	Asn :: Sequence :: operator= ( s );
	m_headerFormat = s.m_headerFormat;
	m_crcLength = s.m_crcLength;
	m_rcpcCodeRate = s.m_rcpcCodeRate;
	m_arqType = s.m_arqType;
	m_alpduInterleaving = s.m_alpduInterleaving;
	assignCopy ( m_rsCodeCorrection, s.m_rsCodeCorrection );
	return * this;
}

H223AL3MParameters :: H223AL3MParameters ( const H223AL3MParameters & s ) : Asn :: Sequence ( s ), m_headerFormat ( s.m_headerFormat ), m_crcLength ( s.m_crcLength ), m_rcpcCodeRate ( s.m_rcpcCodeRate ), m_arqType ( s.m_arqType ), m_alpduInterleaving ( s.m_alpduInterleaving ), m_rsCodeCorrection ( 0 ) {
	try {
		if ( s.m_rsCodeCorrection )
			m_rsCodeCorrection = new H223AL3MParameters_rsCodeCorrection ( * s.m_rsCodeCorrection );
	} catch ( ... ) {
		delete m_rsCodeCorrection;
		throw;
	}
}


void H223AL3MParameters :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_rsCodeCorrection:
			assignNew ( m_rsCodeCorrection, new H223AL3MParameters_rsCodeCorrection );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void H223AL3MParameters :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_rsCodeCorrection:
			delete m_rsCodeCorrection;
			m_rsCodeCorrection = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void H223AL3MParameters :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_headerFormat.encode ( os );
	m_crcLength.encode ( os );
	m_rcpcCodeRate.encode ( os );
	m_arqType.encode ( os );
	m_alpduInterleaving.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_rsCodeCorrection, m_rsCodeCorrection );
		unknownExtensionsEncode ( os );
	}
}

H223AL3MParameters :: ~H223AL3MParameters ( ) {
	delete m_rsCodeCorrection;
}

void H223AL3MParameters :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 15 ) << "headerFormat = " << std :: setprecision ( indent ) << m_headerFormat << '\n';
	os << std :: setw ( indent + 12 ) << "crcLength = " << std :: setprecision ( indent ) << m_crcLength << '\n';
	os << std :: setw ( indent + 15 ) << "rcpcCodeRate = " << std :: setprecision ( indent ) << m_rcpcCodeRate << '\n';
	os << std :: setw ( indent + 10 ) << "arqType = " << std :: setprecision ( indent ) << m_arqType << '\n';
	os << std :: setw ( indent + 20 ) << "alpduInterleaving = " << std :: setprecision ( indent ) << m_alpduInterleaving << '\n';
	if ( hasOptionalField ( e_rsCodeCorrection ) ) {
		os << std :: setw ( indent + 19 ) << "rsCodeCorrection = " << std :: setprecision ( indent );
		m_rsCodeCorrection -> H223AL3MParameters_rsCodeCorrection :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H223AL3MParameters * H223AL3MParameters :: clone ( ) const {
	return new H223AL3MParameters ( * this );
}

//
// V76LogicalChannelParameters
//

V76LogicalChannelParameters :: V76LogicalChannelParameters ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_hdlcParameters ( is ), m_suspendResume ( is ), m_uIH ( is ), m_mode ( is ), m_v75Parameters ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

V76LogicalChannelParameters :: V76LogicalChannelParameters ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void V76LogicalChannelParameters :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_hdlcParameters.encode ( os );
	m_suspendResume.encode ( os );
	m_uIH.encode ( os );
	m_mode.encode ( os );
	m_v75Parameters.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void V76LogicalChannelParameters :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 17 ) << "hdlcParameters = " << std :: setprecision ( indent ) << m_hdlcParameters << '\n';
	os << std :: setw ( indent + 16 ) << "suspendResume = " << std :: setprecision ( indent ) << m_suspendResume << '\n';
	os << std :: setw ( indent + 6 ) << "uIH = " << std :: setprecision ( indent ) << m_uIH << '\n';
	os << std :: setw ( indent + 7 ) << "mode = " << std :: setprecision ( indent ) << m_mode << '\n';
	os << std :: setw ( indent + 16 ) << "v75Parameters = " << std :: setprecision ( indent ) << m_v75Parameters << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

V76LogicalChannelParameters * V76LogicalChannelParameters :: clone ( ) const {
	return new V76LogicalChannelParameters ( * this );
}

//
// RedundancyEncoding
//

RedundancyEncoding :: RedundancyEncoding ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 1 ), m_redundancyEncodingMethod ( is ), m_secondaryEncoding ( 0 ), m_rtpRedundancyEncoding ( 0 ) {
	try {
		if ( hasOptionalField ( e_secondaryEncoding ) )
			m_secondaryEncoding = new DataType ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_rtpRedundancyEncoding ) )
				m_rtpRedundancyEncoding = new RedundancyEncoding_rtpRedundancyEncoding ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_secondaryEncoding;
		delete m_rtpRedundancyEncoding;
		throw;
	}
}

RedundancyEncoding :: RedundancyEncoding ( ) : Asn :: Sequence ( 1, true, 1 ), m_secondaryEncoding ( 0 ), m_rtpRedundancyEncoding ( 0 ) { }

RedundancyEncoding & RedundancyEncoding :: operator= ( const RedundancyEncoding & s ) {
	Asn :: Sequence :: operator= ( s );
	m_redundancyEncodingMethod = s.m_redundancyEncodingMethod;
	assignCopy ( m_secondaryEncoding, s.m_secondaryEncoding );
	assignCopy ( m_rtpRedundancyEncoding, s.m_rtpRedundancyEncoding );
	return * this;
}

RedundancyEncoding :: RedundancyEncoding ( const RedundancyEncoding & s ) : Asn :: Sequence ( s ), m_redundancyEncodingMethod ( s.m_redundancyEncodingMethod ), m_secondaryEncoding ( 0 ), m_rtpRedundancyEncoding ( 0 ) {
	try {
		if ( s.m_secondaryEncoding )
			m_secondaryEncoding = new DataType ( * s.m_secondaryEncoding );
		if ( s.m_rtpRedundancyEncoding )
			m_rtpRedundancyEncoding = new RedundancyEncoding_rtpRedundancyEncoding ( * s.m_rtpRedundancyEncoding );
	} catch ( ... ) {
		delete m_secondaryEncoding;
		delete m_rtpRedundancyEncoding;
		throw;
	}
}


void RedundancyEncoding :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_secondaryEncoding:
			assignNew ( m_secondaryEncoding, new DataType );
			break;
		case e_rtpRedundancyEncoding:
			assignNew ( m_rtpRedundancyEncoding, new RedundancyEncoding_rtpRedundancyEncoding );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void RedundancyEncoding :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_secondaryEncoding:
			delete m_secondaryEncoding;
			m_secondaryEncoding = 0;
			break;
		case e_rtpRedundancyEncoding:
			delete m_rtpRedundancyEncoding;
			m_rtpRedundancyEncoding = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void RedundancyEncoding :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_redundancyEncodingMethod.encode ( os );
	if ( hasOptionalField ( e_secondaryEncoding ) )
		m_secondaryEncoding -> DataType :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_rtpRedundancyEncoding, m_rtpRedundancyEncoding );
		unknownExtensionsEncode ( os );
	}
}

RedundancyEncoding :: ~RedundancyEncoding ( ) {
	delete m_secondaryEncoding;
	delete m_rtpRedundancyEncoding;
}

void RedundancyEncoding :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 27 ) << "redundancyEncodingMethod = " << std :: setprecision ( indent ) << m_redundancyEncodingMethod << '\n';
	if ( hasOptionalField ( e_secondaryEncoding ) ) {
		os << std :: setw ( indent + 20 ) << "secondaryEncoding = " << std :: setprecision ( indent );
		m_secondaryEncoding -> DataType :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_rtpRedundancyEncoding ) ) {
		os << std :: setw ( indent + 24 ) << "rtpRedundancyEncoding = " << std :: setprecision ( indent );
		m_rtpRedundancyEncoding -> RedundancyEncoding_rtpRedundancyEncoding :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RedundancyEncoding * RedundancyEncoding :: clone ( ) const {
	return new RedundancyEncoding ( * this );
}

//
// FECData
//

FECData :: FECData ( Asn :: istream & is ) : Asn :: Choice ( is, 1, true ) {
	switch ( tag ) {
		case e_rfc2733:
			choice = new FECData_rfc2733 ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

FECData :: FECData ( ) : Asn :: Choice ( 1, true ) { }

void FECData :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_rfc2733:
			o = new FECData_rfc2733;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & FECData :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_rfc2733, "rfc2733" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

FECData * FECData :: clone ( ) const {
	return new FECData ( * this );
}

//
// UnicastAddress
//

UnicastAddress :: UnicastAddress ( Asn :: istream & is ) : Asn :: Choice ( is, 5, true ) {
	switch ( tag ) {
		case e_iPAddress:
			choice = new UnicastAddress_iPAddress ( is );
			break;
		case e_iPXAddress:
			choice = new UnicastAddress_iPXAddress ( is );
			break;
		case e_iP6Address:
			choice = new UnicastAddress_iP6Address ( is );
			break;
		case e_netBios:
			choice = new UnicastAddress_netBios ( is );
			break;
		case e_iPSourceRouteAddress:
			choice = new UnicastAddress_iPSourceRouteAddress ( is );
			break;
		case e_nsap:
			choice = new UnicastAddress_nsap ( is );
			break;
		case e_nonStandardAddress:
			choice = new NonStandardParameter ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

UnicastAddress :: UnicastAddress ( ) : Asn :: Choice ( 5, true ) { }

void UnicastAddress :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_iPAddress:
			o = new UnicastAddress_iPAddress;
			break;
		case e_iPXAddress:
			o = new UnicastAddress_iPXAddress;
			break;
		case e_iP6Address:
			o = new UnicastAddress_iP6Address;
			break;
		case e_netBios:
			o = new UnicastAddress_netBios;
			break;
		case e_iPSourceRouteAddress:
			o = new UnicastAddress_iPSourceRouteAddress;
			break;
		case e_nsap:
			o = new UnicastAddress_nsap;
			break;
		case e_nonStandardAddress:
			o = new NonStandardParameter;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & UnicastAddress :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_iPAddress, "iPAddress" },
		{ e_iPXAddress, "iPXAddress" },
		{ e_iP6Address, "iP6Address" },
		{ e_netBios, "netBios" },
		{ e_iPSourceRouteAddress, "iPSourceRouteAddress" },
		{ e_nsap, "nsap" },
		{ e_nonStandardAddress, "nonStandardAddress" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

UnicastAddress * UnicastAddress :: clone ( ) const {
	return new UnicastAddress ( * this );
}

//
// MulticastAddress
//

MulticastAddress :: MulticastAddress ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_iPAddress:
			choice = new MulticastAddress_iPAddress ( is );
			break;
		case e_iP6Address:
			choice = new MulticastAddress_iP6Address ( is );
			break;
		case e_nsap:
			choice = new MulticastAddress_nsap ( is );
			break;
		case e_nonStandardAddress:
			choice = new NonStandardParameter ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

MulticastAddress :: MulticastAddress ( ) : Asn :: Choice ( 2, true ) { }

void MulticastAddress :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_iPAddress:
			o = new MulticastAddress_iPAddress;
			break;
		case e_iP6Address:
			o = new MulticastAddress_iP6Address;
			break;
		case e_nsap:
			o = new MulticastAddress_nsap;
			break;
		case e_nonStandardAddress:
			o = new NonStandardParameter;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & MulticastAddress :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_iPAddress, "iPAddress" },
		{ e_iP6Address, "iP6Address" },
		{ e_nsap, "nsap" },
		{ e_nonStandardAddress, "nonStandardAddress" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

MulticastAddress * MulticastAddress :: clone ( ) const {
	return new MulticastAddress ( * this );
}

//
// RedundancyEncodingMode
//

RedundancyEncodingMode :: RedundancyEncodingMode ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_redundancyEncodingMethod ( is ), m_secondaryEncoding ( 0 ) {
	try {
		if ( hasOptionalField ( e_secondaryEncoding ) )
			m_secondaryEncoding = new RedundancyEncodingMode_secondaryEncoding ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_secondaryEncoding;
		throw;
	}
}

RedundancyEncodingMode :: RedundancyEncodingMode ( ) : Asn :: Sequence ( 1, true, 0 ), m_secondaryEncoding ( 0 ) { }

RedundancyEncodingMode & RedundancyEncodingMode :: operator= ( const RedundancyEncodingMode & s ) {
	Asn :: Sequence :: operator= ( s );
	m_redundancyEncodingMethod = s.m_redundancyEncodingMethod;
	assignCopy ( m_secondaryEncoding, s.m_secondaryEncoding );
	return * this;
}

RedundancyEncodingMode :: RedundancyEncodingMode ( const RedundancyEncodingMode & s ) : Asn :: Sequence ( s ), m_redundancyEncodingMethod ( s.m_redundancyEncodingMethod ), m_secondaryEncoding ( 0 ) {
	try {
		if ( s.m_secondaryEncoding )
			m_secondaryEncoding = new RedundancyEncodingMode_secondaryEncoding ( * s.m_secondaryEncoding );
	} catch ( ... ) {
		delete m_secondaryEncoding;
		throw;
	}
}


void RedundancyEncodingMode :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_secondaryEncoding:
			assignNew ( m_secondaryEncoding, new RedundancyEncodingMode_secondaryEncoding );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void RedundancyEncodingMode :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_secondaryEncoding:
			delete m_secondaryEncoding;
			m_secondaryEncoding = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void RedundancyEncodingMode :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_redundancyEncodingMethod.encode ( os );
	if ( hasOptionalField ( e_secondaryEncoding ) )
		m_secondaryEncoding -> RedundancyEncodingMode_secondaryEncoding :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

RedundancyEncodingMode :: ~RedundancyEncodingMode ( ) {
	delete m_secondaryEncoding;
}

void RedundancyEncodingMode :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 27 ) << "redundancyEncodingMethod = " << std :: setprecision ( indent ) << m_redundancyEncodingMethod << '\n';
	if ( hasOptionalField ( e_secondaryEncoding ) ) {
		os << std :: setw ( indent + 20 ) << "secondaryEncoding = " << std :: setprecision ( indent );
		m_secondaryEncoding -> RedundancyEncodingMode_secondaryEncoding :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RedundancyEncodingMode * RedundancyEncodingMode :: clone ( ) const {
	return new RedundancyEncodingMode ( * this );
}

//
// EncryptionMode
//

EncryptionMode :: EncryptionMode ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_nonStandard:
			choice = new NonStandardParameter ( is );
			break;
		case e_h233Encryption:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

EncryptionMode :: EncryptionMode ( ) : Asn :: Choice ( 2, true ) { }

void EncryptionMode :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandard:
			o = new NonStandardParameter;
			break;
		case e_h233Encryption:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & EncryptionMode :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandard, "nonStandard" },
		{ e_h233Encryption, "h233Encryption" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

EncryptionMode * EncryptionMode :: clone ( ) const {
	return new EncryptionMode ( * this );
}

//
// EndSessionCommand
//

EndSessionCommand :: EndSessionCommand ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_nonStandard:
			choice = new NonStandardParameter ( is );
			break;
		case e_disconnect:
			choice = new Asn :: Null ( is );
			break;
		case e_gstnOptions:
			choice = new EndSessionCommand_gstnOptions ( is );
			break;
		case e_isdnOptions:
			choice = new EndSessionCommand_isdnOptions ( is );
			break;
		case e_genericInformation:
			choice = new ArrayOf_GenericInformation ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

EndSessionCommand :: EndSessionCommand ( ) : Asn :: Choice ( 3, true ) { }

void EndSessionCommand :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandard:
			o = new NonStandardParameter;
			break;
		case e_disconnect:
			o = new Asn :: Null;
			break;
		case e_gstnOptions:
			o = new EndSessionCommand_gstnOptions;
			break;
		case e_isdnOptions:
			o = new EndSessionCommand_isdnOptions;
			break;
		case e_genericInformation:
			o = new ArrayOf_GenericInformation;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & EndSessionCommand :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandard, "nonStandard" },
		{ e_disconnect, "disconnect" },
		{ e_gstnOptions, "gstnOptions" },
		{ e_isdnOptions, "isdnOptions" },
		{ e_genericInformation, "genericInformation" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

EndSessionCommand * EndSessionCommand :: clone ( ) const {
	return new EndSessionCommand ( * this );
}

//
// MiscellaneousCommand
//

MiscellaneousCommand :: MiscellaneousCommand ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 1 ), m_logicalChannelNumber ( is ), m_type ( is ), m_direction ( 0 ) {
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_direction ) )
				m_direction = new EncryptionUpdateDirection ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_direction;
		throw;
	}
}

MiscellaneousCommand :: MiscellaneousCommand ( ) : Asn :: Sequence ( 0, true, 1 ), m_direction ( 0 ) { }

MiscellaneousCommand & MiscellaneousCommand :: operator= ( const MiscellaneousCommand & s ) {
	Asn :: Sequence :: operator= ( s );
	m_logicalChannelNumber = s.m_logicalChannelNumber;
	m_type = s.m_type;
	assignCopy ( m_direction, s.m_direction );
	return * this;
}

MiscellaneousCommand :: MiscellaneousCommand ( const MiscellaneousCommand & s ) : Asn :: Sequence ( s ), m_logicalChannelNumber ( s.m_logicalChannelNumber ), m_type ( s.m_type ), m_direction ( 0 ) {
	try {
		if ( s.m_direction )
			m_direction = new EncryptionUpdateDirection ( * s.m_direction );
	} catch ( ... ) {
		delete m_direction;
		throw;
	}
}


void MiscellaneousCommand :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_direction:
			assignNew ( m_direction, new EncryptionUpdateDirection );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void MiscellaneousCommand :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_direction:
			delete m_direction;
			m_direction = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void MiscellaneousCommand :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_logicalChannelNumber.encode ( os );
	m_type.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_direction, m_direction );
		unknownExtensionsEncode ( os );
	}
}

MiscellaneousCommand :: ~MiscellaneousCommand ( ) {
	delete m_direction;
}

void MiscellaneousCommand :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 23 ) << "logicalChannelNumber = " << std :: setprecision ( indent ) << m_logicalChannelNumber << '\n';
	os << std :: setw ( indent + 7 ) << "type = " << std :: setprecision ( indent ) << m_type << '\n';
	if ( hasOptionalField ( e_direction ) ) {
		os << std :: setw ( indent + 12 ) << "direction = " << std :: setprecision ( indent );
		m_direction -> EncryptionUpdateDirection :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MiscellaneousCommand * MiscellaneousCommand :: clone ( ) const {
	return new MiscellaneousCommand ( * this );
}

//
// NewATMVCCommand
//

NewATMVCCommand :: NewATMVCCommand ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_resourceID ( is ), m_bitRate ( is ), m_bitRateLockedToPCRClock ( is ), m_bitRateLockedToNetworkClock ( is ), m_aal ( is ), m_multiplex ( is ), m_reverseParameters ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

NewATMVCCommand :: NewATMVCCommand ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void NewATMVCCommand :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_resourceID.encode ( os );
	m_bitRate.encode ( os );
	m_bitRateLockedToPCRClock.encode ( os );
	m_bitRateLockedToNetworkClock.encode ( os );
	m_aal.encode ( os );
	m_multiplex.encode ( os );
	m_reverseParameters.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void NewATMVCCommand :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 13 ) << "resourceID = " << std :: setprecision ( indent ) << m_resourceID << '\n';
	os << std :: setw ( indent + 10 ) << "bitRate = " << std :: setprecision ( indent ) << m_bitRate << '\n';
	os << std :: setw ( indent + 26 ) << "bitRateLockedToPCRClock = " << std :: setprecision ( indent ) << m_bitRateLockedToPCRClock << '\n';
	os << std :: setw ( indent + 30 ) << "bitRateLockedToNetworkClock = " << std :: setprecision ( indent ) << m_bitRateLockedToNetworkClock << '\n';
	os << std :: setw ( indent + 6 ) << "aal = " << std :: setprecision ( indent ) << m_aal << '\n';
	os << std :: setw ( indent + 12 ) << "multiplex = " << std :: setprecision ( indent ) << m_multiplex << '\n';
	os << std :: setw ( indent + 20 ) << "reverseParameters = " << std :: setprecision ( indent ) << m_reverseParameters << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

NewATMVCCommand * NewATMVCCommand :: clone ( ) const {
	return new NewATMVCCommand ( * this );
}

//
// MiscellaneousIndication
//

MiscellaneousIndication :: MiscellaneousIndication ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_logicalChannelNumber ( is ), m_type ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MiscellaneousIndication :: MiscellaneousIndication ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MiscellaneousIndication :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_logicalChannelNumber.encode ( os );
	m_type.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MiscellaneousIndication :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 23 ) << "logicalChannelNumber = " << std :: setprecision ( indent ) << m_logicalChannelNumber << '\n';
	os << std :: setw ( indent + 7 ) << "type = " << std :: setprecision ( indent ) << m_type << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MiscellaneousIndication * MiscellaneousIndication :: clone ( ) const {
	return new MiscellaneousIndication ( * this );
}

//
// NewATMVCIndication
//

NewATMVCIndication :: NewATMVCIndication ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 1 ), m_resourceID ( is ), m_bitRate ( is ), m_bitRateLockedToPCRClock ( is ), m_bitRateLockedToNetworkClock ( is ), m_aal ( is ), m_multiplex ( is ), m_reverseParameters ( 0 ) {
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_reverseParameters ) )
				m_reverseParameters = new NewATMVCIndication_reverseParameters ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_reverseParameters;
		throw;
	}
}

NewATMVCIndication :: NewATMVCIndication ( ) : Asn :: Sequence ( 0, true, 1 ), m_reverseParameters ( 0 ) {
	try {
		Asn :: Sequence :: includeOptionalField ( e_reverseParameters );
		m_reverseParameters = new NewATMVCIndication_reverseParameters;
	} catch ( ... ) {
		delete m_reverseParameters;
		throw;
	}
}

NewATMVCIndication & NewATMVCIndication :: operator= ( const NewATMVCIndication & s ) {
	Asn :: Sequence :: operator= ( s );
	m_resourceID = s.m_resourceID;
	m_bitRate = s.m_bitRate;
	m_bitRateLockedToPCRClock = s.m_bitRateLockedToPCRClock;
	m_bitRateLockedToNetworkClock = s.m_bitRateLockedToNetworkClock;
	m_aal = s.m_aal;
	m_multiplex = s.m_multiplex;
	assignCopy ( m_reverseParameters, s.m_reverseParameters );
	return * this;
}

NewATMVCIndication :: NewATMVCIndication ( const NewATMVCIndication & s ) : Asn :: Sequence ( s ), m_resourceID ( s.m_resourceID ), m_bitRate ( s.m_bitRate ), m_bitRateLockedToPCRClock ( s.m_bitRateLockedToPCRClock ), m_bitRateLockedToNetworkClock ( s.m_bitRateLockedToNetworkClock ), m_aal ( s.m_aal ), m_multiplex ( s.m_multiplex ), m_reverseParameters ( 0 ) {
	try {
		if ( s.m_reverseParameters )
			m_reverseParameters = new NewATMVCIndication_reverseParameters ( * s.m_reverseParameters );
	} catch ( ... ) {
		delete m_reverseParameters;
		throw;
	}
}


void NewATMVCIndication :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_reverseParameters:
			assignNew ( m_reverseParameters, new NewATMVCIndication_reverseParameters );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void NewATMVCIndication :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_reverseParameters:
			delete m_reverseParameters;
			m_reverseParameters = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void NewATMVCIndication :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_resourceID.encode ( os );
	m_bitRate.encode ( os );
	m_bitRateLockedToPCRClock.encode ( os );
	m_bitRateLockedToNetworkClock.encode ( os );
	m_aal.encode ( os );
	m_multiplex.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_reverseParameters, m_reverseParameters );
		unknownExtensionsEncode ( os );
	}
}

NewATMVCIndication :: ~NewATMVCIndication ( ) {
	delete m_reverseParameters;
}

void NewATMVCIndication :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 13 ) << "resourceID = " << std :: setprecision ( indent ) << m_resourceID << '\n';
	os << std :: setw ( indent + 10 ) << "bitRate = " << std :: setprecision ( indent ) << m_bitRate << '\n';
	os << std :: setw ( indent + 26 ) << "bitRateLockedToPCRClock = " << std :: setprecision ( indent ) << m_bitRateLockedToPCRClock << '\n';
	os << std :: setw ( indent + 30 ) << "bitRateLockedToNetworkClock = " << std :: setprecision ( indent ) << m_bitRateLockedToNetworkClock << '\n';
	os << std :: setw ( indent + 6 ) << "aal = " << std :: setprecision ( indent ) << m_aal << '\n';
	os << std :: setw ( indent + 12 ) << "multiplex = " << std :: setprecision ( indent ) << m_multiplex << '\n';
	if ( hasOptionalField ( e_reverseParameters ) ) {
		os << std :: setw ( indent + 20 ) << "reverseParameters = " << std :: setprecision ( indent );
		m_reverseParameters -> NewATMVCIndication_reverseParameters :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

NewATMVCIndication * NewATMVCIndication :: clone ( ) const {
	return new NewATMVCIndication ( * this );
}

//
// VCCapability_availableBitRates
//

VCCapability_availableBitRates :: VCCapability_availableBitRates ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_type ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

VCCapability_availableBitRates :: VCCapability_availableBitRates ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void VCCapability_availableBitRates :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_type.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void VCCapability_availableBitRates :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 7 ) << "type = " << std :: setprecision ( indent ) << m_type << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

VCCapability_availableBitRates * VCCapability_availableBitRates :: clone ( ) const {
	return new VCCapability_availableBitRates ( * this );
}

//
// H223LogicalChannelParameters_adaptationLayerType
//

H223LogicalChannelParameters_adaptationLayerType :: H223LogicalChannelParameters_adaptationLayerType ( Asn :: istream & is ) : Asn :: Choice ( is, 6, true ) {
	switch ( tag ) {
		case e_nonStandard:
			choice = new NonStandardParameter ( is );
			break;
		case e_al1Framed:
		case e_al1NotFramed:
		case e_al2WithoutSequenceNumbers:
		case e_al2WithSequenceNumbers:
			choice = new Asn :: Null ( is );
			break;
		case e_al3:
			choice = new H223LogicalChannelParameters_adaptationLayerType_al3 ( is );
			break;
		case e_al1M:
			choice = new H223AL1MParameters ( is );
			break;
		case e_al2M:
			choice = new H223AL2MParameters ( is );
			break;
		case e_al3M:
			choice = new H223AL3MParameters ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

H223LogicalChannelParameters_adaptationLayerType :: H223LogicalChannelParameters_adaptationLayerType ( ) : Asn :: Choice ( 6, true ) { }

void H223LogicalChannelParameters_adaptationLayerType :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandard:
			o = new NonStandardParameter;
			break;
		case e_al1Framed:
		case e_al1NotFramed:
		case e_al2WithoutSequenceNumbers:
		case e_al2WithSequenceNumbers:
			o = new Asn :: Null;
			break;
		case e_al3:
			o = new H223LogicalChannelParameters_adaptationLayerType_al3;
			break;
		case e_al1M:
			o = new H223AL1MParameters;
			break;
		case e_al2M:
			o = new H223AL2MParameters;
			break;
		case e_al3M:
			o = new H223AL3MParameters;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & H223LogicalChannelParameters_adaptationLayerType :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandard, "nonStandard" },
		{ e_al1Framed, "al1Framed" },
		{ e_al1NotFramed, "al1NotFramed" },
		{ e_al2WithoutSequenceNumbers, "al2WithoutSequenceNumbers" },
		{ e_al2WithSequenceNumbers, "al2WithSequenceNumbers" },
		{ e_al3, "al3" },
		{ e_al1M, "al1M" },
		{ e_al2M, "al2M" },
		{ e_al3M, "al3M" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

H223LogicalChannelParameters_adaptationLayerType * H223LogicalChannelParameters_adaptationLayerType :: clone ( ) const {
	return new H223LogicalChannelParameters_adaptationLayerType ( * this );
}

//
// RTPPayloadType_payloadDescriptor
//

RTPPayloadType_payloadDescriptor :: RTPPayloadType_payloadDescriptor ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_nonStandardIdentifier:
			choice = new NonStandardParameter ( is );
			break;
		case e_rfc_number:
			choice = new RTPPayloadType_payloadDescriptor_rfc_number ( is );
			break;
		case e_oid:
			choice = new Asn :: ObjectId ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

RTPPayloadType_payloadDescriptor :: RTPPayloadType_payloadDescriptor ( ) : Asn :: Choice ( 3, true ) { }

void RTPPayloadType_payloadDescriptor :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandardIdentifier:
			o = new NonStandardParameter;
			break;
		case e_rfc_number:
			o = new RTPPayloadType_payloadDescriptor_rfc_number;
			break;
		case e_oid:
			o = new Asn :: ObjectId;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & RTPPayloadType_payloadDescriptor :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandardIdentifier, "nonStandardIdentifier" },
		{ e_rfc_number, "rfc_number" },
		{ e_oid, "oid" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

RTPPayloadType_payloadDescriptor * RTPPayloadType_payloadDescriptor :: clone ( ) const {
	return new RTPPayloadType_payloadDescriptor ( * this );
}

//
// H223ModeParameters_adaptationLayerType
//

H223ModeParameters_adaptationLayerType :: H223ModeParameters_adaptationLayerType ( Asn :: istream & is ) : Asn :: Choice ( is, 6, true ) {
	switch ( tag ) {
		case e_nonStandard:
			choice = new NonStandardParameter ( is );
			break;
		case e_al1Framed:
		case e_al1NotFramed:
		case e_al2WithoutSequenceNumbers:
		case e_al2WithSequenceNumbers:
			choice = new Asn :: Null ( is );
			break;
		case e_al3:
			choice = new H223ModeParameters_adaptationLayerType_al3 ( is );
			break;
		case e_al1M:
			choice = new H223AL1MParameters ( is );
			break;
		case e_al2M:
			choice = new H223AL2MParameters ( is );
			break;
		case e_al3M:
			choice = new H223AL3MParameters ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

H223ModeParameters_adaptationLayerType :: H223ModeParameters_adaptationLayerType ( ) : Asn :: Choice ( 6, true ) { }

void H223ModeParameters_adaptationLayerType :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandard:
			o = new NonStandardParameter;
			break;
		case e_al1Framed:
		case e_al1NotFramed:
		case e_al2WithoutSequenceNumbers:
		case e_al2WithSequenceNumbers:
			o = new Asn :: Null;
			break;
		case e_al3:
			o = new H223ModeParameters_adaptationLayerType_al3;
			break;
		case e_al1M:
			o = new H223AL1MParameters;
			break;
		case e_al2M:
			o = new H223AL2MParameters;
			break;
		case e_al3M:
			o = new H223AL3MParameters;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & H223ModeParameters_adaptationLayerType :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandard, "nonStandard" },
		{ e_al1Framed, "al1Framed" },
		{ e_al1NotFramed, "al1NotFramed" },
		{ e_al2WithoutSequenceNumbers, "al2WithoutSequenceNumbers" },
		{ e_al2WithSequenceNumbers, "al2WithSequenceNumbers" },
		{ e_al3, "al3" },
		{ e_al1M, "al1M" },
		{ e_al2M, "al2M" },
		{ e_al3M, "al3M" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

H223ModeParameters_adaptationLayerType * H223ModeParameters_adaptationLayerType :: clone ( ) const {
	return new H223ModeParameters_adaptationLayerType ( * this );
}

//
// EncryptionCommand_encryptionAlgorithmID
//

EncryptionCommand_encryptionAlgorithmID :: EncryptionCommand_encryptionAlgorithmID ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, false, 0 ), m_h233AlgorithmIdentifier ( is ), m_associatedAlgorithm ( is ) {
}

EncryptionCommand_encryptionAlgorithmID :: EncryptionCommand_encryptionAlgorithmID ( ) : Asn :: Sequence ( 0, false, 0 ) { }

void EncryptionCommand_encryptionAlgorithmID :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_h233AlgorithmIdentifier.encode ( os );
	m_associatedAlgorithm.encode ( os );
}

void EncryptionCommand_encryptionAlgorithmID :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 26 ) << "h233AlgorithmIdentifier = " << std :: setprecision ( indent ) << m_h233AlgorithmIdentifier << '\n';
	os << std :: setw ( indent + 22 ) << "associatedAlgorithm = " << std :: setprecision ( indent ) << m_associatedAlgorithm << '\n';
	os << std :: setw ( indent - 1 ) << '}';
}

EncryptionCommand_encryptionAlgorithmID * EncryptionCommand_encryptionAlgorithmID :: clone ( ) const {
	return new EncryptionCommand_encryptionAlgorithmID ( * this );
}

//
// UserInputIndication_userInputSupportIndication
//

UserInputIndication_userInputSupportIndication :: UserInputIndication_userInputSupportIndication ( Asn :: istream & is ) : Asn :: Choice ( is, 4, true ) {
	switch ( tag ) {
		case e_nonStandard:
			choice = new NonStandardParameter ( is );
			break;
		case e_basicString:
		case e_iA5String:
		case e_generalString:
		case e_encryptedBasicString:
		case e_encryptedIA5String:
		case e_encryptedGeneralString:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

UserInputIndication_userInputSupportIndication :: UserInputIndication_userInputSupportIndication ( ) : Asn :: Choice ( 4, true ) { }

void UserInputIndication_userInputSupportIndication :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandard:
			o = new NonStandardParameter;
			break;
		case e_basicString:
		case e_iA5String:
		case e_generalString:
		case e_encryptedBasicString:
		case e_encryptedIA5String:
		case e_encryptedGeneralString:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & UserInputIndication_userInputSupportIndication :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandard, "nonStandard" },
		{ e_basicString, "basicString" },
		{ e_iA5String, "iA5String" },
		{ e_generalString, "generalString" },
		{ e_encryptedBasicString, "encryptedBasicString" },
		{ e_encryptedIA5String, "encryptedIA5String" },
		{ e_encryptedGeneralString, "encryptedGeneralString" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

UserInputIndication_userInputSupportIndication * UserInputIndication_userInputSupportIndication :: clone ( ) const {
	return new UserInputIndication_userInputSupportIndication ( * this );
}

//
// DataApplicationCapability_application_t84
//

DataApplicationCapability_application_t84 :: DataApplicationCapability_application_t84 ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, false, 0 ), m_t84Protocol ( is ), m_t84Profile ( is ) {
}

DataApplicationCapability_application_t84 :: DataApplicationCapability_application_t84 ( ) : Asn :: Sequence ( 0, false, 0 ) { }

void DataApplicationCapability_application_t84 :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_t84Protocol.encode ( os );
	m_t84Profile.encode ( os );
}

void DataApplicationCapability_application_t84 :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 14 ) << "t84Protocol = " << std :: setprecision ( indent ) << m_t84Protocol << '\n';
	os << std :: setw ( indent + 13 ) << "t84Profile = " << std :: setprecision ( indent ) << m_t84Profile << '\n';
	os << std :: setw ( indent - 1 ) << '}';
}

DataApplicationCapability_application_t84 * DataApplicationCapability_application_t84 :: clone ( ) const {
	return new DataApplicationCapability_application_t84 ( * this );
}

//
// DataApplicationCapability_application_nlpid
//

DataApplicationCapability_application_nlpid :: DataApplicationCapability_application_nlpid ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, false, 0 ), m_nlpidProtocol ( is ), m_nlpidData ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) {
}

DataApplicationCapability_application_nlpid :: DataApplicationCapability_application_nlpid ( ) : Asn :: Sequence ( 0, false, 0 ) { }

void DataApplicationCapability_application_nlpid :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_nlpidProtocol.encode ( os );
	m_nlpidData.encode ( os );
}

void DataApplicationCapability_application_nlpid :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "nlpidProtocol = " << std :: setprecision ( indent ) << m_nlpidProtocol << '\n';
	os << std :: setw ( indent + 12 ) << "nlpidData = " << std :: setprecision ( indent ) << m_nlpidData << '\n';
	os << std :: setw ( indent - 1 ) << '}';
}

DataApplicationCapability_application_nlpid * DataApplicationCapability_application_nlpid :: clone ( ) const {
	return new DataApplicationCapability_application_nlpid ( * this );
}

//
// DataApplicationCapability_application_t38fax
//

DataApplicationCapability_application_t38fax :: DataApplicationCapability_application_t38fax ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, false, 0 ), m_t38FaxProtocol ( is ), m_t38FaxProfile ( is ) {
}

DataApplicationCapability_application_t38fax :: DataApplicationCapability_application_t38fax ( ) : Asn :: Sequence ( 0, false, 0 ) { }

void DataApplicationCapability_application_t38fax :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_t38FaxProtocol.encode ( os );
	m_t38FaxProfile.encode ( os );
}

void DataApplicationCapability_application_t38fax :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 17 ) << "t38FaxProtocol = " << std :: setprecision ( indent ) << m_t38FaxProtocol << '\n';
	os << std :: setw ( indent + 16 ) << "t38FaxProfile = " << std :: setprecision ( indent ) << m_t38FaxProfile << '\n';
	os << std :: setw ( indent - 1 ) << '}';
}

DataApplicationCapability_application_t38fax * DataApplicationCapability_application_t38fax :: clone ( ) const {
	return new DataApplicationCapability_application_t38fax ( * this );
}

//
// DepFECData_rfc2733_mode
//

DepFECData_rfc2733_mode :: DepFECData_rfc2733_mode ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_redundancyEncoding:
			choice = new Asn :: Null ( is );
			break;
		case e_separateStream:
			choice = new DepFECData_rfc2733_mode_separateStream ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

DepFECData_rfc2733_mode :: DepFECData_rfc2733_mode ( ) : Asn :: Choice ( 2, true ) { }

void DepFECData_rfc2733_mode :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_redundancyEncoding:
			o = new Asn :: Null;
			break;
		case e_separateStream:
			o = new DepFECData_rfc2733_mode_separateStream;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & DepFECData_rfc2733_mode :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_redundancyEncoding, "redundancyEncoding" },
		{ e_separateStream, "separateStream" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

DepFECData_rfc2733_mode * DepFECData_rfc2733_mode :: clone ( ) const {
	return new DepFECData_rfc2733_mode ( * this );
}

//
// DataMode_application_nlpid
//

DataMode_application_nlpid :: DataMode_application_nlpid ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, false, 0 ), m_nlpidProtocol ( is ), m_nlpidData ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) ) {
}

DataMode_application_nlpid :: DataMode_application_nlpid ( ) : Asn :: Sequence ( 0, false, 0 ) { }

void DataMode_application_nlpid :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_nlpidProtocol.encode ( os );
	m_nlpidData.encode ( os );
}

void DataMode_application_nlpid :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "nlpidProtocol = " << std :: setprecision ( indent ) << m_nlpidProtocol << '\n';
	os << std :: setw ( indent + 12 ) << "nlpidData = " << std :: setprecision ( indent ) << m_nlpidData << '\n';
	os << std :: setw ( indent - 1 ) << '}';
}

DataMode_application_nlpid * DataMode_application_nlpid :: clone ( ) const {
	return new DataMode_application_nlpid ( * this );
}

//
// DataMode_application_t38fax
//

DataMode_application_t38fax :: DataMode_application_t38fax ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, false, 0 ), m_t38FaxProtocol ( is ), m_t38FaxProfile ( is ) {
}

DataMode_application_t38fax :: DataMode_application_t38fax ( ) : Asn :: Sequence ( 0, false, 0 ) { }

void DataMode_application_t38fax :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_t38FaxProtocol.encode ( os );
	m_t38FaxProfile.encode ( os );
}

void DataMode_application_t38fax :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 17 ) << "t38FaxProtocol = " << std :: setprecision ( indent ) << m_t38FaxProtocol << '\n';
	os << std :: setw ( indent + 16 ) << "t38FaxProfile = " << std :: setprecision ( indent ) << m_t38FaxProfile << '\n';
	os << std :: setw ( indent - 1 ) << '}';
}

DataMode_application_t38fax * DataMode_application_t38fax :: clone ( ) const {
	return new DataMode_application_t38fax ( * this );
}

//
// GenericMessage
//

GenericMessage :: GenericMessage ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 0 ), m_messageIdentifier ( is ), m_subMessageIdentifier ( 0 ), m_messageContent ( 0 ) {
	try {
		if ( hasOptionalField ( e_subMessageIdentifier ) )
			m_subMessageIdentifier = new GenericMessage_subMessageIdentifier ( is );
		if ( hasOptionalField ( e_messageContent ) )
			m_messageContent = new ArrayOf_GenericParameter ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_subMessageIdentifier;
		delete m_messageContent;
		throw;
	}
}

GenericMessage :: GenericMessage ( ) : Asn :: Sequence ( 2, true, 0 ), m_subMessageIdentifier ( 0 ), m_messageContent ( 0 ) { }

GenericMessage & GenericMessage :: operator= ( const GenericMessage & s ) {
	Asn :: Sequence :: operator= ( s );
	m_messageIdentifier = s.m_messageIdentifier;
	assignCopy ( m_subMessageIdentifier, s.m_subMessageIdentifier );
	assignCopy ( m_messageContent, s.m_messageContent );
	return * this;
}

GenericMessage :: GenericMessage ( const GenericMessage & s ) : Asn :: Sequence ( s ), m_messageIdentifier ( s.m_messageIdentifier ), m_subMessageIdentifier ( 0 ), m_messageContent ( 0 ) {
	try {
		if ( s.m_subMessageIdentifier )
			m_subMessageIdentifier = new GenericMessage_subMessageIdentifier ( * s.m_subMessageIdentifier );
		if ( s.m_messageContent )
			m_messageContent = new ArrayOf_GenericParameter ( * s.m_messageContent );
	} catch ( ... ) {
		delete m_subMessageIdentifier;
		delete m_messageContent;
		throw;
	}
}


void GenericMessage :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_subMessageIdentifier:
			assignNew ( m_subMessageIdentifier, new GenericMessage_subMessageIdentifier );
			break;
		case e_messageContent:
			assignNew ( m_messageContent, new ArrayOf_GenericParameter );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void GenericMessage :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_subMessageIdentifier:
			delete m_subMessageIdentifier;
			m_subMessageIdentifier = 0;
			break;
		case e_messageContent:
			delete m_messageContent;
			m_messageContent = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void GenericMessage :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_messageIdentifier.encode ( os );
	if ( hasOptionalField ( e_subMessageIdentifier ) )
		m_subMessageIdentifier -> GenericMessage_subMessageIdentifier :: encode ( os );
	if ( hasOptionalField ( e_messageContent ) )
		m_messageContent -> ArrayOf_GenericParameter :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

GenericMessage :: ~GenericMessage ( ) {
	delete m_subMessageIdentifier;
	delete m_messageContent;
}

void GenericMessage :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 20 ) << "messageIdentifier = " << std :: setprecision ( indent ) << m_messageIdentifier << '\n';
	if ( hasOptionalField ( e_subMessageIdentifier ) ) {
		os << std :: setw ( indent + 23 ) << "subMessageIdentifier = " << std :: setprecision ( indent );
		m_subMessageIdentifier -> GenericMessage_subMessageIdentifier :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_messageContent ) ) {
		os << std :: setw ( indent + 17 ) << "messageContent = " << std :: setprecision ( indent );
		m_messageContent -> ArrayOf_GenericParameter :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

GenericMessage * GenericMessage :: clone ( ) const {
	return new GenericMessage ( * this );
}

//
// GenericInformation
//

GenericInformation :: GenericInformation ( Asn :: istream & is ) : GenericMessage ( is ) { }

GenericInformation :: GenericInformation ( ) : GenericMessage ( ) { }

GenericInformation * GenericInformation :: clone ( ) const {
	return new GenericInformation ( * this );
}

//
// NonStandardMessage
//

NonStandardMessage :: NonStandardMessage ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_nonStandardData ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

NonStandardMessage :: NonStandardMessage ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void NonStandardMessage :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_nonStandardData.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void NonStandardMessage :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 18 ) << "nonStandardData = " << std :: setprecision ( indent ) << m_nonStandardData << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

NonStandardMessage * NonStandardMessage :: clone ( ) const {
	return new NonStandardMessage ( * this );
}

//
// VCCapability
//

VCCapability :: VCCapability ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 1 ), m_aal1 ( hasOptionalField ( e_aal1 ) ? pushTemporaryMember ( new VCCapability_aal1 ( is ) ) : 0 ), m_aal5 ( hasOptionalField ( e_aal5 ) ? pushTemporaryMember ( new VCCapability_aal5 ( is ) ) : 0 ), m_transportStream ( is ), m_programStream ( is ), m_availableBitRates ( is ), m_aal1ViaGateway ( 0 ) {
	clearTemporaryMembers ( );
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_aal1ViaGateway ) )
				m_aal1ViaGateway = new VCCapability_aal1ViaGateway ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_aal1;
		delete m_aal5;
		delete m_aal1ViaGateway;
		throw;
	}
}

VCCapability :: VCCapability ( ) : Asn :: Sequence ( 2, true, 1 ), m_aal1 ( 0 ), m_aal5 ( 0 ), m_aal1ViaGateway ( 0 ) { }

VCCapability & VCCapability :: operator= ( const VCCapability & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_aal1, s.m_aal1 );
	assignCopy ( m_aal5, s.m_aal5 );
	m_transportStream = s.m_transportStream;
	m_programStream = s.m_programStream;
	m_availableBitRates = s.m_availableBitRates;
	assignCopy ( m_aal1ViaGateway, s.m_aal1ViaGateway );
	return * this;
}

VCCapability :: VCCapability ( const VCCapability & s ) : Asn :: Sequence ( s ), m_aal1 ( 0 ), m_aal5 ( 0 ), m_transportStream ( s.m_transportStream ), m_programStream ( s.m_programStream ), m_availableBitRates ( s.m_availableBitRates ), m_aal1ViaGateway ( 0 ) {
	try {
		if ( s.m_aal1 )
			m_aal1 = new VCCapability_aal1 ( * s.m_aal1 );
		if ( s.m_aal5 )
			m_aal5 = new VCCapability_aal5 ( * s.m_aal5 );
		if ( s.m_aal1ViaGateway )
			m_aal1ViaGateway = new VCCapability_aal1ViaGateway ( * s.m_aal1ViaGateway );
	} catch ( ... ) {
		delete m_aal1;
		delete m_aal5;
		delete m_aal1ViaGateway;
		throw;
	}
}


void VCCapability :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_aal1:
			assignNew ( m_aal1, new VCCapability_aal1 );
			break;
		case e_aal5:
			assignNew ( m_aal5, new VCCapability_aal5 );
			break;
		case e_aal1ViaGateway:
			assignNew ( m_aal1ViaGateway, new VCCapability_aal1ViaGateway );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void VCCapability :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_aal1:
			delete m_aal1;
			m_aal1 = 0;
			break;
		case e_aal5:
			delete m_aal5;
			m_aal5 = 0;
			break;
		case e_aal1ViaGateway:
			delete m_aal1ViaGateway;
			m_aal1ViaGateway = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void VCCapability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_aal1 ) )
		m_aal1 -> VCCapability_aal1 :: encode ( os );
	if ( hasOptionalField ( e_aal5 ) )
		m_aal5 -> VCCapability_aal5 :: encode ( os );
	m_transportStream.encode ( os );
	m_programStream.encode ( os );
	m_availableBitRates.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_aal1ViaGateway, m_aal1ViaGateway );
		unknownExtensionsEncode ( os );
	}
}

VCCapability :: ~VCCapability ( ) {
	delete m_aal1;
	delete m_aal5;
	delete m_aal1ViaGateway;
}

void VCCapability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_aal1 ) ) {
		os << std :: setw ( indent + 7 ) << "aal1 = " << std :: setprecision ( indent );
		m_aal1 -> VCCapability_aal1 :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_aal5 ) ) {
		os << std :: setw ( indent + 7 ) << "aal5 = " << std :: setprecision ( indent );
		m_aal5 -> VCCapability_aal5 :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 18 ) << "transportStream = " << std :: setprecision ( indent ) << m_transportStream << '\n';
	os << std :: setw ( indent + 16 ) << "programStream = " << std :: setprecision ( indent ) << m_programStream << '\n';
	os << std :: setw ( indent + 20 ) << "availableBitRates = " << std :: setprecision ( indent ) << m_availableBitRates << '\n';
	if ( hasOptionalField ( e_aal1ViaGateway ) ) {
		os << std :: setw ( indent + 17 ) << "aal1ViaGateway = " << std :: setprecision ( indent );
		m_aal1ViaGateway -> VCCapability_aal1ViaGateway :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

VCCapability * VCCapability :: clone ( ) const {
	return new VCCapability ( * this );
}

//
// RedundancyEncodingCapability
//

RedundancyEncodingCapability :: RedundancyEncodingCapability ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_redundancyEncodingMethod ( is ), m_primaryEncoding ( is ), m_secondaryEncoding ( 0 ) {
	try {
		if ( hasOptionalField ( e_secondaryEncoding ) )
			m_secondaryEncoding = new RedundancyEncodingCapability_secondaryEncoding ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_secondaryEncoding;
		throw;
	}
}

RedundancyEncodingCapability :: RedundancyEncodingCapability ( ) : Asn :: Sequence ( 1, true, 0 ), m_secondaryEncoding ( 0 ) { }

RedundancyEncodingCapability & RedundancyEncodingCapability :: operator= ( const RedundancyEncodingCapability & s ) {
	Asn :: Sequence :: operator= ( s );
	m_redundancyEncodingMethod = s.m_redundancyEncodingMethod;
	m_primaryEncoding = s.m_primaryEncoding;
	assignCopy ( m_secondaryEncoding, s.m_secondaryEncoding );
	return * this;
}

RedundancyEncodingCapability :: RedundancyEncodingCapability ( const RedundancyEncodingCapability & s ) : Asn :: Sequence ( s ), m_redundancyEncodingMethod ( s.m_redundancyEncodingMethod ), m_primaryEncoding ( s.m_primaryEncoding ), m_secondaryEncoding ( 0 ) {
	try {
		if ( s.m_secondaryEncoding )
			m_secondaryEncoding = new RedundancyEncodingCapability_secondaryEncoding ( * s.m_secondaryEncoding );
	} catch ( ... ) {
		delete m_secondaryEncoding;
		throw;
	}
}


void RedundancyEncodingCapability :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_secondaryEncoding:
			assignNew ( m_secondaryEncoding, new RedundancyEncodingCapability_secondaryEncoding );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void RedundancyEncodingCapability :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_secondaryEncoding:
			delete m_secondaryEncoding;
			m_secondaryEncoding = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void RedundancyEncodingCapability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_redundancyEncodingMethod.encode ( os );
	m_primaryEncoding.encode ( os );
	if ( hasOptionalField ( e_secondaryEncoding ) )
		m_secondaryEncoding -> RedundancyEncodingCapability_secondaryEncoding :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

RedundancyEncodingCapability :: ~RedundancyEncodingCapability ( ) {
	delete m_secondaryEncoding;
}

void RedundancyEncodingCapability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 27 ) << "redundancyEncodingMethod = " << std :: setprecision ( indent ) << m_redundancyEncodingMethod << '\n';
	os << std :: setw ( indent + 18 ) << "primaryEncoding = " << std :: setprecision ( indent ) << m_primaryEncoding << '\n';
	if ( hasOptionalField ( e_secondaryEncoding ) ) {
		os << std :: setw ( indent + 20 ) << "secondaryEncoding = " << std :: setprecision ( indent );
		m_secondaryEncoding -> RedundancyEncodingCapability_secondaryEncoding :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RedundancyEncodingCapability * RedundancyEncodingCapability :: clone ( ) const {
	return new RedundancyEncodingCapability ( * this );
}

//
// GenericCapability
//

GenericCapability :: GenericCapability ( Asn :: istream & is ) : Asn :: Sequence ( is, 5, true, 0 ), m_capabilityIdentifier ( is ), m_maxBitRate ( 0 ), m_collapsing ( 0 ), m_nonCollapsing ( 0 ), m_nonCollapsingRaw ( 0 ), m_transport ( 0 ) {
	try {
		if ( hasOptionalField ( e_maxBitRate ) )
			m_maxBitRate = new GenericCapability_maxBitRate ( is );
		if ( hasOptionalField ( e_collapsing ) )
			m_collapsing = new ArrayOf_GenericParameter ( is );
		if ( hasOptionalField ( e_nonCollapsing ) )
			m_nonCollapsing = new ArrayOf_GenericParameter ( is );
		if ( hasOptionalField ( e_nonCollapsingRaw ) )
			m_nonCollapsingRaw = new Asn :: OctetString ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) );
		if ( hasOptionalField ( e_transport ) )
			m_transport = new DataProtocolCapability ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_maxBitRate;
		delete m_collapsing;
		delete m_nonCollapsing;
		delete m_nonCollapsingRaw;
		delete m_transport;
		throw;
	}
}

GenericCapability :: GenericCapability ( ) : Asn :: Sequence ( 5, true, 0 ), m_maxBitRate ( 0 ), m_collapsing ( 0 ), m_nonCollapsing ( 0 ), m_nonCollapsingRaw ( 0 ), m_transport ( 0 ) { }

GenericCapability & GenericCapability :: operator= ( const GenericCapability & s ) {
	Asn :: Sequence :: operator= ( s );
	m_capabilityIdentifier = s.m_capabilityIdentifier;
	assignCopy ( m_maxBitRate, s.m_maxBitRate );
	assignCopy ( m_collapsing, s.m_collapsing );
	assignCopy ( m_nonCollapsing, s.m_nonCollapsing );
	assignCopy ( m_nonCollapsingRaw, s.m_nonCollapsingRaw );
	assignCopy ( m_transport, s.m_transport );
	return * this;
}

GenericCapability :: GenericCapability ( const GenericCapability & s ) : Asn :: Sequence ( s ), m_capabilityIdentifier ( s.m_capabilityIdentifier ), m_maxBitRate ( 0 ), m_collapsing ( 0 ), m_nonCollapsing ( 0 ), m_nonCollapsingRaw ( 0 ), m_transport ( 0 ) {
	try {
		if ( s.m_maxBitRate )
			m_maxBitRate = new GenericCapability_maxBitRate ( * s.m_maxBitRate );
		if ( s.m_collapsing )
			m_collapsing = new ArrayOf_GenericParameter ( * s.m_collapsing );
		if ( s.m_nonCollapsing )
			m_nonCollapsing = new ArrayOf_GenericParameter ( * s.m_nonCollapsing );
		if ( s.m_nonCollapsingRaw )
			m_nonCollapsingRaw = new Asn :: OctetString ( * s.m_nonCollapsingRaw );
		if ( s.m_transport )
			m_transport = new DataProtocolCapability ( * s.m_transport );
	} catch ( ... ) {
		delete m_maxBitRate;
		delete m_collapsing;
		delete m_nonCollapsing;
		delete m_nonCollapsingRaw;
		delete m_transport;
		throw;
	}
}


void GenericCapability :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_maxBitRate:
			assignNew ( m_maxBitRate, new GenericCapability_maxBitRate );
			break;
		case e_collapsing:
			assignNew ( m_collapsing, new ArrayOf_GenericParameter );
			break;
		case e_nonCollapsing:
			assignNew ( m_nonCollapsing, new ArrayOf_GenericParameter );
			break;
		case e_nonCollapsingRaw:
			assignNew ( m_nonCollapsingRaw, new Asn :: OctetString );
			break;
		case e_transport:
			assignNew ( m_transport, new DataProtocolCapability );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void GenericCapability :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_maxBitRate:
			delete m_maxBitRate;
			m_maxBitRate = 0;
			break;
		case e_collapsing:
			delete m_collapsing;
			m_collapsing = 0;
			break;
		case e_nonCollapsing:
			delete m_nonCollapsing;
			m_nonCollapsing = 0;
			break;
		case e_nonCollapsingRaw:
			delete m_nonCollapsingRaw;
			m_nonCollapsingRaw = 0;
			break;
		case e_transport:
			delete m_transport;
			m_transport = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void GenericCapability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_capabilityIdentifier.encode ( os );
	if ( hasOptionalField ( e_maxBitRate ) )
		m_maxBitRate -> GenericCapability_maxBitRate :: encode ( os );
	if ( hasOptionalField ( e_collapsing ) )
		m_collapsing -> ArrayOf_GenericParameter :: encode ( os );
	if ( hasOptionalField ( e_nonCollapsing ) )
		m_nonCollapsing -> ArrayOf_GenericParameter :: encode ( os );
	if ( hasOptionalField ( e_nonCollapsingRaw ) )
		m_nonCollapsingRaw -> Asn :: OctetString :: encode ( os );
	if ( hasOptionalField ( e_transport ) )
		m_transport -> DataProtocolCapability :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

GenericCapability :: ~GenericCapability ( ) {
	delete m_maxBitRate;
	delete m_collapsing;
	delete m_nonCollapsing;
	delete m_nonCollapsingRaw;
	delete m_transport;
}

void GenericCapability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 23 ) << "capabilityIdentifier = " << std :: setprecision ( indent ) << m_capabilityIdentifier << '\n';
	if ( hasOptionalField ( e_maxBitRate ) ) {
		os << std :: setw ( indent + 13 ) << "maxBitRate = " << std :: setprecision ( indent );
		m_maxBitRate -> GenericCapability_maxBitRate :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_collapsing ) ) {
		os << std :: setw ( indent + 13 ) << "collapsing = " << std :: setprecision ( indent );
		m_collapsing -> ArrayOf_GenericParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_nonCollapsing ) ) {
		os << std :: setw ( indent + 16 ) << "nonCollapsing = " << std :: setprecision ( indent );
		m_nonCollapsing -> ArrayOf_GenericParameter :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_nonCollapsingRaw ) ) {
		os << std :: setw ( indent + 19 ) << "nonCollapsingRaw = " << std :: setprecision ( indent );
		m_nonCollapsingRaw -> Asn :: OctetString :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_transport ) ) {
		os << std :: setw ( indent + 12 ) << "transport = " << std :: setprecision ( indent );
		m_transport -> DataProtocolCapability :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

GenericCapability * GenericCapability :: clone ( ) const {
	return new GenericCapability ( * this );
}

//
// GenericParameter
//

GenericParameter :: GenericParameter ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_parameterIdentifier ( is ), m_parameterValue ( is ), m_supersedes ( 0 ) {
	try {
		if ( hasOptionalField ( e_supersedes ) )
			m_supersedes = new ArrayOf_ParameterIdentifier ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_supersedes;
		throw;
	}
}

GenericParameter :: GenericParameter ( ) : Asn :: Sequence ( 1, true, 0 ), m_supersedes ( 0 ) { }

GenericParameter & GenericParameter :: operator= ( const GenericParameter & s ) {
	Asn :: Sequence :: operator= ( s );
	m_parameterIdentifier = s.m_parameterIdentifier;
	m_parameterValue = s.m_parameterValue;
	assignCopy ( m_supersedes, s.m_supersedes );
	return * this;
}

GenericParameter :: GenericParameter ( const GenericParameter & s ) : Asn :: Sequence ( s ), m_parameterIdentifier ( s.m_parameterIdentifier ), m_parameterValue ( s.m_parameterValue ), m_supersedes ( 0 ) {
	try {
		if ( s.m_supersedes )
			m_supersedes = new ArrayOf_ParameterIdentifier ( * s.m_supersedes );
	} catch ( ... ) {
		delete m_supersedes;
		throw;
	}
}


void GenericParameter :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_supersedes:
			assignNew ( m_supersedes, new ArrayOf_ParameterIdentifier );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void GenericParameter :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_supersedes:
			delete m_supersedes;
			m_supersedes = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void GenericParameter :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_parameterIdentifier.encode ( os );
	m_parameterValue.encode ( os );
	if ( hasOptionalField ( e_supersedes ) )
		m_supersedes -> ArrayOf_ParameterIdentifier :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

GenericParameter :: ~GenericParameter ( ) {
	delete m_supersedes;
}

void GenericParameter :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 22 ) << "parameterIdentifier = " << std :: setprecision ( indent ) << m_parameterIdentifier << '\n';
	os << std :: setw ( indent + 17 ) << "parameterValue = " << std :: setprecision ( indent ) << m_parameterValue << '\n';
	if ( hasOptionalField ( e_supersedes ) ) {
		os << std :: setw ( indent + 13 ) << "supersedes = " << std :: setprecision ( indent );
		m_supersedes -> ArrayOf_ParameterIdentifier :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

GenericParameter * GenericParameter :: clone ( ) const {
	return new GenericParameter ( * this );
}

//
// MultiplexedStreamCapability
//

MultiplexedStreamCapability :: MultiplexedStreamCapability ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_multiplexFormat ( is ), m_controlOnMuxStream ( is ), m_capabilityOnMuxStream ( 0 ) {
	try {
		if ( hasOptionalField ( e_capabilityOnMuxStream ) )
			m_capabilityOnMuxStream = new MultiplexedStreamCapability_capabilityOnMuxStream ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_capabilityOnMuxStream;
		throw;
	}
}

MultiplexedStreamCapability :: MultiplexedStreamCapability ( ) : Asn :: Sequence ( 1, true, 0 ), m_capabilityOnMuxStream ( 0 ) { }

MultiplexedStreamCapability & MultiplexedStreamCapability :: operator= ( const MultiplexedStreamCapability & s ) {
	Asn :: Sequence :: operator= ( s );
	m_multiplexFormat = s.m_multiplexFormat;
	m_controlOnMuxStream = s.m_controlOnMuxStream;
	assignCopy ( m_capabilityOnMuxStream, s.m_capabilityOnMuxStream );
	return * this;
}

MultiplexedStreamCapability :: MultiplexedStreamCapability ( const MultiplexedStreamCapability & s ) : Asn :: Sequence ( s ), m_multiplexFormat ( s.m_multiplexFormat ), m_controlOnMuxStream ( s.m_controlOnMuxStream ), m_capabilityOnMuxStream ( 0 ) {
	try {
		if ( s.m_capabilityOnMuxStream )
			m_capabilityOnMuxStream = new MultiplexedStreamCapability_capabilityOnMuxStream ( * s.m_capabilityOnMuxStream );
	} catch ( ... ) {
		delete m_capabilityOnMuxStream;
		throw;
	}
}


void MultiplexedStreamCapability :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_capabilityOnMuxStream:
			assignNew ( m_capabilityOnMuxStream, new MultiplexedStreamCapability_capabilityOnMuxStream );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void MultiplexedStreamCapability :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_capabilityOnMuxStream:
			delete m_capabilityOnMuxStream;
			m_capabilityOnMuxStream = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void MultiplexedStreamCapability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_multiplexFormat.encode ( os );
	m_controlOnMuxStream.encode ( os );
	if ( hasOptionalField ( e_capabilityOnMuxStream ) )
		m_capabilityOnMuxStream -> MultiplexedStreamCapability_capabilityOnMuxStream :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

MultiplexedStreamCapability :: ~MultiplexedStreamCapability ( ) {
	delete m_capabilityOnMuxStream;
}

void MultiplexedStreamCapability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 18 ) << "multiplexFormat = " << std :: setprecision ( indent ) << m_multiplexFormat << '\n';
	os << std :: setw ( indent + 21 ) << "controlOnMuxStream = " << std :: setprecision ( indent ) << m_controlOnMuxStream << '\n';
	if ( hasOptionalField ( e_capabilityOnMuxStream ) ) {
		os << std :: setw ( indent + 24 ) << "capabilityOnMuxStream = " << std :: setprecision ( indent );
		m_capabilityOnMuxStream -> MultiplexedStreamCapability_capabilityOnMuxStream :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MultiplexedStreamCapability * MultiplexedStreamCapability :: clone ( ) const {
	return new MultiplexedStreamCapability ( * this );
}

//
// H223LogicalChannelParameters
//

H223LogicalChannelParameters :: H223LogicalChannelParameters ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_adaptationLayerType ( is ), m_segmentableFlag ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

H223LogicalChannelParameters :: H223LogicalChannelParameters ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void H223LogicalChannelParameters :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_adaptationLayerType.encode ( os );
	m_segmentableFlag.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void H223LogicalChannelParameters :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 22 ) << "adaptationLayerType = " << std :: setprecision ( indent ) << m_adaptationLayerType << '\n';
	os << std :: setw ( indent + 18 ) << "segmentableFlag = " << std :: setprecision ( indent ) << m_segmentableFlag << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H223LogicalChannelParameters * H223LogicalChannelParameters :: clone ( ) const {
	return new H223LogicalChannelParameters ( * this );
}

//
// RTPPayloadType
//

RTPPayloadType :: RTPPayloadType ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_payloadDescriptor ( is ), m_payloadType ( 0 ) {
	try {
		if ( hasOptionalField ( e_payloadType ) )
			m_payloadType = new RTPPayloadType_payloadType ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_payloadType;
		throw;
	}
}

RTPPayloadType :: RTPPayloadType ( ) : Asn :: Sequence ( 1, true, 0 ), m_payloadType ( 0 ) { }

RTPPayloadType & RTPPayloadType :: operator= ( const RTPPayloadType & s ) {
	Asn :: Sequence :: operator= ( s );
	m_payloadDescriptor = s.m_payloadDescriptor;
	assignCopy ( m_payloadType, s.m_payloadType );
	return * this;
}

RTPPayloadType :: RTPPayloadType ( const RTPPayloadType & s ) : Asn :: Sequence ( s ), m_payloadDescriptor ( s.m_payloadDescriptor ), m_payloadType ( 0 ) {
	try {
		if ( s.m_payloadType )
			m_payloadType = new RTPPayloadType_payloadType ( * s.m_payloadType );
	} catch ( ... ) {
		delete m_payloadType;
		throw;
	}
}


void RTPPayloadType :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_payloadType:
			assignNew ( m_payloadType, new RTPPayloadType_payloadType );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void RTPPayloadType :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_payloadType:
			delete m_payloadType;
			m_payloadType = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void RTPPayloadType :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_payloadDescriptor.encode ( os );
	if ( hasOptionalField ( e_payloadType ) )
		m_payloadType -> RTPPayloadType_payloadType :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

RTPPayloadType :: ~RTPPayloadType ( ) {
	delete m_payloadType;
}

void RTPPayloadType :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 20 ) << "payloadDescriptor = " << std :: setprecision ( indent ) << m_payloadDescriptor << '\n';
	if ( hasOptionalField ( e_payloadType ) ) {
		os << std :: setw ( indent + 14 ) << "payloadType = " << std :: setprecision ( indent );
		m_payloadType -> RTPPayloadType_payloadType :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RTPPayloadType * RTPPayloadType :: clone ( ) const {
	return new RTPPayloadType ( * this );
}

//
// TransportAddress
//

TransportAddress :: TransportAddress ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_unicastAddress:
			choice = new UnicastAddress ( is );
			break;
		case e_multicastAddress:
			choice = new MulticastAddress ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

TransportAddress :: TransportAddress ( ) : Asn :: Choice ( 2, true ) { }

void TransportAddress :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_unicastAddress:
			o = new UnicastAddress;
			break;
		case e_multicastAddress:
			o = new MulticastAddress;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & TransportAddress :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_unicastAddress, "unicastAddress" },
		{ e_multicastAddress, "multicastAddress" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

TransportAddress * TransportAddress :: clone ( ) const {
	return new TransportAddress ( * this );
}

//
// H223ModeParameters
//

H223ModeParameters :: H223ModeParameters ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_adaptationLayerType ( is ), m_segmentableFlag ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

H223ModeParameters :: H223ModeParameters ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void H223ModeParameters :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_adaptationLayerType.encode ( os );
	m_segmentableFlag.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void H223ModeParameters :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 22 ) << "adaptationLayerType = " << std :: setprecision ( indent ) << m_adaptationLayerType << '\n';
	os << std :: setw ( indent + 18 ) << "segmentableFlag = " << std :: setprecision ( indent ) << m_segmentableFlag << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H223ModeParameters * H223ModeParameters :: clone ( ) const {
	return new H223ModeParameters ( * this );
}

//
// VideoMode
//

VideoMode :: VideoMode ( Asn :: istream & is ) : Asn :: Choice ( is, 5, true ) {
	switch ( tag ) {
		case e_nonStandard:
			choice = new NonStandardParameter ( is );
			break;
		case e_h261VideoMode:
			choice = new H261VideoMode ( is );
			break;
		case e_h262VideoMode:
			choice = new H262VideoMode ( is );
			break;
		case e_h263VideoMode:
			choice = new H263VideoMode ( is );
			break;
		case e_is11172VideoMode:
			choice = new IS11172VideoMode ( is );
			break;
		case e_genericVideoMode:
			choice = new GenericCapability ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

VideoMode :: VideoMode ( ) : Asn :: Choice ( 5, true ) { }

void VideoMode :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandard:
			o = new NonStandardParameter;
			break;
		case e_h261VideoMode:
			o = new H261VideoMode;
			break;
		case e_h262VideoMode:
			o = new H262VideoMode;
			break;
		case e_h263VideoMode:
			o = new H263VideoMode;
			break;
		case e_is11172VideoMode:
			o = new IS11172VideoMode;
			break;
		case e_genericVideoMode:
			o = new GenericCapability;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & VideoMode :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandard, "nonStandard" },
		{ e_h261VideoMode, "h261VideoMode" },
		{ e_h262VideoMode, "h262VideoMode" },
		{ e_h263VideoMode, "h263VideoMode" },
		{ e_is11172VideoMode, "is11172VideoMode" },
		{ e_genericVideoMode, "genericVideoMode" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

VideoMode * VideoMode :: clone ( ) const {
	return new VideoMode ( * this );
}

//
// MultilinkIndication
//

MultilinkIndication :: MultilinkIndication ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_nonStandard:
			choice = new NonStandardMessage ( is );
			break;
		case e_crcDesired:
			choice = new MultilinkIndication_crcDesired ( is );
			break;
		case e_excessiveError:
			choice = new MultilinkIndication_excessiveError ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

MultilinkIndication :: MultilinkIndication ( ) : Asn :: Choice ( 3, true ) { }

void MultilinkIndication :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandard:
			o = new NonStandardMessage;
			break;
		case e_crcDesired:
			o = new MultilinkIndication_crcDesired;
			break;
		case e_excessiveError:
			o = new MultilinkIndication_excessiveError;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & MultilinkIndication :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandard, "nonStandard" },
		{ e_crcDesired, "crcDesired" },
		{ e_excessiveError, "excessiveError" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

MultilinkIndication * MultilinkIndication :: clone ( ) const {
	return new MultilinkIndication ( * this );
}

//
// DialingInformation
//

DialingInformation :: DialingInformation ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_nonStandard:
			choice = new NonStandardMessage ( is );
			break;
		case e_differential:
			choice = new DialingInformation_differential ( is );
			break;
		case e_infoNotAvailable:
			choice = new DialingInformation_infoNotAvailable ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

DialingInformation :: DialingInformation ( ) : Asn :: Choice ( 3, true ) { }

void DialingInformation :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandard:
			o = new NonStandardMessage;
			break;
		case e_differential:
			o = new DialingInformation_differential;
			break;
		case e_infoNotAvailable:
			o = new DialingInformation_infoNotAvailable;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & DialingInformation :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandard, "nonStandard" },
		{ e_differential, "differential" },
		{ e_infoNotAvailable, "infoNotAvailable" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

DialingInformation * DialingInformation :: clone ( ) const {
	return new DialingInformation ( * this );
}

//
// DialingInformationNetworkType
//

DialingInformationNetworkType :: DialingInformationNetworkType ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_nonStandard:
			choice = new NonStandardMessage ( is );
			break;
		case e_n_isdn:
		case e_gstn:
		case e_mobile:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

DialingInformationNetworkType :: DialingInformationNetworkType ( ) : Asn :: Choice ( 3, true ) { }

void DialingInformationNetworkType :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandard:
			o = new NonStandardMessage;
			break;
		case e_n_isdn:
		case e_gstn:
		case e_mobile:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & DialingInformationNetworkType :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandard, "nonStandard" },
		{ e_n_isdn, "n_isdn" },
		{ e_gstn, "gstn" },
		{ e_mobile, "mobile" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

DialingInformationNetworkType * DialingInformationNetworkType :: clone ( ) const {
	return new DialingInformationNetworkType ( * this );
}

//
// EncryptionCommand
//

EncryptionCommand :: EncryptionCommand ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_encryptionSE:
			choice = new Asn :: OctetString ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) );
			break;
		case e_encryptionIVRequest:
			choice = new Asn :: Null ( is );
			break;
		case e_encryptionAlgorithmID:
			choice = new EncryptionCommand_encryptionAlgorithmID ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

EncryptionCommand :: EncryptionCommand ( ) : Asn :: Choice ( 3, true ) { }

void EncryptionCommand :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_encryptionSE:
			o = new Asn :: OctetString;
			break;
		case e_encryptionIVRequest:
			o = new Asn :: Null;
			break;
		case e_encryptionAlgorithmID:
			o = new EncryptionCommand_encryptionAlgorithmID;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & EncryptionCommand :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_encryptionSE, "encryptionSE" },
		{ e_encryptionIVRequest, "encryptionIVRequest" },
		{ e_encryptionAlgorithmID, "encryptionAlgorithmID" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

EncryptionCommand * EncryptionCommand :: clone ( ) const {
	return new EncryptionCommand ( * this );
}

//
// MCLocationIndication
//

MCLocationIndication :: MCLocationIndication ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_signalAddress ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MCLocationIndication :: MCLocationIndication ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MCLocationIndication :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_signalAddress.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MCLocationIndication :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "signalAddress = " << std :: setprecision ( indent ) << m_signalAddress << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MCLocationIndication * MCLocationIndication :: clone ( ) const {
	return new MCLocationIndication ( * this );
}

//
// UserInputIndication
//

UserInputIndication :: UserInputIndication ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_nonStandard:
			choice = new NonStandardParameter ( is );
			break;
		case e_alphanumeric:
			choice = new Asn :: GeneralString ( is, Asn :: unconstrained, 0, std :: numeric_limits < unsigned > :: max ( ) );
			break;
		case e_userInputSupportIndication:
			choice = new UserInputIndication_userInputSupportIndication ( is );
			break;
		case e_signal:
			choice = new UserInputIndication_signal ( is );
			break;
		case e_signalUpdate:
			choice = new UserInputIndication_signalUpdate ( is );
			break;
		case e_extendedAlphanumeric:
			choice = new UserInputIndication_extendedAlphanumeric ( is );
			break;
		case e_encryptedAlphanumeric:
			choice = new UserInputIndication_encryptedAlphanumeric ( is );
			break;
		case e_genericInformation:
			choice = new ArrayOf_GenericInformation ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

UserInputIndication :: UserInputIndication ( ) : Asn :: Choice ( 2, true ) { }

void UserInputIndication :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandard:
			o = new NonStandardParameter;
			break;
		case e_alphanumeric:
			o = new Asn :: GeneralString;
			break;
		case e_userInputSupportIndication:
			o = new UserInputIndication_userInputSupportIndication;
			break;
		case e_signal:
			o = new UserInputIndication_signal;
			break;
		case e_signalUpdate:
			o = new UserInputIndication_signalUpdate;
			break;
		case e_extendedAlphanumeric:
			o = new UserInputIndication_extendedAlphanumeric;
			break;
		case e_encryptedAlphanumeric:
			o = new UserInputIndication_encryptedAlphanumeric;
			break;
		case e_genericInformation:
			o = new ArrayOf_GenericInformation;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & UserInputIndication :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandard, "nonStandard" },
		{ e_alphanumeric, "alphanumeric" },
		{ e_userInputSupportIndication, "userInputSupportIndication" },
		{ e_signal, "signal" },
		{ e_signalUpdate, "signalUpdate" },
		{ e_extendedAlphanumeric, "extendedAlphanumeric" },
		{ e_encryptedAlphanumeric, "encryptedAlphanumeric" },
		{ e_genericInformation, "genericInformation" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

UserInputIndication * UserInputIndication :: clone ( ) const {
	return new UserInputIndication ( * this );
}

//
// DataApplicationCapability_application
//

DataApplicationCapability_application :: DataApplicationCapability_application ( Asn :: istream & is ) : Asn :: Choice ( is, 10, true ) {
	switch ( tag ) {
		case e_nonStandard:
			choice = new NonStandardParameter ( is );
			break;
		case e_t120:
		case e_dsm_cc:
		case e_userData:
		case e_t434:
		case e_h224:
		case e_h222DataPartitioning:
		case e_t30fax:
		case e_t140:
			choice = new DataProtocolCapability ( is );
			break;
		case e_t84:
			choice = new DataApplicationCapability_application_t84 ( is );
			break;
		case e_nlpid:
			choice = new DataApplicationCapability_application_nlpid ( is );
			break;
		case e_dsvdControl:
			choice = new Asn :: Null ( is );
			break;
		case e_t38fax:
			choice = new DataApplicationCapability_application_t38fax ( is );
			break;
		case e_genericDataCapability:
			choice = new GenericCapability ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

DataApplicationCapability_application :: DataApplicationCapability_application ( ) : Asn :: Choice ( 10, true ) { }

void DataApplicationCapability_application :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandard:
			o = new NonStandardParameter;
			break;
		case e_t120:
		case e_dsm_cc:
		case e_userData:
		case e_t434:
		case e_h224:
		case e_h222DataPartitioning:
		case e_t30fax:
		case e_t140:
			o = new DataProtocolCapability;
			break;
		case e_t84:
			o = new DataApplicationCapability_application_t84;
			break;
		case e_nlpid:
			o = new DataApplicationCapability_application_nlpid;
			break;
		case e_dsvdControl:
			o = new Asn :: Null;
			break;
		case e_t38fax:
			o = new DataApplicationCapability_application_t38fax;
			break;
		case e_genericDataCapability:
			o = new GenericCapability;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & DataApplicationCapability_application :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandard, "nonStandard" },
		{ e_t120, "t120" },
		{ e_dsm_cc, "dsm_cc" },
		{ e_userData, "userData" },
		{ e_t84, "t84" },
		{ e_t434, "t434" },
		{ e_h224, "h224" },
		{ e_nlpid, "nlpid" },
		{ e_dsvdControl, "dsvdControl" },
		{ e_h222DataPartitioning, "h222DataPartitioning" },
		{ e_t30fax, "t30fax" },
		{ e_t140, "t140" },
		{ e_t38fax, "t38fax" },
		{ e_genericDataCapability, "genericDataCapability" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

DataApplicationCapability_application * DataApplicationCapability_application :: clone ( ) const {
	return new DataApplicationCapability_application ( * this );
}

//
// NetworkAccessParameters_networkAddress
//

NetworkAccessParameters_networkAddress :: NetworkAccessParameters_networkAddress ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_q2931Address:
			choice = new Q2931Address ( is );
			break;
		case e_e164Address:
			choice = new NetworkAccessParameters_networkAddress_e164Address ( is );
			break;
		case e_localAreaAddress:
			choice = new TransportAddress ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

NetworkAccessParameters_networkAddress :: NetworkAccessParameters_networkAddress ( ) : Asn :: Choice ( 3, true ) { }

void NetworkAccessParameters_networkAddress :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_q2931Address:
			o = new Q2931Address;
			break;
		case e_e164Address:
			o = new NetworkAccessParameters_networkAddress_e164Address;
			break;
		case e_localAreaAddress:
			o = new TransportAddress;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & NetworkAccessParameters_networkAddress :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_q2931Address, "q2931Address" },
		{ e_e164Address, "e164Address" },
		{ e_localAreaAddress, "localAreaAddress" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

NetworkAccessParameters_networkAddress * NetworkAccessParameters_networkAddress :: clone ( ) const {
	return new NetworkAccessParameters_networkAddress ( * this );
}

//
// H2250LogicalChannelParameters_mediaPacketization
//

H2250LogicalChannelParameters_mediaPacketization :: H2250LogicalChannelParameters_mediaPacketization ( Asn :: istream & is ) : Asn :: Choice ( is, 1, true ) {
	switch ( tag ) {
		case e_h261aVideoPacketization:
			choice = new Asn :: Null ( is );
			break;
		case e_rtpPayloadType:
			choice = new RTPPayloadType ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

H2250LogicalChannelParameters_mediaPacketization :: H2250LogicalChannelParameters_mediaPacketization ( ) : Asn :: Choice ( 1, true ) { }

void H2250LogicalChannelParameters_mediaPacketization :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_h261aVideoPacketization:
			o = new Asn :: Null;
			break;
		case e_rtpPayloadType:
			o = new RTPPayloadType;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & H2250LogicalChannelParameters_mediaPacketization :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_h261aVideoPacketization, "h261aVideoPacketization" },
		{ e_rtpPayloadType, "rtpPayloadType" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

H2250LogicalChannelParameters_mediaPacketization * H2250LogicalChannelParameters_mediaPacketization :: clone ( ) const {
	return new H2250LogicalChannelParameters_mediaPacketization ( * this );
}

//
// DepFECData_rfc2733
//

DepFECData_rfc2733 :: DepFECData_rfc2733 ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_mode ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

DepFECData_rfc2733 :: DepFECData_rfc2733 ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void DepFECData_rfc2733 :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_mode.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void DepFECData_rfc2733 :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 7 ) << "mode = " << std :: setprecision ( indent ) << m_mode << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

DepFECData_rfc2733 * DepFECData_rfc2733 :: clone ( ) const {
	return new DepFECData_rfc2733 ( * this );
}

//
// DataMode_application
//

DataMode_application :: DataMode_application ( Asn :: istream & is ) : Asn :: Choice ( is, 10, true ) {
	switch ( tag ) {
		case e_nonStandard:
			choice = new NonStandardParameter ( is );
			break;
		case e_t120:
		case e_dsm_cc:
		case e_userData:
		case e_t84:
		case e_t434:
		case e_h224:
		case e_h222DataPartitioning:
		case e_t30fax:
		case e_t140:
			choice = new DataProtocolCapability ( is );
			break;
		case e_nlpid:
			choice = new DataMode_application_nlpid ( is );
			break;
		case e_dsvdControl:
			choice = new Asn :: Null ( is );
			break;
		case e_t38fax:
			choice = new DataMode_application_t38fax ( is );
			break;
		case e_genericDataMode:
			choice = new GenericCapability ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

DataMode_application :: DataMode_application ( ) : Asn :: Choice ( 10, true ) { }

void DataMode_application :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandard:
			o = new NonStandardParameter;
			break;
		case e_t120:
		case e_dsm_cc:
		case e_userData:
		case e_t84:
		case e_t434:
		case e_h224:
		case e_h222DataPartitioning:
		case e_t30fax:
		case e_t140:
			o = new DataProtocolCapability;
			break;
		case e_nlpid:
			o = new DataMode_application_nlpid;
			break;
		case e_dsvdControl:
			o = new Asn :: Null;
			break;
		case e_t38fax:
			o = new DataMode_application_t38fax;
			break;
		case e_genericDataMode:
			o = new GenericCapability;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & DataMode_application :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandard, "nonStandard" },
		{ e_t120, "t120" },
		{ e_dsm_cc, "dsm_cc" },
		{ e_userData, "userData" },
		{ e_t84, "t84" },
		{ e_t434, "t434" },
		{ e_h224, "h224" },
		{ e_nlpid, "nlpid" },
		{ e_dsvdControl, "dsvdControl" },
		{ e_h222DataPartitioning, "h222DataPartitioning" },
		{ e_t30fax, "t30fax" },
		{ e_t140, "t140" },
		{ e_t38fax, "t38fax" },
		{ e_genericDataMode, "genericDataMode" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

DataMode_application * DataMode_application :: clone ( ) const {
	return new DataMode_application ( * this );
}

//
// MultilinkRequest_addConnection
//

MultilinkRequest_addConnection :: MultilinkRequest_addConnection ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_sequenceNumber ( is ), m_dialingInformation ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MultilinkRequest_addConnection :: MultilinkRequest_addConnection ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MultilinkRequest_addConnection :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_sequenceNumber.encode ( os );
	m_dialingInformation.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MultilinkRequest_addConnection :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 17 ) << "sequenceNumber = " << std :: setprecision ( indent ) << m_sequenceNumber << '\n';
	os << std :: setw ( indent + 21 ) << "dialingInformation = " << std :: setprecision ( indent ) << m_dialingInformation << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MultilinkRequest_addConnection * MultilinkRequest_addConnection :: clone ( ) const {
	return new MultilinkRequest_addConnection ( * this );
}

//
// MultilinkResponse_callInformation
//

MultilinkResponse_callInformation :: MultilinkResponse_callInformation ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_dialingInformation ( is ), m_callAssociationNumber ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MultilinkResponse_callInformation :: MultilinkResponse_callInformation ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MultilinkResponse_callInformation :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_dialingInformation.encode ( os );
	m_callAssociationNumber.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MultilinkResponse_callInformation :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 21 ) << "dialingInformation = " << std :: setprecision ( indent ) << m_dialingInformation << '\n';
	os << std :: setw ( indent + 24 ) << "callAssociationNumber = " << std :: setprecision ( indent ) << m_callAssociationNumber << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MultilinkResponse_callInformation * MultilinkResponse_callInformation :: clone ( ) const {
	return new MultilinkResponse_callInformation ( * this );
}

//
// OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters
//

OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters :: OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_h222LogicalChannelParameters:
			choice = new H222LogicalChannelParameters ( is );
			break;
		case e_h223LogicalChannelParameters:
			choice = new H223LogicalChannelParameters ( is );
			break;
		case e_v76LogicalChannelParameters:
			choice = new V76LogicalChannelParameters ( is );
			break;
		case e_h2250LogicalChannelParameters:
			choice = new H2250LogicalChannelParameters ( is );
			break;
		case e_none:
			choice = new Asn :: Null ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters :: OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters ( ) : Asn :: Choice ( 3, true ) { }

void OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_h222LogicalChannelParameters:
			o = new H222LogicalChannelParameters;
			break;
		case e_h223LogicalChannelParameters:
			o = new H223LogicalChannelParameters;
			break;
		case e_v76LogicalChannelParameters:
			o = new V76LogicalChannelParameters;
			break;
		case e_h2250LogicalChannelParameters:
			o = new H2250LogicalChannelParameters;
			break;
		case e_none:
			o = new Asn :: Null;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_h222LogicalChannelParameters, "h222LogicalChannelParameters" },
		{ e_h223LogicalChannelParameters, "h223LogicalChannelParameters" },
		{ e_v76LogicalChannelParameters, "v76LogicalChannelParameters" },
		{ e_h2250LogicalChannelParameters, "h2250LogicalChannelParameters" },
		{ e_none, "none" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters * OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters :: clone ( ) const {
	return new OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters ( * this );
}

//
// OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters
//

OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters :: OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_h223LogicalChannelParameters:
			choice = new H223LogicalChannelParameters ( is );
			break;
		case e_v76LogicalChannelParameters:
			choice = new V76LogicalChannelParameters ( is );
			break;
		case e_h2250LogicalChannelParameters:
			choice = new H2250LogicalChannelParameters ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters :: OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters ( ) : Asn :: Choice ( 2, true ) { }

void OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_h223LogicalChannelParameters:
			o = new H223LogicalChannelParameters;
			break;
		case e_v76LogicalChannelParameters:
			o = new V76LogicalChannelParameters;
			break;
		case e_h2250LogicalChannelParameters:
			o = new H2250LogicalChannelParameters;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_h223LogicalChannelParameters, "h223LogicalChannelParameters" },
		{ e_v76LogicalChannelParameters, "v76LogicalChannelParameters" },
		{ e_h2250LogicalChannelParameters, "h2250LogicalChannelParameters" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters * OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters :: clone ( ) const {
	return new OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters ( * this );
}

//
// CommandMessage
//

CommandMessage :: CommandMessage ( Asn :: istream & is ) : Asn :: Choice ( is, 7, true ) {
	switch ( tag ) {
		case e_nonStandard:
			choice = new NonStandardMessage ( is );
			break;
		case e_maintenanceLoopOffCommand:
			choice = new MaintenanceLoopOffCommand ( is );
			break;
		case e_sendTerminalCapabilitySet:
			choice = new SendTerminalCapabilitySet ( is );
			break;
		case e_encryptionCommand:
			choice = new EncryptionCommand ( is );
			break;
		case e_flowControlCommand:
			choice = new FlowControlCommand ( is );
			break;
		case e_endSessionCommand:
			choice = new EndSessionCommand ( is );
			break;
		case e_miscellaneousCommand:
			choice = new MiscellaneousCommand ( is );
			break;
		case e_communicationModeCommand:
			choice = new CommunicationModeCommand ( is );
			break;
		case e_conferenceCommand:
			choice = new ConferenceCommand ( is );
			break;
		case e_h223MultiplexReconfiguration:
			choice = new H223MultiplexReconfiguration ( is );
			break;
		case e_newATMVCCommand:
			choice = new NewATMVCCommand ( is );
			break;
		case e_mobileMultilinkReconfigurationCommand:
			choice = new MobileMultilinkReconfigurationCommand ( is );
			break;
		case e_genericCommand:
			choice = new GenericMessage ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

CommandMessage :: CommandMessage ( ) : Asn :: Choice ( 7, true ) { }

void CommandMessage :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandard:
			o = new NonStandardMessage;
			break;
		case e_maintenanceLoopOffCommand:
			o = new MaintenanceLoopOffCommand;
			break;
		case e_sendTerminalCapabilitySet:
			o = new SendTerminalCapabilitySet;
			break;
		case e_encryptionCommand:
			o = new EncryptionCommand;
			break;
		case e_flowControlCommand:
			o = new FlowControlCommand;
			break;
		case e_endSessionCommand:
			o = new EndSessionCommand;
			break;
		case e_miscellaneousCommand:
			o = new MiscellaneousCommand;
			break;
		case e_communicationModeCommand:
			o = new CommunicationModeCommand;
			break;
		case e_conferenceCommand:
			o = new ConferenceCommand;
			break;
		case e_h223MultiplexReconfiguration:
			o = new H223MultiplexReconfiguration;
			break;
		case e_newATMVCCommand:
			o = new NewATMVCCommand;
			break;
		case e_mobileMultilinkReconfigurationCommand:
			o = new MobileMultilinkReconfigurationCommand;
			break;
		case e_genericCommand:
			o = new GenericMessage;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & CommandMessage :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandard, "nonStandard" },
		{ e_maintenanceLoopOffCommand, "maintenanceLoopOffCommand" },
		{ e_sendTerminalCapabilitySet, "sendTerminalCapabilitySet" },
		{ e_encryptionCommand, "encryptionCommand" },
		{ e_flowControlCommand, "flowControlCommand" },
		{ e_endSessionCommand, "endSessionCommand" },
		{ e_miscellaneousCommand, "miscellaneousCommand" },
		{ e_communicationModeCommand, "communicationModeCommand" },
		{ e_conferenceCommand, "conferenceCommand" },
		{ e_h223MultiplexReconfiguration, "h223MultiplexReconfiguration" },
		{ e_newATMVCCommand, "newATMVCCommand" },
		{ e_mobileMultilinkReconfigurationCommand, "mobileMultilinkReconfigurationCommand" },
		{ e_genericCommand, "genericCommand" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

CommandMessage * CommandMessage :: clone ( ) const {
	return new CommandMessage ( * this );
}

//
// MultiplexCapability
//

MultiplexCapability :: MultiplexCapability ( Asn :: istream & is ) : Asn :: Choice ( is, 4, true ) {
	switch ( tag ) {
		case e_nonStandard:
			choice = new NonStandardParameter ( is );
			break;
		case e_h222Capability:
			choice = new H222Capability ( is );
			break;
		case e_h223Capability:
			choice = new H223Capability ( is );
			break;
		case e_v76Capability:
			choice = new V76Capability ( is );
			break;
		case e_h2250Capability:
			choice = new H2250Capability ( is );
			break;
		case e_genericMultiplexCapability:
			choice = new GenericCapability ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

MultiplexCapability :: MultiplexCapability ( ) : Asn :: Choice ( 4, true ) { }

void MultiplexCapability :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandard:
			o = new NonStandardParameter;
			break;
		case e_h222Capability:
			o = new H222Capability;
			break;
		case e_h223Capability:
			o = new H223Capability;
			break;
		case e_v76Capability:
			o = new V76Capability;
			break;
		case e_h2250Capability:
			o = new H2250Capability;
			break;
		case e_genericMultiplexCapability:
			o = new GenericCapability;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & MultiplexCapability :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandard, "nonStandard" },
		{ e_h222Capability, "h222Capability" },
		{ e_h223Capability, "h223Capability" },
		{ e_v76Capability, "v76Capability" },
		{ e_h2250Capability, "h2250Capability" },
		{ e_genericMultiplexCapability, "genericMultiplexCapability" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

MultiplexCapability * MultiplexCapability :: clone ( ) const {
	return new MultiplexCapability ( * this );
}

//
// VideoCapability
//

VideoCapability :: VideoCapability ( Asn :: istream & is ) : Asn :: Choice ( is, 5, true ) {
	switch ( tag ) {
		case e_nonStandard:
			choice = new NonStandardParameter ( is );
			break;
		case e_h261VideoCapability:
			choice = new H261VideoCapability ( is );
			break;
		case e_h262VideoCapability:
			choice = new H262VideoCapability ( is );
			break;
		case e_h263VideoCapability:
			choice = new H263VideoCapability ( is );
			break;
		case e_is11172VideoCapability:
			choice = new IS11172VideoCapability ( is );
			break;
		case e_genericVideoCapability:
			choice = new GenericCapability ( is );
			break;
		case e_extendedVideoCapability:
			choice = new ExtendedVideoCapability ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

VideoCapability :: VideoCapability ( ) : Asn :: Choice ( 5, true ) { }

void VideoCapability :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandard:
			o = new NonStandardParameter;
			break;
		case e_h261VideoCapability:
			o = new H261VideoCapability;
			break;
		case e_h262VideoCapability:
			o = new H262VideoCapability;
			break;
		case e_h263VideoCapability:
			o = new H263VideoCapability;
			break;
		case e_is11172VideoCapability:
			o = new IS11172VideoCapability;
			break;
		case e_genericVideoCapability:
			o = new GenericCapability;
			break;
		case e_extendedVideoCapability:
			o = new ExtendedVideoCapability;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & VideoCapability :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandard, "nonStandard" },
		{ e_h261VideoCapability, "h261VideoCapability" },
		{ e_h262VideoCapability, "h262VideoCapability" },
		{ e_h263VideoCapability, "h263VideoCapability" },
		{ e_is11172VideoCapability, "is11172VideoCapability" },
		{ e_genericVideoCapability, "genericVideoCapability" },
		{ e_extendedVideoCapability, "extendedVideoCapability" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

VideoCapability * VideoCapability :: clone ( ) const {
	return new VideoCapability ( * this );
}

//
// DataApplicationCapability
//

DataApplicationCapability :: DataApplicationCapability ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_application ( is ), m_maxBitRate ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

DataApplicationCapability :: DataApplicationCapability ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void DataApplicationCapability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_application.encode ( os );
	m_maxBitRate.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void DataApplicationCapability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 14 ) << "application = " << std :: setprecision ( indent ) << m_application << '\n';
	os << std :: setw ( indent + 13 ) << "maxBitRate = " << std :: setprecision ( indent ) << m_maxBitRate << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

DataApplicationCapability * DataApplicationCapability :: clone ( ) const {
	return new DataApplicationCapability ( * this );
}

//
// UserInputCapability
//

UserInputCapability :: UserInputCapability ( Asn :: istream & is ) : Asn :: Choice ( is, 6, true ) {
	switch ( tag ) {
		case e_nonStandard:
			choice = new UserInputCapability_nonStandard ( is );
			break;
		case e_basicString:
		case e_iA5String:
		case e_generalString:
		case e_dtmf:
		case e_hookflash:
		case e_extendedAlphanumeric:
		case e_encryptedBasicString:
		case e_encryptedIA5String:
		case e_encryptedGeneralString:
		case e_secureDTMF:
			choice = new Asn :: Null ( is );
			break;
		case e_genericUserInputCapability:
			choice = new GenericCapability ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

UserInputCapability :: UserInputCapability ( ) : Asn :: Choice ( 6, true ) { }

void UserInputCapability :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandard:
			o = new UserInputCapability_nonStandard;
			break;
		case e_basicString:
		case e_iA5String:
		case e_generalString:
		case e_dtmf:
		case e_hookflash:
		case e_extendedAlphanumeric:
		case e_encryptedBasicString:
		case e_encryptedIA5String:
		case e_encryptedGeneralString:
		case e_secureDTMF:
			o = new Asn :: Null;
			break;
		case e_genericUserInputCapability:
			o = new GenericCapability;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & UserInputCapability :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandard, "nonStandard" },
		{ e_basicString, "basicString" },
		{ e_iA5String, "iA5String" },
		{ e_generalString, "generalString" },
		{ e_dtmf, "dtmf" },
		{ e_hookflash, "hookflash" },
		{ e_extendedAlphanumeric, "extendedAlphanumeric" },
		{ e_encryptedBasicString, "encryptedBasicString" },
		{ e_encryptedIA5String, "encryptedIA5String" },
		{ e_encryptedGeneralString, "encryptedGeneralString" },
		{ e_secureDTMF, "secureDTMF" },
		{ e_genericUserInputCapability, "genericUserInputCapability" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

UserInputCapability * UserInputCapability :: clone ( ) const {
	return new UserInputCapability ( * this );
}

//
// NetworkAccessParameters
//

NetworkAccessParameters :: NetworkAccessParameters ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 1 ), m_distribution ( hasOptionalField ( e_distribution ) ? pushTemporaryMember ( new NetworkAccessParameters_distribution ( is ) ) : 0 ), m_networkAddress ( is ), m_associateConference ( is ), m_externalReference ( 0 ), m_t120SetupProcedure ( 0 ) {
	clearTemporaryMembers ( );
	try {
		if ( hasOptionalField ( e_externalReference ) )
			m_externalReference = new NetworkAccessParameters_externalReference ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_t120SetupProcedure ) )
				m_t120SetupProcedure = new NetworkAccessParameters_t120SetupProcedure ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_distribution;
		delete m_externalReference;
		delete m_t120SetupProcedure;
		throw;
	}
}

NetworkAccessParameters :: NetworkAccessParameters ( ) : Asn :: Sequence ( 2, true, 1 ), m_distribution ( 0 ), m_externalReference ( 0 ), m_t120SetupProcedure ( 0 ) { }

NetworkAccessParameters & NetworkAccessParameters :: operator= ( const NetworkAccessParameters & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_distribution, s.m_distribution );
	m_networkAddress = s.m_networkAddress;
	m_associateConference = s.m_associateConference;
	assignCopy ( m_externalReference, s.m_externalReference );
	assignCopy ( m_t120SetupProcedure, s.m_t120SetupProcedure );
	return * this;
}

NetworkAccessParameters :: NetworkAccessParameters ( const NetworkAccessParameters & s ) : Asn :: Sequence ( s ), m_distribution ( 0 ), m_networkAddress ( s.m_networkAddress ), m_associateConference ( s.m_associateConference ), m_externalReference ( 0 ), m_t120SetupProcedure ( 0 ) {
	try {
		if ( s.m_distribution )
			m_distribution = new NetworkAccessParameters_distribution ( * s.m_distribution );
		if ( s.m_externalReference )
			m_externalReference = new NetworkAccessParameters_externalReference ( * s.m_externalReference );
		if ( s.m_t120SetupProcedure )
			m_t120SetupProcedure = new NetworkAccessParameters_t120SetupProcedure ( * s.m_t120SetupProcedure );
	} catch ( ... ) {
		delete m_distribution;
		delete m_externalReference;
		delete m_t120SetupProcedure;
		throw;
	}
}


void NetworkAccessParameters :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_distribution:
			assignNew ( m_distribution, new NetworkAccessParameters_distribution );
			break;
		case e_externalReference:
			assignNew ( m_externalReference, new NetworkAccessParameters_externalReference );
			break;
		case e_t120SetupProcedure:
			assignNew ( m_t120SetupProcedure, new NetworkAccessParameters_t120SetupProcedure );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void NetworkAccessParameters :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_distribution:
			delete m_distribution;
			m_distribution = 0;
			break;
		case e_externalReference:
			delete m_externalReference;
			m_externalReference = 0;
			break;
		case e_t120SetupProcedure:
			delete m_t120SetupProcedure;
			m_t120SetupProcedure = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void NetworkAccessParameters :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_distribution ) )
		m_distribution -> NetworkAccessParameters_distribution :: encode ( os );
	m_networkAddress.encode ( os );
	m_associateConference.encode ( os );
	if ( hasOptionalField ( e_externalReference ) )
		m_externalReference -> NetworkAccessParameters_externalReference :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_t120SetupProcedure, m_t120SetupProcedure );
		unknownExtensionsEncode ( os );
	}
}

NetworkAccessParameters :: ~NetworkAccessParameters ( ) {
	delete m_distribution;
	delete m_externalReference;
	delete m_t120SetupProcedure;
}

void NetworkAccessParameters :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_distribution ) ) {
		os << std :: setw ( indent + 15 ) << "distribution = " << std :: setprecision ( indent );
		m_distribution -> NetworkAccessParameters_distribution :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 17 ) << "networkAddress = " << std :: setprecision ( indent ) << m_networkAddress << '\n';
	os << std :: setw ( indent + 22 ) << "associateConference = " << std :: setprecision ( indent ) << m_associateConference << '\n';
	if ( hasOptionalField ( e_externalReference ) ) {
		os << std :: setw ( indent + 20 ) << "externalReference = " << std :: setprecision ( indent );
		m_externalReference -> NetworkAccessParameters_externalReference :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_t120SetupProcedure ) ) {
		os << std :: setw ( indent + 21 ) << "t120SetupProcedure = " << std :: setprecision ( indent );
		m_t120SetupProcedure -> NetworkAccessParameters_t120SetupProcedure :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

NetworkAccessParameters * NetworkAccessParameters :: clone ( ) const {
	return new NetworkAccessParameters ( * this );
}

//
// DepFECData
//

DepFECData :: DepFECData ( Asn :: istream & is ) : Asn :: Choice ( is, 1, false ) {
	switch ( tag ) {
		case e_rfc2733:
			choice = new DepFECData_rfc2733 ( is );
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
}

DepFECData :: DepFECData ( ) : Asn :: Choice ( 1, false ) { }

void DepFECData :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_rfc2733:
			o = new DepFECData_rfc2733;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & DepFECData :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_rfc2733, "rfc2733" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

DepFECData * DepFECData :: clone ( ) const {
	return new DepFECData ( * this );
}

//
// DataMode
//

DataMode :: DataMode ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_application ( is ), m_bitRate ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

DataMode :: DataMode ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void DataMode :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_application.encode ( os );
	m_bitRate.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void DataMode :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 14 ) << "application = " << std :: setprecision ( indent ) << m_application << '\n';
	os << std :: setw ( indent + 10 ) << "bitRate = " << std :: setprecision ( indent ) << m_bitRate << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

DataMode * DataMode :: clone ( ) const {
	return new DataMode ( * this );
}

//
// MultilinkRequest
//

MultilinkRequest :: MultilinkRequest ( Asn :: istream & is ) : Asn :: Choice ( is, 5, true ) {
	switch ( tag ) {
		case e_nonStandard:
			choice = new NonStandardMessage ( is );
			break;
		case e_callInformation:
			choice = new MultilinkRequest_callInformation ( is );
			break;
		case e_addConnection:
			choice = new MultilinkRequest_addConnection ( is );
			break;
		case e_removeConnection:
			choice = new MultilinkRequest_removeConnection ( is );
			break;
		case e_maximumHeaderInterval:
			choice = new MultilinkRequest_maximumHeaderInterval ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

MultilinkRequest :: MultilinkRequest ( ) : Asn :: Choice ( 5, true ) { }

void MultilinkRequest :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandard:
			o = new NonStandardMessage;
			break;
		case e_callInformation:
			o = new MultilinkRequest_callInformation;
			break;
		case e_addConnection:
			o = new MultilinkRequest_addConnection;
			break;
		case e_removeConnection:
			o = new MultilinkRequest_removeConnection;
			break;
		case e_maximumHeaderInterval:
			o = new MultilinkRequest_maximumHeaderInterval;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & MultilinkRequest :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandard, "nonStandard" },
		{ e_callInformation, "callInformation" },
		{ e_addConnection, "addConnection" },
		{ e_removeConnection, "removeConnection" },
		{ e_maximumHeaderInterval, "maximumHeaderInterval" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

MultilinkRequest * MultilinkRequest :: clone ( ) const {
	return new MultilinkRequest ( * this );
}

//
// MultilinkResponse
//

MultilinkResponse :: MultilinkResponse ( Asn :: istream & is ) : Asn :: Choice ( is, 5, true ) {
	switch ( tag ) {
		case e_nonStandard:
			choice = new NonStandardMessage ( is );
			break;
		case e_callInformation:
			choice = new MultilinkResponse_callInformation ( is );
			break;
		case e_addConnection:
			choice = new MultilinkResponse_addConnection ( is );
			break;
		case e_removeConnection:
			choice = new MultilinkResponse_removeConnection ( is );
			break;
		case e_maximumHeaderInterval:
			choice = new MultilinkResponse_maximumHeaderInterval ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

MultilinkResponse :: MultilinkResponse ( ) : Asn :: Choice ( 5, true ) { }

void MultilinkResponse :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandard:
			o = new NonStandardMessage;
			break;
		case e_callInformation:
			o = new MultilinkResponse_callInformation;
			break;
		case e_addConnection:
			o = new MultilinkResponse_addConnection;
			break;
		case e_removeConnection:
			o = new MultilinkResponse_removeConnection;
			break;
		case e_maximumHeaderInterval:
			o = new MultilinkResponse_maximumHeaderInterval;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & MultilinkResponse :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandard, "nonStandard" },
		{ e_callInformation, "callInformation" },
		{ e_addConnection, "addConnection" },
		{ e_removeConnection, "removeConnection" },
		{ e_maximumHeaderInterval, "maximumHeaderInterval" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

MultilinkResponse * MultilinkResponse :: clone ( ) const {
	return new MultilinkResponse ( * this );
}

//
// ResponseMessage
//

ResponseMessage :: ResponseMessage ( Asn :: istream & is ) : Asn :: Choice ( is, 19, true ) {
	switch ( tag ) {
		case e_nonStandard:
			choice = new NonStandardMessage ( is );
			break;
		case e_masterSlaveDeterminationAck:
			choice = new MasterSlaveDeterminationAck ( is );
			break;
		case e_masterSlaveDeterminationReject:
			choice = new MasterSlaveDeterminationReject ( is );
			break;
		case e_terminalCapabilitySetAck:
			choice = new TerminalCapabilitySetAck ( is );
			break;
		case e_terminalCapabilitySetReject:
			choice = new TerminalCapabilitySetReject ( is );
			break;
		case e_openLogicalChannelAck:
			choice = new OpenLogicalChannelAck ( is );
			break;
		case e_openLogicalChannelReject:
			choice = new OpenLogicalChannelReject ( is );
			break;
		case e_closeLogicalChannelAck:
			choice = new CloseLogicalChannelAck ( is );
			break;
		case e_requestChannelCloseAck:
			choice = new RequestChannelCloseAck ( is );
			break;
		case e_requestChannelCloseReject:
			choice = new RequestChannelCloseReject ( is );
			break;
		case e_multiplexEntrySendAck:
			choice = new MultiplexEntrySendAck ( is );
			break;
		case e_multiplexEntrySendReject:
			choice = new MultiplexEntrySendReject ( is );
			break;
		case e_requestMultiplexEntryAck:
			choice = new RequestMultiplexEntryAck ( is );
			break;
		case e_requestMultiplexEntryReject:
			choice = new RequestMultiplexEntryReject ( is );
			break;
		case e_requestModeAck:
			choice = new RequestModeAck ( is );
			break;
		case e_requestModeReject:
			choice = new RequestModeReject ( is );
			break;
		case e_roundTripDelayResponse:
			choice = new RoundTripDelayResponse ( is );
			break;
		case e_maintenanceLoopAck:
			choice = new MaintenanceLoopAck ( is );
			break;
		case e_maintenanceLoopReject:
			choice = new MaintenanceLoopReject ( is );
			break;
		case e_communicationModeResponse:
			choice = new CommunicationModeResponse ( is );
			break;
		case e_conferenceResponse:
			choice = new ConferenceResponse ( is );
			break;
		case e_multilinkResponse:
			choice = new MultilinkResponse ( is );
			break;
		case e_logicalChannelRateAcknowledge:
			choice = new LogicalChannelRateAcknowledge ( is );
			break;
		case e_logicalChannelRateReject:
			choice = new LogicalChannelRateReject ( is );
			break;
		case e_genericResponse:
			choice = new GenericMessage ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

ResponseMessage :: ResponseMessage ( ) : Asn :: Choice ( 19, true ) { }

void ResponseMessage :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandard:
			o = new NonStandardMessage;
			break;
		case e_masterSlaveDeterminationAck:
			o = new MasterSlaveDeterminationAck;
			break;
		case e_masterSlaveDeterminationReject:
			o = new MasterSlaveDeterminationReject;
			break;
		case e_terminalCapabilitySetAck:
			o = new TerminalCapabilitySetAck;
			break;
		case e_terminalCapabilitySetReject:
			o = new TerminalCapabilitySetReject;
			break;
		case e_openLogicalChannelAck:
			o = new OpenLogicalChannelAck;
			break;
		case e_openLogicalChannelReject:
			o = new OpenLogicalChannelReject;
			break;
		case e_closeLogicalChannelAck:
			o = new CloseLogicalChannelAck;
			break;
		case e_requestChannelCloseAck:
			o = new RequestChannelCloseAck;
			break;
		case e_requestChannelCloseReject:
			o = new RequestChannelCloseReject;
			break;
		case e_multiplexEntrySendAck:
			o = new MultiplexEntrySendAck;
			break;
		case e_multiplexEntrySendReject:
			o = new MultiplexEntrySendReject;
			break;
		case e_requestMultiplexEntryAck:
			o = new RequestMultiplexEntryAck;
			break;
		case e_requestMultiplexEntryReject:
			o = new RequestMultiplexEntryReject;
			break;
		case e_requestModeAck:
			o = new RequestModeAck;
			break;
		case e_requestModeReject:
			o = new RequestModeReject;
			break;
		case e_roundTripDelayResponse:
			o = new RoundTripDelayResponse;
			break;
		case e_maintenanceLoopAck:
			o = new MaintenanceLoopAck;
			break;
		case e_maintenanceLoopReject:
			o = new MaintenanceLoopReject;
			break;
		case e_communicationModeResponse:
			o = new CommunicationModeResponse;
			break;
		case e_conferenceResponse:
			o = new ConferenceResponse;
			break;
		case e_multilinkResponse:
			o = new MultilinkResponse;
			break;
		case e_logicalChannelRateAcknowledge:
			o = new LogicalChannelRateAcknowledge;
			break;
		case e_logicalChannelRateReject:
			o = new LogicalChannelRateReject;
			break;
		case e_genericResponse:
			o = new GenericMessage;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & ResponseMessage :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandard, "nonStandard" },
		{ e_masterSlaveDeterminationAck, "masterSlaveDeterminationAck" },
		{ e_masterSlaveDeterminationReject, "masterSlaveDeterminationReject" },
		{ e_terminalCapabilitySetAck, "terminalCapabilitySetAck" },
		{ e_terminalCapabilitySetReject, "terminalCapabilitySetReject" },
		{ e_openLogicalChannelAck, "openLogicalChannelAck" },
		{ e_openLogicalChannelReject, "openLogicalChannelReject" },
		{ e_closeLogicalChannelAck, "closeLogicalChannelAck" },
		{ e_requestChannelCloseAck, "requestChannelCloseAck" },
		{ e_requestChannelCloseReject, "requestChannelCloseReject" },
		{ e_multiplexEntrySendAck, "multiplexEntrySendAck" },
		{ e_multiplexEntrySendReject, "multiplexEntrySendReject" },
		{ e_requestMultiplexEntryAck, "requestMultiplexEntryAck" },
		{ e_requestMultiplexEntryReject, "requestMultiplexEntryReject" },
		{ e_requestModeAck, "requestModeAck" },
		{ e_requestModeReject, "requestModeReject" },
		{ e_roundTripDelayResponse, "roundTripDelayResponse" },
		{ e_maintenanceLoopAck, "maintenanceLoopAck" },
		{ e_maintenanceLoopReject, "maintenanceLoopReject" },
		{ e_communicationModeResponse, "communicationModeResponse" },
		{ e_conferenceResponse, "conferenceResponse" },
		{ e_multilinkResponse, "multilinkResponse" },
		{ e_logicalChannelRateAcknowledge, "logicalChannelRateAcknowledge" },
		{ e_logicalChannelRateReject, "logicalChannelRateReject" },
		{ e_genericResponse, "genericResponse" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

ResponseMessage * ResponseMessage :: clone ( ) const {
	return new ResponseMessage ( * this );
}

//
// DataType
//

DataType :: DataType ( Asn :: istream & is ) : Asn :: Choice ( is, 6, true ) {
	switch ( tag ) {
		case e_nonStandard:
		case e_h235Control:
			choice = new NonStandardParameter ( is );
			break;
		case e_nullData:
			choice = new Asn :: Null ( is );
			break;
		case e_videoData:
			choice = new VideoCapability ( is );
			break;
		case e_audioData:
			choice = new AudioCapability ( is );
			break;
		case e_data:
			choice = new DataApplicationCapability ( is );
			break;
		case e_encryptionData:
			choice = new EncryptionMode ( is );
			break;
		case e_h235Media:
			choice = new H235Media ( is );
			break;
		case e_multiplexedStream:
			choice = new MultiplexedStreamParameter ( is );
			break;
		case e_redundancyEncoding:
			choice = new RedundancyEncoding ( is );
			break;
		case e_multiplePayloadStream:
			choice = new MultiplePayloadStream ( is );
			break;
		case e_depFec:
			choice = new DepFECData ( is );
			break;
		case e_fec:
			choice = new FECData ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

DataType :: DataType ( ) : Asn :: Choice ( 6, true ) { }

DataType :: operator NonStandardParameter & ( ) {
	return dynamic_cast < NonStandardParameter & > ( * choice );
}


DataType :: operator const NonStandardParameter & ( ) const {
	return dynamic_cast < const NonStandardParameter & > ( * choice );
}


DataType :: operator Asn :: Null & ( ) {
	return dynamic_cast < Asn :: Null & > ( * choice );
}


DataType :: operator const Asn :: Null & ( ) const {
	return dynamic_cast < const Asn :: Null & > ( * choice );
}


DataType :: operator VideoCapability & ( ) {
	return dynamic_cast < VideoCapability & > ( * choice );
}


DataType :: operator const VideoCapability & ( ) const {
	return dynamic_cast < const VideoCapability & > ( * choice );
}


DataType :: operator AudioCapability & ( ) {
	return dynamic_cast < AudioCapability & > ( * choice );
}


DataType :: operator const AudioCapability & ( ) const {
	return dynamic_cast < const AudioCapability & > ( * choice );
}


DataType :: operator DataApplicationCapability & ( ) {
	return dynamic_cast < DataApplicationCapability & > ( * choice );
}


DataType :: operator const DataApplicationCapability & ( ) const {
	return dynamic_cast < const DataApplicationCapability & > ( * choice );
}


DataType :: operator EncryptionMode & ( ) {
	return dynamic_cast < EncryptionMode & > ( * choice );
}


DataType :: operator const EncryptionMode & ( ) const {
	return dynamic_cast < const EncryptionMode & > ( * choice );
}


DataType :: operator H235Media & ( ) {
	return dynamic_cast < H235Media & > ( * choice );
}


DataType :: operator const H235Media & ( ) const {
	return dynamic_cast < const H235Media & > ( * choice );
}


DataType :: operator MultiplexedStreamParameter & ( ) {
	return dynamic_cast < MultiplexedStreamParameter & > ( * choice );
}


DataType :: operator const MultiplexedStreamParameter & ( ) const {
	return dynamic_cast < const MultiplexedStreamParameter & > ( * choice );
}


DataType :: operator RedundancyEncoding & ( ) {
	return dynamic_cast < RedundancyEncoding & > ( * choice );
}


DataType :: operator const RedundancyEncoding & ( ) const {
	return dynamic_cast < const RedundancyEncoding & > ( * choice );
}


DataType :: operator MultiplePayloadStream & ( ) {
	return dynamic_cast < MultiplePayloadStream & > ( * choice );
}


DataType :: operator const MultiplePayloadStream & ( ) const {
	return dynamic_cast < const MultiplePayloadStream & > ( * choice );
}


DataType :: operator DepFECData & ( ) {
	return dynamic_cast < DepFECData & > ( * choice );
}


DataType :: operator const DepFECData & ( ) const {
	return dynamic_cast < const DepFECData & > ( * choice );
}


DataType :: operator FECData & ( ) {
	return dynamic_cast < FECData & > ( * choice );
}


DataType :: operator const FECData & ( ) const {
	return dynamic_cast < const FECData & > ( * choice );
}


void DataType :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandard:
		case e_h235Control:
			o = new NonStandardParameter;
			break;
		case e_nullData:
			o = new Asn :: Null;
			break;
		case e_videoData:
			o = new VideoCapability;
			break;
		case e_audioData:
			o = new AudioCapability;
			break;
		case e_data:
			o = new DataApplicationCapability;
			break;
		case e_encryptionData:
			o = new EncryptionMode;
			break;
		case e_h235Media:
			o = new H235Media;
			break;
		case e_multiplexedStream:
			o = new MultiplexedStreamParameter;
			break;
		case e_redundancyEncoding:
			o = new RedundancyEncoding;
			break;
		case e_multiplePayloadStream:
			o = new MultiplePayloadStream;
			break;
		case e_depFec:
			o = new DepFECData;
			break;
		case e_fec:
			o = new FECData;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & DataType :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandard, "nonStandard" },
		{ e_nullData, "nullData" },
		{ e_videoData, "videoData" },
		{ e_audioData, "audioData" },
		{ e_data, "data" },
		{ e_encryptionData, "encryptionData" },
		{ e_h235Control, "h235Control" },
		{ e_h235Media, "h235Media" },
		{ e_multiplexedStream, "multiplexedStream" },
		{ e_redundancyEncoding, "redundancyEncoding" },
		{ e_multiplePayloadStream, "multiplePayloadStream" },
		{ e_depFec, "depFec" },
		{ e_fec, "fec" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

DataType * DataType :: clone ( ) const {
	return new DataType ( * this );
}

//
// RedundancyEncodingElement
//

RedundancyEncodingElement :: RedundancyEncodingElement ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_dataType ( is ), m_payloadType ( 0 ) {
	try {
		if ( hasOptionalField ( e_payloadType ) )
			m_payloadType = new RedundancyEncodingElement_payloadType ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_payloadType;
		throw;
	}
}

RedundancyEncodingElement :: RedundancyEncodingElement ( ) : Asn :: Sequence ( 1, true, 0 ), m_payloadType ( 0 ) { }

RedundancyEncodingElement & RedundancyEncodingElement :: operator= ( const RedundancyEncodingElement & s ) {
	Asn :: Sequence :: operator= ( s );
	m_dataType = s.m_dataType;
	assignCopy ( m_payloadType, s.m_payloadType );
	return * this;
}

RedundancyEncodingElement :: RedundancyEncodingElement ( const RedundancyEncodingElement & s ) : Asn :: Sequence ( s ), m_dataType ( s.m_dataType ), m_payloadType ( 0 ) {
	try {
		if ( s.m_payloadType )
			m_payloadType = new RedundancyEncodingElement_payloadType ( * s.m_payloadType );
	} catch ( ... ) {
		delete m_payloadType;
		throw;
	}
}


void RedundancyEncodingElement :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_payloadType:
			assignNew ( m_payloadType, new RedundancyEncodingElement_payloadType );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void RedundancyEncodingElement :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_payloadType:
			delete m_payloadType;
			m_payloadType = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void RedundancyEncodingElement :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_dataType.encode ( os );
	if ( hasOptionalField ( e_payloadType ) )
		m_payloadType -> RedundancyEncodingElement_payloadType :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

RedundancyEncodingElement :: ~RedundancyEncodingElement ( ) {
	delete m_payloadType;
}

void RedundancyEncodingElement :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 11 ) << "dataType = " << std :: setprecision ( indent ) << m_dataType << '\n';
	if ( hasOptionalField ( e_payloadType ) ) {
		os << std :: setw ( indent + 14 ) << "payloadType = " << std :: setprecision ( indent );
		m_payloadType -> RedundancyEncodingElement_payloadType :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RedundancyEncodingElement * RedundancyEncodingElement :: clone ( ) const {
	return new RedundancyEncodingElement ( * this );
}

//
// MultiplePayloadStreamElement
//

MultiplePayloadStreamElement :: MultiplePayloadStreamElement ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 0 ), m_dataType ( is ), m_payloadType ( 0 ) {
	try {
		if ( hasOptionalField ( e_payloadType ) )
			m_payloadType = new MultiplePayloadStreamElement_payloadType ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_payloadType;
		throw;
	}
}

MultiplePayloadStreamElement :: MultiplePayloadStreamElement ( ) : Asn :: Sequence ( 1, true, 0 ), m_payloadType ( 0 ) { }

MultiplePayloadStreamElement & MultiplePayloadStreamElement :: operator= ( const MultiplePayloadStreamElement & s ) {
	Asn :: Sequence :: operator= ( s );
	m_dataType = s.m_dataType;
	assignCopy ( m_payloadType, s.m_payloadType );
	return * this;
}

MultiplePayloadStreamElement :: MultiplePayloadStreamElement ( const MultiplePayloadStreamElement & s ) : Asn :: Sequence ( s ), m_dataType ( s.m_dataType ), m_payloadType ( 0 ) {
	try {
		if ( s.m_payloadType )
			m_payloadType = new MultiplePayloadStreamElement_payloadType ( * s.m_payloadType );
	} catch ( ... ) {
		delete m_payloadType;
		throw;
	}
}


void MultiplePayloadStreamElement :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_payloadType:
			assignNew ( m_payloadType, new MultiplePayloadStreamElement_payloadType );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void MultiplePayloadStreamElement :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_payloadType:
			delete m_payloadType;
			m_payloadType = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void MultiplePayloadStreamElement :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_dataType.encode ( os );
	if ( hasOptionalField ( e_payloadType ) )
		m_payloadType -> MultiplePayloadStreamElement_payloadType :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

MultiplePayloadStreamElement :: ~MultiplePayloadStreamElement ( ) {
	delete m_payloadType;
}

void MultiplePayloadStreamElement :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 11 ) << "dataType = " << std :: setprecision ( indent ) << m_dataType << '\n';
	if ( hasOptionalField ( e_payloadType ) ) {
		os << std :: setw ( indent + 14 ) << "payloadType = " << std :: setprecision ( indent );
		m_payloadType -> MultiplePayloadStreamElement_payloadType :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MultiplePayloadStreamElement * MultiplePayloadStreamElement :: clone ( ) const {
	return new MultiplePayloadStreamElement ( * this );
}

//
// ModeElementType
//

ModeElementType :: ModeElementType ( Asn :: istream & is ) : Asn :: Choice ( is, 5, true ) {
	switch ( tag ) {
		case e_nonStandard:
			choice = new NonStandardParameter ( is );
			break;
		case e_videoMode:
			choice = new VideoMode ( is );
			break;
		case e_audioMode:
			choice = new AudioMode ( is );
			break;
		case e_dataMode:
			choice = new DataMode ( is );
			break;
		case e_encryptionMode:
			choice = new EncryptionMode ( is );
			break;
		case e_h235Mode:
			choice = new H235Mode ( is );
			break;
		case e_multiplexedStreamMode:
			choice = new MultiplexedStreamParameter ( is );
			break;
		case e_redundancyEncodingDTMode:
			choice = new RedundancyEncodingDTMode ( is );
			break;
		case e_multiplePayloadStreamMode:
			choice = new MultiplePayloadStreamMode ( is );
			break;
		case e_depFecMode:
			choice = new DepFECMode ( is );
			break;
		case e_fecMode:
			choice = new FECMode ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

ModeElementType :: ModeElementType ( ) : Asn :: Choice ( 5, true ) { }

ModeElementType :: operator NonStandardParameter & ( ) {
	return dynamic_cast < NonStandardParameter & > ( * choice );
}


ModeElementType :: operator const NonStandardParameter & ( ) const {
	return dynamic_cast < const NonStandardParameter & > ( * choice );
}


ModeElementType :: operator VideoMode & ( ) {
	return dynamic_cast < VideoMode & > ( * choice );
}


ModeElementType :: operator const VideoMode & ( ) const {
	return dynamic_cast < const VideoMode & > ( * choice );
}


ModeElementType :: operator AudioMode & ( ) {
	return dynamic_cast < AudioMode & > ( * choice );
}


ModeElementType :: operator const AudioMode & ( ) const {
	return dynamic_cast < const AudioMode & > ( * choice );
}


ModeElementType :: operator DataMode & ( ) {
	return dynamic_cast < DataMode & > ( * choice );
}


ModeElementType :: operator const DataMode & ( ) const {
	return dynamic_cast < const DataMode & > ( * choice );
}


ModeElementType :: operator EncryptionMode & ( ) {
	return dynamic_cast < EncryptionMode & > ( * choice );
}


ModeElementType :: operator const EncryptionMode & ( ) const {
	return dynamic_cast < const EncryptionMode & > ( * choice );
}


ModeElementType :: operator H235Mode & ( ) {
	return dynamic_cast < H235Mode & > ( * choice );
}


ModeElementType :: operator const H235Mode & ( ) const {
	return dynamic_cast < const H235Mode & > ( * choice );
}


ModeElementType :: operator MultiplexedStreamParameter & ( ) {
	return dynamic_cast < MultiplexedStreamParameter & > ( * choice );
}


ModeElementType :: operator const MultiplexedStreamParameter & ( ) const {
	return dynamic_cast < const MultiplexedStreamParameter & > ( * choice );
}


ModeElementType :: operator RedundancyEncodingDTMode & ( ) {
	return dynamic_cast < RedundancyEncodingDTMode & > ( * choice );
}


ModeElementType :: operator const RedundancyEncodingDTMode & ( ) const {
	return dynamic_cast < const RedundancyEncodingDTMode & > ( * choice );
}


ModeElementType :: operator MultiplePayloadStreamMode & ( ) {
	return dynamic_cast < MultiplePayloadStreamMode & > ( * choice );
}


ModeElementType :: operator const MultiplePayloadStreamMode & ( ) const {
	return dynamic_cast < const MultiplePayloadStreamMode & > ( * choice );
}


ModeElementType :: operator DepFECMode & ( ) {
	return dynamic_cast < DepFECMode & > ( * choice );
}


ModeElementType :: operator const DepFECMode & ( ) const {
	return dynamic_cast < const DepFECMode & > ( * choice );
}


ModeElementType :: operator FECMode & ( ) {
	return dynamic_cast < FECMode & > ( * choice );
}


ModeElementType :: operator const FECMode & ( ) const {
	return dynamic_cast < const FECMode & > ( * choice );
}


void ModeElementType :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandard:
			o = new NonStandardParameter;
			break;
		case e_videoMode:
			o = new VideoMode;
			break;
		case e_audioMode:
			o = new AudioMode;
			break;
		case e_dataMode:
			o = new DataMode;
			break;
		case e_encryptionMode:
			o = new EncryptionMode;
			break;
		case e_h235Mode:
			o = new H235Mode;
			break;
		case e_multiplexedStreamMode:
			o = new MultiplexedStreamParameter;
			break;
		case e_redundancyEncodingDTMode:
			o = new RedundancyEncodingDTMode;
			break;
		case e_multiplePayloadStreamMode:
			o = new MultiplePayloadStreamMode;
			break;
		case e_depFecMode:
			o = new DepFECMode;
			break;
		case e_fecMode:
			o = new FECMode;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & ModeElementType :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandard, "nonStandard" },
		{ e_videoMode, "videoMode" },
		{ e_audioMode, "audioMode" },
		{ e_dataMode, "dataMode" },
		{ e_encryptionMode, "encryptionMode" },
		{ e_h235Mode, "h235Mode" },
		{ e_multiplexedStreamMode, "multiplexedStreamMode" },
		{ e_redundancyEncodingDTMode, "redundancyEncodingDTMode" },
		{ e_multiplePayloadStreamMode, "multiplePayloadStreamMode" },
		{ e_depFecMode, "depFecMode" },
		{ e_fecMode, "fecMode" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

ModeElementType * ModeElementType :: clone ( ) const {
	return new ModeElementType ( * this );
}

//
// ModeElement
//

ModeElement :: ModeElement ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 5 ), m_type ( is ), m_h223ModeParameters ( 0 ), m_v76ModeParameters ( 0 ), m_h2250ModeParameters ( 0 ), m_genericModeParameters ( 0 ), m_multiplexedStreamModeParameters ( 0 ), m_logicalChannelNumber ( 0 ) {
	try {
		if ( hasOptionalField ( e_h223ModeParameters ) )
			m_h223ModeParameters = new H223ModeParameters ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_v76ModeParameters ) )
				m_v76ModeParameters = new V76ModeParameters ( is );
			if ( hasKnownExtensionToDecode ( is, e_h2250ModeParameters ) )
				m_h2250ModeParameters = new H2250ModeParameters ( is );
			if ( hasKnownExtensionToDecode ( is, e_genericModeParameters ) )
				m_genericModeParameters = new GenericCapability ( is );
			if ( hasKnownExtensionToDecode ( is, e_multiplexedStreamModeParameters ) )
				m_multiplexedStreamModeParameters = new MultiplexedStreamModeParameters ( is );
			if ( hasKnownExtensionToDecode ( is, e_logicalChannelNumber ) )
				m_logicalChannelNumber = new LogicalChannelNumber ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_h223ModeParameters;
		delete m_v76ModeParameters;
		delete m_h2250ModeParameters;
		delete m_genericModeParameters;
		delete m_multiplexedStreamModeParameters;
		delete m_logicalChannelNumber;
		throw;
	}
}

ModeElement :: ModeElement ( ) : Asn :: Sequence ( 1, true, 5 ), m_h223ModeParameters ( 0 ), m_v76ModeParameters ( 0 ), m_h2250ModeParameters ( 0 ), m_genericModeParameters ( 0 ), m_multiplexedStreamModeParameters ( 0 ), m_logicalChannelNumber ( 0 ) { }

ModeElement & ModeElement :: operator= ( const ModeElement & s ) {
	Asn :: Sequence :: operator= ( s );
	m_type = s.m_type;
	assignCopy ( m_h223ModeParameters, s.m_h223ModeParameters );
	assignCopy ( m_v76ModeParameters, s.m_v76ModeParameters );
	assignCopy ( m_h2250ModeParameters, s.m_h2250ModeParameters );
	assignCopy ( m_genericModeParameters, s.m_genericModeParameters );
	assignCopy ( m_multiplexedStreamModeParameters, s.m_multiplexedStreamModeParameters );
	assignCopy ( m_logicalChannelNumber, s.m_logicalChannelNumber );
	return * this;
}

ModeElement :: ModeElement ( const ModeElement & s ) : Asn :: Sequence ( s ), m_type ( s.m_type ), m_h223ModeParameters ( 0 ), m_v76ModeParameters ( 0 ), m_h2250ModeParameters ( 0 ), m_genericModeParameters ( 0 ), m_multiplexedStreamModeParameters ( 0 ), m_logicalChannelNumber ( 0 ) {
	try {
		if ( s.m_h223ModeParameters )
			m_h223ModeParameters = new H223ModeParameters ( * s.m_h223ModeParameters );
		if ( s.m_v76ModeParameters )
			m_v76ModeParameters = new V76ModeParameters ( * s.m_v76ModeParameters );
		if ( s.m_h2250ModeParameters )
			m_h2250ModeParameters = new H2250ModeParameters ( * s.m_h2250ModeParameters );
		if ( s.m_genericModeParameters )
			m_genericModeParameters = new GenericCapability ( * s.m_genericModeParameters );
		if ( s.m_multiplexedStreamModeParameters )
			m_multiplexedStreamModeParameters = new MultiplexedStreamModeParameters ( * s.m_multiplexedStreamModeParameters );
		if ( s.m_logicalChannelNumber )
			m_logicalChannelNumber = new LogicalChannelNumber ( * s.m_logicalChannelNumber );
	} catch ( ... ) {
		delete m_h223ModeParameters;
		delete m_v76ModeParameters;
		delete m_h2250ModeParameters;
		delete m_genericModeParameters;
		delete m_multiplexedStreamModeParameters;
		delete m_logicalChannelNumber;
		throw;
	}
}


void ModeElement :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_h223ModeParameters:
			assignNew ( m_h223ModeParameters, new H223ModeParameters );
			break;
		case e_v76ModeParameters:
			assignNew ( m_v76ModeParameters, new V76ModeParameters );
			break;
		case e_h2250ModeParameters:
			assignNew ( m_h2250ModeParameters, new H2250ModeParameters );
			break;
		case e_genericModeParameters:
			assignNew ( m_genericModeParameters, new GenericCapability );
			break;
		case e_multiplexedStreamModeParameters:
			assignNew ( m_multiplexedStreamModeParameters, new MultiplexedStreamModeParameters );
			break;
		case e_logicalChannelNumber:
			assignNew ( m_logicalChannelNumber, new LogicalChannelNumber );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void ModeElement :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_h223ModeParameters:
			delete m_h223ModeParameters;
			m_h223ModeParameters = 0;
			break;
		case e_v76ModeParameters:
			delete m_v76ModeParameters;
			m_v76ModeParameters = 0;
			break;
		case e_h2250ModeParameters:
			delete m_h2250ModeParameters;
			m_h2250ModeParameters = 0;
			break;
		case e_genericModeParameters:
			delete m_genericModeParameters;
			m_genericModeParameters = 0;
			break;
		case e_multiplexedStreamModeParameters:
			delete m_multiplexedStreamModeParameters;
			m_multiplexedStreamModeParameters = 0;
			break;
		case e_logicalChannelNumber:
			delete m_logicalChannelNumber;
			m_logicalChannelNumber = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void ModeElement :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_type.encode ( os );
	if ( hasOptionalField ( e_h223ModeParameters ) )
		m_h223ModeParameters -> H223ModeParameters :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_v76ModeParameters, m_v76ModeParameters );
		knownExtensionEncode ( os, e_h2250ModeParameters, m_h2250ModeParameters );
		knownExtensionEncode ( os, e_genericModeParameters, m_genericModeParameters );
		knownExtensionEncode ( os, e_multiplexedStreamModeParameters, m_multiplexedStreamModeParameters );
		knownExtensionEncode ( os, e_logicalChannelNumber, m_logicalChannelNumber );
		unknownExtensionsEncode ( os );
	}
}

ModeElement :: ~ModeElement ( ) {
	delete m_h223ModeParameters;
	delete m_v76ModeParameters;
	delete m_h2250ModeParameters;
	delete m_genericModeParameters;
	delete m_multiplexedStreamModeParameters;
	delete m_logicalChannelNumber;
}

void ModeElement :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 7 ) << "type = " << std :: setprecision ( indent ) << m_type << '\n';
	if ( hasOptionalField ( e_h223ModeParameters ) ) {
		os << std :: setw ( indent + 21 ) << "h223ModeParameters = " << std :: setprecision ( indent );
		m_h223ModeParameters -> H223ModeParameters :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_v76ModeParameters ) ) {
		os << std :: setw ( indent + 20 ) << "v76ModeParameters = " << std :: setprecision ( indent );
		m_v76ModeParameters -> V76ModeParameters :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_h2250ModeParameters ) ) {
		os << std :: setw ( indent + 22 ) << "h2250ModeParameters = " << std :: setprecision ( indent );
		m_h2250ModeParameters -> H2250ModeParameters :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_genericModeParameters ) ) {
		os << std :: setw ( indent + 24 ) << "genericModeParameters = " << std :: setprecision ( indent );
		m_genericModeParameters -> GenericCapability :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_multiplexedStreamModeParameters ) ) {
		os << std :: setw ( indent + 34 ) << "multiplexedStreamModeParameters = " << std :: setprecision ( indent );
		m_multiplexedStreamModeParameters -> MultiplexedStreamModeParameters :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_logicalChannelNumber ) ) {
		os << std :: setw ( indent + 23 ) << "logicalChannelNumber = " << std :: setprecision ( indent );
		m_logicalChannelNumber -> LogicalChannelNumber :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

ModeElement * ModeElement :: clone ( ) const {
	return new ModeElement ( * this );
}

//
// MultiplePayloadStreamElementMode
//

MultiplePayloadStreamElementMode :: MultiplePayloadStreamElementMode ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_type ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

MultiplePayloadStreamElementMode :: MultiplePayloadStreamElementMode ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void MultiplePayloadStreamElementMode :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_type.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void MultiplePayloadStreamElementMode :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 7 ) << "type = " << std :: setprecision ( indent ) << m_type << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

MultiplePayloadStreamElementMode * MultiplePayloadStreamElementMode :: clone ( ) const {
	return new MultiplePayloadStreamElementMode ( * this );
}

//
// DepFECMode
//

DepFECMode :: DepFECMode ( Asn :: istream & is ) : Asn :: Choice ( is, 1, true ) {
	switch ( tag ) {
		case e_rfc2733Mode:
			choice = new DepFECMode_rfc2733Mode ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

DepFECMode :: DepFECMode ( ) : Asn :: Choice ( 1, true ) { }

DepFECMode :: operator DepFECMode_rfc2733Mode & ( ) {
	return dynamic_cast < DepFECMode_rfc2733Mode & > ( * choice );
}


DepFECMode :: operator const DepFECMode_rfc2733Mode & ( ) const {
	return dynamic_cast < const DepFECMode_rfc2733Mode & > ( * choice );
}


void DepFECMode :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_rfc2733Mode:
			o = new DepFECMode_rfc2733Mode;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & DepFECMode :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_rfc2733Mode, "rfc2733Mode" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

DepFECMode * DepFECMode :: clone ( ) const {
	return new DepFECMode ( * this );
}

//
// FECMode
//

FECMode :: FECMode ( Asn :: istream & is ) : Asn :: Sequence ( is, 2, true, 0 ), m_protectedElement ( is ), m_fecScheme ( 0 ), m_rfc2733Format ( 0 ) {
	try {
		if ( hasOptionalField ( e_fecScheme ) )
			m_fecScheme = new Asn :: ObjectId ( is );
		if ( hasOptionalField ( e_rfc2733Format ) )
			m_rfc2733Format = new FECMode_rfc2733Format ( is );
		if ( extensionMapDecode ( is ) )
			unknownExtensionsDecode ( is );
	} catch ( ... ) {
		delete m_fecScheme;
		delete m_rfc2733Format;
		throw;
	}
}

FECMode :: FECMode ( ) : Asn :: Sequence ( 2, true, 0 ), m_fecScheme ( 0 ), m_rfc2733Format ( 0 ) { }

FECMode & FECMode :: operator= ( const FECMode & s ) {
	Asn :: Sequence :: operator= ( s );
	m_protectedElement = s.m_protectedElement;
	assignCopy ( m_fecScheme, s.m_fecScheme );
	assignCopy ( m_rfc2733Format, s.m_rfc2733Format );
	return * this;
}

FECMode :: FECMode ( const FECMode & s ) : Asn :: Sequence ( s ), m_protectedElement ( s.m_protectedElement ), m_fecScheme ( 0 ), m_rfc2733Format ( 0 ) {
	try {
		if ( s.m_fecScheme )
			m_fecScheme = new Asn :: ObjectId ( * s.m_fecScheme );
		if ( s.m_rfc2733Format )
			m_rfc2733Format = new FECMode_rfc2733Format ( * s.m_rfc2733Format );
	} catch ( ... ) {
		delete m_fecScheme;
		delete m_rfc2733Format;
		throw;
	}
}


void FECMode :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_fecScheme:
			assignNew ( m_fecScheme, new Asn :: ObjectId );
			break;
		case e_rfc2733Format:
			assignNew ( m_rfc2733Format, new FECMode_rfc2733Format );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void FECMode :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_fecScheme:
			delete m_fecScheme;
			m_fecScheme = 0;
			break;
		case e_rfc2733Format:
			delete m_rfc2733Format;
			m_rfc2733Format = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void FECMode :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_protectedElement.encode ( os );
	if ( hasOptionalField ( e_fecScheme ) )
		m_fecScheme -> Asn :: ObjectId :: encode ( os );
	if ( hasOptionalField ( e_rfc2733Format ) )
		m_rfc2733Format -> FECMode_rfc2733Format :: encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

FECMode :: ~FECMode ( ) {
	delete m_fecScheme;
	delete m_rfc2733Format;
}

void FECMode :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 19 ) << "protectedElement = " << std :: setprecision ( indent ) << m_protectedElement << '\n';
	if ( hasOptionalField ( e_fecScheme ) ) {
		os << std :: setw ( indent + 12 ) << "fecScheme = " << std :: setprecision ( indent );
		m_fecScheme -> Asn :: ObjectId :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_rfc2733Format ) ) {
		os << std :: setw ( indent + 16 ) << "rfc2733Format = " << std :: setprecision ( indent );
		m_rfc2733Format -> FECMode_rfc2733Format :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

FECMode * FECMode :: clone ( ) const {
	return new FECMode ( * this );
}

//
// AudioMode
//

AudioMode :: AudioMode ( Asn :: istream & is ) : Asn :: Choice ( is, 14, true ) {
	switch ( tag ) {
		case e_nonStandard:
			choice = new NonStandardParameter ( is );
			break;
		case e_g711Alaw64k:
		case e_g711Alaw56k:
		case e_g711Ulaw64k:
		case e_g711Ulaw56k:
		case e_g722_64k:
		case e_g722_56k:
		case e_g722_48k:
		case e_g728:
		case e_g729:
		case e_g729AnnexA:
			choice = new Asn :: Null ( is );
			break;
		case e_g7231:
			choice = new AudioMode_g7231 ( is );
			break;
		case e_is11172AudioMode:
			choice = new IS11172AudioMode ( is );
			break;
		case e_is13818AudioMode:
			choice = new IS13818AudioMode ( is );
			break;
		case e_g729wAnnexB:
			choice = new AudioMode_g729wAnnexB ( is );
			break;
		case e_g729AnnexAwAnnexB:
			choice = new AudioMode_g729AnnexAwAnnexB ( is );
			break;
		case e_g7231AnnexCMode:
			choice = new G7231AnnexCMode ( is );
			break;
		case e_gsmFullRate:
		case e_gsmHalfRate:
		case e_gsmEnhancedFullRate:
			choice = new GSMAudioCapability ( is );
			break;
		case e_genericAudioMode:
			choice = new GenericCapability ( is );
			break;
		case e_g729Extensions:
			choice = new G729Extensions ( is );
			break;
		case e_vbd:
			choice = new VBDMode ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

AudioMode :: AudioMode ( ) : Asn :: Choice ( 14, true ) { }

AudioMode :: operator NonStandardParameter & ( ) {
	return dynamic_cast < NonStandardParameter & > ( * choice );
}


AudioMode :: operator const NonStandardParameter & ( ) const {
	return dynamic_cast < const NonStandardParameter & > ( * choice );
}


AudioMode :: operator Asn :: Null & ( ) {
	return dynamic_cast < Asn :: Null & > ( * choice );
}


AudioMode :: operator const Asn :: Null & ( ) const {
	return dynamic_cast < const Asn :: Null & > ( * choice );
}


AudioMode :: operator AudioMode_g7231 & ( ) {
	return dynamic_cast < AudioMode_g7231 & > ( * choice );
}


AudioMode :: operator const AudioMode_g7231 & ( ) const {
	return dynamic_cast < const AudioMode_g7231 & > ( * choice );
}


AudioMode :: operator IS11172AudioMode & ( ) {
	return dynamic_cast < IS11172AudioMode & > ( * choice );
}


AudioMode :: operator const IS11172AudioMode & ( ) const {
	return dynamic_cast < const IS11172AudioMode & > ( * choice );
}


AudioMode :: operator IS13818AudioMode & ( ) {
	return dynamic_cast < IS13818AudioMode & > ( * choice );
}


AudioMode :: operator const IS13818AudioMode & ( ) const {
	return dynamic_cast < const IS13818AudioMode & > ( * choice );
}


AudioMode :: operator AudioMode_g729wAnnexB & ( ) {
	return dynamic_cast < AudioMode_g729wAnnexB & > ( * choice );
}


AudioMode :: operator const AudioMode_g729wAnnexB & ( ) const {
	return dynamic_cast < const AudioMode_g729wAnnexB & > ( * choice );
}


AudioMode :: operator AudioMode_g729AnnexAwAnnexB & ( ) {
	return dynamic_cast < AudioMode_g729AnnexAwAnnexB & > ( * choice );
}


AudioMode :: operator const AudioMode_g729AnnexAwAnnexB & ( ) const {
	return dynamic_cast < const AudioMode_g729AnnexAwAnnexB & > ( * choice );
}


AudioMode :: operator G7231AnnexCMode & ( ) {
	return dynamic_cast < G7231AnnexCMode & > ( * choice );
}


AudioMode :: operator const G7231AnnexCMode & ( ) const {
	return dynamic_cast < const G7231AnnexCMode & > ( * choice );
}


AudioMode :: operator GSMAudioCapability & ( ) {
	return dynamic_cast < GSMAudioCapability & > ( * choice );
}


AudioMode :: operator const GSMAudioCapability & ( ) const {
	return dynamic_cast < const GSMAudioCapability & > ( * choice );
}


AudioMode :: operator GenericCapability & ( ) {
	return dynamic_cast < GenericCapability & > ( * choice );
}


AudioMode :: operator const GenericCapability & ( ) const {
	return dynamic_cast < const GenericCapability & > ( * choice );
}


AudioMode :: operator G729Extensions & ( ) {
	return dynamic_cast < G729Extensions & > ( * choice );
}


AudioMode :: operator const G729Extensions & ( ) const {
	return dynamic_cast < const G729Extensions & > ( * choice );
}


AudioMode :: operator VBDMode & ( ) {
	return dynamic_cast < VBDMode & > ( * choice );
}


AudioMode :: operator const VBDMode & ( ) const {
	return dynamic_cast < const VBDMode & > ( * choice );
}


void AudioMode :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandard:
			o = new NonStandardParameter;
			break;
		case e_g711Alaw64k:
		case e_g711Alaw56k:
		case e_g711Ulaw64k:
		case e_g711Ulaw56k:
		case e_g722_64k:
		case e_g722_56k:
		case e_g722_48k:
		case e_g728:
		case e_g729:
		case e_g729AnnexA:
			o = new Asn :: Null;
			break;
		case e_g7231:
			o = new AudioMode_g7231;
			break;
		case e_is11172AudioMode:
			o = new IS11172AudioMode;
			break;
		case e_is13818AudioMode:
			o = new IS13818AudioMode;
			break;
		case e_g729wAnnexB:
			o = new AudioMode_g729wAnnexB;
			break;
		case e_g729AnnexAwAnnexB:
			o = new AudioMode_g729AnnexAwAnnexB;
			break;
		case e_g7231AnnexCMode:
			o = new G7231AnnexCMode;
			break;
		case e_gsmFullRate:
		case e_gsmHalfRate:
		case e_gsmEnhancedFullRate:
			o = new GSMAudioCapability;
			break;
		case e_genericAudioMode:
			o = new GenericCapability;
			break;
		case e_g729Extensions:
			o = new G729Extensions;
			break;
		case e_vbd:
			o = new VBDMode;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & AudioMode :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandard, "nonStandard" },
		{ e_g711Alaw64k, "g711Alaw64k" },
		{ e_g711Alaw56k, "g711Alaw56k" },
		{ e_g711Ulaw64k, "g711Ulaw64k" },
		{ e_g711Ulaw56k, "g711Ulaw56k" },
		{ e_g722_64k, "g722_64k" },
		{ e_g722_56k, "g722_56k" },
		{ e_g722_48k, "g722_48k" },
		{ e_g728, "g728" },
		{ e_g729, "g729" },
		{ e_g729AnnexA, "g729AnnexA" },
		{ e_g7231, "g7231" },
		{ e_is11172AudioMode, "is11172AudioMode" },
		{ e_is13818AudioMode, "is13818AudioMode" },
		{ e_g729wAnnexB, "g729wAnnexB" },
		{ e_g729AnnexAwAnnexB, "g729AnnexAwAnnexB" },
		{ e_g7231AnnexCMode, "g7231AnnexCMode" },
		{ e_gsmFullRate, "gsmFullRate" },
		{ e_gsmHalfRate, "gsmHalfRate" },
		{ e_gsmEnhancedFullRate, "gsmEnhancedFullRate" },
		{ e_genericAudioMode, "genericAudioMode" },
		{ e_g729Extensions, "g729Extensions" },
		{ e_vbd, "vbd" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

AudioMode * AudioMode :: clone ( ) const {
	return new AudioMode ( * this );
}

//
// VBDMode
//

VBDMode :: VBDMode ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_type ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

VBDMode :: VBDMode ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void VBDMode :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_type.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void VBDMode :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 7 ) << "type = " << std :: setprecision ( indent ) << m_type << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

VBDMode * VBDMode :: clone ( ) const {
	return new VBDMode ( * this );
}

//
// FunctionNotUnderstood
//

FunctionNotUnderstood :: FunctionNotUnderstood ( Asn :: istream & is ) : Asn :: Choice ( is, 3, false ) {
	switch ( tag ) {
		case e_request:
			choice = new RequestMessage ( is );
			break;
		case e_response:
			choice = new ResponseMessage ( is );
			break;
		case e_command:
			choice = new CommandMessage ( is );
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
}

FunctionNotUnderstood :: FunctionNotUnderstood ( ) : Asn :: Choice ( 3, false ) { }

FunctionNotUnderstood :: operator RequestMessage & ( ) {
	return dynamic_cast < RequestMessage & > ( * choice );
}


FunctionNotUnderstood :: operator const RequestMessage & ( ) const {
	return dynamic_cast < const RequestMessage & > ( * choice );
}


FunctionNotUnderstood :: operator ResponseMessage & ( ) {
	return dynamic_cast < ResponseMessage & > ( * choice );
}


FunctionNotUnderstood :: operator const ResponseMessage & ( ) const {
	return dynamic_cast < const ResponseMessage & > ( * choice );
}


FunctionNotUnderstood :: operator CommandMessage & ( ) {
	return dynamic_cast < CommandMessage & > ( * choice );
}


FunctionNotUnderstood :: operator const CommandMessage & ( ) const {
	return dynamic_cast < const CommandMessage & > ( * choice );
}


void FunctionNotUnderstood :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_request:
			o = new RequestMessage;
			break;
		case e_response:
			o = new ResponseMessage;
			break;
		case e_command:
			o = new CommandMessage;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & FunctionNotUnderstood :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_request, "request" },
		{ e_response, "response" },
		{ e_command, "command" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

FunctionNotUnderstood * FunctionNotUnderstood :: clone ( ) const {
	return new FunctionNotUnderstood ( * this );
}

//
// OpenLogicalChannel_forwardLogicalChannelParameters
//

OpenLogicalChannel_forwardLogicalChannelParameters :: OpenLogicalChannel_forwardLogicalChannelParameters ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 2 ), m_portNumber ( hasOptionalField ( e_portNumber ) ? pushTemporaryMember ( new OpenLogicalChannel_forwardLogicalChannelParameters_portNumber ( is ) ) : 0 ), m_dataType ( is ), m_multiplexParameters ( is ), m_forwardLogicalChannelDependency ( 0 ), m_replacementFor ( 0 ) {
	clearTemporaryMembers ( );
	try {
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_forwardLogicalChannelDependency ) )
				m_forwardLogicalChannelDependency = new LogicalChannelNumber ( is );
			if ( hasKnownExtensionToDecode ( is, e_replacementFor ) )
				m_replacementFor = new LogicalChannelNumber ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_portNumber;
		delete m_forwardLogicalChannelDependency;
		delete m_replacementFor;
		throw;
	}
}

OpenLogicalChannel_forwardLogicalChannelParameters :: OpenLogicalChannel_forwardLogicalChannelParameters ( ) : Asn :: Sequence ( 1, true, 2 ), m_portNumber ( 0 ), m_forwardLogicalChannelDependency ( 0 ), m_replacementFor ( 0 ) { }

OpenLogicalChannel_forwardLogicalChannelParameters & OpenLogicalChannel_forwardLogicalChannelParameters :: operator= ( const OpenLogicalChannel_forwardLogicalChannelParameters & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_portNumber, s.m_portNumber );
	m_dataType = s.m_dataType;
	m_multiplexParameters = s.m_multiplexParameters;
	assignCopy ( m_forwardLogicalChannelDependency, s.m_forwardLogicalChannelDependency );
	assignCopy ( m_replacementFor, s.m_replacementFor );
	return * this;
}

OpenLogicalChannel_forwardLogicalChannelParameters :: OpenLogicalChannel_forwardLogicalChannelParameters ( const OpenLogicalChannel_forwardLogicalChannelParameters & s ) : Asn :: Sequence ( s ), m_portNumber ( 0 ), m_dataType ( s.m_dataType ), m_multiplexParameters ( s.m_multiplexParameters ), m_forwardLogicalChannelDependency ( 0 ), m_replacementFor ( 0 ) {
	try {
		if ( s.m_portNumber )
			m_portNumber = new OpenLogicalChannel_forwardLogicalChannelParameters_portNumber ( * s.m_portNumber );
		if ( s.m_forwardLogicalChannelDependency )
			m_forwardLogicalChannelDependency = new LogicalChannelNumber ( * s.m_forwardLogicalChannelDependency );
		if ( s.m_replacementFor )
			m_replacementFor = new LogicalChannelNumber ( * s.m_replacementFor );
	} catch ( ... ) {
		delete m_portNumber;
		delete m_forwardLogicalChannelDependency;
		delete m_replacementFor;
		throw;
	}
}


void OpenLogicalChannel_forwardLogicalChannelParameters :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_portNumber:
			assignNew ( m_portNumber, new OpenLogicalChannel_forwardLogicalChannelParameters_portNumber );
			break;
		case e_forwardLogicalChannelDependency:
			assignNew ( m_forwardLogicalChannelDependency, new LogicalChannelNumber );
			break;
		case e_replacementFor:
			assignNew ( m_replacementFor, new LogicalChannelNumber );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void OpenLogicalChannel_forwardLogicalChannelParameters :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_portNumber:
			delete m_portNumber;
			m_portNumber = 0;
			break;
		case e_forwardLogicalChannelDependency:
			delete m_forwardLogicalChannelDependency;
			m_forwardLogicalChannelDependency = 0;
			break;
		case e_replacementFor:
			delete m_replacementFor;
			m_replacementFor = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void OpenLogicalChannel_forwardLogicalChannelParameters :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_portNumber ) )
		m_portNumber -> OpenLogicalChannel_forwardLogicalChannelParameters_portNumber :: encode ( os );
	m_dataType.encode ( os );
	m_multiplexParameters.encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_forwardLogicalChannelDependency, m_forwardLogicalChannelDependency );
		knownExtensionEncode ( os, e_replacementFor, m_replacementFor );
		unknownExtensionsEncode ( os );
	}
}

OpenLogicalChannel_forwardLogicalChannelParameters :: ~OpenLogicalChannel_forwardLogicalChannelParameters ( ) {
	delete m_portNumber;
	delete m_forwardLogicalChannelDependency;
	delete m_replacementFor;
}

void OpenLogicalChannel_forwardLogicalChannelParameters :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_portNumber ) ) {
		os << std :: setw ( indent + 13 ) << "portNumber = " << std :: setprecision ( indent );
		m_portNumber -> OpenLogicalChannel_forwardLogicalChannelParameters_portNumber :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 11 ) << "dataType = " << std :: setprecision ( indent ) << m_dataType << '\n';
	os << std :: setw ( indent + 22 ) << "multiplexParameters = " << std :: setprecision ( indent ) << m_multiplexParameters << '\n';
	if ( hasOptionalField ( e_forwardLogicalChannelDependency ) ) {
		os << std :: setw ( indent + 34 ) << "forwardLogicalChannelDependency = " << std :: setprecision ( indent );
		m_forwardLogicalChannelDependency -> LogicalChannelNumber :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_replacementFor ) ) {
		os << std :: setw ( indent + 17 ) << "replacementFor = " << std :: setprecision ( indent );
		m_replacementFor -> LogicalChannelNumber :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

OpenLogicalChannel_forwardLogicalChannelParameters * OpenLogicalChannel_forwardLogicalChannelParameters :: clone ( ) const {
	return new OpenLogicalChannel_forwardLogicalChannelParameters ( * this );
}

//
// OpenLogicalChannel_reverseLogicalChannelParameters
//

OpenLogicalChannel_reverseLogicalChannelParameters :: OpenLogicalChannel_reverseLogicalChannelParameters ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 2 ), m_dataType ( is ), m_multiplexParameters ( 0 ), m_reverseLogicalChannelDependency ( 0 ), m_replacementFor ( 0 ) {
	try {
		if ( hasOptionalField ( e_multiplexParameters ) )
			m_multiplexParameters = new OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_reverseLogicalChannelDependency ) )
				m_reverseLogicalChannelDependency = new LogicalChannelNumber ( is );
			if ( hasKnownExtensionToDecode ( is, e_replacementFor ) )
				m_replacementFor = new LogicalChannelNumber ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_multiplexParameters;
		delete m_reverseLogicalChannelDependency;
		delete m_replacementFor;
		throw;
	}
}

OpenLogicalChannel_reverseLogicalChannelParameters :: OpenLogicalChannel_reverseLogicalChannelParameters ( ) : Asn :: Sequence ( 1, true, 2 ), m_multiplexParameters ( 0 ), m_reverseLogicalChannelDependency ( 0 ), m_replacementFor ( 0 ) { }

OpenLogicalChannel_reverseLogicalChannelParameters & OpenLogicalChannel_reverseLogicalChannelParameters :: operator= ( const OpenLogicalChannel_reverseLogicalChannelParameters & s ) {
	Asn :: Sequence :: operator= ( s );
	m_dataType = s.m_dataType;
	assignCopy ( m_multiplexParameters, s.m_multiplexParameters );
	assignCopy ( m_reverseLogicalChannelDependency, s.m_reverseLogicalChannelDependency );
	assignCopy ( m_replacementFor, s.m_replacementFor );
	return * this;
}

OpenLogicalChannel_reverseLogicalChannelParameters :: OpenLogicalChannel_reverseLogicalChannelParameters ( const OpenLogicalChannel_reverseLogicalChannelParameters & s ) : Asn :: Sequence ( s ), m_dataType ( s.m_dataType ), m_multiplexParameters ( 0 ), m_reverseLogicalChannelDependency ( 0 ), m_replacementFor ( 0 ) {
	try {
		if ( s.m_multiplexParameters )
			m_multiplexParameters = new OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters ( * s.m_multiplexParameters );
		if ( s.m_reverseLogicalChannelDependency )
			m_reverseLogicalChannelDependency = new LogicalChannelNumber ( * s.m_reverseLogicalChannelDependency );
		if ( s.m_replacementFor )
			m_replacementFor = new LogicalChannelNumber ( * s.m_replacementFor );
	} catch ( ... ) {
		delete m_multiplexParameters;
		delete m_reverseLogicalChannelDependency;
		delete m_replacementFor;
		throw;
	}
}


void OpenLogicalChannel_reverseLogicalChannelParameters :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_multiplexParameters:
			assignNew ( m_multiplexParameters, new OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters );
			break;
		case e_reverseLogicalChannelDependency:
			assignNew ( m_reverseLogicalChannelDependency, new LogicalChannelNumber );
			break;
		case e_replacementFor:
			assignNew ( m_replacementFor, new LogicalChannelNumber );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void OpenLogicalChannel_reverseLogicalChannelParameters :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_multiplexParameters:
			delete m_multiplexParameters;
			m_multiplexParameters = 0;
			break;
		case e_reverseLogicalChannelDependency:
			delete m_reverseLogicalChannelDependency;
			m_reverseLogicalChannelDependency = 0;
			break;
		case e_replacementFor:
			delete m_replacementFor;
			m_replacementFor = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void OpenLogicalChannel_reverseLogicalChannelParameters :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_dataType.encode ( os );
	if ( hasOptionalField ( e_multiplexParameters ) )
		m_multiplexParameters -> OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_reverseLogicalChannelDependency, m_reverseLogicalChannelDependency );
		knownExtensionEncode ( os, e_replacementFor, m_replacementFor );
		unknownExtensionsEncode ( os );
	}
}

OpenLogicalChannel_reverseLogicalChannelParameters :: ~OpenLogicalChannel_reverseLogicalChannelParameters ( ) {
	delete m_multiplexParameters;
	delete m_reverseLogicalChannelDependency;
	delete m_replacementFor;
}

void OpenLogicalChannel_reverseLogicalChannelParameters :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 11 ) << "dataType = " << std :: setprecision ( indent ) << m_dataType << '\n';
	if ( hasOptionalField ( e_multiplexParameters ) ) {
		os << std :: setw ( indent + 22 ) << "multiplexParameters = " << std :: setprecision ( indent );
		m_multiplexParameters -> OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_reverseLogicalChannelDependency ) ) {
		os << std :: setw ( indent + 34 ) << "reverseLogicalChannelDependency = " << std :: setprecision ( indent );
		m_reverseLogicalChannelDependency -> LogicalChannelNumber :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_replacementFor ) ) {
		os << std :: setw ( indent + 17 ) << "replacementFor = " << std :: setprecision ( indent );
		m_replacementFor -> LogicalChannelNumber :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

OpenLogicalChannel_reverseLogicalChannelParameters * OpenLogicalChannel_reverseLogicalChannelParameters :: clone ( ) const {
	return new OpenLogicalChannel_reverseLogicalChannelParameters ( * this );
}

//
// H235Media_mediaType
//

H235Media_mediaType :: H235Media_mediaType ( Asn :: istream & is ) : Asn :: Choice ( is, 4, true ) {
	switch ( tag ) {
		case e_nonStandard:
			choice = new NonStandardParameter ( is );
			break;
		case e_videoData:
			choice = new VideoCapability ( is );
			break;
		case e_audioData:
			choice = new AudioCapability ( is );
			break;
		case e_data:
			choice = new DataApplicationCapability ( is );
			break;
		case e_redundancyEncoding:
			choice = new RedundancyEncoding ( is );
			break;
		case e_multiplePayloadStream:
			choice = new MultiplePayloadStream ( is );
			break;
		case e_depFec:
			choice = new DepFECData ( is );
			break;
		case e_fec:
			choice = new FECData ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

H235Media_mediaType :: H235Media_mediaType ( ) : Asn :: Choice ( 4, true ) { }

H235Media_mediaType :: operator NonStandardParameter & ( ) {
	return dynamic_cast < NonStandardParameter & > ( * choice );
}


H235Media_mediaType :: operator const NonStandardParameter & ( ) const {
	return dynamic_cast < const NonStandardParameter & > ( * choice );
}


H235Media_mediaType :: operator VideoCapability & ( ) {
	return dynamic_cast < VideoCapability & > ( * choice );
}


H235Media_mediaType :: operator const VideoCapability & ( ) const {
	return dynamic_cast < const VideoCapability & > ( * choice );
}


H235Media_mediaType :: operator AudioCapability & ( ) {
	return dynamic_cast < AudioCapability & > ( * choice );
}


H235Media_mediaType :: operator const AudioCapability & ( ) const {
	return dynamic_cast < const AudioCapability & > ( * choice );
}


H235Media_mediaType :: operator DataApplicationCapability & ( ) {
	return dynamic_cast < DataApplicationCapability & > ( * choice );
}


H235Media_mediaType :: operator const DataApplicationCapability & ( ) const {
	return dynamic_cast < const DataApplicationCapability & > ( * choice );
}


H235Media_mediaType :: operator RedundancyEncoding & ( ) {
	return dynamic_cast < RedundancyEncoding & > ( * choice );
}


H235Media_mediaType :: operator const RedundancyEncoding & ( ) const {
	return dynamic_cast < const RedundancyEncoding & > ( * choice );
}


H235Media_mediaType :: operator MultiplePayloadStream & ( ) {
	return dynamic_cast < MultiplePayloadStream & > ( * choice );
}


H235Media_mediaType :: operator const MultiplePayloadStream & ( ) const {
	return dynamic_cast < const MultiplePayloadStream & > ( * choice );
}


H235Media_mediaType :: operator DepFECData & ( ) {
	return dynamic_cast < DepFECData & > ( * choice );
}


H235Media_mediaType :: operator const DepFECData & ( ) const {
	return dynamic_cast < const DepFECData & > ( * choice );
}


H235Media_mediaType :: operator FECData & ( ) {
	return dynamic_cast < FECData & > ( * choice );
}


H235Media_mediaType :: operator const FECData & ( ) const {
	return dynamic_cast < const FECData & > ( * choice );
}


void H235Media_mediaType :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandard:
			o = new NonStandardParameter;
			break;
		case e_videoData:
			o = new VideoCapability;
			break;
		case e_audioData:
			o = new AudioCapability;
			break;
		case e_data:
			o = new DataApplicationCapability;
			break;
		case e_redundancyEncoding:
			o = new RedundancyEncoding;
			break;
		case e_multiplePayloadStream:
			o = new MultiplePayloadStream;
			break;
		case e_depFec:
			o = new DepFECData;
			break;
		case e_fec:
			o = new FECData;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & H235Media_mediaType :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandard, "nonStandard" },
		{ e_videoData, "videoData" },
		{ e_audioData, "audioData" },
		{ e_data, "data" },
		{ e_redundancyEncoding, "redundancyEncoding" },
		{ e_multiplePayloadStream, "multiplePayloadStream" },
		{ e_depFec, "depFec" },
		{ e_fec, "fec" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

H235Media_mediaType * H235Media_mediaType :: clone ( ) const {
	return new H235Media_mediaType ( * this );
}

//
// H235Mode_mediaMode
//

H235Mode_mediaMode :: H235Mode_mediaMode ( Asn :: istream & is ) : Asn :: Choice ( is, 4, true ) {
	switch ( tag ) {
		case e_nonStandard:
			choice = new NonStandardParameter ( is );
			break;
		case e_videoMode:
			choice = new VideoMode ( is );
			break;
		case e_audioMode:
			choice = new AudioMode ( is );
			break;
		case e_dataMode:
			choice = new DataMode ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

H235Mode_mediaMode :: H235Mode_mediaMode ( ) : Asn :: Choice ( 4, true ) { }

H235Mode_mediaMode :: operator NonStandardParameter & ( ) {
	return dynamic_cast < NonStandardParameter & > ( * choice );
}


H235Mode_mediaMode :: operator const NonStandardParameter & ( ) const {
	return dynamic_cast < const NonStandardParameter & > ( * choice );
}


H235Mode_mediaMode :: operator VideoMode & ( ) {
	return dynamic_cast < VideoMode & > ( * choice );
}


H235Mode_mediaMode :: operator const VideoMode & ( ) const {
	return dynamic_cast < const VideoMode & > ( * choice );
}


H235Mode_mediaMode :: operator AudioMode & ( ) {
	return dynamic_cast < AudioMode & > ( * choice );
}


H235Mode_mediaMode :: operator const AudioMode & ( ) const {
	return dynamic_cast < const AudioMode & > ( * choice );
}


H235Mode_mediaMode :: operator DataMode & ( ) {
	return dynamic_cast < DataMode & > ( * choice );
}


H235Mode_mediaMode :: operator const DataMode & ( ) const {
	return dynamic_cast < const DataMode & > ( * choice );
}


void H235Mode_mediaMode :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandard:
			o = new NonStandardParameter;
			break;
		case e_videoMode:
			o = new VideoMode;
			break;
		case e_audioMode:
			o = new AudioMode;
			break;
		case e_dataMode:
			o = new DataMode;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & H235Mode_mediaMode :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandard, "nonStandard" },
		{ e_videoMode, "videoMode" },
		{ e_audioMode, "audioMode" },
		{ e_dataMode, "dataMode" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

H235Mode_mediaMode * H235Mode_mediaMode :: clone ( ) const {
	return new H235Mode_mediaMode ( * this );
}

//
// RedundancyEncodingDTModeElement_type
//

RedundancyEncodingDTModeElement_type :: RedundancyEncodingDTModeElement_type ( Asn :: istream & is ) : Asn :: Choice ( is, 6, true ) {
	switch ( tag ) {
		case e_nonStandard:
			choice = new NonStandardParameter ( is );
			break;
		case e_videoMode:
			choice = new VideoMode ( is );
			break;
		case e_audioMode:
			choice = new AudioMode ( is );
			break;
		case e_dataMode:
			choice = new DataMode ( is );
			break;
		case e_encryptionMode:
			choice = new EncryptionMode ( is );
			break;
		case e_h235Mode:
			choice = new H235Mode ( is );
			break;
		case e_fecMode:
			choice = new FECMode ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

RedundancyEncodingDTModeElement_type :: RedundancyEncodingDTModeElement_type ( ) : Asn :: Choice ( 6, true ) { }

RedundancyEncodingDTModeElement_type :: operator NonStandardParameter & ( ) {
	return dynamic_cast < NonStandardParameter & > ( * choice );
}


RedundancyEncodingDTModeElement_type :: operator const NonStandardParameter & ( ) const {
	return dynamic_cast < const NonStandardParameter & > ( * choice );
}


RedundancyEncodingDTModeElement_type :: operator VideoMode & ( ) {
	return dynamic_cast < VideoMode & > ( * choice );
}


RedundancyEncodingDTModeElement_type :: operator const VideoMode & ( ) const {
	return dynamic_cast < const VideoMode & > ( * choice );
}


RedundancyEncodingDTModeElement_type :: operator AudioMode & ( ) {
	return dynamic_cast < AudioMode & > ( * choice );
}


RedundancyEncodingDTModeElement_type :: operator const AudioMode & ( ) const {
	return dynamic_cast < const AudioMode & > ( * choice );
}


RedundancyEncodingDTModeElement_type :: operator DataMode & ( ) {
	return dynamic_cast < DataMode & > ( * choice );
}


RedundancyEncodingDTModeElement_type :: operator const DataMode & ( ) const {
	return dynamic_cast < const DataMode & > ( * choice );
}


RedundancyEncodingDTModeElement_type :: operator EncryptionMode & ( ) {
	return dynamic_cast < EncryptionMode & > ( * choice );
}


RedundancyEncodingDTModeElement_type :: operator const EncryptionMode & ( ) const {
	return dynamic_cast < const EncryptionMode & > ( * choice );
}


RedundancyEncodingDTModeElement_type :: operator H235Mode & ( ) {
	return dynamic_cast < H235Mode & > ( * choice );
}


RedundancyEncodingDTModeElement_type :: operator const H235Mode & ( ) const {
	return dynamic_cast < const H235Mode & > ( * choice );
}


RedundancyEncodingDTModeElement_type :: operator FECMode & ( ) {
	return dynamic_cast < FECMode & > ( * choice );
}


RedundancyEncodingDTModeElement_type :: operator const FECMode & ( ) const {
	return dynamic_cast < const FECMode & > ( * choice );
}


void RedundancyEncodingDTModeElement_type :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandard:
			o = new NonStandardParameter;
			break;
		case e_videoMode:
			o = new VideoMode;
			break;
		case e_audioMode:
			o = new AudioMode;
			break;
		case e_dataMode:
			o = new DataMode;
			break;
		case e_encryptionMode:
			o = new EncryptionMode;
			break;
		case e_h235Mode:
			o = new H235Mode;
			break;
		case e_fecMode:
			o = new FECMode;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & RedundancyEncodingDTModeElement_type :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandard, "nonStandard" },
		{ e_videoMode, "videoMode" },
		{ e_audioMode, "audioMode" },
		{ e_dataMode, "dataMode" },
		{ e_encryptionMode, "encryptionMode" },
		{ e_h235Mode, "h235Mode" },
		{ e_fecMode, "fecMode" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

RedundancyEncodingDTModeElement_type * RedundancyEncodingDTModeElement_type :: clone ( ) const {
	return new RedundancyEncodingDTModeElement_type ( * this );
}

//
// RedundancyEncodingMode_secondaryEncoding
//

RedundancyEncodingMode_secondaryEncoding :: RedundancyEncodingMode_secondaryEncoding ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_nonStandard:
			choice = new NonStandardParameter ( is );
			break;
		case e_audioData:
			choice = new AudioMode ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

RedundancyEncodingMode_secondaryEncoding :: RedundancyEncodingMode_secondaryEncoding ( ) : Asn :: Choice ( 2, true ) { }

RedundancyEncodingMode_secondaryEncoding :: operator NonStandardParameter & ( ) {
	return dynamic_cast < NonStandardParameter & > ( * choice );
}


RedundancyEncodingMode_secondaryEncoding :: operator const NonStandardParameter & ( ) const {
	return dynamic_cast < const NonStandardParameter & > ( * choice );
}


RedundancyEncodingMode_secondaryEncoding :: operator AudioMode & ( ) {
	return dynamic_cast < AudioMode & > ( * choice );
}


RedundancyEncodingMode_secondaryEncoding :: operator const AudioMode & ( ) const {
	return dynamic_cast < const AudioMode & > ( * choice );
}


void RedundancyEncodingMode_secondaryEncoding :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandard:
			o = new NonStandardParameter;
			break;
		case e_audioData:
			o = new AudioMode;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & RedundancyEncodingMode_secondaryEncoding :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandard, "nonStandard" },
		{ e_audioData, "audioData" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

RedundancyEncodingMode_secondaryEncoding * RedundancyEncodingMode_secondaryEncoding :: clone ( ) const {
	return new RedundancyEncodingMode_secondaryEncoding ( * this );
}

//
// CommunicationModeTableEntry_dataType
//

CommunicationModeTableEntry_dataType :: CommunicationModeTableEntry_dataType ( Asn :: istream & is ) : Asn :: Choice ( is, 3, true ) {
	switch ( tag ) {
		case e_videoData:
			choice = new VideoCapability ( is );
			break;
		case e_audioData:
			choice = new AudioCapability ( is );
			break;
		case e_data:
			choice = new DataApplicationCapability ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

CommunicationModeTableEntry_dataType :: CommunicationModeTableEntry_dataType ( ) : Asn :: Choice ( 3, true ) { }

CommunicationModeTableEntry_dataType :: operator VideoCapability & ( ) {
	return dynamic_cast < VideoCapability & > ( * choice );
}


CommunicationModeTableEntry_dataType :: operator const VideoCapability & ( ) const {
	return dynamic_cast < const VideoCapability & > ( * choice );
}


CommunicationModeTableEntry_dataType :: operator AudioCapability & ( ) {
	return dynamic_cast < AudioCapability & > ( * choice );
}


CommunicationModeTableEntry_dataType :: operator const AudioCapability & ( ) const {
	return dynamic_cast < const AudioCapability & > ( * choice );
}


CommunicationModeTableEntry_dataType :: operator DataApplicationCapability & ( ) {
	return dynamic_cast < DataApplicationCapability & > ( * choice );
}


CommunicationModeTableEntry_dataType :: operator const DataApplicationCapability & ( ) const {
	return dynamic_cast < const DataApplicationCapability & > ( * choice );
}


void CommunicationModeTableEntry_dataType :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_videoData:
			o = new VideoCapability;
			break;
		case e_audioData:
			o = new AudioCapability;
			break;
		case e_data:
			o = new DataApplicationCapability;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & CommunicationModeTableEntry_dataType :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_videoData, "videoData" },
		{ e_audioData, "audioData" },
		{ e_data, "data" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

CommunicationModeTableEntry_dataType * CommunicationModeTableEntry_dataType :: clone ( ) const {
	return new CommunicationModeTableEntry_dataType ( * this );
}

//
// DepFECMode_rfc2733Mode_mode
//

DepFECMode_rfc2733Mode_mode :: DepFECMode_rfc2733Mode_mode ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_redundancyEncoding:
			choice = new Asn :: Null ( is );
			break;
		case e_separateStream:
			choice = new DepFECMode_rfc2733Mode_mode_separateStream ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

DepFECMode_rfc2733Mode_mode :: DepFECMode_rfc2733Mode_mode ( ) : Asn :: Choice ( 2, true ) { }

DepFECMode_rfc2733Mode_mode :: operator Asn :: Null & ( ) {
	return dynamic_cast < Asn :: Null & > ( * choice );
}


DepFECMode_rfc2733Mode_mode :: operator const Asn :: Null & ( ) const {
	return dynamic_cast < const Asn :: Null & > ( * choice );
}


DepFECMode_rfc2733Mode_mode :: operator DepFECMode_rfc2733Mode_mode_separateStream & ( ) {
	return dynamic_cast < DepFECMode_rfc2733Mode_mode_separateStream & > ( * choice );
}


DepFECMode_rfc2733Mode_mode :: operator const DepFECMode_rfc2733Mode_mode_separateStream & ( ) const {
	return dynamic_cast < const DepFECMode_rfc2733Mode_mode_separateStream & > ( * choice );
}


void DepFECMode_rfc2733Mode_mode :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_redundancyEncoding:
			o = new Asn :: Null;
			break;
		case e_separateStream:
			o = new DepFECMode_rfc2733Mode_mode_separateStream;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & DepFECMode_rfc2733Mode_mode :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_redundancyEncoding, "redundancyEncoding" },
		{ e_separateStream, "separateStream" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

DepFECMode_rfc2733Mode_mode * DepFECMode_rfc2733Mode_mode :: clone ( ) const {
	return new DepFECMode_rfc2733Mode_mode ( * this );
}

//
// DepFECMode_rfc2733Mode_mode_separateStream
//

DepFECMode_rfc2733Mode_mode_separateStream :: DepFECMode_rfc2733Mode_mode_separateStream ( Asn :: istream & is ) : Asn :: Choice ( is, 2, true ) {
	switch ( tag ) {
		case e_differentPort:
			choice = new DepFECMode_rfc2733Mode_mode_separateStream_differentPort ( is );
			break;
		case e_samePort:
			choice = new DepFECMode_rfc2733Mode_mode_separateStream_samePort ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

DepFECMode_rfc2733Mode_mode_separateStream :: DepFECMode_rfc2733Mode_mode_separateStream ( ) : Asn :: Choice ( 2, true ) { }

DepFECMode_rfc2733Mode_mode_separateStream :: operator DepFECMode_rfc2733Mode_mode_separateStream_differentPort & ( ) {
	return dynamic_cast < DepFECMode_rfc2733Mode_mode_separateStream_differentPort & > ( * choice );
}


DepFECMode_rfc2733Mode_mode_separateStream :: operator const DepFECMode_rfc2733Mode_mode_separateStream_differentPort & ( ) const {
	return dynamic_cast < const DepFECMode_rfc2733Mode_mode_separateStream_differentPort & > ( * choice );
}


DepFECMode_rfc2733Mode_mode_separateStream :: operator DepFECMode_rfc2733Mode_mode_separateStream_samePort & ( ) {
	return dynamic_cast < DepFECMode_rfc2733Mode_mode_separateStream_samePort & > ( * choice );
}


DepFECMode_rfc2733Mode_mode_separateStream :: operator const DepFECMode_rfc2733Mode_mode_separateStream_samePort & ( ) const {
	return dynamic_cast < const DepFECMode_rfc2733Mode_mode_separateStream_samePort & > ( * choice );
}


void DepFECMode_rfc2733Mode_mode_separateStream :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_differentPort:
			o = new DepFECMode_rfc2733Mode_mode_separateStream_differentPort;
			break;
		case e_samePort:
			o = new DepFECMode_rfc2733Mode_mode_separateStream_samePort;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & DepFECMode_rfc2733Mode_mode_separateStream :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_differentPort, "differentPort" },
		{ e_samePort, "samePort" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

DepFECMode_rfc2733Mode_mode_separateStream * DepFECMode_rfc2733Mode_mode_separateStream :: clone ( ) const {
	return new DepFECMode_rfc2733Mode_mode_separateStream ( * this );
}

//
// DepFECMode_rfc2733Mode_mode_separateStream_samePort
//

DepFECMode_rfc2733Mode_mode_separateStream_samePort :: DepFECMode_rfc2733Mode_mode_separateStream_samePort ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_protectedType ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

DepFECMode_rfc2733Mode_mode_separateStream_samePort :: DepFECMode_rfc2733Mode_mode_separateStream_samePort ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void DepFECMode_rfc2733Mode_mode_separateStream_samePort :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_protectedType.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void DepFECMode_rfc2733Mode_mode_separateStream_samePort :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 16 ) << "protectedType = " << std :: setprecision ( indent ) << m_protectedType << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

DepFECMode_rfc2733Mode_mode_separateStream_samePort * DepFECMode_rfc2733Mode_mode_separateStream_samePort :: clone ( ) const {
	return new DepFECMode_rfc2733Mode_mode_separateStream_samePort ( * this );
}

//
// MultimediaSystemControlMessage
//

MultimediaSystemControlMessage :: MultimediaSystemControlMessage ( Asn :: istream & is ) : Asn :: Choice ( is, 4, true ) {
	switch ( tag ) {
		case e_request:
			choice = new RequestMessage ( is );
			break;
		case e_response:
			choice = new ResponseMessage ( is );
			break;
		case e_command:
			choice = new CommandMessage ( is );
			break;
		case e_indication:
			choice = new IndicationMessage ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

MultimediaSystemControlMessage :: MultimediaSystemControlMessage ( ) : Asn :: Choice ( 4, true ) { }

MultimediaSystemControlMessage :: operator RequestMessage & ( ) {
	return dynamic_cast < RequestMessage & > ( * choice );
}


MultimediaSystemControlMessage :: operator const RequestMessage & ( ) const {
	return dynamic_cast < const RequestMessage & > ( * choice );
}


MultimediaSystemControlMessage :: operator ResponseMessage & ( ) {
	return dynamic_cast < ResponseMessage & > ( * choice );
}


MultimediaSystemControlMessage :: operator const ResponseMessage & ( ) const {
	return dynamic_cast < const ResponseMessage & > ( * choice );
}


MultimediaSystemControlMessage :: operator CommandMessage & ( ) {
	return dynamic_cast < CommandMessage & > ( * choice );
}


MultimediaSystemControlMessage :: operator const CommandMessage & ( ) const {
	return dynamic_cast < const CommandMessage & > ( * choice );
}


MultimediaSystemControlMessage :: operator IndicationMessage & ( ) {
	return dynamic_cast < IndicationMessage & > ( * choice );
}


MultimediaSystemControlMessage :: operator const IndicationMessage & ( ) const {
	return dynamic_cast < const IndicationMessage & > ( * choice );
}


void MultimediaSystemControlMessage :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_request:
			o = new RequestMessage;
			break;
		case e_response:
			o = new ResponseMessage;
			break;
		case e_command:
			o = new CommandMessage;
			break;
		case e_indication:
			o = new IndicationMessage;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & MultimediaSystemControlMessage :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_request, "request" },
		{ e_response, "response" },
		{ e_command, "command" },
		{ e_indication, "indication" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

MultimediaSystemControlMessage * MultimediaSystemControlMessage :: clone ( ) const {
	return new MultimediaSystemControlMessage ( * this );
}

//
// RequestMessage
//

RequestMessage :: RequestMessage ( Asn :: istream & is ) : Asn :: Choice ( is, 11, true ) {
	switch ( tag ) {
		case e_nonStandard:
			choice = new NonStandardMessage ( is );
			break;
		case e_masterSlaveDetermination:
			choice = new MasterSlaveDetermination ( is );
			break;
		case e_terminalCapabilitySet:
			choice = new TerminalCapabilitySet ( is );
			break;
		case e_openLogicalChannel:
			choice = new OpenLogicalChannel ( is );
			break;
		case e_closeLogicalChannel:
			choice = new CloseLogicalChannel ( is );
			break;
		case e_requestChannelClose:
			choice = new RequestChannelClose ( is );
			break;
		case e_multiplexEntrySend:
			choice = new MultiplexEntrySend ( is );
			break;
		case e_requestMultiplexEntry:
			choice = new RequestMultiplexEntry ( is );
			break;
		case e_requestMode:
			choice = new RequestMode ( is );
			break;
		case e_roundTripDelayRequest:
			choice = new RoundTripDelayRequest ( is );
			break;
		case e_maintenanceLoopRequest:
			choice = new MaintenanceLoopRequest ( is );
			break;
		case e_communicationModeRequest:
			choice = new CommunicationModeRequest ( is );
			break;
		case e_conferenceRequest:
			choice = new ConferenceRequest ( is );
			break;
		case e_multilinkRequest:
			choice = new MultilinkRequest ( is );
			break;
		case e_logicalChannelRateRequest:
			choice = new LogicalChannelRateRequest ( is );
			break;
		case e_genericRequest:
			choice = new GenericMessage ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

RequestMessage :: RequestMessage ( ) : Asn :: Choice ( 11, true ) { }

RequestMessage :: operator NonStandardMessage & ( ) {
	return dynamic_cast < NonStandardMessage & > ( * choice );
}


RequestMessage :: operator const NonStandardMessage & ( ) const {
	return dynamic_cast < const NonStandardMessage & > ( * choice );
}


RequestMessage :: operator MasterSlaveDetermination & ( ) {
	return dynamic_cast < MasterSlaveDetermination & > ( * choice );
}


RequestMessage :: operator const MasterSlaveDetermination & ( ) const {
	return dynamic_cast < const MasterSlaveDetermination & > ( * choice );
}


RequestMessage :: operator TerminalCapabilitySet & ( ) {
	return dynamic_cast < TerminalCapabilitySet & > ( * choice );
}


RequestMessage :: operator const TerminalCapabilitySet & ( ) const {
	return dynamic_cast < const TerminalCapabilitySet & > ( * choice );
}


RequestMessage :: operator OpenLogicalChannel & ( ) {
	return dynamic_cast < OpenLogicalChannel & > ( * choice );
}


RequestMessage :: operator const OpenLogicalChannel & ( ) const {
	return dynamic_cast < const OpenLogicalChannel & > ( * choice );
}


RequestMessage :: operator CloseLogicalChannel & ( ) {
	return dynamic_cast < CloseLogicalChannel & > ( * choice );
}


RequestMessage :: operator const CloseLogicalChannel & ( ) const {
	return dynamic_cast < const CloseLogicalChannel & > ( * choice );
}


RequestMessage :: operator RequestChannelClose & ( ) {
	return dynamic_cast < RequestChannelClose & > ( * choice );
}


RequestMessage :: operator const RequestChannelClose & ( ) const {
	return dynamic_cast < const RequestChannelClose & > ( * choice );
}


RequestMessage :: operator MultiplexEntrySend & ( ) {
	return dynamic_cast < MultiplexEntrySend & > ( * choice );
}


RequestMessage :: operator const MultiplexEntrySend & ( ) const {
	return dynamic_cast < const MultiplexEntrySend & > ( * choice );
}


RequestMessage :: operator RequestMultiplexEntry & ( ) {
	return dynamic_cast < RequestMultiplexEntry & > ( * choice );
}


RequestMessage :: operator const RequestMultiplexEntry & ( ) const {
	return dynamic_cast < const RequestMultiplexEntry & > ( * choice );
}


RequestMessage :: operator RequestMode & ( ) {
	return dynamic_cast < RequestMode & > ( * choice );
}


RequestMessage :: operator const RequestMode & ( ) const {
	return dynamic_cast < const RequestMode & > ( * choice );
}


RequestMessage :: operator RoundTripDelayRequest & ( ) {
	return dynamic_cast < RoundTripDelayRequest & > ( * choice );
}


RequestMessage :: operator const RoundTripDelayRequest & ( ) const {
	return dynamic_cast < const RoundTripDelayRequest & > ( * choice );
}


RequestMessage :: operator MaintenanceLoopRequest & ( ) {
	return dynamic_cast < MaintenanceLoopRequest & > ( * choice );
}


RequestMessage :: operator const MaintenanceLoopRequest & ( ) const {
	return dynamic_cast < const MaintenanceLoopRequest & > ( * choice );
}


RequestMessage :: operator CommunicationModeRequest & ( ) {
	return dynamic_cast < CommunicationModeRequest & > ( * choice );
}


RequestMessage :: operator const CommunicationModeRequest & ( ) const {
	return dynamic_cast < const CommunicationModeRequest & > ( * choice );
}


RequestMessage :: operator ConferenceRequest & ( ) {
	return dynamic_cast < ConferenceRequest & > ( * choice );
}


RequestMessage :: operator const ConferenceRequest & ( ) const {
	return dynamic_cast < const ConferenceRequest & > ( * choice );
}


RequestMessage :: operator MultilinkRequest & ( ) {
	return dynamic_cast < MultilinkRequest & > ( * choice );
}


RequestMessage :: operator const MultilinkRequest & ( ) const {
	return dynamic_cast < const MultilinkRequest & > ( * choice );
}


RequestMessage :: operator LogicalChannelRateRequest & ( ) {
	return dynamic_cast < LogicalChannelRateRequest & > ( * choice );
}


RequestMessage :: operator const LogicalChannelRateRequest & ( ) const {
	return dynamic_cast < const LogicalChannelRateRequest & > ( * choice );
}


RequestMessage :: operator GenericMessage & ( ) {
	return dynamic_cast < GenericMessage & > ( * choice );
}


RequestMessage :: operator const GenericMessage & ( ) const {
	return dynamic_cast < const GenericMessage & > ( * choice );
}


void RequestMessage :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandard:
			o = new NonStandardMessage;
			break;
		case e_masterSlaveDetermination:
			o = new MasterSlaveDetermination;
			break;
		case e_terminalCapabilitySet:
			o = new TerminalCapabilitySet;
			break;
		case e_openLogicalChannel:
			o = new OpenLogicalChannel;
			break;
		case e_closeLogicalChannel:
			o = new CloseLogicalChannel;
			break;
		case e_requestChannelClose:
			o = new RequestChannelClose;
			break;
		case e_multiplexEntrySend:
			o = new MultiplexEntrySend;
			break;
		case e_requestMultiplexEntry:
			o = new RequestMultiplexEntry;
			break;
		case e_requestMode:
			o = new RequestMode;
			break;
		case e_roundTripDelayRequest:
			o = new RoundTripDelayRequest;
			break;
		case e_maintenanceLoopRequest:
			o = new MaintenanceLoopRequest;
			break;
		case e_communicationModeRequest:
			o = new CommunicationModeRequest;
			break;
		case e_conferenceRequest:
			o = new ConferenceRequest;
			break;
		case e_multilinkRequest:
			o = new MultilinkRequest;
			break;
		case e_logicalChannelRateRequest:
			o = new LogicalChannelRateRequest;
			break;
		case e_genericRequest:
			o = new GenericMessage;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & RequestMessage :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandard, "nonStandard" },
		{ e_masterSlaveDetermination, "masterSlaveDetermination" },
		{ e_terminalCapabilitySet, "terminalCapabilitySet" },
		{ e_openLogicalChannel, "openLogicalChannel" },
		{ e_closeLogicalChannel, "closeLogicalChannel" },
		{ e_requestChannelClose, "requestChannelClose" },
		{ e_multiplexEntrySend, "multiplexEntrySend" },
		{ e_requestMultiplexEntry, "requestMultiplexEntry" },
		{ e_requestMode, "requestMode" },
		{ e_roundTripDelayRequest, "roundTripDelayRequest" },
		{ e_maintenanceLoopRequest, "maintenanceLoopRequest" },
		{ e_communicationModeRequest, "communicationModeRequest" },
		{ e_conferenceRequest, "conferenceRequest" },
		{ e_multilinkRequest, "multilinkRequest" },
		{ e_logicalChannelRateRequest, "logicalChannelRateRequest" },
		{ e_genericRequest, "genericRequest" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

RequestMessage * RequestMessage :: clone ( ) const {
	return new RequestMessage ( * this );
}

//
// IndicationMessage
//

IndicationMessage :: IndicationMessage ( Asn :: istream & is ) : Asn :: Choice ( is, 14, true ) {
	switch ( tag ) {
		case e_nonStandard:
			choice = new NonStandardMessage ( is );
			break;
		case e_functionNotUnderstood:
			choice = new FunctionNotUnderstood ( is );
			break;
		case e_masterSlaveDeterminationRelease:
			choice = new MasterSlaveDeterminationRelease ( is );
			break;
		case e_terminalCapabilitySetRelease:
			choice = new TerminalCapabilitySetRelease ( is );
			break;
		case e_openLogicalChannelConfirm:
			choice = new OpenLogicalChannelConfirm ( is );
			break;
		case e_requestChannelCloseRelease:
			choice = new RequestChannelCloseRelease ( is );
			break;
		case e_multiplexEntrySendRelease:
			choice = new MultiplexEntrySendRelease ( is );
			break;
		case e_requestMultiplexEntryRelease:
			choice = new RequestMultiplexEntryRelease ( is );
			break;
		case e_requestModeRelease:
			choice = new RequestModeRelease ( is );
			break;
		case e_miscellaneousIndication:
			choice = new MiscellaneousIndication ( is );
			break;
		case e_jitterIndication:
			choice = new JitterIndication ( is );
			break;
		case e_h223SkewIndication:
			choice = new H223SkewIndication ( is );
			break;
		case e_newATMVCIndication:
			choice = new NewATMVCIndication ( is );
			break;
		case e_userInput:
			choice = new UserInputIndication ( is );
			break;
		case e_h2250MaximumSkewIndication:
			choice = new H2250MaximumSkewIndication ( is );
			break;
		case e_mcLocationIndication:
			choice = new MCLocationIndication ( is );
			break;
		case e_conferenceIndication:
			choice = new ConferenceIndication ( is );
			break;
		case e_vendorIdentification:
			choice = new VendorIdentification ( is );
			break;
		case e_functionNotSupported:
			choice = new FunctionNotSupported ( is );
			break;
		case e_multilinkIndication:
			choice = new MultilinkIndication ( is );
			break;
		case e_logicalChannelRateRelease:
			choice = new LogicalChannelRateRelease ( is );
			break;
		case e_flowControlIndication:
			choice = new FlowControlIndication ( is );
			break;
		case e_mobileMultilinkReconfigurationIndication:
			choice = new MobileMultilinkReconfigurationIndication ( is );
			break;
		case e_genericIndication:
			choice = new GenericMessage ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

IndicationMessage :: IndicationMessage ( ) : Asn :: Choice ( 14, true ) { }

IndicationMessage :: operator NonStandardMessage & ( ) {
	return dynamic_cast < NonStandardMessage & > ( * choice );
}


IndicationMessage :: operator const NonStandardMessage & ( ) const {
	return dynamic_cast < const NonStandardMessage & > ( * choice );
}


IndicationMessage :: operator FunctionNotUnderstood & ( ) {
	return dynamic_cast < FunctionNotUnderstood & > ( * choice );
}


IndicationMessage :: operator const FunctionNotUnderstood & ( ) const {
	return dynamic_cast < const FunctionNotUnderstood & > ( * choice );
}


IndicationMessage :: operator MasterSlaveDeterminationRelease & ( ) {
	return dynamic_cast < MasterSlaveDeterminationRelease & > ( * choice );
}


IndicationMessage :: operator const MasterSlaveDeterminationRelease & ( ) const {
	return dynamic_cast < const MasterSlaveDeterminationRelease & > ( * choice );
}


IndicationMessage :: operator TerminalCapabilitySetRelease & ( ) {
	return dynamic_cast < TerminalCapabilitySetRelease & > ( * choice );
}


IndicationMessage :: operator const TerminalCapabilitySetRelease & ( ) const {
	return dynamic_cast < const TerminalCapabilitySetRelease & > ( * choice );
}


IndicationMessage :: operator OpenLogicalChannelConfirm & ( ) {
	return dynamic_cast < OpenLogicalChannelConfirm & > ( * choice );
}


IndicationMessage :: operator const OpenLogicalChannelConfirm & ( ) const {
	return dynamic_cast < const OpenLogicalChannelConfirm & > ( * choice );
}


IndicationMessage :: operator RequestChannelCloseRelease & ( ) {
	return dynamic_cast < RequestChannelCloseRelease & > ( * choice );
}


IndicationMessage :: operator const RequestChannelCloseRelease & ( ) const {
	return dynamic_cast < const RequestChannelCloseRelease & > ( * choice );
}


IndicationMessage :: operator MultiplexEntrySendRelease & ( ) {
	return dynamic_cast < MultiplexEntrySendRelease & > ( * choice );
}


IndicationMessage :: operator const MultiplexEntrySendRelease & ( ) const {
	return dynamic_cast < const MultiplexEntrySendRelease & > ( * choice );
}


IndicationMessage :: operator RequestMultiplexEntryRelease & ( ) {
	return dynamic_cast < RequestMultiplexEntryRelease & > ( * choice );
}


IndicationMessage :: operator const RequestMultiplexEntryRelease & ( ) const {
	return dynamic_cast < const RequestMultiplexEntryRelease & > ( * choice );
}


IndicationMessage :: operator RequestModeRelease & ( ) {
	return dynamic_cast < RequestModeRelease & > ( * choice );
}


IndicationMessage :: operator const RequestModeRelease & ( ) const {
	return dynamic_cast < const RequestModeRelease & > ( * choice );
}


IndicationMessage :: operator MiscellaneousIndication & ( ) {
	return dynamic_cast < MiscellaneousIndication & > ( * choice );
}


IndicationMessage :: operator const MiscellaneousIndication & ( ) const {
	return dynamic_cast < const MiscellaneousIndication & > ( * choice );
}


IndicationMessage :: operator JitterIndication & ( ) {
	return dynamic_cast < JitterIndication & > ( * choice );
}


IndicationMessage :: operator const JitterIndication & ( ) const {
	return dynamic_cast < const JitterIndication & > ( * choice );
}


IndicationMessage :: operator H223SkewIndication & ( ) {
	return dynamic_cast < H223SkewIndication & > ( * choice );
}


IndicationMessage :: operator const H223SkewIndication & ( ) const {
	return dynamic_cast < const H223SkewIndication & > ( * choice );
}


IndicationMessage :: operator NewATMVCIndication & ( ) {
	return dynamic_cast < NewATMVCIndication & > ( * choice );
}


IndicationMessage :: operator const NewATMVCIndication & ( ) const {
	return dynamic_cast < const NewATMVCIndication & > ( * choice );
}


IndicationMessage :: operator UserInputIndication & ( ) {
	return dynamic_cast < UserInputIndication & > ( * choice );
}


IndicationMessage :: operator const UserInputIndication & ( ) const {
	return dynamic_cast < const UserInputIndication & > ( * choice );
}


IndicationMessage :: operator H2250MaximumSkewIndication & ( ) {
	return dynamic_cast < H2250MaximumSkewIndication & > ( * choice );
}


IndicationMessage :: operator const H2250MaximumSkewIndication & ( ) const {
	return dynamic_cast < const H2250MaximumSkewIndication & > ( * choice );
}


IndicationMessage :: operator MCLocationIndication & ( ) {
	return dynamic_cast < MCLocationIndication & > ( * choice );
}


IndicationMessage :: operator const MCLocationIndication & ( ) const {
	return dynamic_cast < const MCLocationIndication & > ( * choice );
}


IndicationMessage :: operator ConferenceIndication & ( ) {
	return dynamic_cast < ConferenceIndication & > ( * choice );
}


IndicationMessage :: operator const ConferenceIndication & ( ) const {
	return dynamic_cast < const ConferenceIndication & > ( * choice );
}


IndicationMessage :: operator VendorIdentification & ( ) {
	return dynamic_cast < VendorIdentification & > ( * choice );
}


IndicationMessage :: operator const VendorIdentification & ( ) const {
	return dynamic_cast < const VendorIdentification & > ( * choice );
}


IndicationMessage :: operator FunctionNotSupported & ( ) {
	return dynamic_cast < FunctionNotSupported & > ( * choice );
}


IndicationMessage :: operator const FunctionNotSupported & ( ) const {
	return dynamic_cast < const FunctionNotSupported & > ( * choice );
}


IndicationMessage :: operator MultilinkIndication & ( ) {
	return dynamic_cast < MultilinkIndication & > ( * choice );
}


IndicationMessage :: operator const MultilinkIndication & ( ) const {
	return dynamic_cast < const MultilinkIndication & > ( * choice );
}


IndicationMessage :: operator LogicalChannelRateRelease & ( ) {
	return dynamic_cast < LogicalChannelRateRelease & > ( * choice );
}


IndicationMessage :: operator const LogicalChannelRateRelease & ( ) const {
	return dynamic_cast < const LogicalChannelRateRelease & > ( * choice );
}


IndicationMessage :: operator FlowControlIndication & ( ) {
	return dynamic_cast < FlowControlIndication & > ( * choice );
}


IndicationMessage :: operator const FlowControlIndication & ( ) const {
	return dynamic_cast < const FlowControlIndication & > ( * choice );
}


IndicationMessage :: operator MobileMultilinkReconfigurationIndication & ( ) {
	return dynamic_cast < MobileMultilinkReconfigurationIndication & > ( * choice );
}


IndicationMessage :: operator const MobileMultilinkReconfigurationIndication & ( ) const {
	return dynamic_cast < const MobileMultilinkReconfigurationIndication & > ( * choice );
}


IndicationMessage :: operator GenericMessage & ( ) {
	return dynamic_cast < GenericMessage & > ( * choice );
}


IndicationMessage :: operator const GenericMessage & ( ) const {
	return dynamic_cast < const GenericMessage & > ( * choice );
}


void IndicationMessage :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandard:
			o = new NonStandardMessage;
			break;
		case e_functionNotUnderstood:
			o = new FunctionNotUnderstood;
			break;
		case e_masterSlaveDeterminationRelease:
			o = new MasterSlaveDeterminationRelease;
			break;
		case e_terminalCapabilitySetRelease:
			o = new TerminalCapabilitySetRelease;
			break;
		case e_openLogicalChannelConfirm:
			o = new OpenLogicalChannelConfirm;
			break;
		case e_requestChannelCloseRelease:
			o = new RequestChannelCloseRelease;
			break;
		case e_multiplexEntrySendRelease:
			o = new MultiplexEntrySendRelease;
			break;
		case e_requestMultiplexEntryRelease:
			o = new RequestMultiplexEntryRelease;
			break;
		case e_requestModeRelease:
			o = new RequestModeRelease;
			break;
		case e_miscellaneousIndication:
			o = new MiscellaneousIndication;
			break;
		case e_jitterIndication:
			o = new JitterIndication;
			break;
		case e_h223SkewIndication:
			o = new H223SkewIndication;
			break;
		case e_newATMVCIndication:
			o = new NewATMVCIndication;
			break;
		case e_userInput:
			o = new UserInputIndication;
			break;
		case e_h2250MaximumSkewIndication:
			o = new H2250MaximumSkewIndication;
			break;
		case e_mcLocationIndication:
			o = new MCLocationIndication;
			break;
		case e_conferenceIndication:
			o = new ConferenceIndication;
			break;
		case e_vendorIdentification:
			o = new VendorIdentification;
			break;
		case e_functionNotSupported:
			o = new FunctionNotSupported;
			break;
		case e_multilinkIndication:
			o = new MultilinkIndication;
			break;
		case e_logicalChannelRateRelease:
			o = new LogicalChannelRateRelease;
			break;
		case e_flowControlIndication:
			o = new FlowControlIndication;
			break;
		case e_mobileMultilinkReconfigurationIndication:
			o = new MobileMultilinkReconfigurationIndication;
			break;
		case e_genericIndication:
			o = new GenericMessage;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & IndicationMessage :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandard, "nonStandard" },
		{ e_functionNotUnderstood, "functionNotUnderstood" },
		{ e_masterSlaveDeterminationRelease, "masterSlaveDeterminationRelease" },
		{ e_terminalCapabilitySetRelease, "terminalCapabilitySetRelease" },
		{ e_openLogicalChannelConfirm, "openLogicalChannelConfirm" },
		{ e_requestChannelCloseRelease, "requestChannelCloseRelease" },
		{ e_multiplexEntrySendRelease, "multiplexEntrySendRelease" },
		{ e_requestMultiplexEntryRelease, "requestMultiplexEntryRelease" },
		{ e_requestModeRelease, "requestModeRelease" },
		{ e_miscellaneousIndication, "miscellaneousIndication" },
		{ e_jitterIndication, "jitterIndication" },
		{ e_h223SkewIndication, "h223SkewIndication" },
		{ e_newATMVCIndication, "newATMVCIndication" },
		{ e_userInput, "userInput" },
		{ e_h2250MaximumSkewIndication, "h2250MaximumSkewIndication" },
		{ e_mcLocationIndication, "mcLocationIndication" },
		{ e_conferenceIndication, "conferenceIndication" },
		{ e_vendorIdentification, "vendorIdentification" },
		{ e_functionNotSupported, "functionNotSupported" },
		{ e_multilinkIndication, "multilinkIndication" },
		{ e_logicalChannelRateRelease, "logicalChannelRateRelease" },
		{ e_flowControlIndication, "flowControlIndication" },
		{ e_mobileMultilinkReconfigurationIndication, "mobileMultilinkReconfigurationIndication" },
		{ e_genericIndication, "genericIndication" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

IndicationMessage * IndicationMessage :: clone ( ) const {
	return new IndicationMessage ( * this );
}

//
// Capability
//

Capability :: Capability ( Asn :: istream & is ) : Asn :: Choice ( is, 12, true ) {
	switch ( tag ) {
		case e_nonStandard:
			choice = new NonStandardParameter ( is );
			break;
		case e_receiveVideoCapability:
		case e_transmitVideoCapability:
		case e_receiveAndTransmitVideoCapability:
			choice = new VideoCapability ( is );
			break;
		case e_receiveAudioCapability:
		case e_transmitAudioCapability:
		case e_receiveAndTransmitAudioCapability:
			choice = new AudioCapability ( is );
			break;
		case e_receiveDataApplicationCapability:
		case e_transmitDataApplicationCapability:
		case e_receiveAndTransmitDataApplicationCapability:
			choice = new DataApplicationCapability ( is );
			break;
		case e_h233EncryptionTransmitCapability:
			choice = new Asn :: Boolean ( is );
			break;
		case e_h233EncryptionReceiveCapability:
			choice = new Capability_h233EncryptionReceiveCapability ( is );
			break;
		case e_conferenceCapability:
			choice = new ConferenceCapability ( is );
			break;
		case e_h235SecurityCapability:
			choice = new H235SecurityCapability ( is );
			break;
		case e_maxPendingReplacementFor:
			choice = new Capability_maxPendingReplacementFor ( is );
			break;
		case e_receiveUserInputCapability:
		case e_transmitUserInputCapability:
		case e_receiveAndTransmitUserInputCapability:
			choice = new UserInputCapability ( is );
			break;
		case e_genericControlCapability:
			choice = new GenericCapability ( is );
			break;
		case e_receiveMultiplexedStreamCapability:
		case e_transmitMultiplexedStreamCapability:
		case e_receiveAndTransmitMultiplexedStreamCapability:
			choice = new MultiplexedStreamCapability ( is );
			break;
		case e_receiveRTPAudioTelephonyEventCapability:
			choice = new AudioTelephonyEventCapability ( is );
			break;
		case e_receiveRTPAudioToneCapability:
			choice = new AudioToneCapability ( is );
			break;
		case e_depFecCapability:
			choice = new DepFECCapability ( is );
			break;
		case e_multiplePayloadStreamCapability:
			choice = new MultiplePayloadStreamCapability ( is );
			break;
		case e_fecCapability:
			choice = new FECCapability ( is );
			break;
		case e_redundancyEncodingCap:
			choice = new RedundancyEncodingCapability ( is );
			break;
		case e_oneOfCapabilities:
			choice = new AlternativeCapabilitySet ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

Capability :: Capability ( ) : Asn :: Choice ( 12, true ) { }

Capability :: operator NonStandardParameter & ( ) {
	return dynamic_cast < NonStandardParameter & > ( * choice );
}


Capability :: operator const NonStandardParameter & ( ) const {
	return dynamic_cast < const NonStandardParameter & > ( * choice );
}


Capability :: operator VideoCapability & ( ) {
	return dynamic_cast < VideoCapability & > ( * choice );
}


Capability :: operator const VideoCapability & ( ) const {
	return dynamic_cast < const VideoCapability & > ( * choice );
}


Capability :: operator AudioCapability & ( ) {
	return dynamic_cast < AudioCapability & > ( * choice );
}


Capability :: operator const AudioCapability & ( ) const {
	return dynamic_cast < const AudioCapability & > ( * choice );
}


Capability :: operator DataApplicationCapability & ( ) {
	return dynamic_cast < DataApplicationCapability & > ( * choice );
}


Capability :: operator const DataApplicationCapability & ( ) const {
	return dynamic_cast < const DataApplicationCapability & > ( * choice );
}


Capability :: operator Capability_h233EncryptionReceiveCapability & ( ) {
	return dynamic_cast < Capability_h233EncryptionReceiveCapability & > ( * choice );
}


Capability :: operator const Capability_h233EncryptionReceiveCapability & ( ) const {
	return dynamic_cast < const Capability_h233EncryptionReceiveCapability & > ( * choice );
}


Capability :: operator ConferenceCapability & ( ) {
	return dynamic_cast < ConferenceCapability & > ( * choice );
}


Capability :: operator const ConferenceCapability & ( ) const {
	return dynamic_cast < const ConferenceCapability & > ( * choice );
}


Capability :: operator H235SecurityCapability & ( ) {
	return dynamic_cast < H235SecurityCapability & > ( * choice );
}


Capability :: operator const H235SecurityCapability & ( ) const {
	return dynamic_cast < const H235SecurityCapability & > ( * choice );
}


Capability :: operator Capability_maxPendingReplacementFor & ( ) {
	return dynamic_cast < Capability_maxPendingReplacementFor & > ( * choice );
}


Capability :: operator const Capability_maxPendingReplacementFor & ( ) const {
	return dynamic_cast < const Capability_maxPendingReplacementFor & > ( * choice );
}


Capability :: operator UserInputCapability & ( ) {
	return dynamic_cast < UserInputCapability & > ( * choice );
}


Capability :: operator const UserInputCapability & ( ) const {
	return dynamic_cast < const UserInputCapability & > ( * choice );
}


Capability :: operator GenericCapability & ( ) {
	return dynamic_cast < GenericCapability & > ( * choice );
}


Capability :: operator const GenericCapability & ( ) const {
	return dynamic_cast < const GenericCapability & > ( * choice );
}


Capability :: operator MultiplexedStreamCapability & ( ) {
	return dynamic_cast < MultiplexedStreamCapability & > ( * choice );
}


Capability :: operator const MultiplexedStreamCapability & ( ) const {
	return dynamic_cast < const MultiplexedStreamCapability & > ( * choice );
}


Capability :: operator AudioTelephonyEventCapability & ( ) {
	return dynamic_cast < AudioTelephonyEventCapability & > ( * choice );
}


Capability :: operator const AudioTelephonyEventCapability & ( ) const {
	return dynamic_cast < const AudioTelephonyEventCapability & > ( * choice );
}


Capability :: operator AudioToneCapability & ( ) {
	return dynamic_cast < AudioToneCapability & > ( * choice );
}


Capability :: operator const AudioToneCapability & ( ) const {
	return dynamic_cast < const AudioToneCapability & > ( * choice );
}


Capability :: operator DepFECCapability & ( ) {
	return dynamic_cast < DepFECCapability & > ( * choice );
}


Capability :: operator const DepFECCapability & ( ) const {
	return dynamic_cast < const DepFECCapability & > ( * choice );
}


Capability :: operator MultiplePayloadStreamCapability & ( ) {
	return dynamic_cast < MultiplePayloadStreamCapability & > ( * choice );
}


Capability :: operator const MultiplePayloadStreamCapability & ( ) const {
	return dynamic_cast < const MultiplePayloadStreamCapability & > ( * choice );
}


Capability :: operator FECCapability & ( ) {
	return dynamic_cast < FECCapability & > ( * choice );
}


Capability :: operator const FECCapability & ( ) const {
	return dynamic_cast < const FECCapability & > ( * choice );
}


Capability :: operator RedundancyEncodingCapability & ( ) {
	return dynamic_cast < RedundancyEncodingCapability & > ( * choice );
}


Capability :: operator const RedundancyEncodingCapability & ( ) const {
	return dynamic_cast < const RedundancyEncodingCapability & > ( * choice );
}


Capability :: operator AlternativeCapabilitySet & ( ) {
	return dynamic_cast < AlternativeCapabilitySet & > ( * choice );
}


Capability :: operator const AlternativeCapabilitySet & ( ) const {
	return dynamic_cast < const AlternativeCapabilitySet & > ( * choice );
}


void Capability :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandard:
			o = new NonStandardParameter;
			break;
		case e_receiveVideoCapability:
		case e_transmitVideoCapability:
		case e_receiveAndTransmitVideoCapability:
			o = new VideoCapability;
			break;
		case e_receiveAudioCapability:
		case e_transmitAudioCapability:
		case e_receiveAndTransmitAudioCapability:
			o = new AudioCapability;
			break;
		case e_receiveDataApplicationCapability:
		case e_transmitDataApplicationCapability:
		case e_receiveAndTransmitDataApplicationCapability:
			o = new DataApplicationCapability;
			break;
		case e_h233EncryptionTransmitCapability:
			o = new Asn :: Boolean;
			break;
		case e_h233EncryptionReceiveCapability:
			o = new Capability_h233EncryptionReceiveCapability;
			break;
		case e_conferenceCapability:
			o = new ConferenceCapability;
			break;
		case e_h235SecurityCapability:
			o = new H235SecurityCapability;
			break;
		case e_maxPendingReplacementFor:
			o = new Capability_maxPendingReplacementFor;
			break;
		case e_receiveUserInputCapability:
		case e_transmitUserInputCapability:
		case e_receiveAndTransmitUserInputCapability:
			o = new UserInputCapability;
			break;
		case e_genericControlCapability:
			o = new GenericCapability;
			break;
		case e_receiveMultiplexedStreamCapability:
		case e_transmitMultiplexedStreamCapability:
		case e_receiveAndTransmitMultiplexedStreamCapability:
			o = new MultiplexedStreamCapability;
			break;
		case e_receiveRTPAudioTelephonyEventCapability:
			o = new AudioTelephonyEventCapability;
			break;
		case e_receiveRTPAudioToneCapability:
			o = new AudioToneCapability;
			break;
		case e_depFecCapability:
			o = new DepFECCapability;
			break;
		case e_multiplePayloadStreamCapability:
			o = new MultiplePayloadStreamCapability;
			break;
		case e_fecCapability:
			o = new FECCapability;
			break;
		case e_redundancyEncodingCap:
			o = new RedundancyEncodingCapability;
			break;
		case e_oneOfCapabilities:
			o = new AlternativeCapabilitySet;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & Capability :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandard, "nonStandard" },
		{ e_receiveVideoCapability, "receiveVideoCapability" },
		{ e_transmitVideoCapability, "transmitVideoCapability" },
		{ e_receiveAndTransmitVideoCapability, "receiveAndTransmitVideoCapability" },
		{ e_receiveAudioCapability, "receiveAudioCapability" },
		{ e_transmitAudioCapability, "transmitAudioCapability" },
		{ e_receiveAndTransmitAudioCapability, "receiveAndTransmitAudioCapability" },
		{ e_receiveDataApplicationCapability, "receiveDataApplicationCapability" },
		{ e_transmitDataApplicationCapability, "transmitDataApplicationCapability" },
		{ e_receiveAndTransmitDataApplicationCapability, "receiveAndTransmitDataApplicationCapability" },
		{ e_h233EncryptionTransmitCapability, "h233EncryptionTransmitCapability" },
		{ e_h233EncryptionReceiveCapability, "h233EncryptionReceiveCapability" },
		{ e_conferenceCapability, "conferenceCapability" },
		{ e_h235SecurityCapability, "h235SecurityCapability" },
		{ e_maxPendingReplacementFor, "maxPendingReplacementFor" },
		{ e_receiveUserInputCapability, "receiveUserInputCapability" },
		{ e_transmitUserInputCapability, "transmitUserInputCapability" },
		{ e_receiveAndTransmitUserInputCapability, "receiveAndTransmitUserInputCapability" },
		{ e_genericControlCapability, "genericControlCapability" },
		{ e_receiveMultiplexedStreamCapability, "receiveMultiplexedStreamCapability" },
		{ e_transmitMultiplexedStreamCapability, "transmitMultiplexedStreamCapability" },
		{ e_receiveAndTransmitMultiplexedStreamCapability, "receiveAndTransmitMultiplexedStreamCapability" },
		{ e_receiveRTPAudioTelephonyEventCapability, "receiveRTPAudioTelephonyEventCapability" },
		{ e_receiveRTPAudioToneCapability, "receiveRTPAudioToneCapability" },
		{ e_depFecCapability, "depFecCapability" },
		{ e_multiplePayloadStreamCapability, "multiplePayloadStreamCapability" },
		{ e_fecCapability, "fecCapability" },
		{ e_redundancyEncodingCap, "redundancyEncodingCap" },
		{ e_oneOfCapabilities, "oneOfCapabilities" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

Capability * Capability :: clone ( ) const {
	return new Capability ( * this );
}

//
// AudioCapability
//

AudioCapability :: AudioCapability ( Asn :: istream & is ) : Asn :: Choice ( is, 14, true ) {
	switch ( tag ) {
		case e_nonStandard:
			choice = new NonStandardParameter ( is );
			break;
		case e_g711Alaw64k:
			choice = new AudioCapability_g711Alaw64k ( is );
			break;
		case e_g711Alaw56k:
			choice = new AudioCapability_g711Alaw56k ( is );
			break;
		case e_g711Ulaw64k:
			choice = new AudioCapability_g711Ulaw64k ( is );
			break;
		case e_g711Ulaw56k:
			choice = new AudioCapability_g711Ulaw56k ( is );
			break;
		case e_g722_64k:
			choice = new AudioCapability_g722_64k ( is );
			break;
		case e_g722_56k:
			choice = new AudioCapability_g722_56k ( is );
			break;
		case e_g722_48k:
			choice = new AudioCapability_g722_48k ( is );
			break;
		case e_g7231:
			choice = new AudioCapability_g7231 ( is );
			break;
		case e_g728:
			choice = new AudioCapability_g728 ( is );
			break;
		case e_g729:
			choice = new AudioCapability_g729 ( is );
			break;
		case e_g729AnnexA:
			choice = new AudioCapability_g729AnnexA ( is );
			break;
		case e_is11172AudioCapability:
			choice = new IS11172AudioCapability ( is );
			break;
		case e_is13818AudioCapability:
			choice = new IS13818AudioCapability ( is );
			break;
		case e_g729wAnnexB:
			choice = new AudioCapability_g729wAnnexB ( is );
			break;
		case e_g729AnnexAwAnnexB:
			choice = new AudioCapability_g729AnnexAwAnnexB ( is );
			break;
		case e_g7231AnnexCCapability:
			choice = new G7231AnnexCCapability ( is );
			break;
		case e_gsmFullRate:
		case e_gsmHalfRate:
		case e_gsmEnhancedFullRate:
			choice = new GSMAudioCapability ( is );
			break;
		case e_genericAudioCapability:
			choice = new GenericCapability ( is );
			break;
		case e_g729Extensions:
			choice = new G729Extensions ( is );
			break;
		case e_vbd:
			choice = new VBDCapability ( is );
			break;
		case e_audioTelephonyEvent:
			choice = new NoPTAudioTelephonyEventCapability ( is );
			break;
		case e_audioTone:
			choice = new NoPTAudioToneCapability ( is );
			break;
		default:
			if ( nextPosition ) {
				unsigned l = unsigned ( nextPosition - is.getPosition ( ) );
				choice = new Asn :: OctetString ( is, Asn :: fixedConstraint, l, l );
			} else
				throw std :: runtime_error ( "unknown choice" );
	}
	if ( nextPosition )
		is.setPosition ( nextPosition );
}

AudioCapability :: AudioCapability ( ) : Asn :: Choice ( 14, true ) { }

AudioCapability :: operator NonStandardParameter & ( ) {
	return dynamic_cast < NonStandardParameter & > ( * choice );
}


AudioCapability :: operator const NonStandardParameter & ( ) const {
	return dynamic_cast < const NonStandardParameter & > ( * choice );
}


AudioCapability :: operator AudioCapability_g711Alaw64k & ( ) {
	return dynamic_cast < AudioCapability_g711Alaw64k & > ( * choice );
}


AudioCapability :: operator const AudioCapability_g711Alaw64k & ( ) const {
	return dynamic_cast < const AudioCapability_g711Alaw64k & > ( * choice );
}


AudioCapability :: operator AudioCapability_g711Alaw56k & ( ) {
	return dynamic_cast < AudioCapability_g711Alaw56k & > ( * choice );
}


AudioCapability :: operator const AudioCapability_g711Alaw56k & ( ) const {
	return dynamic_cast < const AudioCapability_g711Alaw56k & > ( * choice );
}


AudioCapability :: operator AudioCapability_g711Ulaw64k & ( ) {
	return dynamic_cast < AudioCapability_g711Ulaw64k & > ( * choice );
}


AudioCapability :: operator const AudioCapability_g711Ulaw64k & ( ) const {
	return dynamic_cast < const AudioCapability_g711Ulaw64k & > ( * choice );
}


AudioCapability :: operator AudioCapability_g711Ulaw56k & ( ) {
	return dynamic_cast < AudioCapability_g711Ulaw56k & > ( * choice );
}


AudioCapability :: operator const AudioCapability_g711Ulaw56k & ( ) const {
	return dynamic_cast < const AudioCapability_g711Ulaw56k & > ( * choice );
}


AudioCapability :: operator AudioCapability_g722_64k & ( ) {
	return dynamic_cast < AudioCapability_g722_64k & > ( * choice );
}


AudioCapability :: operator const AudioCapability_g722_64k & ( ) const {
	return dynamic_cast < const AudioCapability_g722_64k & > ( * choice );
}


AudioCapability :: operator AudioCapability_g722_56k & ( ) {
	return dynamic_cast < AudioCapability_g722_56k & > ( * choice );
}


AudioCapability :: operator const AudioCapability_g722_56k & ( ) const {
	return dynamic_cast < const AudioCapability_g722_56k & > ( * choice );
}


AudioCapability :: operator AudioCapability_g722_48k & ( ) {
	return dynamic_cast < AudioCapability_g722_48k & > ( * choice );
}


AudioCapability :: operator const AudioCapability_g722_48k & ( ) const {
	return dynamic_cast < const AudioCapability_g722_48k & > ( * choice );
}


AudioCapability :: operator AudioCapability_g7231 & ( ) {
	return dynamic_cast < AudioCapability_g7231 & > ( * choice );
}


AudioCapability :: operator const AudioCapability_g7231 & ( ) const {
	return dynamic_cast < const AudioCapability_g7231 & > ( * choice );
}


AudioCapability :: operator AudioCapability_g728 & ( ) {
	return dynamic_cast < AudioCapability_g728 & > ( * choice );
}


AudioCapability :: operator const AudioCapability_g728 & ( ) const {
	return dynamic_cast < const AudioCapability_g728 & > ( * choice );
}


AudioCapability :: operator AudioCapability_g729 & ( ) {
	return dynamic_cast < AudioCapability_g729 & > ( * choice );
}


AudioCapability :: operator const AudioCapability_g729 & ( ) const {
	return dynamic_cast < const AudioCapability_g729 & > ( * choice );
}


AudioCapability :: operator AudioCapability_g729AnnexA & ( ) {
	return dynamic_cast < AudioCapability_g729AnnexA & > ( * choice );
}


AudioCapability :: operator const AudioCapability_g729AnnexA & ( ) const {
	return dynamic_cast < const AudioCapability_g729AnnexA & > ( * choice );
}


AudioCapability :: operator IS11172AudioCapability & ( ) {
	return dynamic_cast < IS11172AudioCapability & > ( * choice );
}


AudioCapability :: operator const IS11172AudioCapability & ( ) const {
	return dynamic_cast < const IS11172AudioCapability & > ( * choice );
}


AudioCapability :: operator IS13818AudioCapability & ( ) {
	return dynamic_cast < IS13818AudioCapability & > ( * choice );
}


AudioCapability :: operator const IS13818AudioCapability & ( ) const {
	return dynamic_cast < const IS13818AudioCapability & > ( * choice );
}


AudioCapability :: operator AudioCapability_g729wAnnexB & ( ) {
	return dynamic_cast < AudioCapability_g729wAnnexB & > ( * choice );
}


AudioCapability :: operator const AudioCapability_g729wAnnexB & ( ) const {
	return dynamic_cast < const AudioCapability_g729wAnnexB & > ( * choice );
}


AudioCapability :: operator AudioCapability_g729AnnexAwAnnexB & ( ) {
	return dynamic_cast < AudioCapability_g729AnnexAwAnnexB & > ( * choice );
}


AudioCapability :: operator const AudioCapability_g729AnnexAwAnnexB & ( ) const {
	return dynamic_cast < const AudioCapability_g729AnnexAwAnnexB & > ( * choice );
}


AudioCapability :: operator G7231AnnexCCapability & ( ) {
	return dynamic_cast < G7231AnnexCCapability & > ( * choice );
}


AudioCapability :: operator const G7231AnnexCCapability & ( ) const {
	return dynamic_cast < const G7231AnnexCCapability & > ( * choice );
}


AudioCapability :: operator GSMAudioCapability & ( ) {
	return dynamic_cast < GSMAudioCapability & > ( * choice );
}


AudioCapability :: operator const GSMAudioCapability & ( ) const {
	return dynamic_cast < const GSMAudioCapability & > ( * choice );
}


AudioCapability :: operator GenericCapability & ( ) {
	return dynamic_cast < GenericCapability & > ( * choice );
}


AudioCapability :: operator const GenericCapability & ( ) const {
	return dynamic_cast < const GenericCapability & > ( * choice );
}


AudioCapability :: operator G729Extensions & ( ) {
	return dynamic_cast < G729Extensions & > ( * choice );
}


AudioCapability :: operator const G729Extensions & ( ) const {
	return dynamic_cast < const G729Extensions & > ( * choice );
}


AudioCapability :: operator VBDCapability & ( ) {
	return dynamic_cast < VBDCapability & > ( * choice );
}


AudioCapability :: operator const VBDCapability & ( ) const {
	return dynamic_cast < const VBDCapability & > ( * choice );
}


AudioCapability :: operator NoPTAudioTelephonyEventCapability & ( ) {
	return dynamic_cast < NoPTAudioTelephonyEventCapability & > ( * choice );
}


AudioCapability :: operator const NoPTAudioTelephonyEventCapability & ( ) const {
	return dynamic_cast < const NoPTAudioTelephonyEventCapability & > ( * choice );
}


AudioCapability :: operator NoPTAudioToneCapability & ( ) {
	return dynamic_cast < NoPTAudioToneCapability & > ( * choice );
}


AudioCapability :: operator const NoPTAudioToneCapability & ( ) const {
	return dynamic_cast < const NoPTAudioToneCapability & > ( * choice );
}


void AudioCapability :: setTag ( Choices t ) {
	Object * o = 0;
	switch ( t ) {
		case e_nonStandard:
			o = new NonStandardParameter;
			break;
		case e_g711Alaw64k:
			o = new AudioCapability_g711Alaw64k;
			break;
		case e_g711Alaw56k:
			o = new AudioCapability_g711Alaw56k;
			break;
		case e_g711Ulaw64k:
			o = new AudioCapability_g711Ulaw64k;
			break;
		case e_g711Ulaw56k:
			o = new AudioCapability_g711Ulaw56k;
			break;
		case e_g722_64k:
			o = new AudioCapability_g722_64k;
			break;
		case e_g722_56k:
			o = new AudioCapability_g722_56k;
			break;
		case e_g722_48k:
			o = new AudioCapability_g722_48k;
			break;
		case e_g7231:
			o = new AudioCapability_g7231;
			break;
		case e_g728:
			o = new AudioCapability_g728;
			break;
		case e_g729:
			o = new AudioCapability_g729;
			break;
		case e_g729AnnexA:
			o = new AudioCapability_g729AnnexA;
			break;
		case e_is11172AudioCapability:
			o = new IS11172AudioCapability;
			break;
		case e_is13818AudioCapability:
			o = new IS13818AudioCapability;
			break;
		case e_g729wAnnexB:
			o = new AudioCapability_g729wAnnexB;
			break;
		case e_g729AnnexAwAnnexB:
			o = new AudioCapability_g729AnnexAwAnnexB;
			break;
		case e_g7231AnnexCCapability:
			o = new G7231AnnexCCapability;
			break;
		case e_gsmFullRate:
		case e_gsmHalfRate:
		case e_gsmEnhancedFullRate:
			o = new GSMAudioCapability;
			break;
		case e_genericAudioCapability:
			o = new GenericCapability;
			break;
		case e_g729Extensions:
			o = new G729Extensions;
			break;
		case e_vbd:
			o = new VBDCapability;
			break;
		case e_audioTelephonyEvent:
			o = new NoPTAudioTelephonyEventCapability;
			break;
		case e_audioTone:
			o = new NoPTAudioToneCapability;
			break;
		default:
			throw std :: runtime_error ( "unknown choice" );
	}
	Asn :: Choice :: setTag ( t, o );
}

const Asn :: NamesMapType & AudioCapability :: getNames ( ) const {
	static Asn :: NamesPair namePairs [ ] = {
		{ e_nonStandard, "nonStandard" },
		{ e_g711Alaw64k, "g711Alaw64k" },
		{ e_g711Alaw56k, "g711Alaw56k" },
		{ e_g711Ulaw64k, "g711Ulaw64k" },
		{ e_g711Ulaw56k, "g711Ulaw56k" },
		{ e_g722_64k, "g722_64k" },
		{ e_g722_56k, "g722_56k" },
		{ e_g722_48k, "g722_48k" },
		{ e_g7231, "g7231" },
		{ e_g728, "g728" },
		{ e_g729, "g729" },
		{ e_g729AnnexA, "g729AnnexA" },
		{ e_is11172AudioCapability, "is11172AudioCapability" },
		{ e_is13818AudioCapability, "is13818AudioCapability" },
		{ e_g729wAnnexB, "g729wAnnexB" },
		{ e_g729AnnexAwAnnexB, "g729AnnexAwAnnexB" },
		{ e_g7231AnnexCCapability, "g7231AnnexCCapability" },
		{ e_gsmFullRate, "gsmFullRate" },
		{ e_gsmHalfRate, "gsmHalfRate" },
		{ e_gsmEnhancedFullRate, "gsmEnhancedFullRate" },
		{ e_genericAudioCapability, "genericAudioCapability" },
		{ e_g729Extensions, "g729Extensions" },
		{ e_vbd, "vbd" },
		{ e_audioTelephonyEvent, "audioTelephonyEvent" },
		{ e_audioTone, "audioTone" }
	};
	static Asn :: NamesMapType namesMap ( namePairs, namePairs + sizeof ( namePairs ) / sizeof ( * namePairs ) );
	return namesMap;
}

AudioCapability * AudioCapability :: clone ( ) const {
	return new AudioCapability ( * this );
}

//
// VBDCapability
//

VBDCapability :: VBDCapability ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_type ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

VBDCapability :: VBDCapability ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void VBDCapability :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_type.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void VBDCapability :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 7 ) << "type = " << std :: setprecision ( indent ) << m_type << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

VBDCapability * VBDCapability :: clone ( ) const {
	return new VBDCapability ( * this );
}

//
// OpenLogicalChannel
//

OpenLogicalChannel :: OpenLogicalChannel ( Asn :: istream & is ) : Asn :: Sequence ( is, 1, true, 3 ), m_forwardLogicalChannelNumber ( is ), m_forwardLogicalChannelParameters ( is ), m_reverseLogicalChannelParameters ( 0 ), m_separateStack ( 0 ), m_encryptionSync ( 0 ), m_genericInformation ( 0 ) {
	try {
		if ( hasOptionalField ( e_reverseLogicalChannelParameters ) )
			m_reverseLogicalChannelParameters = new OpenLogicalChannel_reverseLogicalChannelParameters ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_separateStack ) )
				m_separateStack = new NetworkAccessParameters ( is );
			if ( hasKnownExtensionToDecode ( is, e_encryptionSync ) )
				m_encryptionSync = new EncryptionSync ( is );
			if ( hasKnownExtensionToDecode ( is, e_genericInformation ) )
				m_genericInformation = new ArrayOf_GenericInformation ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_reverseLogicalChannelParameters;
		delete m_separateStack;
		delete m_encryptionSync;
		delete m_genericInformation;
		throw;
	}
}

OpenLogicalChannel :: OpenLogicalChannel ( ) : Asn :: Sequence ( 1, true, 3 ), m_reverseLogicalChannelParameters ( 0 ), m_separateStack ( 0 ), m_encryptionSync ( 0 ), m_genericInformation ( 0 ) { }

OpenLogicalChannel & OpenLogicalChannel :: operator= ( const OpenLogicalChannel & s ) {
	Asn :: Sequence :: operator= ( s );
	m_forwardLogicalChannelNumber = s.m_forwardLogicalChannelNumber;
	m_forwardLogicalChannelParameters = s.m_forwardLogicalChannelParameters;
	assignCopy ( m_reverseLogicalChannelParameters, s.m_reverseLogicalChannelParameters );
	assignCopy ( m_separateStack, s.m_separateStack );
	assignCopy ( m_encryptionSync, s.m_encryptionSync );
	assignCopy ( m_genericInformation, s.m_genericInformation );
	return * this;
}

OpenLogicalChannel :: OpenLogicalChannel ( const OpenLogicalChannel & s ) : Asn :: Sequence ( s ), m_forwardLogicalChannelNumber ( s.m_forwardLogicalChannelNumber ), m_forwardLogicalChannelParameters ( s.m_forwardLogicalChannelParameters ), m_reverseLogicalChannelParameters ( 0 ), m_separateStack ( 0 ), m_encryptionSync ( 0 ), m_genericInformation ( 0 ) {
	try {
		if ( s.m_reverseLogicalChannelParameters )
			m_reverseLogicalChannelParameters = new OpenLogicalChannel_reverseLogicalChannelParameters ( * s.m_reverseLogicalChannelParameters );
		if ( s.m_separateStack )
			m_separateStack = new NetworkAccessParameters ( * s.m_separateStack );
		if ( s.m_encryptionSync )
			m_encryptionSync = new EncryptionSync ( * s.m_encryptionSync );
		if ( s.m_genericInformation )
			m_genericInformation = new ArrayOf_GenericInformation ( * s.m_genericInformation );
	} catch ( ... ) {
		delete m_reverseLogicalChannelParameters;
		delete m_separateStack;
		delete m_encryptionSync;
		delete m_genericInformation;
		throw;
	}
}


void OpenLogicalChannel :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_reverseLogicalChannelParameters:
			assignNew ( m_reverseLogicalChannelParameters, new OpenLogicalChannel_reverseLogicalChannelParameters );
			break;
		case e_separateStack:
			assignNew ( m_separateStack, new NetworkAccessParameters );
			break;
		case e_encryptionSync:
			assignNew ( m_encryptionSync, new EncryptionSync );
			break;
		case e_genericInformation:
			assignNew ( m_genericInformation, new ArrayOf_GenericInformation );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void OpenLogicalChannel :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_reverseLogicalChannelParameters:
			delete m_reverseLogicalChannelParameters;
			m_reverseLogicalChannelParameters = 0;
			break;
		case e_separateStack:
			delete m_separateStack;
			m_separateStack = 0;
			break;
		case e_encryptionSync:
			delete m_encryptionSync;
			m_encryptionSync = 0;
			break;
		case e_genericInformation:
			delete m_genericInformation;
			m_genericInformation = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void OpenLogicalChannel :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_forwardLogicalChannelNumber.encode ( os );
	m_forwardLogicalChannelParameters.encode ( os );
	if ( hasOptionalField ( e_reverseLogicalChannelParameters ) )
		m_reverseLogicalChannelParameters -> OpenLogicalChannel_reverseLogicalChannelParameters :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_separateStack, m_separateStack );
		knownExtensionEncode ( os, e_encryptionSync, m_encryptionSync );
		knownExtensionEncode ( os, e_genericInformation, m_genericInformation );
		unknownExtensionsEncode ( os );
	}
}

OpenLogicalChannel :: ~OpenLogicalChannel ( ) {
	delete m_reverseLogicalChannelParameters;
	delete m_separateStack;
	delete m_encryptionSync;
	delete m_genericInformation;
}

void OpenLogicalChannel :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 30 ) << "forwardLogicalChannelNumber = " << std :: setprecision ( indent ) << m_forwardLogicalChannelNumber << '\n';
	os << std :: setw ( indent + 34 ) << "forwardLogicalChannelParameters = " << std :: setprecision ( indent ) << m_forwardLogicalChannelParameters << '\n';
	if ( hasOptionalField ( e_reverseLogicalChannelParameters ) ) {
		os << std :: setw ( indent + 34 ) << "reverseLogicalChannelParameters = " << std :: setprecision ( indent );
		m_reverseLogicalChannelParameters -> OpenLogicalChannel_reverseLogicalChannelParameters :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_separateStack ) ) {
		os << std :: setw ( indent + 16 ) << "separateStack = " << std :: setprecision ( indent );
		m_separateStack -> NetworkAccessParameters :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_encryptionSync ) ) {
		os << std :: setw ( indent + 17 ) << "encryptionSync = " << std :: setprecision ( indent );
		m_encryptionSync -> EncryptionSync :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_genericInformation ) ) {
		os << std :: setw ( indent + 21 ) << "genericInformation = " << std :: setprecision ( indent );
		m_genericInformation -> ArrayOf_GenericInformation :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

OpenLogicalChannel * OpenLogicalChannel :: clone ( ) const {
	return new OpenLogicalChannel ( * this );
}

//
// H235Media
//

H235Media :: H235Media ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_encryptionAuthenticationAndIntegrity ( is ), m_mediaType ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

H235Media :: H235Media ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void H235Media :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_encryptionAuthenticationAndIntegrity.encode ( os );
	m_mediaType.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void H235Media :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 39 ) << "encryptionAuthenticationAndIntegrity = " << std :: setprecision ( indent ) << m_encryptionAuthenticationAndIntegrity << '\n';
	os << std :: setw ( indent + 12 ) << "mediaType = " << std :: setprecision ( indent ) << m_mediaType << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H235Media * H235Media :: clone ( ) const {
	return new H235Media ( * this );
}

//
// H235Mode
//

H235Mode :: H235Mode ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_encryptionAuthenticationAndIntegrity ( is ), m_mediaMode ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

H235Mode :: H235Mode ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void H235Mode :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_encryptionAuthenticationAndIntegrity.encode ( os );
	m_mediaMode.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void H235Mode :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 39 ) << "encryptionAuthenticationAndIntegrity = " << std :: setprecision ( indent ) << m_encryptionAuthenticationAndIntegrity << '\n';
	os << std :: setw ( indent + 12 ) << "mediaMode = " << std :: setprecision ( indent ) << m_mediaMode << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

H235Mode * H235Mode :: clone ( ) const {
	return new H235Mode ( * this );
}

//
// RedundancyEncodingDTModeElement
//

RedundancyEncodingDTModeElement :: RedundancyEncodingDTModeElement ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_type ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

RedundancyEncodingDTModeElement :: RedundancyEncodingDTModeElement ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void RedundancyEncodingDTModeElement :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_type.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void RedundancyEncodingDTModeElement :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 7 ) << "type = " << std :: setprecision ( indent ) << m_type << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RedundancyEncodingDTModeElement * RedundancyEncodingDTModeElement :: clone ( ) const {
	return new RedundancyEncodingDTModeElement ( * this );
}

//
// CommunicationModeTableEntry
//

CommunicationModeTableEntry :: CommunicationModeTableEntry ( Asn :: istream & is ) : Asn :: Sequence ( is, 7, true, 3 ), m_nonStandard ( hasOptionalField ( e_nonStandard ) ? pushTemporaryMember ( new ArrayOf_NonStandardParameter ( is ) ) : 0 ), m_sessionID ( is ), m_associatedSessionID ( hasOptionalField ( e_associatedSessionID ) ? pushTemporaryMember ( new CommunicationModeTableEntry_associatedSessionID ( is ) ) : 0 ), m_terminalLabel ( hasOptionalField ( e_terminalLabel ) ? pushTemporaryMember ( new TerminalLabel ( is ) ) : 0 ), m_sessionDescription ( is ), m_dataType ( is ), m_mediaChannel ( 0 ), m_mediaGuaranteedDelivery ( 0 ), m_mediaControlChannel ( 0 ), m_mediaControlGuaranteedDelivery ( 0 ), m_redundancyEncoding ( 0 ), m_sessionDependency ( 0 ), m_destination ( 0 ) {
	clearTemporaryMembers ( );
	try {
		if ( hasOptionalField ( e_mediaChannel ) )
			m_mediaChannel = new TransportAddress ( is );
		if ( hasOptionalField ( e_mediaGuaranteedDelivery ) )
			m_mediaGuaranteedDelivery = new Asn :: Boolean ( is );
		if ( hasOptionalField ( e_mediaControlChannel ) )
			m_mediaControlChannel = new TransportAddress ( is );
		if ( hasOptionalField ( e_mediaControlGuaranteedDelivery ) )
			m_mediaControlGuaranteedDelivery = new Asn :: Boolean ( is );
		if ( extensionMapDecode ( is ) ) {
			if ( hasKnownExtensionToDecode ( is, e_redundancyEncoding ) )
				m_redundancyEncoding = new RedundancyEncoding ( is );
			if ( hasKnownExtensionToDecode ( is, e_sessionDependency ) )
				m_sessionDependency = new CommunicationModeTableEntry_sessionDependency ( is );
			if ( hasKnownExtensionToDecode ( is, e_destination ) )
				m_destination = new TerminalLabel ( is );
			unknownExtensionsDecode ( is );
		}
	} catch ( ... ) {
		delete m_nonStandard;
		delete m_associatedSessionID;
		delete m_terminalLabel;
		delete m_mediaChannel;
		delete m_mediaGuaranteedDelivery;
		delete m_mediaControlChannel;
		delete m_mediaControlGuaranteedDelivery;
		delete m_redundancyEncoding;
		delete m_sessionDependency;
		delete m_destination;
		throw;
	}
}

CommunicationModeTableEntry :: CommunicationModeTableEntry ( ) : Asn :: Sequence ( 7, true, 3 ), m_nonStandard ( 0 ), m_associatedSessionID ( 0 ), m_terminalLabel ( 0 ), m_mediaChannel ( 0 ), m_mediaGuaranteedDelivery ( 0 ), m_mediaControlChannel ( 0 ), m_mediaControlGuaranteedDelivery ( 0 ), m_redundancyEncoding ( 0 ), m_sessionDependency ( 0 ), m_destination ( 0 ) { }

CommunicationModeTableEntry & CommunicationModeTableEntry :: operator= ( const CommunicationModeTableEntry & s ) {
	Asn :: Sequence :: operator= ( s );
	assignCopy ( m_nonStandard, s.m_nonStandard );
	m_sessionID = s.m_sessionID;
	assignCopy ( m_associatedSessionID, s.m_associatedSessionID );
	assignCopy ( m_terminalLabel, s.m_terminalLabel );
	m_sessionDescription = s.m_sessionDescription;
	m_dataType = s.m_dataType;
	assignCopy ( m_mediaChannel, s.m_mediaChannel );
	assignCopy ( m_mediaGuaranteedDelivery, s.m_mediaGuaranteedDelivery );
	assignCopy ( m_mediaControlChannel, s.m_mediaControlChannel );
	assignCopy ( m_mediaControlGuaranteedDelivery, s.m_mediaControlGuaranteedDelivery );
	assignCopy ( m_redundancyEncoding, s.m_redundancyEncoding );
	assignCopy ( m_sessionDependency, s.m_sessionDependency );
	assignCopy ( m_destination, s.m_destination );
	return * this;
}

CommunicationModeTableEntry :: CommunicationModeTableEntry ( const CommunicationModeTableEntry & s ) : Asn :: Sequence ( s ), m_nonStandard ( 0 ), m_sessionID ( s.m_sessionID ), m_associatedSessionID ( 0 ), m_terminalLabel ( 0 ), m_sessionDescription ( s.m_sessionDescription ), m_dataType ( s.m_dataType ), m_mediaChannel ( 0 ), m_mediaGuaranteedDelivery ( 0 ), m_mediaControlChannel ( 0 ), m_mediaControlGuaranteedDelivery ( 0 ), m_redundancyEncoding ( 0 ), m_sessionDependency ( 0 ), m_destination ( 0 ) {
	try {
		if ( s.m_nonStandard )
			m_nonStandard = new ArrayOf_NonStandardParameter ( * s.m_nonStandard );
		if ( s.m_associatedSessionID )
			m_associatedSessionID = new CommunicationModeTableEntry_associatedSessionID ( * s.m_associatedSessionID );
		if ( s.m_terminalLabel )
			m_terminalLabel = new TerminalLabel ( * s.m_terminalLabel );
		if ( s.m_mediaChannel )
			m_mediaChannel = new TransportAddress ( * s.m_mediaChannel );
		if ( s.m_mediaGuaranteedDelivery )
			m_mediaGuaranteedDelivery = new Asn :: Boolean ( * s.m_mediaGuaranteedDelivery );
		if ( s.m_mediaControlChannel )
			m_mediaControlChannel = new TransportAddress ( * s.m_mediaControlChannel );
		if ( s.m_mediaControlGuaranteedDelivery )
			m_mediaControlGuaranteedDelivery = new Asn :: Boolean ( * s.m_mediaControlGuaranteedDelivery );
		if ( s.m_redundancyEncoding )
			m_redundancyEncoding = new RedundancyEncoding ( * s.m_redundancyEncoding );
		if ( s.m_sessionDependency )
			m_sessionDependency = new CommunicationModeTableEntry_sessionDependency ( * s.m_sessionDependency );
		if ( s.m_destination )
			m_destination = new TerminalLabel ( * s.m_destination );
	} catch ( ... ) {
		delete m_nonStandard;
		delete m_associatedSessionID;
		delete m_terminalLabel;
		delete m_mediaChannel;
		delete m_mediaGuaranteedDelivery;
		delete m_mediaControlChannel;
		delete m_mediaControlGuaranteedDelivery;
		delete m_redundancyEncoding;
		delete m_sessionDependency;
		delete m_destination;
		throw;
	}
}


void CommunicationModeTableEntry :: includeOptionalField ( OptionalFields f ) {
	switch ( f ) {
		case e_nonStandard:
			assignNew ( m_nonStandard, new ArrayOf_NonStandardParameter );
			break;
		case e_associatedSessionID:
			assignNew ( m_associatedSessionID, new CommunicationModeTableEntry_associatedSessionID );
			break;
		case e_terminalLabel:
			assignNew ( m_terminalLabel, new TerminalLabel );
			break;
		case e_mediaChannel:
			assignNew ( m_mediaChannel, new TransportAddress );
			break;
		case e_mediaGuaranteedDelivery:
			assignNew ( m_mediaGuaranteedDelivery, new Asn :: Boolean );
			break;
		case e_mediaControlChannel:
			assignNew ( m_mediaControlChannel, new TransportAddress );
			break;
		case e_mediaControlGuaranteedDelivery:
			assignNew ( m_mediaControlGuaranteedDelivery, new Asn :: Boolean );
			break;
		case e_redundancyEncoding:
			assignNew ( m_redundancyEncoding, new RedundancyEncoding );
			break;
		case e_sessionDependency:
			assignNew ( m_sessionDependency, new CommunicationModeTableEntry_sessionDependency );
			break;
		case e_destination:
			assignNew ( m_destination, new TerminalLabel );
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
	Asn :: Sequence :: includeOptionalField ( f );
}

void CommunicationModeTableEntry :: removeOptionalField ( OptionalFields f ) {
	Asn :: Sequence :: removeOptionalField ( f );
	switch ( f ) {
		case e_nonStandard:
			delete m_nonStandard;
			m_nonStandard = 0;
			break;
		case e_associatedSessionID:
			delete m_associatedSessionID;
			m_associatedSessionID = 0;
			break;
		case e_terminalLabel:
			delete m_terminalLabel;
			m_terminalLabel = 0;
			break;
		case e_mediaChannel:
			delete m_mediaChannel;
			m_mediaChannel = 0;
			break;
		case e_mediaGuaranteedDelivery:
			delete m_mediaGuaranteedDelivery;
			m_mediaGuaranteedDelivery = 0;
			break;
		case e_mediaControlChannel:
			delete m_mediaControlChannel;
			m_mediaControlChannel = 0;
			break;
		case e_mediaControlGuaranteedDelivery:
			delete m_mediaControlGuaranteedDelivery;
			m_mediaControlGuaranteedDelivery = 0;
			break;
		case e_redundancyEncoding:
			delete m_redundancyEncoding;
			m_redundancyEncoding = 0;
			break;
		case e_sessionDependency:
			delete m_sessionDependency;
			m_sessionDependency = 0;
			break;
		case e_destination:
			delete m_destination;
			m_destination = 0;
			break;
		default:
			throw std :: out_of_range ( "unknown optional field" );
	}
}

void CommunicationModeTableEntry :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	if ( hasOptionalField ( e_nonStandard ) )
		m_nonStandard -> ArrayOf_NonStandardParameter :: encode ( os );
	m_sessionID.encode ( os );
	if ( hasOptionalField ( e_associatedSessionID ) )
		m_associatedSessionID -> CommunicationModeTableEntry_associatedSessionID :: encode ( os );
	if ( hasOptionalField ( e_terminalLabel ) )
		m_terminalLabel -> TerminalLabel :: encode ( os );
	m_sessionDescription.encode ( os );
	m_dataType.encode ( os );
	if ( hasOptionalField ( e_mediaChannel ) )
		m_mediaChannel -> TransportAddress :: encode ( os );
	if ( hasOptionalField ( e_mediaGuaranteedDelivery ) )
		m_mediaGuaranteedDelivery -> Asn :: Boolean :: encode ( os );
	if ( hasOptionalField ( e_mediaControlChannel ) )
		m_mediaControlChannel -> TransportAddress :: encode ( os );
	if ( hasOptionalField ( e_mediaControlGuaranteedDelivery ) )
		m_mediaControlGuaranteedDelivery -> Asn :: Boolean :: encode ( os );
	if ( extensionMapEncode ( os ) ) {
		knownExtensionEncode ( os, e_redundancyEncoding, m_redundancyEncoding );
		knownExtensionEncode ( os, e_sessionDependency, m_sessionDependency );
		knownExtensionEncode ( os, e_destination, m_destination );
		unknownExtensionsEncode ( os );
	}
}

CommunicationModeTableEntry :: ~CommunicationModeTableEntry ( ) {
	delete m_nonStandard;
	delete m_associatedSessionID;
	delete m_terminalLabel;
	delete m_mediaChannel;
	delete m_mediaGuaranteedDelivery;
	delete m_mediaControlChannel;
	delete m_mediaControlGuaranteedDelivery;
	delete m_redundancyEncoding;
	delete m_sessionDependency;
	delete m_destination;
}

void CommunicationModeTableEntry :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	if ( hasOptionalField ( e_nonStandard ) ) {
		os << std :: setw ( indent + 14 ) << "nonStandard = " << std :: setprecision ( indent );
		m_nonStandard -> ArrayOf_NonStandardParameter :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 12 ) << "sessionID = " << std :: setprecision ( indent ) << m_sessionID << '\n';
	if ( hasOptionalField ( e_associatedSessionID ) ) {
		os << std :: setw ( indent + 22 ) << "associatedSessionID = " << std :: setprecision ( indent );
		m_associatedSessionID -> CommunicationModeTableEntry_associatedSessionID :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_terminalLabel ) ) {
		os << std :: setw ( indent + 16 ) << "terminalLabel = " << std :: setprecision ( indent );
		m_terminalLabel -> TerminalLabel :: printOn ( os );
		os << '\n';
	}
	os << std :: setw ( indent + 21 ) << "sessionDescription = " << std :: setprecision ( indent ) << m_sessionDescription << '\n';
	os << std :: setw ( indent + 11 ) << "dataType = " << std :: setprecision ( indent ) << m_dataType << '\n';
	if ( hasOptionalField ( e_mediaChannel ) ) {
		os << std :: setw ( indent + 15 ) << "mediaChannel = " << std :: setprecision ( indent );
		m_mediaChannel -> TransportAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_mediaGuaranteedDelivery ) ) {
		os << std :: setw ( indent + 26 ) << "mediaGuaranteedDelivery = " << std :: setprecision ( indent );
		m_mediaGuaranteedDelivery -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_mediaControlChannel ) ) {
		os << std :: setw ( indent + 22 ) << "mediaControlChannel = " << std :: setprecision ( indent );
		m_mediaControlChannel -> TransportAddress :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_mediaControlGuaranteedDelivery ) ) {
		os << std :: setw ( indent + 33 ) << "mediaControlGuaranteedDelivery = " << std :: setprecision ( indent );
		m_mediaControlGuaranteedDelivery -> Asn :: Boolean :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_redundancyEncoding ) ) {
		os << std :: setw ( indent + 21 ) << "redundancyEncoding = " << std :: setprecision ( indent );
		m_redundancyEncoding -> RedundancyEncoding :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_sessionDependency ) ) {
		os << std :: setw ( indent + 20 ) << "sessionDependency = " << std :: setprecision ( indent );
		m_sessionDependency -> CommunicationModeTableEntry_sessionDependency :: printOn ( os );
		os << '\n';
	}
	if ( hasOptionalField ( e_destination ) ) {
		os << std :: setw ( indent + 14 ) << "destination = " << std :: setprecision ( indent );
		m_destination -> TerminalLabel :: printOn ( os );
		os << '\n';
	}
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

CommunicationModeTableEntry * CommunicationModeTableEntry :: clone ( ) const {
	return new CommunicationModeTableEntry ( * this );
}

//
// DepFECMode_rfc2733Mode
//

DepFECMode_rfc2733Mode :: DepFECMode_rfc2733Mode ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_mode ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

DepFECMode_rfc2733Mode :: DepFECMode_rfc2733Mode ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void DepFECMode_rfc2733Mode :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_mode.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void DepFECMode_rfc2733Mode :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 7 ) << "mode = " << std :: setprecision ( indent ) << m_mode << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

DepFECMode_rfc2733Mode * DepFECMode_rfc2733Mode :: clone ( ) const {
	return new DepFECMode_rfc2733Mode ( * this );
}

//
// RedundancyEncodingDTMode
//

RedundancyEncodingDTMode :: RedundancyEncodingDTMode ( Asn :: istream & is ) : Asn :: Sequence ( is, 0, true, 0 ), m_redundancyEncodingMethod ( is ), m_primary ( is ), m_secondary ( is ) {
	if ( extensionMapDecode ( is ) )
		unknownExtensionsDecode ( is );
}

RedundancyEncodingDTMode :: RedundancyEncodingDTMode ( ) : Asn :: Sequence ( 0, true, 0 ) { }

void RedundancyEncodingDTMode :: encode ( Asn :: ostream & os ) const {
	preambleEncode ( os );
	m_redundancyEncodingMethod.encode ( os );
	m_primary.encode ( os );
	m_secondary.encode ( os );
	if ( extensionMapEncode ( os ) )
		unknownExtensionsEncode ( os );
}

void RedundancyEncodingDTMode :: printOn ( std :: ostream & os ) const {
	int indent = int ( os.precision ( ) + 2 );
	os << "{\n";
	os << std :: setw ( indent + 27 ) << "redundancyEncodingMethod = " << std :: setprecision ( indent ) << m_redundancyEncodingMethod << '\n';
	os << std :: setw ( indent + 10 ) << "primary = " << std :: setprecision ( indent ) << m_primary << '\n';
	os << std :: setw ( indent + 12 ) << "secondary = " << std :: setprecision ( indent ) << m_secondary << '\n';
	unknownExtensionsPrint ( os );
	os << std :: setw ( indent - 1 ) << '}';
}

RedundancyEncodingDTMode * RedundancyEncodingDTMode :: clone ( ) const {
	return new RedundancyEncodingDTMode ( * this );
}


// End of h245.cxx
